import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class GatewayDomain : Tea.TeaModel {
    public var certIdentifier: String?

    public var gatewayId: Int64?

    public var gatewayName: String?

    public var gatewayUniqueId: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var id: Int64?

    public var mustHttps: String?

    public var name: String?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayName != nil {
            map["GatewayName"] = self.gatewayName!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mustHttps != nil {
            map["MustHttps"] = self.mustHttps!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertIdentifier") {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayName") {
            self.gatewayName = dict["GatewayName"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MustHttps") {
            self.mustHttps = dict["MustHttps"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
    }
}

public class GatewayOption : Tea.TeaModel {
    public class LogConfigDetails : Tea.TeaModel {
        public var logEnabled: Bool?

        public var logStoreName: String?

        public var projectName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logEnabled != nil {
                map["LogEnabled"] = self.logEnabled!
            }
            if self.logStoreName != nil {
                map["LogStoreName"] = self.logStoreName!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogEnabled") {
                self.logEnabled = dict["LogEnabled"] as! Bool
            }
            if dict.keys.contains("LogStoreName") {
                self.logStoreName = dict["LogStoreName"] as! String
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
        }
    }
    public class TraceDetails : Tea.TeaModel {
        public var sample: Int64?

        public var serviceId: Int64?

        public var servicePort: String?

        public var traceEnabled: Bool?

        public var traceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sample != nil {
                map["Sample"] = self.sample!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.traceEnabled != nil {
                map["TraceEnabled"] = self.traceEnabled!
            }
            if self.traceType != nil {
                map["TraceType"] = self.traceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Sample") {
                self.sample = dict["Sample"] as! Int64
            }
            if dict.keys.contains("ServiceId") {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") {
                self.servicePort = dict["ServicePort"] as! String
            }
            if dict.keys.contains("TraceEnabled") {
                self.traceEnabled = dict["TraceEnabled"] as! Bool
            }
            if dict.keys.contains("TraceType") {
                self.traceType = dict["TraceType"] as! String
            }
        }
    }
    public var disableHttp2Alpn: Bool?

    public var enableHardwareAcceleration: Bool?

    public var enableWaf: Bool?

    public var logConfigDetails: GatewayOption.LogConfigDetails?

    public var traceDetails: GatewayOption.TraceDetails?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logConfigDetails?.validate()
        try self.traceDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.disableHttp2Alpn != nil {
            map["DisableHttp2Alpn"] = self.disableHttp2Alpn!
        }
        if self.enableHardwareAcceleration != nil {
            map["EnableHardwareAcceleration"] = self.enableHardwareAcceleration!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.logConfigDetails != nil {
            map["LogConfigDetails"] = self.logConfigDetails?.toMap()
        }
        if self.traceDetails != nil {
            map["TraceDetails"] = self.traceDetails?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DisableHttp2Alpn") {
            self.disableHttp2Alpn = dict["DisableHttp2Alpn"] as! Bool
        }
        if dict.keys.contains("EnableHardwareAcceleration") {
            self.enableHardwareAcceleration = dict["EnableHardwareAcceleration"] as! Bool
        }
        if dict.keys.contains("EnableWaf") {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("LogConfigDetails") {
            var model = GatewayOption.LogConfigDetails()
            model.fromMap(dict["LogConfigDetails"] as! [String: Any])
            self.logConfigDetails = model
        }
        if dict.keys.contains("TraceDetails") {
            var model = GatewayOption.TraceDetails()
            model.fromMap(dict["TraceDetails"] as! [String: Any])
            self.traceDetails = model
        }
    }
}

public class GatewayService : Tea.TeaModel {
    public var gatewayTrafficPolicy: TrafficPolicy?

    public var gatewayUniqueId: String?

    public var groupName: String?

    public var id: Int64?

    public var metaInfo: String?

    public var name: String?

    public var namespace: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gatewayTrafficPolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gatewayTrafficPolicy != nil {
            map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicy?.toMap()
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.metaInfo != nil {
            map["MetaInfo"] = self.metaInfo!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GatewayTrafficPolicy") {
            var model = TrafficPolicy()
            model.fromMap(dict["GatewayTrafficPolicy"] as! [String: Any])
            self.gatewayTrafficPolicy = model
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MetaInfo") {
            self.metaInfo = dict["MetaInfo"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class TrafficPolicy : Tea.TeaModel {
    public class LoadBalancerSettings : Tea.TeaModel {
        public class ConsistentHashLBConfig : Tea.TeaModel {
            public class HttpCookie : Tea.TeaModel {
                public var name: String?

                public var path: String?

                public var TTL: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.TTL != nil {
                        map["TTL"] = self.TTL!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("TTL") {
                        self.TTL = dict["TTL"] as! String
                    }
                }
            }
            public var consistentHashLBType: String?

            public var httpCookie: TrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig.HttpCookie?

            public var parameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.httpCookie?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consistentHashLBType != nil {
                    map["ConsistentHashLBType"] = self.consistentHashLBType!
                }
                if self.httpCookie != nil {
                    map["HttpCookie"] = self.httpCookie?.toMap()
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsistentHashLBType") {
                    self.consistentHashLBType = dict["ConsistentHashLBType"] as! String
                }
                if dict.keys.contains("HttpCookie") {
                    var model = TrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig.HttpCookie()
                    model.fromMap(dict["HttpCookie"] as! [String: Any])
                    self.httpCookie = model
                }
                if dict.keys.contains("ParameterName") {
                    self.parameterName = dict["ParameterName"] as! String
                }
            }
        }
        public var consistentHashLBConfig: TrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig?

        public var loadbalancerType: String?

        public var warmupDuration: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.consistentHashLBConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consistentHashLBConfig != nil {
                map["ConsistentHashLBConfig"] = self.consistentHashLBConfig?.toMap()
            }
            if self.loadbalancerType != nil {
                map["LoadbalancerType"] = self.loadbalancerType!
            }
            if self.warmupDuration != nil {
                map["WarmupDuration"] = self.warmupDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsistentHashLBConfig") {
                var model = TrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig()
                model.fromMap(dict["ConsistentHashLBConfig"] as! [String: Any])
                self.consistentHashLBConfig = model
            }
            if dict.keys.contains("LoadbalancerType") {
                self.loadbalancerType = dict["LoadbalancerType"] as! String
            }
            if dict.keys.contains("WarmupDuration") {
                self.warmupDuration = dict["WarmupDuration"] as! Int64
            }
        }
    }
    public class TlsSetting : Tea.TeaModel {
        public var caCertContent: String?

        public var certId: String?

        public var sni: String?

        public var tlsMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caCertContent != nil {
                map["CaCertContent"] = self.caCertContent!
            }
            if self.certId != nil {
                map["CertId"] = self.certId!
            }
            if self.sni != nil {
                map["Sni"] = self.sni!
            }
            if self.tlsMode != nil {
                map["TlsMode"] = self.tlsMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CaCertContent") {
                self.caCertContent = dict["CaCertContent"] as! String
            }
            if dict.keys.contains("CertId") {
                self.certId = dict["CertId"] as! String
            }
            if dict.keys.contains("Sni") {
                self.sni = dict["Sni"] as! String
            }
            if dict.keys.contains("TlsMode") {
                self.tlsMode = dict["TlsMode"] as! String
            }
        }
    }
    public var loadBalancerSettings: TrafficPolicy.LoadBalancerSettings?

    public var tlsSetting: TrafficPolicy.TlsSetting?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.loadBalancerSettings?.validate()
        try self.tlsSetting?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerSettings != nil {
            map["LoadBalancerSettings"] = self.loadBalancerSettings?.toMap()
        }
        if self.tlsSetting != nil {
            map["TlsSetting"] = self.tlsSetting?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerSettings") {
            var model = TrafficPolicy.LoadBalancerSettings()
            model.fromMap(dict["LoadBalancerSettings"] as! [String: Any])
            self.loadBalancerSettings = model
        }
        if dict.keys.contains("TlsSetting") {
            var model = TrafficPolicy.TlsSetting()
            model.fromMap(dict["TlsSetting"] as! [String: Any])
            self.tlsSetting = model
        }
    }
}

public class RulesValue : Tea.TeaModel {
    public class Rules : Tea.TeaModel {
        public class Springcloud : Tea.TeaModel {
            public class RestItems : Tea.TeaModel {
                public var datum: String?

                public var operator_: String?

                public var nameList: [String]?

                public var cond: String?

                public var divisor: Int32?

                public var remainder: Int32?

                public var rate: Int32?

                public var type: String?

                public var name: String?

                public var value: Any?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.datum != nil {
                        map["datum"] = self.datum!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.nameList != nil {
                        map["nameList"] = self.nameList!
                    }
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.divisor != nil {
                        map["divisor"] = self.divisor!
                    }
                    if self.remainder != nil {
                        map["remainder"] = self.remainder!
                    }
                    if self.rate != nil {
                        map["rate"] = self.rate!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("datum") {
                        self.datum = dict["datum"] as! String
                    }
                    if dict.keys.contains("operator") {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("nameList") {
                        self.nameList = dict["nameList"] as! [String]
                    }
                    if dict.keys.contains("cond") {
                        self.cond = dict["cond"] as! String
                    }
                    if dict.keys.contains("divisor") {
                        self.divisor = dict["divisor"] as! Int32
                    }
                    if dict.keys.contains("remainder") {
                        self.remainder = dict["remainder"] as! Int32
                    }
                    if dict.keys.contains("rate") {
                        self.rate = dict["rate"] as! Int32
                    }
                    if dict.keys.contains("type") {
                        self.type = dict["type"] as! String
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! Any
                    }
                }
            }
            public var condition: String?

            public var restItems: [RulesValue.Rules.Springcloud.RestItems]?

            public var triggerPolicy: String?

            public var enable: Bool?

            public var appId: String?

            public var priority: Int32?

            public var tags: [String]?

            public var paths: [String]?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.restItems != nil {
                    var tmp : [Any] = []
                    for k in self.restItems! {
                        tmp.append(k.toMap())
                    }
                    map["restItems"] = tmp
                }
                if self.triggerPolicy != nil {
                    map["triggerPolicy"] = self.triggerPolicy!
                }
                if self.enable != nil {
                    map["enable"] = self.enable!
                }
                if self.appId != nil {
                    map["appId"] = self.appId!
                }
                if self.priority != nil {
                    map["priority"] = self.priority!
                }
                if self.tags != nil {
                    map["tags"] = self.tags!
                }
                if self.paths != nil {
                    map["paths"] = self.paths!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("condition") {
                    self.condition = dict["condition"] as! String
                }
                if dict.keys.contains("restItems") {
                    var tmp : [RulesValue.Rules.Springcloud.RestItems] = []
                    for v in dict["restItems"] as! [Any] {
                        var model = RulesValue.Rules.Springcloud.RestItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.restItems = tmp
                }
                if dict.keys.contains("triggerPolicy") {
                    self.triggerPolicy = dict["triggerPolicy"] as! String
                }
                if dict.keys.contains("enable") {
                    self.enable = dict["enable"] as! Bool
                }
                if dict.keys.contains("appId") {
                    self.appId = dict["appId"] as! String
                }
                if dict.keys.contains("priority") {
                    self.priority = dict["priority"] as! Int32
                }
                if dict.keys.contains("tags") {
                    self.tags = dict["tags"] as! [String]
                }
                if dict.keys.contains("paths") {
                    self.paths = dict["paths"] as! [String]
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
            }
        }
        public class Dubbo : Tea.TeaModel {
            public class ArgumentItems : Tea.TeaModel {
                public var operator_: String?

                public var nameList: [String]?

                public var datum: String?

                public var cond: String?

                public var divisor: Int32?

                public var remainder: Int32?

                public var rate: Int32?

                public var index: Int32?

                public var expr: String?

                public var value: Any?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.nameList != nil {
                        map["nameList"] = self.nameList!
                    }
                    if self.datum != nil {
                        map["datum"] = self.datum!
                    }
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.divisor != nil {
                        map["divisor"] = self.divisor!
                    }
                    if self.remainder != nil {
                        map["remainder"] = self.remainder!
                    }
                    if self.rate != nil {
                        map["rate"] = self.rate!
                    }
                    if self.index != nil {
                        map["index"] = self.index!
                    }
                    if self.expr != nil {
                        map["expr"] = self.expr!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("operator") {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("nameList") {
                        self.nameList = dict["nameList"] as! [String]
                    }
                    if dict.keys.contains("datum") {
                        self.datum = dict["datum"] as! String
                    }
                    if dict.keys.contains("cond") {
                        self.cond = dict["cond"] as! String
                    }
                    if dict.keys.contains("divisor") {
                        self.divisor = dict["divisor"] as! Int32
                    }
                    if dict.keys.contains("remainder") {
                        self.remainder = dict["remainder"] as! Int32
                    }
                    if dict.keys.contains("rate") {
                        self.rate = dict["rate"] as! Int32
                    }
                    if dict.keys.contains("index") {
                        self.index = dict["index"] as! Int32
                    }
                    if dict.keys.contains("expr") {
                        self.expr = dict["expr"] as! String
                    }
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! Any
                    }
                }
            }
            public var appId: String?

            public var tags: [String]?

            public var triggerPolicy: String?

            public var serviceName: String?

            public var group: String?

            public var version: String?

            public var methodName: String?

            public var paramTypes: [String]?

            public var condition: String?

            public var argumentItems: [RulesValue.Rules.Dubbo.ArgumentItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["appId"] = self.appId!
                }
                if self.tags != nil {
                    map["tags"] = self.tags!
                }
                if self.triggerPolicy != nil {
                    map["triggerPolicy"] = self.triggerPolicy!
                }
                if self.serviceName != nil {
                    map["serviceName"] = self.serviceName!
                }
                if self.group != nil {
                    map["group"] = self.group!
                }
                if self.version != nil {
                    map["version"] = self.version!
                }
                if self.methodName != nil {
                    map["methodName"] = self.methodName!
                }
                if self.paramTypes != nil {
                    map["paramTypes"] = self.paramTypes!
                }
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.argumentItems != nil {
                    var tmp : [Any] = []
                    for k in self.argumentItems! {
                        tmp.append(k.toMap())
                    }
                    map["argumentItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("appId") {
                    self.appId = dict["appId"] as! String
                }
                if dict.keys.contains("tags") {
                    self.tags = dict["tags"] as! [String]
                }
                if dict.keys.contains("triggerPolicy") {
                    self.triggerPolicy = dict["triggerPolicy"] as! String
                }
                if dict.keys.contains("serviceName") {
                    self.serviceName = dict["serviceName"] as! String
                }
                if dict.keys.contains("group") {
                    self.group = dict["group"] as! String
                }
                if dict.keys.contains("version") {
                    self.version = dict["version"] as! String
                }
                if dict.keys.contains("methodName") {
                    self.methodName = dict["methodName"] as! String
                }
                if dict.keys.contains("paramTypes") {
                    self.paramTypes = dict["paramTypes"] as! [String]
                }
                if dict.keys.contains("condition") {
                    self.condition = dict["condition"] as! String
                }
                if dict.keys.contains("argumentItems") {
                    var tmp : [RulesValue.Rules.Dubbo.ArgumentItems] = []
                    for v in dict["argumentItems"] as! [Any] {
                        var model = RulesValue.Rules.Dubbo.ArgumentItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.argumentItems = tmp
                }
            }
        }
        public var springcloud: [RulesValue.Rules.Springcloud]?

        public var dubbo: [RulesValue.Rules.Dubbo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.springcloud != nil {
                var tmp : [Any] = []
                for k in self.springcloud! {
                    tmp.append(k.toMap())
                }
                map["springcloud"] = tmp
            }
            if self.dubbo != nil {
                var tmp : [Any] = []
                for k in self.dubbo! {
                    tmp.append(k.toMap())
                }
                map["dubbo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("springcloud") {
                var tmp : [RulesValue.Rules.Springcloud] = []
                for v in dict["springcloud"] as! [Any] {
                    var model = RulesValue.Rules.Springcloud()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.springcloud = tmp
            }
            if dict.keys.contains("dubbo") {
                var tmp : [RulesValue.Rules.Dubbo] = []
                for v in dict["dubbo"] as! [Any] {
                    var model = RulesValue.Rules.Dubbo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dubbo = tmp
            }
        }
    }
    public var status: Int32?

    public var rate: Int32?

    public var enable: Bool?

    public var tag: String?

    public var name: String?

    public var id: Int64?

    public var instanceNum: Int32?

    public var rules: RulesValue.Rules?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.rules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.rate != nil {
            map["Rate"] = self.rate!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceNum != nil {
            map["InstanceNum"] = self.instanceNum!
        }
        if self.rules != nil {
            map["Rules"] = self.rules?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Rate") {
            self.rate = dict["Rate"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("InstanceNum") {
            self.instanceNum = dict["InstanceNum"] as! Int32
        }
        if dict.keys.contains("Rules") {
            var model = RulesValue.Rules()
            model.fromMap(dict["Rules"] as! [String: Any])
            self.rules = model
        }
    }
}

public class DataValue : Tea.TeaModel {
    public var userId: String?

    public var regionId: String?

    public var namespace: String?

    public var appName: String?

    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class AddAuthPolicyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var authRule: String?

    public var authType: Int32?

    public var enable: String?

    public var k8sNamespace: String?

    public var name: String?

    public var namespace: String?

    public var protocol_: String?

    public var region: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.authRule != nil {
            map["AuthRule"] = self.authRule!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.k8sNamespace != nil {
            map["K8sNamespace"] = self.k8sNamespace!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AuthRule") {
            self.authRule = dict["AuthRule"] as! String
        }
        if dict.keys.contains("AuthType") {
            self.authType = dict["AuthType"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! String
        }
        if dict.keys.contains("K8sNamespace") {
            self.k8sNamespace = dict["K8sNamespace"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
    }
}

public class AddAuthPolicyResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddAuthPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAuthPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAuthPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddAuthResourceRequest : Tea.TeaModel {
    public class AuthResourceHeaderList : Tea.TeaModel {
        public var headerKey: String?

        public var headerMethod: String?

        public var headerValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.headerKey != nil {
                map["HeaderKey"] = self.headerKey!
            }
            if self.headerMethod != nil {
                map["HeaderMethod"] = self.headerMethod!
            }
            if self.headerValue != nil {
                map["HeaderValue"] = self.headerValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HeaderKey") {
                self.headerKey = dict["HeaderKey"] as! String
            }
            if dict.keys.contains("HeaderMethod") {
                self.headerMethod = dict["HeaderMethod"] as! String
            }
            if dict.keys.contains("HeaderValue") {
                self.headerValue = dict["HeaderValue"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var authId: Int64?

    public var authResourceHeaderList: [AddAuthResourceRequest.AuthResourceHeaderList]?

    public var domainId: Int64?

    public var gatewayUniqueId: String?

    public var ignoreCase: Bool?

    public var matchType: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.authId != nil {
            map["AuthId"] = self.authId!
        }
        if self.authResourceHeaderList != nil {
            var tmp : [Any] = []
            for k in self.authResourceHeaderList! {
                tmp.append(k.toMap())
            }
            map["AuthResourceHeaderList"] = tmp
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.ignoreCase != nil {
            map["IgnoreCase"] = self.ignoreCase!
        }
        if self.matchType != nil {
            map["MatchType"] = self.matchType!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AuthId") {
            self.authId = dict["AuthId"] as! Int64
        }
        if dict.keys.contains("AuthResourceHeaderList") {
            var tmp : [AddAuthResourceRequest.AuthResourceHeaderList] = []
            for v in dict["AuthResourceHeaderList"] as! [Any] {
                var model = AddAuthResourceRequest.AuthResourceHeaderList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.authResourceHeaderList = tmp
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IgnoreCase") {
            self.ignoreCase = dict["IgnoreCase"] as! Bool
        }
        if dict.keys.contains("MatchType") {
            self.matchType = dict["MatchType"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
    }
}

public class AddAuthResourceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var authId: Int64?

    public var authResourceHeaderListShrink: String?

    public var domainId: Int64?

    public var gatewayUniqueId: String?

    public var ignoreCase: Bool?

    public var matchType: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.authId != nil {
            map["AuthId"] = self.authId!
        }
        if self.authResourceHeaderListShrink != nil {
            map["AuthResourceHeaderList"] = self.authResourceHeaderListShrink!
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.ignoreCase != nil {
            map["IgnoreCase"] = self.ignoreCase!
        }
        if self.matchType != nil {
            map["MatchType"] = self.matchType!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AuthId") {
            self.authId = dict["AuthId"] as! Int64
        }
        if dict.keys.contains("AuthResourceHeaderList") {
            self.authResourceHeaderListShrink = dict["AuthResourceHeaderList"] as! String
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IgnoreCase") {
            self.ignoreCase = dict["IgnoreCase"] as! Bool
        }
        if dict.keys.contains("MatchType") {
            self.matchType = dict["MatchType"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
    }
}

public class AddAuthResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddAuthResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAuthResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAuthResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddBlackWhiteListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var content: String?

    public var gatewayUniqueId: String?

    public var isWhite: Bool?

    public var name: String?

    public var note: String?

    public var resourceIdJsonList: String?

    public var resourceType: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.isWhite != nil {
            map["IsWhite"] = self.isWhite!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.resourceIdJsonList != nil {
            map["ResourceIdJsonList"] = self.resourceIdJsonList!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IsWhite") {
            self.isWhite = dict["IsWhite"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Note") {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("ResourceIdJsonList") {
            self.resourceIdJsonList = dict["ResourceIdJsonList"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddBlackWhiteListResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddBlackWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddBlackWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddBlackWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class ZoneInfo : Tea.TeaModel {
        public var vSwitchId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var chargeType: String?

    public var clbNetworkType: String?

    public var enableHardwareAcceleration: Bool?

    public var enableSls: Bool?

    public var enableXtrace: Bool?

    public var enterpriseSecurityGroup: Bool?

    public var internetSlbSpec: String?

    public var mserVersion: String?

    public var name: String?

    public var nlbNetworkType: String?

    public var region: String?

    public var replica: Int32?

    public var requestPars: String?

    public var resourceGroupId: String?

    public var slbSpec: String?

    public var spec: String?

    public var tag: [AddGatewayRequest.Tag]?

    public var vSwitchId: String?

    public var vSwitchId2: String?

    public var vpc: String?

    public var xtraceRatio: String?

    public var zoneInfo: [AddGatewayRequest.ZoneInfo]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clbNetworkType != nil {
            map["ClbNetworkType"] = self.clbNetworkType!
        }
        if self.enableHardwareAcceleration != nil {
            map["EnableHardwareAcceleration"] = self.enableHardwareAcceleration!
        }
        if self.enableSls != nil {
            map["EnableSls"] = self.enableSls!
        }
        if self.enableXtrace != nil {
            map["EnableXtrace"] = self.enableXtrace!
        }
        if self.enterpriseSecurityGroup != nil {
            map["EnterpriseSecurityGroup"] = self.enterpriseSecurityGroup!
        }
        if self.internetSlbSpec != nil {
            map["InternetSlbSpec"] = self.internetSlbSpec!
        }
        if self.mserVersion != nil {
            map["MserVersion"] = self.mserVersion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nlbNetworkType != nil {
            map["NlbNetworkType"] = self.nlbNetworkType!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.replica != nil {
            map["Replica"] = self.replica!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.slbSpec != nil {
            map["SlbSpec"] = self.slbSpec!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchId2 != nil {
            map["VSwitchId2"] = self.vSwitchId2!
        }
        if self.vpc != nil {
            map["Vpc"] = self.vpc!
        }
        if self.xtraceRatio != nil {
            map["XtraceRatio"] = self.xtraceRatio!
        }
        if self.zoneInfo != nil {
            var tmp : [Any] = []
            for k in self.zoneInfo! {
                tmp.append(k.toMap())
            }
            map["ZoneInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClbNetworkType") {
            self.clbNetworkType = dict["ClbNetworkType"] as! String
        }
        if dict.keys.contains("EnableHardwareAcceleration") {
            self.enableHardwareAcceleration = dict["EnableHardwareAcceleration"] as! Bool
        }
        if dict.keys.contains("EnableSls") {
            self.enableSls = dict["EnableSls"] as! Bool
        }
        if dict.keys.contains("EnableXtrace") {
            self.enableXtrace = dict["EnableXtrace"] as! Bool
        }
        if dict.keys.contains("EnterpriseSecurityGroup") {
            self.enterpriseSecurityGroup = dict["EnterpriseSecurityGroup"] as! Bool
        }
        if dict.keys.contains("InternetSlbSpec") {
            self.internetSlbSpec = dict["InternetSlbSpec"] as! String
        }
        if dict.keys.contains("MserVersion") {
            self.mserVersion = dict["MserVersion"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NlbNetworkType") {
            self.nlbNetworkType = dict["NlbNetworkType"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Replica") {
            self.replica = dict["Replica"] as! Int32
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SlbSpec") {
            self.slbSpec = dict["SlbSpec"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [AddGatewayRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = AddGatewayRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchId2") {
            self.vSwitchId2 = dict["VSwitchId2"] as! String
        }
        if dict.keys.contains("Vpc") {
            self.vpc = dict["Vpc"] as! String
        }
        if dict.keys.contains("XtraceRatio") {
            self.xtraceRatio = dict["XtraceRatio"] as! String
        }
        if dict.keys.contains("ZoneInfo") {
            var tmp : [AddGatewayRequest.ZoneInfo] = []
            for v in dict["ZoneInfo"] as! [Any] {
                var model = AddGatewayRequest.ZoneInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.zoneInfo = tmp
        }
    }
}

public class AddGatewayShrinkRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var chargeType: String?

    public var clbNetworkType: String?

    public var enableHardwareAcceleration: Bool?

    public var enableSls: Bool?

    public var enableXtrace: Bool?

    public var enterpriseSecurityGroup: Bool?

    public var internetSlbSpec: String?

    public var mserVersion: String?

    public var name: String?

    public var nlbNetworkType: String?

    public var region: String?

    public var replica: Int32?

    public var requestPars: String?

    public var resourceGroupId: String?

    public var slbSpec: String?

    public var spec: String?

    public var tag: [AddGatewayShrinkRequest.Tag]?

    public var vSwitchId: String?

    public var vSwitchId2: String?

    public var vpc: String?

    public var xtraceRatio: String?

    public var zoneInfoShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clbNetworkType != nil {
            map["ClbNetworkType"] = self.clbNetworkType!
        }
        if self.enableHardwareAcceleration != nil {
            map["EnableHardwareAcceleration"] = self.enableHardwareAcceleration!
        }
        if self.enableSls != nil {
            map["EnableSls"] = self.enableSls!
        }
        if self.enableXtrace != nil {
            map["EnableXtrace"] = self.enableXtrace!
        }
        if self.enterpriseSecurityGroup != nil {
            map["EnterpriseSecurityGroup"] = self.enterpriseSecurityGroup!
        }
        if self.internetSlbSpec != nil {
            map["InternetSlbSpec"] = self.internetSlbSpec!
        }
        if self.mserVersion != nil {
            map["MserVersion"] = self.mserVersion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nlbNetworkType != nil {
            map["NlbNetworkType"] = self.nlbNetworkType!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.replica != nil {
            map["Replica"] = self.replica!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.slbSpec != nil {
            map["SlbSpec"] = self.slbSpec!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchId2 != nil {
            map["VSwitchId2"] = self.vSwitchId2!
        }
        if self.vpc != nil {
            map["Vpc"] = self.vpc!
        }
        if self.xtraceRatio != nil {
            map["XtraceRatio"] = self.xtraceRatio!
        }
        if self.zoneInfoShrink != nil {
            map["ZoneInfo"] = self.zoneInfoShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClbNetworkType") {
            self.clbNetworkType = dict["ClbNetworkType"] as! String
        }
        if dict.keys.contains("EnableHardwareAcceleration") {
            self.enableHardwareAcceleration = dict["EnableHardwareAcceleration"] as! Bool
        }
        if dict.keys.contains("EnableSls") {
            self.enableSls = dict["EnableSls"] as! Bool
        }
        if dict.keys.contains("EnableXtrace") {
            self.enableXtrace = dict["EnableXtrace"] as! Bool
        }
        if dict.keys.contains("EnterpriseSecurityGroup") {
            self.enterpriseSecurityGroup = dict["EnterpriseSecurityGroup"] as! Bool
        }
        if dict.keys.contains("InternetSlbSpec") {
            self.internetSlbSpec = dict["InternetSlbSpec"] as! String
        }
        if dict.keys.contains("MserVersion") {
            self.mserVersion = dict["MserVersion"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NlbNetworkType") {
            self.nlbNetworkType = dict["NlbNetworkType"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Replica") {
            self.replica = dict["Replica"] as! Int32
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SlbSpec") {
            self.slbSpec = dict["SlbSpec"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [AddGatewayShrinkRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = AddGatewayShrinkRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchId2") {
            self.vSwitchId2 = dict["VSwitchId2"] as! String
        }
        if dict.keys.contains("Vpc") {
            self.vpc = dict["Vpc"] as! String
        }
        if dict.keys.contains("XtraceRatio") {
            self.xtraceRatio = dict["XtraceRatio"] as! String
        }
        if dict.keys.contains("ZoneInfo") {
            self.zoneInfoShrink = dict["ZoneInfo"] as! String
        }
    }
}

public class AddGatewayResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var gatewayUniqueId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: AddGatewayResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = AddGatewayResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayAuthRequest : Tea.TeaModel {
    public class AuthResourceList : Tea.TeaModel {
        public class AuthResourceHeaderList : Tea.TeaModel {
            public var headerKey: String?

            public var headerMethod: String?

            public var headerValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.headerKey != nil {
                    map["HeaderKey"] = self.headerKey!
                }
                if self.headerMethod != nil {
                    map["HeaderMethod"] = self.headerMethod!
                }
                if self.headerValue != nil {
                    map["HeaderValue"] = self.headerValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HeaderKey") {
                    self.headerKey = dict["HeaderKey"] as! String
                }
                if dict.keys.contains("HeaderMethod") {
                    self.headerMethod = dict["HeaderMethod"] as! String
                }
                if dict.keys.contains("HeaderValue") {
                    self.headerValue = dict["HeaderValue"] as! String
                }
            }
        }
        public var authResourceHeaderList: [AddGatewayAuthRequest.AuthResourceList.AuthResourceHeaderList]?

        public var domainId: Int64?

        public var ignoreCase: Bool?

        public var matchType: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authResourceHeaderList != nil {
                var tmp : [Any] = []
                for k in self.authResourceHeaderList! {
                    tmp.append(k.toMap())
                }
                map["AuthResourceHeaderList"] = tmp
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.ignoreCase != nil {
                map["IgnoreCase"] = self.ignoreCase!
            }
            if self.matchType != nil {
                map["MatchType"] = self.matchType!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthResourceHeaderList") {
                var tmp : [AddGatewayAuthRequest.AuthResourceList.AuthResourceHeaderList] = []
                for v in dict["AuthResourceHeaderList"] as! [Any] {
                    var model = AddGatewayAuthRequest.AuthResourceList.AuthResourceHeaderList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authResourceHeaderList = tmp
            }
            if dict.keys.contains("DomainId") {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("IgnoreCase") {
                self.ignoreCase = dict["IgnoreCase"] as! Bool
            }
            if dict.keys.contains("MatchType") {
                self.matchType = dict["MatchType"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public class ExternalAuthZJSON : Tea.TeaModel {
        public var allowRequestHeaders: [String]?

        public var allowUpstreamHeaders: [String]?

        public var bodyMaxBytes: Int32?

        public var isRestrict: Bool?

        public var prefixPath: String?

        public var serviceId: Int64?

        public var timeout: Int32?

        public var tokenKey: String?

        public var withRematchRoute: Bool?

        public var withRequestBody: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowRequestHeaders != nil {
                map["AllowRequestHeaders"] = self.allowRequestHeaders!
            }
            if self.allowUpstreamHeaders != nil {
                map["AllowUpstreamHeaders"] = self.allowUpstreamHeaders!
            }
            if self.bodyMaxBytes != nil {
                map["BodyMaxBytes"] = self.bodyMaxBytes!
            }
            if self.isRestrict != nil {
                map["IsRestrict"] = self.isRestrict!
            }
            if self.prefixPath != nil {
                map["PrefixPath"] = self.prefixPath!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.tokenKey != nil {
                map["TokenKey"] = self.tokenKey!
            }
            if self.withRematchRoute != nil {
                map["WithRematchRoute"] = self.withRematchRoute!
            }
            if self.withRequestBody != nil {
                map["WithRequestBody"] = self.withRequestBody!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowRequestHeaders") {
                self.allowRequestHeaders = dict["AllowRequestHeaders"] as! [String]
            }
            if dict.keys.contains("AllowUpstreamHeaders") {
                self.allowUpstreamHeaders = dict["AllowUpstreamHeaders"] as! [String]
            }
            if dict.keys.contains("BodyMaxBytes") {
                self.bodyMaxBytes = dict["BodyMaxBytes"] as! Int32
            }
            if dict.keys.contains("IsRestrict") {
                self.isRestrict = dict["IsRestrict"] as! Bool
            }
            if dict.keys.contains("PrefixPath") {
                self.prefixPath = dict["PrefixPath"] as! String
            }
            if dict.keys.contains("ServiceId") {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("Timeout") {
                self.timeout = dict["Timeout"] as! Int32
            }
            if dict.keys.contains("TokenKey") {
                self.tokenKey = dict["TokenKey"] as! String
            }
            if dict.keys.contains("WithRematchRoute") {
                self.withRematchRoute = dict["WithRematchRoute"] as! Bool
            }
            if dict.keys.contains("WithRequestBody") {
                self.withRequestBody = dict["WithRequestBody"] as! Bool
            }
        }
    }
    public var acceptLanguage: String?

    public var authResourceConfig: String?

    public var authResourceList: [AddGatewayAuthRequest.AuthResourceList]?

    public var authResourceMode: Int32?

    public var clientId: String?

    public var clientSecret: String?

    public var cookieDomain: String?

    public var externalAuthZJSON: AddGatewayAuthRequest.ExternalAuthZJSON?

    public var gatewayUniqueId: String?

    public var isWhite: Bool?

    public var issuer: String?

    public var jwks: String?

    public var loginUrl: String?

    public var name: String?

    public var redirectUrl: String?

    public var scopesList: [String]?

    public var status: Bool?

    public var sub: String?

    public var tokenName: String?

    public var tokenNamePrefix: String?

    public var tokenPass: Bool?

    public var tokenPosition: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.externalAuthZJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.authResourceConfig != nil {
            map["AuthResourceConfig"] = self.authResourceConfig!
        }
        if self.authResourceList != nil {
            var tmp : [Any] = []
            for k in self.authResourceList! {
                tmp.append(k.toMap())
            }
            map["AuthResourceList"] = tmp
        }
        if self.authResourceMode != nil {
            map["AuthResourceMode"] = self.authResourceMode!
        }
        if self.clientId != nil {
            map["ClientId"] = self.clientId!
        }
        if self.clientSecret != nil {
            map["ClientSecret"] = self.clientSecret!
        }
        if self.cookieDomain != nil {
            map["CookieDomain"] = self.cookieDomain!
        }
        if self.externalAuthZJSON != nil {
            map["ExternalAuthZJSON"] = self.externalAuthZJSON?.toMap()
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.isWhite != nil {
            map["IsWhite"] = self.isWhite!
        }
        if self.issuer != nil {
            map["Issuer"] = self.issuer!
        }
        if self.jwks != nil {
            map["Jwks"] = self.jwks!
        }
        if self.loginUrl != nil {
            map["LoginUrl"] = self.loginUrl!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.redirectUrl != nil {
            map["RedirectUrl"] = self.redirectUrl!
        }
        if self.scopesList != nil {
            map["ScopesList"] = self.scopesList!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.sub != nil {
            map["Sub"] = self.sub!
        }
        if self.tokenName != nil {
            map["TokenName"] = self.tokenName!
        }
        if self.tokenNamePrefix != nil {
            map["TokenNamePrefix"] = self.tokenNamePrefix!
        }
        if self.tokenPass != nil {
            map["TokenPass"] = self.tokenPass!
        }
        if self.tokenPosition != nil {
            map["TokenPosition"] = self.tokenPosition!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AuthResourceConfig") {
            self.authResourceConfig = dict["AuthResourceConfig"] as! String
        }
        if dict.keys.contains("AuthResourceList") {
            var tmp : [AddGatewayAuthRequest.AuthResourceList] = []
            for v in dict["AuthResourceList"] as! [Any] {
                var model = AddGatewayAuthRequest.AuthResourceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.authResourceList = tmp
        }
        if dict.keys.contains("AuthResourceMode") {
            self.authResourceMode = dict["AuthResourceMode"] as! Int32
        }
        if dict.keys.contains("ClientId") {
            self.clientId = dict["ClientId"] as! String
        }
        if dict.keys.contains("ClientSecret") {
            self.clientSecret = dict["ClientSecret"] as! String
        }
        if dict.keys.contains("CookieDomain") {
            self.cookieDomain = dict["CookieDomain"] as! String
        }
        if dict.keys.contains("ExternalAuthZJSON") {
            var model = AddGatewayAuthRequest.ExternalAuthZJSON()
            model.fromMap(dict["ExternalAuthZJSON"] as! [String: Any])
            self.externalAuthZJSON = model
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IsWhite") {
            self.isWhite = dict["IsWhite"] as! Bool
        }
        if dict.keys.contains("Issuer") {
            self.issuer = dict["Issuer"] as! String
        }
        if dict.keys.contains("Jwks") {
            self.jwks = dict["Jwks"] as! String
        }
        if dict.keys.contains("LoginUrl") {
            self.loginUrl = dict["LoginUrl"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RedirectUrl") {
            self.redirectUrl = dict["RedirectUrl"] as! String
        }
        if dict.keys.contains("ScopesList") {
            self.scopesList = dict["ScopesList"] as! [String]
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Bool
        }
        if dict.keys.contains("Sub") {
            self.sub = dict["Sub"] as! String
        }
        if dict.keys.contains("TokenName") {
            self.tokenName = dict["TokenName"] as! String
        }
        if dict.keys.contains("TokenNamePrefix") {
            self.tokenNamePrefix = dict["TokenNamePrefix"] as! String
        }
        if dict.keys.contains("TokenPass") {
            self.tokenPass = dict["TokenPass"] as! Bool
        }
        if dict.keys.contains("TokenPosition") {
            self.tokenPosition = dict["TokenPosition"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddGatewayAuthShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var authResourceConfig: String?

    public var authResourceListShrink: String?

    public var authResourceMode: Int32?

    public var clientId: String?

    public var clientSecret: String?

    public var cookieDomain: String?

    public var externalAuthZJSONShrink: String?

    public var gatewayUniqueId: String?

    public var isWhite: Bool?

    public var issuer: String?

    public var jwks: String?

    public var loginUrl: String?

    public var name: String?

    public var redirectUrl: String?

    public var scopesListShrink: String?

    public var status: Bool?

    public var sub: String?

    public var tokenName: String?

    public var tokenNamePrefix: String?

    public var tokenPass: Bool?

    public var tokenPosition: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.authResourceConfig != nil {
            map["AuthResourceConfig"] = self.authResourceConfig!
        }
        if self.authResourceListShrink != nil {
            map["AuthResourceList"] = self.authResourceListShrink!
        }
        if self.authResourceMode != nil {
            map["AuthResourceMode"] = self.authResourceMode!
        }
        if self.clientId != nil {
            map["ClientId"] = self.clientId!
        }
        if self.clientSecret != nil {
            map["ClientSecret"] = self.clientSecret!
        }
        if self.cookieDomain != nil {
            map["CookieDomain"] = self.cookieDomain!
        }
        if self.externalAuthZJSONShrink != nil {
            map["ExternalAuthZJSON"] = self.externalAuthZJSONShrink!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.isWhite != nil {
            map["IsWhite"] = self.isWhite!
        }
        if self.issuer != nil {
            map["Issuer"] = self.issuer!
        }
        if self.jwks != nil {
            map["Jwks"] = self.jwks!
        }
        if self.loginUrl != nil {
            map["LoginUrl"] = self.loginUrl!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.redirectUrl != nil {
            map["RedirectUrl"] = self.redirectUrl!
        }
        if self.scopesListShrink != nil {
            map["ScopesList"] = self.scopesListShrink!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.sub != nil {
            map["Sub"] = self.sub!
        }
        if self.tokenName != nil {
            map["TokenName"] = self.tokenName!
        }
        if self.tokenNamePrefix != nil {
            map["TokenNamePrefix"] = self.tokenNamePrefix!
        }
        if self.tokenPass != nil {
            map["TokenPass"] = self.tokenPass!
        }
        if self.tokenPosition != nil {
            map["TokenPosition"] = self.tokenPosition!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AuthResourceConfig") {
            self.authResourceConfig = dict["AuthResourceConfig"] as! String
        }
        if dict.keys.contains("AuthResourceList") {
            self.authResourceListShrink = dict["AuthResourceList"] as! String
        }
        if dict.keys.contains("AuthResourceMode") {
            self.authResourceMode = dict["AuthResourceMode"] as! Int32
        }
        if dict.keys.contains("ClientId") {
            self.clientId = dict["ClientId"] as! String
        }
        if dict.keys.contains("ClientSecret") {
            self.clientSecret = dict["ClientSecret"] as! String
        }
        if dict.keys.contains("CookieDomain") {
            self.cookieDomain = dict["CookieDomain"] as! String
        }
        if dict.keys.contains("ExternalAuthZJSON") {
            self.externalAuthZJSONShrink = dict["ExternalAuthZJSON"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IsWhite") {
            self.isWhite = dict["IsWhite"] as! Bool
        }
        if dict.keys.contains("Issuer") {
            self.issuer = dict["Issuer"] as! String
        }
        if dict.keys.contains("Jwks") {
            self.jwks = dict["Jwks"] as! String
        }
        if dict.keys.contains("LoginUrl") {
            self.loginUrl = dict["LoginUrl"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RedirectUrl") {
            self.redirectUrl = dict["RedirectUrl"] as! String
        }
        if dict.keys.contains("ScopesList") {
            self.scopesListShrink = dict["ScopesList"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Bool
        }
        if dict.keys.contains("Sub") {
            self.sub = dict["Sub"] as! String
        }
        if dict.keys.contains("TokenName") {
            self.tokenName = dict["TokenName"] as! String
        }
        if dict.keys.contains("TokenNamePrefix") {
            self.tokenNamePrefix = dict["TokenNamePrefix"] as! String
        }
        if dict.keys.contains("TokenPass") {
            self.tokenPass = dict["TokenPass"] as! Bool
        }
        if dict.keys.contains("TokenPosition") {
            self.tokenPosition = dict["TokenPosition"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddGatewayAuthResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGatewayAuthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayAuthConsumerRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var description_: String?

    public var encodeType: String?

    public var gatewayUniqueId: String?

    public var jwks: String?

    public var keyName: String?

    public var keyValue: String?

    public var name: String?

    public var tokenName: String?

    public var tokenPass: Bool?

    public var tokenPosition: String?

    public var tokenPrefix: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.encodeType != nil {
            map["EncodeType"] = self.encodeType!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.jwks != nil {
            map["Jwks"] = self.jwks!
        }
        if self.keyName != nil {
            map["KeyName"] = self.keyName!
        }
        if self.keyValue != nil {
            map["KeyValue"] = self.keyValue!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tokenName != nil {
            map["TokenName"] = self.tokenName!
        }
        if self.tokenPass != nil {
            map["TokenPass"] = self.tokenPass!
        }
        if self.tokenPosition != nil {
            map["TokenPosition"] = self.tokenPosition!
        }
        if self.tokenPrefix != nil {
            map["TokenPrefix"] = self.tokenPrefix!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EncodeType") {
            self.encodeType = dict["EncodeType"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Jwks") {
            self.jwks = dict["Jwks"] as! String
        }
        if dict.keys.contains("KeyName") {
            self.keyName = dict["KeyName"] as! String
        }
        if dict.keys.contains("KeyValue") {
            self.keyValue = dict["KeyValue"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TokenName") {
            self.tokenName = dict["TokenName"] as! String
        }
        if dict.keys.contains("TokenPass") {
            self.tokenPass = dict["TokenPass"] as! Bool
        }
        if dict.keys.contains("TokenPosition") {
            self.tokenPosition = dict["TokenPosition"] as! String
        }
        if dict.keys.contains("TokenPrefix") {
            self.tokenPrefix = dict["TokenPrefix"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddGatewayAuthConsumerResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayAuthConsumerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayAuthConsumerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGatewayAuthConsumerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayDomainRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certIdentifier: String?

    public var gatewayUniqueId: String?

    public var http2: String?

    public var mustHttps: Bool?

    public var name: String?

    public var protocol_: String?

    public var tlsMax: String?

    public var tlsMin: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.http2 != nil {
            map["Http2"] = self.http2!
        }
        if self.mustHttps != nil {
            map["MustHttps"] = self.mustHttps!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.tlsMax != nil {
            map["TlsMax"] = self.tlsMax!
        }
        if self.tlsMin != nil {
            map["TlsMin"] = self.tlsMin!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertIdentifier") {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Http2") {
            self.http2 = dict["Http2"] as! String
        }
        if dict.keys.contains("MustHttps") {
            self.mustHttps = dict["MustHttps"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("TlsMax") {
            self.tlsMax = dict["TlsMax"] as! String
        }
        if dict.keys.contains("TlsMin") {
            self.tlsMin = dict["TlsMin"] as! String
        }
    }
}

public class AddGatewayDomainResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGatewayDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayRouteRequest : Tea.TeaModel {
    public class DirectResponseJSON : Tea.TeaModel {
        public var body: String?

        public var code: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.body != nil {
                map["Body"] = self.body!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Body") {
                self.body = dict["Body"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! Int64
            }
        }
    }
    public class FallbackServices : Tea.TeaModel {
        public var agreementType: String?

        public var groupName: String?

        public var name: String?

        public var namespace: String?

        public var percent: Int32?

        public var serviceId: Int64?

        public var servicePort: Int32?

        public var sourceType: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agreementType != nil {
                map["AgreementType"] = self.agreementType!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgreementType") {
                self.agreementType = dict["AgreementType"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("ServiceId") {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") {
                self.servicePort = dict["ServicePort"] as! Int32
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public class Predicates : Tea.TeaModel {
        public class HeaderPredicates : Tea.TeaModel {
            public var key: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class PathPredicates : Tea.TeaModel {
            public var ignoreCase: Bool?

            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ignoreCase != nil {
                    map["IgnoreCase"] = self.ignoreCase!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IgnoreCase") {
                    self.ignoreCase = dict["IgnoreCase"] as! Bool
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class QueryPredicates : Tea.TeaModel {
            public var key: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var headerPredicates: [AddGatewayRouteRequest.Predicates.HeaderPredicates]?

        public var methodPredicates: [String]?

        public var pathPredicates: AddGatewayRouteRequest.Predicates.PathPredicates?

        public var queryPredicates: [AddGatewayRouteRequest.Predicates.QueryPredicates]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pathPredicates?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.headerPredicates != nil {
                var tmp : [Any] = []
                for k in self.headerPredicates! {
                    tmp.append(k.toMap())
                }
                map["HeaderPredicates"] = tmp
            }
            if self.methodPredicates != nil {
                map["MethodPredicates"] = self.methodPredicates!
            }
            if self.pathPredicates != nil {
                map["PathPredicates"] = self.pathPredicates?.toMap()
            }
            if self.queryPredicates != nil {
                var tmp : [Any] = []
                for k in self.queryPredicates! {
                    tmp.append(k.toMap())
                }
                map["QueryPredicates"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HeaderPredicates") {
                var tmp : [AddGatewayRouteRequest.Predicates.HeaderPredicates] = []
                for v in dict["HeaderPredicates"] as! [Any] {
                    var model = AddGatewayRouteRequest.Predicates.HeaderPredicates()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.headerPredicates = tmp
            }
            if dict.keys.contains("MethodPredicates") {
                self.methodPredicates = dict["MethodPredicates"] as! [String]
            }
            if dict.keys.contains("PathPredicates") {
                var model = AddGatewayRouteRequest.Predicates.PathPredicates()
                model.fromMap(dict["PathPredicates"] as! [String: Any])
                self.pathPredicates = model
            }
            if dict.keys.contains("QueryPredicates") {
                var tmp : [AddGatewayRouteRequest.Predicates.QueryPredicates] = []
                for v in dict["QueryPredicates"] as! [Any] {
                    var model = AddGatewayRouteRequest.Predicates.QueryPredicates()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.queryPredicates = tmp
            }
        }
    }
    public class RedirectJSON : Tea.TeaModel {
        public var code: Int32?

        public var host: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! Int32
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public class Services : Tea.TeaModel {
        public class HttpDubboTranscoder : Tea.TeaModel {
            public class MothedMapList : Tea.TeaModel {
                public class ParamMapsList : Tea.TeaModel {
                    public var extractKey: String?

                    public var extractKeySpec: String?

                    public var mappingType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extractKey != nil {
                            map["ExtractKey"] = self.extractKey!
                        }
                        if self.extractKeySpec != nil {
                            map["ExtractKeySpec"] = self.extractKeySpec!
                        }
                        if self.mappingType != nil {
                            map["MappingType"] = self.mappingType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExtractKey") {
                            self.extractKey = dict["ExtractKey"] as! String
                        }
                        if dict.keys.contains("ExtractKeySpec") {
                            self.extractKeySpec = dict["ExtractKeySpec"] as! String
                        }
                        if dict.keys.contains("MappingType") {
                            self.mappingType = dict["MappingType"] as! String
                        }
                    }
                }
                public var dubboMothedName: String?

                public var httpMothed: String?

                public var mothedpath: String?

                public var paramMapsList: [AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList]?

                public var passThroughAllHeaders: String?

                public var passThroughList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dubboMothedName != nil {
                        map["DubboMothedName"] = self.dubboMothedName!
                    }
                    if self.httpMothed != nil {
                        map["HttpMothed"] = self.httpMothed!
                    }
                    if self.mothedpath != nil {
                        map["Mothedpath"] = self.mothedpath!
                    }
                    if self.paramMapsList != nil {
                        var tmp : [Any] = []
                        for k in self.paramMapsList! {
                            tmp.append(k.toMap())
                        }
                        map["ParamMapsList"] = tmp
                    }
                    if self.passThroughAllHeaders != nil {
                        map["PassThroughAllHeaders"] = self.passThroughAllHeaders!
                    }
                    if self.passThroughList != nil {
                        map["PassThroughList"] = self.passThroughList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DubboMothedName") {
                        self.dubboMothedName = dict["DubboMothedName"] as! String
                    }
                    if dict.keys.contains("HttpMothed") {
                        self.httpMothed = dict["HttpMothed"] as! String
                    }
                    if dict.keys.contains("Mothedpath") {
                        self.mothedpath = dict["Mothedpath"] as! String
                    }
                    if dict.keys.contains("ParamMapsList") {
                        var tmp : [AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList] = []
                        for v in dict["ParamMapsList"] as! [Any] {
                            var model = AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.paramMapsList = tmp
                    }
                    if dict.keys.contains("PassThroughAllHeaders") {
                        self.passThroughAllHeaders = dict["PassThroughAllHeaders"] as! String
                    }
                    if dict.keys.contains("PassThroughList") {
                        self.passThroughList = dict["PassThroughList"] as! [String]
                    }
                }
            }
            public var dubboServiceGroup: String?

            public var dubboServiceName: String?

            public var dubboServiceVersion: String?

            public var mothedMapList: [AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dubboServiceGroup != nil {
                    map["DubboServiceGroup"] = self.dubboServiceGroup!
                }
                if self.dubboServiceName != nil {
                    map["DubboServiceName"] = self.dubboServiceName!
                }
                if self.dubboServiceVersion != nil {
                    map["DubboServiceVersion"] = self.dubboServiceVersion!
                }
                if self.mothedMapList != nil {
                    var tmp : [Any] = []
                    for k in self.mothedMapList! {
                        tmp.append(k.toMap())
                    }
                    map["MothedMapList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DubboServiceGroup") {
                    self.dubboServiceGroup = dict["DubboServiceGroup"] as! String
                }
                if dict.keys.contains("DubboServiceName") {
                    self.dubboServiceName = dict["DubboServiceName"] as! String
                }
                if dict.keys.contains("DubboServiceVersion") {
                    self.dubboServiceVersion = dict["DubboServiceVersion"] as! String
                }
                if dict.keys.contains("MothedMapList") {
                    var tmp : [AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList] = []
                    for v in dict["MothedMapList"] as! [Any] {
                        var model = AddGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.mothedMapList = tmp
                }
            }
        }
        public var agreementType: String?

        public var groupName: String?

        public var httpDubboTranscoder: AddGatewayRouteRequest.Services.HttpDubboTranscoder?

        public var name: String?

        public var namespace: String?

        public var percent: Int32?

        public var serviceId: Int64?

        public var servicePort: Int32?

        public var sourceType: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.httpDubboTranscoder?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agreementType != nil {
                map["AgreementType"] = self.agreementType!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.httpDubboTranscoder != nil {
                map["HttpDubboTranscoder"] = self.httpDubboTranscoder?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgreementType") {
                self.agreementType = dict["AgreementType"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("HttpDubboTranscoder") {
                var model = AddGatewayRouteRequest.Services.HttpDubboTranscoder()
                model.fromMap(dict["HttpDubboTranscoder"] as! [String: Any])
                self.httpDubboTranscoder = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("ServiceId") {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") {
                self.servicePort = dict["ServicePort"] as! Int32
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var description_: String?

    public var destinationType: String?

    public var directResponseJSON: AddGatewayRouteRequest.DirectResponseJSON?

    public var domainId: Int64?

    public var domainIdListJSON: String?

    public var enableWaf: Bool?

    public var fallback: Bool?

    public var fallbackServices: [AddGatewayRouteRequest.FallbackServices]?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var name: String?

    public var policies: String?

    public var predicates: AddGatewayRouteRequest.Predicates?

    public var redirectJSON: AddGatewayRouteRequest.RedirectJSON?

    public var routeOrder: Int32?

    public var routeType: String?

    public var services: [AddGatewayRouteRequest.Services]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.directResponseJSON?.validate()
        try self.predicates?.validate()
        try self.redirectJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.directResponseJSON != nil {
            map["DirectResponseJSON"] = self.directResponseJSON?.toMap()
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainIdListJSON != nil {
            map["DomainIdListJSON"] = self.domainIdListJSON!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.fallback != nil {
            map["Fallback"] = self.fallback!
        }
        if self.fallbackServices != nil {
            var tmp : [Any] = []
            for k in self.fallbackServices! {
                tmp.append(k.toMap())
            }
            map["FallbackServices"] = tmp
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.policies != nil {
            map["Policies"] = self.policies!
        }
        if self.predicates != nil {
            map["Predicates"] = self.predicates?.toMap()
        }
        if self.redirectJSON != nil {
            map["RedirectJSON"] = self.redirectJSON?.toMap()
        }
        if self.routeOrder != nil {
            map["RouteOrder"] = self.routeOrder!
        }
        if self.routeType != nil {
            map["RouteType"] = self.routeType!
        }
        if self.services != nil {
            var tmp : [Any] = []
            for k in self.services! {
                tmp.append(k.toMap())
            }
            map["Services"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationType") {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("DirectResponseJSON") {
            var model = AddGatewayRouteRequest.DirectResponseJSON()
            model.fromMap(dict["DirectResponseJSON"] as! [String: Any])
            self.directResponseJSON = model
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("DomainIdListJSON") {
            self.domainIdListJSON = dict["DomainIdListJSON"] as! String
        }
        if dict.keys.contains("EnableWaf") {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("Fallback") {
            self.fallback = dict["Fallback"] as! Bool
        }
        if dict.keys.contains("FallbackServices") {
            var tmp : [AddGatewayRouteRequest.FallbackServices] = []
            for v in dict["FallbackServices"] as! [Any] {
                var model = AddGatewayRouteRequest.FallbackServices()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fallbackServices = tmp
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Policies") {
            self.policies = dict["Policies"] as! String
        }
        if dict.keys.contains("Predicates") {
            var model = AddGatewayRouteRequest.Predicates()
            model.fromMap(dict["Predicates"] as! [String: Any])
            self.predicates = model
        }
        if dict.keys.contains("RedirectJSON") {
            var model = AddGatewayRouteRequest.RedirectJSON()
            model.fromMap(dict["RedirectJSON"] as! [String: Any])
            self.redirectJSON = model
        }
        if dict.keys.contains("RouteOrder") {
            self.routeOrder = dict["RouteOrder"] as! Int32
        }
        if dict.keys.contains("RouteType") {
            self.routeType = dict["RouteType"] as! String
        }
        if dict.keys.contains("Services") {
            var tmp : [AddGatewayRouteRequest.Services] = []
            for v in dict["Services"] as! [Any] {
                var model = AddGatewayRouteRequest.Services()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.services = tmp
        }
    }
}

public class AddGatewayRouteShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var description_: String?

    public var destinationType: String?

    public var directResponseJSONShrink: String?

    public var domainId: Int64?

    public var domainIdListJSON: String?

    public var enableWaf: Bool?

    public var fallback: Bool?

    public var fallbackServicesShrink: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var name: String?

    public var policies: String?

    public var predicatesShrink: String?

    public var redirectJSONShrink: String?

    public var routeOrder: Int32?

    public var routeType: String?

    public var servicesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.directResponseJSONShrink != nil {
            map["DirectResponseJSON"] = self.directResponseJSONShrink!
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainIdListJSON != nil {
            map["DomainIdListJSON"] = self.domainIdListJSON!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.fallback != nil {
            map["Fallback"] = self.fallback!
        }
        if self.fallbackServicesShrink != nil {
            map["FallbackServices"] = self.fallbackServicesShrink!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.policies != nil {
            map["Policies"] = self.policies!
        }
        if self.predicatesShrink != nil {
            map["Predicates"] = self.predicatesShrink!
        }
        if self.redirectJSONShrink != nil {
            map["RedirectJSON"] = self.redirectJSONShrink!
        }
        if self.routeOrder != nil {
            map["RouteOrder"] = self.routeOrder!
        }
        if self.routeType != nil {
            map["RouteType"] = self.routeType!
        }
        if self.servicesShrink != nil {
            map["Services"] = self.servicesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationType") {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("DirectResponseJSON") {
            self.directResponseJSONShrink = dict["DirectResponseJSON"] as! String
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("DomainIdListJSON") {
            self.domainIdListJSON = dict["DomainIdListJSON"] as! String
        }
        if dict.keys.contains("EnableWaf") {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("Fallback") {
            self.fallback = dict["Fallback"] as! Bool
        }
        if dict.keys.contains("FallbackServices") {
            self.fallbackServicesShrink = dict["FallbackServices"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Policies") {
            self.policies = dict["Policies"] as! String
        }
        if dict.keys.contains("Predicates") {
            self.predicatesShrink = dict["Predicates"] as! String
        }
        if dict.keys.contains("RedirectJSON") {
            self.redirectJSONShrink = dict["RedirectJSON"] as! String
        }
        if dict.keys.contains("RouteOrder") {
            self.routeOrder = dict["RouteOrder"] as! Int32
        }
        if dict.keys.contains("RouteType") {
            self.routeType = dict["RouteType"] as! String
        }
        if dict.keys.contains("Services") {
            self.servicesShrink = dict["Services"] as! String
        }
    }
}

public class AddGatewayRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewayServiceVersionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var serviceId: Int64?

    public var serviceVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceVersion != nil {
            map["ServiceVersion"] = self.serviceVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! Int64
        }
        if dict.keys.contains("ServiceVersion") {
            self.serviceVersion = dict["ServiceVersion"] as! String
        }
    }
}

public class AddGatewayServiceVersionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewayServiceVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewayServiceVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGatewayServiceVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGatewaySlbRequest : Tea.TeaModel {
    public class VServiceList : Tea.TeaModel {
        public var port: Int32?

        public var protocol_: String?

        public var VServerGroupId: String?

        public var VServerGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.VServerGroupId != nil {
                map["VServerGroupId"] = self.VServerGroupId!
            }
            if self.VServerGroupName != nil {
                map["VServerGroupName"] = self.VServerGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("VServerGroupId") {
                self.VServerGroupId = dict["VServerGroupId"] as! String
            }
            if dict.keys.contains("VServerGroupName") {
                self.VServerGroupName = dict["VServerGroupName"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var httpPort: Int32?

    public var httpsPort: Int32?

    public var httpsVServerGroupId: String?

    public var serviceWeight: Int32?

    public var slbId: String?

    public var type: String?

    public var VServerGroupId: String?

    public var VServiceList: [AddGatewaySlbRequest.VServiceList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.httpPort != nil {
            map["HttpPort"] = self.httpPort!
        }
        if self.httpsPort != nil {
            map["HttpsPort"] = self.httpsPort!
        }
        if self.httpsVServerGroupId != nil {
            map["HttpsVServerGroupId"] = self.httpsVServerGroupId!
        }
        if self.serviceWeight != nil {
            map["ServiceWeight"] = self.serviceWeight!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.VServerGroupId != nil {
            map["VServerGroupId"] = self.VServerGroupId!
        }
        if self.VServiceList != nil {
            var tmp : [Any] = []
            for k in self.VServiceList! {
                tmp.append(k.toMap())
            }
            map["VServiceList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HttpPort") {
            self.httpPort = dict["HttpPort"] as! Int32
        }
        if dict.keys.contains("HttpsPort") {
            self.httpsPort = dict["HttpsPort"] as! Int32
        }
        if dict.keys.contains("HttpsVServerGroupId") {
            self.httpsVServerGroupId = dict["HttpsVServerGroupId"] as! String
        }
        if dict.keys.contains("ServiceWeight") {
            self.serviceWeight = dict["ServiceWeight"] as! Int32
        }
        if dict.keys.contains("SlbId") {
            self.slbId = dict["SlbId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VServerGroupId") {
            self.VServerGroupId = dict["VServerGroupId"] as! String
        }
        if dict.keys.contains("VServiceList") {
            var tmp : [AddGatewaySlbRequest.VServiceList] = []
            for v in dict["VServiceList"] as! [Any] {
                var model = AddGatewaySlbRequest.VServiceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.VServiceList = tmp
        }
    }
}

public class AddGatewaySlbShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var httpPort: Int32?

    public var httpsPort: Int32?

    public var httpsVServerGroupId: String?

    public var serviceWeight: Int32?

    public var slbId: String?

    public var type: String?

    public var VServerGroupId: String?

    public var VServiceListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.httpPort != nil {
            map["HttpPort"] = self.httpPort!
        }
        if self.httpsPort != nil {
            map["HttpsPort"] = self.httpsPort!
        }
        if self.httpsVServerGroupId != nil {
            map["HttpsVServerGroupId"] = self.httpsVServerGroupId!
        }
        if self.serviceWeight != nil {
            map["ServiceWeight"] = self.serviceWeight!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.VServerGroupId != nil {
            map["VServerGroupId"] = self.VServerGroupId!
        }
        if self.VServiceListShrink != nil {
            map["VServiceList"] = self.VServiceListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HttpPort") {
            self.httpPort = dict["HttpPort"] as! Int32
        }
        if dict.keys.contains("HttpsPort") {
            self.httpsPort = dict["HttpsPort"] as! Int32
        }
        if dict.keys.contains("HttpsVServerGroupId") {
            self.httpsVServerGroupId = dict["HttpsVServerGroupId"] as! String
        }
        if dict.keys.contains("ServiceWeight") {
            self.serviceWeight = dict["ServiceWeight"] as! Int32
        }
        if dict.keys.contains("SlbId") {
            self.slbId = dict["SlbId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VServerGroupId") {
            self.VServerGroupId = dict["VServerGroupId"] as! String
        }
        if dict.keys.contains("VServiceList") {
            self.VServiceListShrink = dict["VServiceList"] as! String
        }
    }
}

public class AddGatewaySlbResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddGatewaySlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGatewaySlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGatewaySlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMigrationTaskRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterType: String?

    public var originInstanceAddress: String?

    public var originInstanceName: String?

    public var originInstanceNamespace: String?

    public var projectDesc: String?

    public var requestPars: String?

    public var syncType: String?

    public var targetClusterName: String?

    public var targetClusterUrl: String?

    public var targetInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.originInstanceAddress != nil {
            map["OriginInstanceAddress"] = self.originInstanceAddress!
        }
        if self.originInstanceName != nil {
            map["OriginInstanceName"] = self.originInstanceName!
        }
        if self.originInstanceNamespace != nil {
            map["OriginInstanceNamespace"] = self.originInstanceNamespace!
        }
        if self.projectDesc != nil {
            map["ProjectDesc"] = self.projectDesc!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.syncType != nil {
            map["SyncType"] = self.syncType!
        }
        if self.targetClusterName != nil {
            map["TargetClusterName"] = self.targetClusterName!
        }
        if self.targetClusterUrl != nil {
            map["TargetClusterUrl"] = self.targetClusterUrl!
        }
        if self.targetInstanceId != nil {
            map["TargetInstanceId"] = self.targetInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("OriginInstanceAddress") {
            self.originInstanceAddress = dict["OriginInstanceAddress"] as! String
        }
        if dict.keys.contains("OriginInstanceName") {
            self.originInstanceName = dict["OriginInstanceName"] as! String
        }
        if dict.keys.contains("OriginInstanceNamespace") {
            self.originInstanceNamespace = dict["OriginInstanceNamespace"] as! String
        }
        if dict.keys.contains("ProjectDesc") {
            self.projectDesc = dict["ProjectDesc"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("SyncType") {
            self.syncType = dict["SyncType"] as! String
        }
        if dict.keys.contains("TargetClusterName") {
            self.targetClusterName = dict["TargetClusterName"] as! String
        }
        if dict.keys.contains("TargetClusterUrl") {
            self.targetClusterUrl = dict["TargetClusterUrl"] as! String
        }
        if dict.keys.contains("TargetInstanceId") {
            self.targetInstanceId = dict["TargetInstanceId"] as! String
        }
    }
}

public class AddMigrationTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterType: String?

        public var id: String?

        public var originInstanceAddress: String?

        public var originInstanceName: String?

        public var originInstanceNamespace: String?

        public var projectDesc: String?

        public var syncType: String?

        public var targetClusterName: String?

        public var targetClusterUrl: String?

        public var targetInstanceId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.originInstanceAddress != nil {
                map["OriginInstanceAddress"] = self.originInstanceAddress!
            }
            if self.originInstanceName != nil {
                map["OriginInstanceName"] = self.originInstanceName!
            }
            if self.originInstanceNamespace != nil {
                map["OriginInstanceNamespace"] = self.originInstanceNamespace!
            }
            if self.projectDesc != nil {
                map["ProjectDesc"] = self.projectDesc!
            }
            if self.syncType != nil {
                map["SyncType"] = self.syncType!
            }
            if self.targetClusterName != nil {
                map["TargetClusterName"] = self.targetClusterName!
            }
            if self.targetClusterUrl != nil {
                map["TargetClusterUrl"] = self.targetClusterUrl!
            }
            if self.targetInstanceId != nil {
                map["TargetInstanceId"] = self.targetInstanceId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterType") {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("OriginInstanceAddress") {
                self.originInstanceAddress = dict["OriginInstanceAddress"] as! String
            }
            if dict.keys.contains("OriginInstanceName") {
                self.originInstanceName = dict["OriginInstanceName"] as! String
            }
            if dict.keys.contains("OriginInstanceNamespace") {
                self.originInstanceNamespace = dict["OriginInstanceNamespace"] as! String
            }
            if dict.keys.contains("ProjectDesc") {
                self.projectDesc = dict["ProjectDesc"] as! String
            }
            if dict.keys.contains("SyncType") {
                self.syncType = dict["SyncType"] as! String
            }
            if dict.keys.contains("TargetClusterName") {
                self.targetClusterName = dict["TargetClusterName"] as! String
            }
            if dict.keys.contains("TargetClusterUrl") {
                self.targetClusterUrl = dict["TargetClusterUrl"] as! String
            }
            if dict.keys.contains("TargetInstanceId") {
                self.targetInstanceId = dict["TargetInstanceId"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var data: AddMigrationTaskResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = AddMigrationTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddMigrationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMigrationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMigrationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMockRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerAppIds: String?

    public var dubboMockItems: String?

    public var enable: Bool?

    public var extraJson: String?

    public var mockType: Int64?

    public var name: String?

    public var providerAppId: String?

    public var providerAppName: String?

    public var region: String?

    public var scMockItems: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerAppIds != nil {
            map["ConsumerAppIds"] = self.consumerAppIds!
        }
        if self.dubboMockItems != nil {
            map["DubboMockItems"] = self.dubboMockItems!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.extraJson != nil {
            map["ExtraJson"] = self.extraJson!
        }
        if self.mockType != nil {
            map["MockType"] = self.mockType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.providerAppId != nil {
            map["ProviderAppId"] = self.providerAppId!
        }
        if self.providerAppName != nil {
            map["ProviderAppName"] = self.providerAppName!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.scMockItems != nil {
            map["ScMockItems"] = self.scMockItems!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerAppIds") {
            self.consumerAppIds = dict["ConsumerAppIds"] as! String
        }
        if dict.keys.contains("DubboMockItems") {
            self.dubboMockItems = dict["DubboMockItems"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("ExtraJson") {
            self.extraJson = dict["ExtraJson"] as! String
        }
        if dict.keys.contains("MockType") {
            self.mockType = dict["MockType"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProviderAppId") {
            self.providerAppId = dict["ProviderAppId"] as! String
        }
        if dict.keys.contains("ProviderAppName") {
            self.providerAppName = dict["ProviderAppName"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("ScMockItems") {
            self.scMockItems = dict["ScMockItems"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
    }
}

public class AddMockRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accountId: String?

        public var consumerAppId: String?

        public var consumerAppName: String?

        public var enable: Bool?

        public var extraJson: String?

        public var id: Int64?

        public var mockType: Int64?

        public var name: String?

        public var namespaceId: String?

        public var providerAppId: String?

        public var providerAppName: String?

        public var region: String?

        public var scMockItemJson: String?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.consumerAppId != nil {
                map["ConsumerAppId"] = self.consumerAppId!
            }
            if self.consumerAppName != nil {
                map["ConsumerAppName"] = self.consumerAppName!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.extraJson != nil {
                map["ExtraJson"] = self.extraJson!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.mockType != nil {
                map["MockType"] = self.mockType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.providerAppId != nil {
                map["ProviderAppId"] = self.providerAppId!
            }
            if self.providerAppName != nil {
                map["ProviderAppName"] = self.providerAppName!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.scMockItemJson != nil {
                map["ScMockItemJson"] = self.scMockItemJson!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("ConsumerAppId") {
                self.consumerAppId = dict["ConsumerAppId"] as! String
            }
            if dict.keys.contains("ConsumerAppName") {
                self.consumerAppName = dict["ConsumerAppName"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("ExtraJson") {
                self.extraJson = dict["ExtraJson"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MockType") {
                self.mockType = dict["MockType"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("ProviderAppId") {
                self.providerAppId = dict["ProviderAppId"] as! String
            }
            if dict.keys.contains("ProviderAppName") {
                self.providerAppName = dict["ProviderAppName"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("ScMockItemJson") {
                self.scMockItemJson = dict["ScMockItemJson"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: AddMockRuleResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = AddMockRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddMockRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMockRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMockRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSSLCertRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certIdentifier: String?

    public var domainId: Int64?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertIdentifier") {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class AddSSLCertResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddSSLCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSSLCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddSSLCertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSecurityGroupRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var description_: String?

    public var gatewayUniqueId: String?

    public var portRange: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class AddSecurityGroupRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddSecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddSecurityGroupRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddServiceSourceRequest : Tea.TeaModel {
    public class IngressOptionsRequest : Tea.TeaModel {
        public var enableIngress: Bool?

        public var enableStatus: Bool?

        public var ingressClass: String?

        public var watchNamespace: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableIngress != nil {
                map["EnableIngress"] = self.enableIngress!
            }
            if self.enableStatus != nil {
                map["EnableStatus"] = self.enableStatus!
            }
            if self.ingressClass != nil {
                map["IngressClass"] = self.ingressClass!
            }
            if self.watchNamespace != nil {
                map["WatchNamespace"] = self.watchNamespace!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableIngress") {
                self.enableIngress = dict["EnableIngress"] as! Bool
            }
            if dict.keys.contains("EnableStatus") {
                self.enableStatus = dict["EnableStatus"] as! Bool
            }
            if dict.keys.contains("IngressClass") {
                self.ingressClass = dict["IngressClass"] as! String
            }
            if dict.keys.contains("WatchNamespace") {
                self.watchNamespace = dict["WatchNamespace"] as! String
            }
        }
    }
    public class ToAuthorizeSecurityGroups : Tea.TeaModel {
        public var description_: String?

        public var portRange: String?

        public var securityGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var address: String?

    public var gatewayUniqueId: String?

    public var groupList: [String]?

    public var ingressOptionsRequest: AddServiceSourceRequest.IngressOptionsRequest?

    public var name: String?

    public var pathList: [String]?

    public var source: String?

    public var toAuthorizeSecurityGroups: [AddServiceSourceRequest.ToAuthorizeSecurityGroups]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ingressOptionsRequest?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.groupList != nil {
            map["GroupList"] = self.groupList!
        }
        if self.ingressOptionsRequest != nil {
            map["IngressOptionsRequest"] = self.ingressOptionsRequest?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pathList != nil {
            map["PathList"] = self.pathList!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.toAuthorizeSecurityGroups != nil {
            var tmp : [Any] = []
            for k in self.toAuthorizeSecurityGroups! {
                tmp.append(k.toMap())
            }
            map["ToAuthorizeSecurityGroups"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GroupList") {
            self.groupList = dict["GroupList"] as! [String]
        }
        if dict.keys.contains("IngressOptionsRequest") {
            var model = AddServiceSourceRequest.IngressOptionsRequest()
            model.fromMap(dict["IngressOptionsRequest"] as! [String: Any])
            self.ingressOptionsRequest = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PathList") {
            self.pathList = dict["PathList"] as! [String]
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("ToAuthorizeSecurityGroups") {
            var tmp : [AddServiceSourceRequest.ToAuthorizeSecurityGroups] = []
            for v in dict["ToAuthorizeSecurityGroups"] as! [Any] {
                var model = AddServiceSourceRequest.ToAuthorizeSecurityGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.toAuthorizeSecurityGroups = tmp
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddServiceSourceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var gatewayUniqueId: String?

    public var groupListShrink: String?

    public var ingressOptionsRequestShrink: String?

    public var name: String?

    public var pathListShrink: String?

    public var source: String?

    public var toAuthorizeSecurityGroupsShrink: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.groupListShrink != nil {
            map["GroupList"] = self.groupListShrink!
        }
        if self.ingressOptionsRequestShrink != nil {
            map["IngressOptionsRequest"] = self.ingressOptionsRequestShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pathListShrink != nil {
            map["PathList"] = self.pathListShrink!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.toAuthorizeSecurityGroupsShrink != nil {
            map["ToAuthorizeSecurityGroups"] = self.toAuthorizeSecurityGroupsShrink!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GroupList") {
            self.groupListShrink = dict["GroupList"] as! String
        }
        if dict.keys.contains("IngressOptionsRequest") {
            self.ingressOptionsRequestShrink = dict["IngressOptionsRequest"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PathList") {
            self.pathListShrink = dict["PathList"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("ToAuthorizeSecurityGroups") {
            self.toAuthorizeSecurityGroupsShrink = dict["ToAuthorizeSecurityGroups"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddServiceSourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddServiceSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddServiceSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddServiceSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyGatewayRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var routeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! String
        }
    }
}

public class ApplyGatewayRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ApplyGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyTagPoliciesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var namespace: String?

    public var namespaceId: String?

    public var region: String?

    public var rules: [String: RulesValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.rules != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.rules! {
                tmp[k] = v.toMap()
            }
            map["Rules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Rules") {
            var tmp : [String: RulesValue] = [:]
            for (k, v) in dict["Rules"] as! [String: Any] {
                if v != nil {
                    var model = RulesValue()
                    model.fromMap(v as! [String: Any])
                    tmp[k] = model
                }
            }
            self.rules = tmp
        }
    }
}

public class ApplyTagPoliciesShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var namespace: String?

    public var namespaceId: String?

    public var region: String?

    public var rulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.rulesShrink != nil {
            map["Rules"] = self.rulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Rules") {
            self.rulesShrink = dict["Rules"] as! String
        }
    }
}

public class ApplyTagPoliciesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var carryData: Bool?

        public var enable: Bool?

        public var id: Int64?

        public var instanceNum: Int32?

        public var name: String?

        public var rate: Int32?

        public var remove: Bool?

        public var rules: String?

        public var status: Int32?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.carryData != nil {
                map["CarryData"] = self.carryData!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceNum != nil {
                map["InstanceNum"] = self.instanceNum!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.rate != nil {
                map["Rate"] = self.rate!
            }
            if self.remove != nil {
                map["Remove"] = self.remove!
            }
            if self.rules != nil {
                map["Rules"] = self.rules!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CarryData") {
                self.carryData = dict["CarryData"] as! Bool
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceNum") {
                self.instanceNum = dict["InstanceNum"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Rate") {
                self.rate = dict["Rate"] as! Int32
            }
            if dict.keys.contains("Remove") {
                self.remove = dict["Remove"] as! Bool
            }
            if dict.keys.contains("Rules") {
                self.rules = dict["Rules"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Tag") {
                self.tag = dict["Tag"] as! String
            }
        }
    }
    public var data: [ApplyTagPoliciesResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ApplyTagPoliciesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ApplyTagPoliciesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ApplyTagPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyTagPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyTagPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindSentinelBlockFallbackDefinitionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var fallbackId: Int64?

    public var namespace: String?

    public var resource: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.fallbackId != nil {
            map["FallbackId"] = self.fallbackId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("FallbackId") {
            self.fallbackId = dict["FallbackId"] as! Int64
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Resource") {
            self.resource = dict["Resource"] as! String
        }
        if dict.keys.contains("TargetType") {
            self.targetType = dict["TargetType"] as! String
        }
    }
}

public class BindSentinelBlockFallbackDefinitionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class BindSentinelBlockFallbackDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindSentinelBlockFallbackDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindSentinelBlockFallbackDefinitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeResourceGroupRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var resourceGroupId: String?

    public var resourceId: String?

    public var resourceRegionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceRegionId != nil {
            map["ResourceRegionId"] = self.resourceRegionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceRegionId") {
            self.resourceRegionId = dict["ResourceRegionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ChangeResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloneNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dataIds: String?

    public var ids: String?

    public var instanceId: String?

    public var originNamespaceId: String?

    public var policy: String?

    public var targetNamespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dataIds != nil {
            map["DataIds"] = self.dataIds!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.originNamespaceId != nil {
            map["OriginNamespaceId"] = self.originNamespaceId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.targetNamespaceId != nil {
            map["TargetNamespaceId"] = self.targetNamespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DataIds") {
            self.dataIds = dict["DataIds"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OriginNamespaceId") {
            self.originNamespaceId = dict["OriginNamespaceId"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("TargetNamespaceId") {
            self.targetNamespaceId = dict["TargetNamespaceId"] as! String
        }
    }
}

public class CloneNacosConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FailData : Tea.TeaModel {
            public var dataId: String?

            public var group: String?

            public var reason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataId != nil {
                    map["DataId"] = self.dataId!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataId") {
                    self.dataId = dict["DataId"] as! String
                }
                if dict.keys.contains("Group") {
                    self.group = dict["Group"] as! String
                }
                if dict.keys.contains("Reason") {
                    self.reason = dict["Reason"] as! String
                }
            }
        }
        public class SkipData : Tea.TeaModel {
            public var dataId: String?

            public var group: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataId != nil {
                    map["DataId"] = self.dataId!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataId") {
                    self.dataId = dict["DataId"] as! String
                }
                if dict.keys.contains("Group") {
                    self.group = dict["Group"] as! String
                }
            }
        }
        public var failData: [CloneNacosConfigResponseBody.Data.FailData]?

        public var skipCount: Int32?

        public var skipData: [CloneNacosConfigResponseBody.Data.SkipData]?

        public var succCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failData != nil {
                var tmp : [Any] = []
                for k in self.failData! {
                    tmp.append(k.toMap())
                }
                map["FailData"] = tmp
            }
            if self.skipCount != nil {
                map["SkipCount"] = self.skipCount!
            }
            if self.skipData != nil {
                var tmp : [Any] = []
                for k in self.skipData! {
                    tmp.append(k.toMap())
                }
                map["SkipData"] = tmp
            }
            if self.succCount != nil {
                map["SuccCount"] = self.succCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailData") {
                var tmp : [CloneNacosConfigResponseBody.Data.FailData] = []
                for v in dict["FailData"] as! [Any] {
                    var model = CloneNacosConfigResponseBody.Data.FailData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.failData = tmp
            }
            if dict.keys.contains("SkipCount") {
                self.skipCount = dict["SkipCount"] as! Int32
            }
            if dict.keys.contains("SkipData") {
                var tmp : [CloneNacosConfigResponseBody.Data.SkipData] = []
                for v in dict["SkipData"] as! [Any] {
                    var model = CloneNacosConfigResponseBody.Data.SkipData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.skipData = tmp
            }
            if dict.keys.contains("SuccCount") {
                self.succCount = dict["SuccCount"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: CloneNacosConfigResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = CloneNacosConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CloneNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloneNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CloneNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloneSentinelRuleFromAhasRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ahasNamespace: String?

    public var appName: String?

    public var isAHASPublicRegion: Bool?

    public var mseAppName: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ahasNamespace != nil {
            map["AhasNamespace"] = self.ahasNamespace!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.isAHASPublicRegion != nil {
            map["IsAHASPublicRegion"] = self.isAHASPublicRegion!
        }
        if self.mseAppName != nil {
            map["MseAppName"] = self.mseAppName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AhasNamespace") {
            self.ahasNamespace = dict["AhasNamespace"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("IsAHASPublicRegion") {
            self.isAHASPublicRegion = dict["IsAHASPublicRegion"] as! Bool
        }
        if dict.keys.contains("MseAppName") {
            self.mseAppName = dict["MseAppName"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class CloneSentinelRuleFromAhasResponseBody : Tea.TeaModel {
    public var data: [String: [String]]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String: [String]]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CloneSentinelRuleFromAhasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloneSentinelRuleFromAhasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CloneSentinelRuleFromAhasResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApplicationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var language: String?

    public var namespace: String?

    public var region: String?

    public var sentinelEnable: String?

    public var source: String?

    public var switchEnable: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.sentinelEnable != nil {
            map["SentinelEnable"] = self.sentinelEnable!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.switchEnable != nil {
            map["SwitchEnable"] = self.switchEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("SentinelEnable") {
            self.sentinelEnable = dict["SentinelEnable"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SwitchEnable") {
            self.switchEnable = dict["SwitchEnable"] as! String
        }
    }
}

public class CreateApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var createTime: Int64?

        public var extraInfo: String?

        public var language: String?

        public var licenseKey: String?

        public var namespace: String?

        public var regionId: String?

        public var source: String?

        public var status: Int32?

        public var updateTime: Int64?

        public var userId: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.licenseKey != nil {
                map["LicenseKey"] = self.licenseKey!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ExtraInfo") {
                self.extraInfo = dict["ExtraInfo"] as! String
            }
            if dict.keys.contains("Language") {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("LicenseKey") {
                self.licenseKey = dict["LicenseKey"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: CreateApplicationResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = CreateApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCircuitBreakerRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var halfOpenBaseAmountPerStep: Int32?

    public var halfOpenRecoveryStepNum: Int32?

    public var maxAllowedRtMs: Int32?

    public var minRequestAmount: Int32?

    public var namespace: String?

    public var regionId: String?

    public var resource: String?

    public var resourceType: Int32?

    public var retryTimeoutMs: Int32?

    public var statIntervalMs: Int32?

    public var strategy: Int32?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.halfOpenBaseAmountPerStep != nil {
            map["HalfOpenBaseAmountPerStep"] = self.halfOpenBaseAmountPerStep!
        }
        if self.halfOpenRecoveryStepNum != nil {
            map["HalfOpenRecoveryStepNum"] = self.halfOpenRecoveryStepNum!
        }
        if self.maxAllowedRtMs != nil {
            map["MaxAllowedRtMs"] = self.maxAllowedRtMs!
        }
        if self.minRequestAmount != nil {
            map["MinRequestAmount"] = self.minRequestAmount!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.retryTimeoutMs != nil {
            map["RetryTimeoutMs"] = self.retryTimeoutMs!
        }
        if self.statIntervalMs != nil {
            map["StatIntervalMs"] = self.statIntervalMs!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("HalfOpenBaseAmountPerStep") {
            self.halfOpenBaseAmountPerStep = dict["HalfOpenBaseAmountPerStep"] as! Int32
        }
        if dict.keys.contains("HalfOpenRecoveryStepNum") {
            self.halfOpenRecoveryStepNum = dict["HalfOpenRecoveryStepNum"] as! Int32
        }
        if dict.keys.contains("MaxAllowedRtMs") {
            self.maxAllowedRtMs = dict["MaxAllowedRtMs"] as! Int32
        }
        if dict.keys.contains("MinRequestAmount") {
            self.minRequestAmount = dict["MinRequestAmount"] as! Int32
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Resource") {
            self.resource = dict["Resource"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! Int32
        }
        if dict.keys.contains("RetryTimeoutMs") {
            self.retryTimeoutMs = dict["RetryTimeoutMs"] as! Int32
        }
        if dict.keys.contains("StatIntervalMs") {
            self.statIntervalMs = dict["StatIntervalMs"] as! Int32
        }
        if dict.keys.contains("Strategy") {
            self.strategy = dict["Strategy"] as! Int32
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Double
        }
    }
}

public class CreateCircuitBreakerRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var enable: Bool?

        public var halfOpenBaseAmountPerStep: Int32?

        public var halfOpenRecoveryStepNum: Int32?

        public var id: Int64?

        public var maxAllowedRtMs: Int32?

        public var minRequestAmount: Int32?

        public var namespace: String?

        public var regionId: String?

        public var resource: String?

        public var retryTimeoutMs: Int32?

        public var statIntervalMs: Int32?

        public var strategy: Int32?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.halfOpenBaseAmountPerStep != nil {
                map["HalfOpenBaseAmountPerStep"] = self.halfOpenBaseAmountPerStep!
            }
            if self.halfOpenRecoveryStepNum != nil {
                map["HalfOpenRecoveryStepNum"] = self.halfOpenRecoveryStepNum!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.maxAllowedRtMs != nil {
                map["MaxAllowedRtMs"] = self.maxAllowedRtMs!
            }
            if self.minRequestAmount != nil {
                map["MinRequestAmount"] = self.minRequestAmount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            if self.retryTimeoutMs != nil {
                map["RetryTimeoutMs"] = self.retryTimeoutMs!
            }
            if self.statIntervalMs != nil {
                map["StatIntervalMs"] = self.statIntervalMs!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("HalfOpenBaseAmountPerStep") {
                self.halfOpenBaseAmountPerStep = dict["HalfOpenBaseAmountPerStep"] as! Int32
            }
            if dict.keys.contains("HalfOpenRecoveryStepNum") {
                self.halfOpenRecoveryStepNum = dict["HalfOpenRecoveryStepNum"] as! Int32
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MaxAllowedRtMs") {
                self.maxAllowedRtMs = dict["MaxAllowedRtMs"] as! Int32
            }
            if dict.keys.contains("MinRequestAmount") {
                self.minRequestAmount = dict["MinRequestAmount"] as! Int32
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Resource") {
                self.resource = dict["Resource"] as! String
            }
            if dict.keys.contains("RetryTimeoutMs") {
                self.retryTimeoutMs = dict["RetryTimeoutMs"] as! Int32
            }
            if dict.keys.contains("StatIntervalMs") {
                self.statIntervalMs = dict["StatIntervalMs"] as! Int32
            }
            if dict.keys.contains("Strategy") {
                self.strategy = dict["Strategy"] as! Int32
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var code: String?

    public var data: CreateCircuitBreakerRuleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateCircuitBreakerRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateCircuitBreakerRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCircuitBreakerRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCircuitBreakerRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateClusterRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var chargeType: String?

    public var clusterSpecification: String?

    public var clusterType: String?

    public var clusterVersion: String?

    public var connectionType: String?

    public var diskType: String?

    public var eipEnabled: Bool?

    public var instanceCount: Int32?

    public var instanceName: String?

    public var mseVersion: String?

    public var netType: String?

    public var privateSlbSpecification: String?

    public var pubNetworkFlow: String?

    public var pubSlbSpecification: String?

    public var region: String?

    public var requestPars: String?

    public var resourceGroupId: String?

    public var securityGroupType: String?

    public var tag: [CreateClusterRequest.Tag]?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clusterSpecification != nil {
            map["ClusterSpecification"] = self.clusterSpecification!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.clusterVersion != nil {
            map["ClusterVersion"] = self.clusterVersion!
        }
        if self.connectionType != nil {
            map["ConnectionType"] = self.connectionType!
        }
        if self.diskType != nil {
            map["DiskType"] = self.diskType!
        }
        if self.eipEnabled != nil {
            map["EipEnabled"] = self.eipEnabled!
        }
        if self.instanceCount != nil {
            map["InstanceCount"] = self.instanceCount!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.netType != nil {
            map["NetType"] = self.netType!
        }
        if self.privateSlbSpecification != nil {
            map["PrivateSlbSpecification"] = self.privateSlbSpecification!
        }
        if self.pubNetworkFlow != nil {
            map["PubNetworkFlow"] = self.pubNetworkFlow!
        }
        if self.pubSlbSpecification != nil {
            map["PubSlbSpecification"] = self.pubSlbSpecification!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityGroupType != nil {
            map["SecurityGroupType"] = self.securityGroupType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClusterSpecification") {
            self.clusterSpecification = dict["ClusterSpecification"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("ClusterVersion") {
            self.clusterVersion = dict["ClusterVersion"] as! String
        }
        if dict.keys.contains("ConnectionType") {
            self.connectionType = dict["ConnectionType"] as! String
        }
        if dict.keys.contains("DiskType") {
            self.diskType = dict["DiskType"] as! String
        }
        if dict.keys.contains("EipEnabled") {
            self.eipEnabled = dict["EipEnabled"] as! Bool
        }
        if dict.keys.contains("InstanceCount") {
            self.instanceCount = dict["InstanceCount"] as! Int32
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("MseVersion") {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("NetType") {
            self.netType = dict["NetType"] as! String
        }
        if dict.keys.contains("PrivateSlbSpecification") {
            self.privateSlbSpecification = dict["PrivateSlbSpecification"] as! String
        }
        if dict.keys.contains("PubNetworkFlow") {
            self.pubNetworkFlow = dict["PubNetworkFlow"] as! String
        }
        if dict.keys.contains("PubSlbSpecification") {
            self.pubSlbSpecification = dict["PubSlbSpecification"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupType") {
            self.securityGroupType = dict["SecurityGroupType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateClusterRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateClusterRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var instanceId: String?

    public var message: String?

    public var orderId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEngineNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var desc: String?

    public var id: String?

    public var instanceId: String?

    public var name: String?

    public var serviceCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.serviceCount != nil {
            map["ServiceCount"] = self.serviceCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Desc") {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ServiceCount") {
            self.serviceCount = dict["ServiceCount"] as! Int32
        }
    }
}

public class CreateEngineNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configCount: Int32?

        public var namespace: String?

        public var namespaceDesc: String?

        public var namespaceShowName: String?

        public var quota: Int32?

        public var serviceCount: Int32?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configCount != nil {
                map["ConfigCount"] = self.configCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.namespaceDesc != nil {
                map["NamespaceDesc"] = self.namespaceDesc!
            }
            if self.namespaceShowName != nil {
                map["NamespaceShowName"] = self.namespaceShowName!
            }
            if self.quota != nil {
                map["Quota"] = self.quota!
            }
            if self.serviceCount != nil {
                map["ServiceCount"] = self.serviceCount!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigCount") {
                self.configCount = dict["ConfigCount"] as! Int32
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NamespaceDesc") {
                self.namespaceDesc = dict["NamespaceDesc"] as! String
            }
            if dict.keys.contains("NamespaceShowName") {
                self.namespaceShowName = dict["NamespaceShowName"] as! String
            }
            if dict.keys.contains("Quota") {
                self.quota = dict["Quota"] as! Int32
            }
            if dict.keys.contains("ServiceCount") {
                self.serviceCount = dict["ServiceCount"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var clusterId: String?

    public var data: CreateEngineNamespaceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateEngineNamespaceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateEngineNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEngineNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEngineNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFlowRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var controlBehavior: Int32?

    public var enable: Bool?

    public var limitApp: String?

    public var maxQueueingTimeMs: Int32?

    public var namespace: String?

    public var regionId: String?

    public var resource: String?

    public var resourceType: Int32?

    public var threshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.controlBehavior != nil {
            map["ControlBehavior"] = self.controlBehavior!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.limitApp != nil {
            map["LimitApp"] = self.limitApp!
        }
        if self.maxQueueingTimeMs != nil {
            map["MaxQueueingTimeMs"] = self.maxQueueingTimeMs!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ControlBehavior") {
            self.controlBehavior = dict["ControlBehavior"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("LimitApp") {
            self.limitApp = dict["LimitApp"] as! String
        }
        if dict.keys.contains("MaxQueueingTimeMs") {
            self.maxQueueingTimeMs = dict["MaxQueueingTimeMs"] as! Int32
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Resource") {
            self.resource = dict["Resource"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! Int32
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Int32
        }
    }
}

public class CreateFlowRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var controlBehavior: Int32?

        public var enable: Bool?

        public var id: Int64?

        public var limitApp: String?

        public var maxQueueingTimeMs: Int32?

        public var namespace: String?

        public var regionId: String?

        public var resource: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.controlBehavior != nil {
                map["ControlBehavior"] = self.controlBehavior!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.limitApp != nil {
                map["LimitApp"] = self.limitApp!
            }
            if self.maxQueueingTimeMs != nil {
                map["MaxQueueingTimeMs"] = self.maxQueueingTimeMs!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ControlBehavior") {
                self.controlBehavior = dict["ControlBehavior"] as! Int32
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("LimitApp") {
                self.limitApp = dict["LimitApp"] as! String
            }
            if dict.keys.contains("MaxQueueingTimeMs") {
                self.maxQueueingTimeMs = dict["MaxQueueingTimeMs"] as! Int32
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Resource") {
                self.resource = dict["Resource"] as! String
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var code: String?

    public var data: CreateFlowRuleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateFlowRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateFlowRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFlowRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateGatewayCircuitBreakerRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var behaviorType: Int32?

    public var bodyEncoding: Int32?

    public var enable: Int32?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var maxAllowedMs: Int32?

    public var minRequestAmount: Int32?

    public var recoveryTimeoutSec: Int32?

    public var responseContentBody: String?

    public var responseRedirectUrl: String?

    public var responseStatusCode: Int32?

    public var routeId: Int64?

    public var routeName: String?

    public var statDurationSec: Int32?

    public var strategy: Int32?

    public var triggerRatio: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.behaviorType != nil {
            map["BehaviorType"] = self.behaviorType!
        }
        if self.bodyEncoding != nil {
            map["BodyEncoding"] = self.bodyEncoding!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.maxAllowedMs != nil {
            map["MaxAllowedMs"] = self.maxAllowedMs!
        }
        if self.minRequestAmount != nil {
            map["MinRequestAmount"] = self.minRequestAmount!
        }
        if self.recoveryTimeoutSec != nil {
            map["RecoveryTimeoutSec"] = self.recoveryTimeoutSec!
        }
        if self.responseContentBody != nil {
            map["ResponseContentBody"] = self.responseContentBody!
        }
        if self.responseRedirectUrl != nil {
            map["ResponseRedirectUrl"] = self.responseRedirectUrl!
        }
        if self.responseStatusCode != nil {
            map["ResponseStatusCode"] = self.responseStatusCode!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        if self.routeName != nil {
            map["RouteName"] = self.routeName!
        }
        if self.statDurationSec != nil {
            map["StatDurationSec"] = self.statDurationSec!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        if self.triggerRatio != nil {
            map["TriggerRatio"] = self.triggerRatio!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("BehaviorType") {
            self.behaviorType = dict["BehaviorType"] as! Int32
        }
        if dict.keys.contains("BodyEncoding") {
            self.bodyEncoding = dict["BodyEncoding"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Int32
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MaxAllowedMs") {
            self.maxAllowedMs = dict["MaxAllowedMs"] as! Int32
        }
        if dict.keys.contains("MinRequestAmount") {
            self.minRequestAmount = dict["MinRequestAmount"] as! Int32
        }
        if dict.keys.contains("RecoveryTimeoutSec") {
            self.recoveryTimeoutSec = dict["RecoveryTimeoutSec"] as! Int32
        }
        if dict.keys.contains("ResponseContentBody") {
            self.responseContentBody = dict["ResponseContentBody"] as! String
        }
        if dict.keys.contains("ResponseRedirectUrl") {
            self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
        }
        if dict.keys.contains("ResponseStatusCode") {
            self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
        if dict.keys.contains("RouteName") {
            self.routeName = dict["RouteName"] as! String
        }
        if dict.keys.contains("StatDurationSec") {
            self.statDurationSec = dict["StatDurationSec"] as! Int32
        }
        if dict.keys.contains("Strategy") {
            self.strategy = dict["Strategy"] as! Int32
        }
        if dict.keys.contains("TriggerRatio") {
            self.triggerRatio = dict["TriggerRatio"] as! Int32
        }
    }
}

public class CreateGatewayCircuitBreakerRuleResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateGatewayCircuitBreakerRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGatewayCircuitBreakerRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateGatewayCircuitBreakerRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateGatewayFlowRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var behaviorType: Int32?

    public var bodyEncoding: Int32?

    public var enable: Int32?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var responseContentBody: String?

    public var responseRedirectUrl: String?

    public var responseStatusCode: Int32?

    public var routeId: Int64?

    public var routeName: String?

    public var threshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.behaviorType != nil {
            map["BehaviorType"] = self.behaviorType!
        }
        if self.bodyEncoding != nil {
            map["BodyEncoding"] = self.bodyEncoding!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.responseContentBody != nil {
            map["ResponseContentBody"] = self.responseContentBody!
        }
        if self.responseRedirectUrl != nil {
            map["ResponseRedirectUrl"] = self.responseRedirectUrl!
        }
        if self.responseStatusCode != nil {
            map["ResponseStatusCode"] = self.responseStatusCode!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        if self.routeName != nil {
            map["RouteName"] = self.routeName!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("BehaviorType") {
            self.behaviorType = dict["BehaviorType"] as! Int32
        }
        if dict.keys.contains("BodyEncoding") {
            self.bodyEncoding = dict["BodyEncoding"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Int32
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ResponseContentBody") {
            self.responseContentBody = dict["ResponseContentBody"] as! String
        }
        if dict.keys.contains("ResponseRedirectUrl") {
            self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
        }
        if dict.keys.contains("ResponseStatusCode") {
            self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
        if dict.keys.contains("RouteName") {
            self.routeName = dict["RouteName"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Int32
        }
    }
}

public class CreateGatewayFlowRuleResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateGatewayFlowRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGatewayFlowRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateGatewayFlowRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateGatewayIsolationRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var behaviorType: Int32?

    public var bodyEncoding: Int32?

    public var enable: Int32?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var maxConcurrency: Int32?

    public var responseContentBody: String?

    public var responseRedirectUrl: String?

    public var responseStatusCode: Int32?

    public var routeId: Int64?

    public var routeName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.behaviorType != nil {
            map["BehaviorType"] = self.behaviorType!
        }
        if self.bodyEncoding != nil {
            map["BodyEncoding"] = self.bodyEncoding!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.maxConcurrency != nil {
            map["MaxConcurrency"] = self.maxConcurrency!
        }
        if self.responseContentBody != nil {
            map["ResponseContentBody"] = self.responseContentBody!
        }
        if self.responseRedirectUrl != nil {
            map["ResponseRedirectUrl"] = self.responseRedirectUrl!
        }
        if self.responseStatusCode != nil {
            map["ResponseStatusCode"] = self.responseStatusCode!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        if self.routeName != nil {
            map["RouteName"] = self.routeName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("BehaviorType") {
            self.behaviorType = dict["BehaviorType"] as! Int32
        }
        if dict.keys.contains("BodyEncoding") {
            self.bodyEncoding = dict["BodyEncoding"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Int32
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("MaxConcurrency") {
            self.maxConcurrency = dict["MaxConcurrency"] as! Int32
        }
        if dict.keys.contains("ResponseContentBody") {
            self.responseContentBody = dict["ResponseContentBody"] as! String
        }
        if dict.keys.contains("ResponseRedirectUrl") {
            self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
        }
        if dict.keys.contains("ResponseStatusCode") {
            self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
        if dict.keys.contains("RouteName") {
            self.routeName = dict["RouteName"] as! String
        }
    }
}

public class CreateGatewayIsolationRuleResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateGatewayIsolationRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGatewayIsolationRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateGatewayIsolationRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIsolationRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var limitApp: String?

    public var namespace: String?

    public var regionId: String?

    public var resource: String?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.limitApp != nil {
            map["LimitApp"] = self.limitApp!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("LimitApp") {
            self.limitApp = dict["LimitApp"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Resource") {
            self.resource = dict["Resource"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Double
        }
    }
}

public class CreateIsolationRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var enable: Bool?

        public var id: Int64?

        public var limitApp: String?

        public var namespace: String?

        public var regionId: String?

        public var resource: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.limitApp != nil {
                map["LimitApp"] = self.limitApp!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("LimitApp") {
                self.limitApp = dict["LimitApp"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Resource") {
                self.resource = dict["Resource"] as! String
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var code: String?

    public var data: CreateIsolationRuleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateIsolationRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateIsolationRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIsolationRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIsolationRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMseServiceApplicationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var extraInfo: String?

    public var language: String?

    public var mseVersion: String?

    public var region: String?

    public var sentinelEnable: String?

    public var source: String?

    public var switchEnable: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.extraInfo != nil {
            map["ExtraInfo"] = self.extraInfo!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.sentinelEnable != nil {
            map["SentinelEnable"] = self.sentinelEnable!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.switchEnable != nil {
            map["SwitchEnable"] = self.switchEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ExtraInfo") {
            self.extraInfo = dict["ExtraInfo"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("MseVersion") {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("SentinelEnable") {
            self.sentinelEnable = dict["SentinelEnable"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SwitchEnable") {
            self.switchEnable = dict["SwitchEnable"] as! String
        }
    }
}

public class CreateMseServiceApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var createTime: Int64?

        public var extraInfo: String?

        public var language: String?

        public var licenseKey: String?

        public var regionId: String?

        public var source: String?

        public var status: Int32?

        public var updateTime: Int64?

        public var userId: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.language != nil {
                map["Language"] = self.language!
            }
            if self.licenseKey != nil {
                map["LicenseKey"] = self.licenseKey!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ExtraInfo") {
                self.extraInfo = dict["ExtraInfo"] as! String
            }
            if dict.keys.contains("Language") {
                self.language = dict["Language"] as! String
            }
            if dict.keys.contains("LicenseKey") {
                self.licenseKey = dict["LicenseKey"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var data: CreateMseServiceApplicationResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateMseServiceApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateMseServiceApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMseServiceApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMseServiceApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var betaIps: String?

    public var content: String?

    public var dataId: String?

    public var desc: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var tags: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.betaIps != nil {
            map["BetaIps"] = self.betaIps!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BetaIps") {
            self.betaIps = dict["BetaIps"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Desc") {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateNacosConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNacosInstanceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterName: String?

    public var enabled: Bool?

    public var ephemeral: Bool?

    public var groupName: String?

    public var instanceId: String?

    public var ip: String?

    public var metadata: String?

    public var namespaceId: String?

    public var port: Int32?

    public var serviceName: String?

    public var weight: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.ephemeral != nil {
            map["Ephemeral"] = self.ephemeral!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.metadata != nil {
            map["Metadata"] = self.metadata!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("Ephemeral") {
            self.ephemeral = dict["Ephemeral"] as! Bool
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Metadata") {
            self.metadata = dict["Metadata"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! String
        }
    }
}

public class CreateNacosInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateNacosInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNacosInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNacosInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNacosServiceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var ephemeral: Bool?

    public var groupName: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var protectThreshold: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.ephemeral != nil {
            map["Ephemeral"] = self.ephemeral!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.protectThreshold != nil {
            map["ProtectThreshold"] = self.protectThreshold!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Ephemeral") {
            self.ephemeral = dict["Ephemeral"] as! Bool
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("ProtectThreshold") {
            self.protectThreshold = dict["ProtectThreshold"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class CreateNacosServiceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateNacosServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNacosServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNacosServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var describe: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.describe != nil {
            map["Describe"] = self.describe!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Describe") {
            self.describe = dict["Describe"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class CreateNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var namespace: String?

        public var region: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
        }
    }
    public var data: CreateNamespaceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateNamespaceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateSwimmingLaneRequest : Tea.TeaModel {
    public class EntryRules : Tea.TeaModel {
        public class RestItems : Tea.TeaModel {
            public var cond: String?

            public var datum: String?

            public var divisor: Int32?

            public var name: String?

            public var nameList: [String]?

            public var operator_: String?

            public var rate: Int32?

            public var remainder: Int32?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cond != nil {
                    map["Cond"] = self.cond!
                }
                if self.datum != nil {
                    map["Datum"] = self.datum!
                }
                if self.divisor != nil {
                    map["Divisor"] = self.divisor!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameList != nil {
                    map["NameList"] = self.nameList!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.remainder != nil {
                    map["Remainder"] = self.remainder!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cond") {
                    self.cond = dict["Cond"] as! String
                }
                if dict.keys.contains("Datum") {
                    self.datum = dict["Datum"] as! String
                }
                if dict.keys.contains("Divisor") {
                    self.divisor = dict["Divisor"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NameList") {
                    self.nameList = dict["NameList"] as! [String]
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! Int32
                }
                if dict.keys.contains("Remainder") {
                    self.remainder = dict["Remainder"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var condition: String?

        public var paths: [String]?

        public var priority: Int32?

        public var restItems: [CreateOrUpdateSwimmingLaneRequest.EntryRules.RestItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.paths != nil {
                map["Paths"] = self.paths!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.restItems != nil {
                var tmp : [Any] = []
                for k in self.restItems! {
                    tmp.append(k.toMap())
                }
                map["RestItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Condition") {
                self.condition = dict["Condition"] as! String
            }
            if dict.keys.contains("Paths") {
                self.paths = dict["Paths"] as! [String]
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("RestItems") {
                var tmp : [CreateOrUpdateSwimmingLaneRequest.EntryRules.RestItems] = []
                for v in dict["RestItems"] as! [Any] {
                    var model = CreateOrUpdateSwimmingLaneRequest.EntryRules.RestItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.restItems = tmp
            }
        }
    }
    public class GatewaySwimmingLaneRouteJson : Tea.TeaModel {
        public class Conditions : Tea.TeaModel {
            public var cond: String?

            public var name: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cond != nil {
                    map["Cond"] = self.cond!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cond") {
                    self.cond = dict["Cond"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class RouteIndependentPercentageList : Tea.TeaModel {
            public var percentage: Int32?

            public var routeId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.percentage != nil {
                    map["Percentage"] = self.percentage!
                }
                if self.routeId != nil {
                    map["RouteId"] = self.routeId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Percentage") {
                    self.percentage = dict["Percentage"] as! Int32
                }
                if dict.keys.contains("RouteId") {
                    self.routeId = dict["RouteId"] as! Int64
                }
            }
        }
        public var canaryModel: Int32?

        public var condition: String?

        public var conditions: [CreateOrUpdateSwimmingLaneRequest.GatewaySwimmingLaneRouteJson.Conditions]?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var percentage: Int32?

        public var routeIdList: [Int64]?

        public var routeIndependentPercentageEnable: Bool?

        public var routeIndependentPercentageList: [CreateOrUpdateSwimmingLaneRequest.GatewaySwimmingLaneRouteJson.RouteIndependentPercentageList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canaryModel != nil {
                map["CanaryModel"] = self.canaryModel!
            }
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.conditions != nil {
                var tmp : [Any] = []
                for k in self.conditions! {
                    tmp.append(k.toMap())
                }
                map["Conditions"] = tmp
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.percentage != nil {
                map["Percentage"] = self.percentage!
            }
            if self.routeIdList != nil {
                map["RouteIdList"] = self.routeIdList!
            }
            if self.routeIndependentPercentageEnable != nil {
                map["RouteIndependentPercentageEnable"] = self.routeIndependentPercentageEnable!
            }
            if self.routeIndependentPercentageList != nil {
                var tmp : [Any] = []
                for k in self.routeIndependentPercentageList! {
                    tmp.append(k.toMap())
                }
                map["RouteIndependentPercentageList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanaryModel") {
                self.canaryModel = dict["CanaryModel"] as! Int32
            }
            if dict.keys.contains("Condition") {
                self.condition = dict["Condition"] as! String
            }
            if dict.keys.contains("Conditions") {
                var tmp : [CreateOrUpdateSwimmingLaneRequest.GatewaySwimmingLaneRouteJson.Conditions] = []
                for v in dict["Conditions"] as! [Any] {
                    var model = CreateOrUpdateSwimmingLaneRequest.GatewaySwimmingLaneRouteJson.Conditions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.conditions = tmp
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("Percentage") {
                self.percentage = dict["Percentage"] as! Int32
            }
            if dict.keys.contains("RouteIdList") {
                self.routeIdList = dict["RouteIdList"] as! [Int64]
            }
            if dict.keys.contains("RouteIndependentPercentageEnable") {
                self.routeIndependentPercentageEnable = dict["RouteIndependentPercentageEnable"] as! Bool
            }
            if dict.keys.contains("RouteIndependentPercentageList") {
                var tmp : [CreateOrUpdateSwimmingLaneRequest.GatewaySwimmingLaneRouteJson.RouteIndependentPercentageList] = []
                for v in dict["RouteIndependentPercentageList"] as! [Any] {
                    var model = CreateOrUpdateSwimmingLaneRequest.GatewaySwimmingLaneRouteJson.RouteIndependentPercentageList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.routeIndependentPercentageList = tmp
            }
        }
    }
    public var acceptLanguage: String?

    public var enable: Bool?

    public var enableRules: Bool?

    public var entryRule: String?

    public var entryRules: [CreateOrUpdateSwimmingLaneRequest.EntryRules]?

    public var gatewaySwimmingLaneRouteJson: CreateOrUpdateSwimmingLaneRequest.GatewaySwimmingLaneRouteJson?

    public var groupId: Int64?

    public var id: Int64?

    public var name: String?

    public var namespace: String?

    public var pathIndependentPercentageEnable: Bool?

    public var regionId: String?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gatewaySwimmingLaneRouteJson?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.enableRules != nil {
            map["EnableRules"] = self.enableRules!
        }
        if self.entryRule != nil {
            map["EntryRule"] = self.entryRule!
        }
        if self.entryRules != nil {
            var tmp : [Any] = []
            for k in self.entryRules! {
                tmp.append(k.toMap())
            }
            map["EntryRules"] = tmp
        }
        if self.gatewaySwimmingLaneRouteJson != nil {
            map["GatewaySwimmingLaneRouteJson"] = self.gatewaySwimmingLaneRouteJson?.toMap()
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pathIndependentPercentageEnable != nil {
            map["PathIndependentPercentageEnable"] = self.pathIndependentPercentageEnable!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("EnableRules") {
            self.enableRules = dict["EnableRules"] as! Bool
        }
        if dict.keys.contains("EntryRule") {
            self.entryRule = dict["EntryRule"] as! String
        }
        if dict.keys.contains("EntryRules") {
            var tmp : [CreateOrUpdateSwimmingLaneRequest.EntryRules] = []
            for v in dict["EntryRules"] as! [Any] {
                var model = CreateOrUpdateSwimmingLaneRequest.EntryRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.entryRules = tmp
        }
        if dict.keys.contains("GatewaySwimmingLaneRouteJson") {
            var model = CreateOrUpdateSwimmingLaneRequest.GatewaySwimmingLaneRouteJson()
            model.fromMap(dict["GatewaySwimmingLaneRouteJson"] as! [String: Any])
            self.gatewaySwimmingLaneRouteJson = model
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PathIndependentPercentageEnable") {
            self.pathIndependentPercentageEnable = dict["PathIndependentPercentageEnable"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class CreateOrUpdateSwimmingLaneShrinkRequest : Tea.TeaModel {
    public class EntryRules : Tea.TeaModel {
        public class RestItems : Tea.TeaModel {
            public var cond: String?

            public var datum: String?

            public var divisor: Int32?

            public var name: String?

            public var nameList: [String]?

            public var operator_: String?

            public var rate: Int32?

            public var remainder: Int32?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cond != nil {
                    map["Cond"] = self.cond!
                }
                if self.datum != nil {
                    map["Datum"] = self.datum!
                }
                if self.divisor != nil {
                    map["Divisor"] = self.divisor!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameList != nil {
                    map["NameList"] = self.nameList!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.remainder != nil {
                    map["Remainder"] = self.remainder!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cond") {
                    self.cond = dict["Cond"] as! String
                }
                if dict.keys.contains("Datum") {
                    self.datum = dict["Datum"] as! String
                }
                if dict.keys.contains("Divisor") {
                    self.divisor = dict["Divisor"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NameList") {
                    self.nameList = dict["NameList"] as! [String]
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! Int32
                }
                if dict.keys.contains("Remainder") {
                    self.remainder = dict["Remainder"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var condition: String?

        public var paths: [String]?

        public var priority: Int32?

        public var restItems: [CreateOrUpdateSwimmingLaneShrinkRequest.EntryRules.RestItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.paths != nil {
                map["Paths"] = self.paths!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.restItems != nil {
                var tmp : [Any] = []
                for k in self.restItems! {
                    tmp.append(k.toMap())
                }
                map["RestItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Condition") {
                self.condition = dict["Condition"] as! String
            }
            if dict.keys.contains("Paths") {
                self.paths = dict["Paths"] as! [String]
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("RestItems") {
                var tmp : [CreateOrUpdateSwimmingLaneShrinkRequest.EntryRules.RestItems] = []
                for v in dict["RestItems"] as! [Any] {
                    var model = CreateOrUpdateSwimmingLaneShrinkRequest.EntryRules.RestItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.restItems = tmp
            }
        }
    }
    public var acceptLanguage: String?

    public var enable: Bool?

    public var enableRules: Bool?

    public var entryRule: String?

    public var entryRules: [CreateOrUpdateSwimmingLaneShrinkRequest.EntryRules]?

    public var gatewaySwimmingLaneRouteJsonShrink: String?

    public var groupId: Int64?

    public var id: Int64?

    public var name: String?

    public var namespace: String?

    public var pathIndependentPercentageEnable: Bool?

    public var regionId: String?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.enableRules != nil {
            map["EnableRules"] = self.enableRules!
        }
        if self.entryRule != nil {
            map["EntryRule"] = self.entryRule!
        }
        if self.entryRules != nil {
            var tmp : [Any] = []
            for k in self.entryRules! {
                tmp.append(k.toMap())
            }
            map["EntryRules"] = tmp
        }
        if self.gatewaySwimmingLaneRouteJsonShrink != nil {
            map["GatewaySwimmingLaneRouteJson"] = self.gatewaySwimmingLaneRouteJsonShrink!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pathIndependentPercentageEnable != nil {
            map["PathIndependentPercentageEnable"] = self.pathIndependentPercentageEnable!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("EnableRules") {
            self.enableRules = dict["EnableRules"] as! Bool
        }
        if dict.keys.contains("EntryRule") {
            self.entryRule = dict["EntryRule"] as! String
        }
        if dict.keys.contains("EntryRules") {
            var tmp : [CreateOrUpdateSwimmingLaneShrinkRequest.EntryRules] = []
            for v in dict["EntryRules"] as! [Any] {
                var model = CreateOrUpdateSwimmingLaneShrinkRequest.EntryRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.entryRules = tmp
        }
        if dict.keys.contains("GatewaySwimmingLaneRouteJson") {
            self.gatewaySwimmingLaneRouteJsonShrink = dict["GatewaySwimmingLaneRouteJson"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PathIndependentPercentageEnable") {
            self.pathIndependentPercentageEnable = dict["PathIndependentPercentageEnable"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class CreateOrUpdateSwimmingLaneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EntryRules : Tea.TeaModel {
            public class RestItems : Tea.TeaModel {
                public var cond: String?

                public var datum: String?

                public var divisor: Int32?

                public var name: String?

                public var nameList: [String]?

                public var operator_: String?

                public var rate: Int32?

                public var remainder: Int32?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.datum != nil {
                        map["datum"] = self.datum!
                    }
                    if self.divisor != nil {
                        map["divisor"] = self.divisor!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.nameList != nil {
                        map["nameList"] = self.nameList!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.rate != nil {
                        map["rate"] = self.rate!
                    }
                    if self.remainder != nil {
                        map["remainder"] = self.remainder!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("cond") {
                        self.cond = dict["cond"] as! String
                    }
                    if dict.keys.contains("datum") {
                        self.datum = dict["datum"] as! String
                    }
                    if dict.keys.contains("divisor") {
                        self.divisor = dict["divisor"] as! Int32
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("nameList") {
                        self.nameList = dict["nameList"] as! [String]
                    }
                    if dict.keys.contains("operator") {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("rate") {
                        self.rate = dict["rate"] as! Int32
                    }
                    if dict.keys.contains("remainder") {
                        self.remainder = dict["remainder"] as! Int32
                    }
                    if dict.keys.contains("type") {
                        self.type = dict["type"] as! String
                    }
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var condition: String?

            public var path: String?

            public var paths: [String]?

            public var restItems: [CreateOrUpdateSwimmingLaneResponseBody.Data.EntryRules.RestItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.paths != nil {
                    map["paths"] = self.paths!
                }
                if self.restItems != nil {
                    var tmp : [Any] = []
                    for k in self.restItems! {
                        tmp.append(k.toMap())
                    }
                    map["restItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("condition") {
                    self.condition = dict["condition"] as! String
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("paths") {
                    self.paths = dict["paths"] as! [String]
                }
                if dict.keys.contains("restItems") {
                    var tmp : [CreateOrUpdateSwimmingLaneResponseBody.Data.EntryRules.RestItems] = []
                    for v in dict["restItems"] as! [Any] {
                        var model = CreateOrUpdateSwimmingLaneResponseBody.Data.EntryRules.RestItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.restItems = tmp
                }
            }
        }
        public var enable: Bool?

        public var enableRules: Bool?

        public var entryRule: String?

        public var entryRules: [CreateOrUpdateSwimmingLaneResponseBody.Data.EntryRules]?

        public var gatewaySwimmingLaneRouteJson: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var groupId: Int64?

        public var id: Int64?

        public var name: String?

        public var pathIndependentPercentageEnable: Bool?

        public var regionId: String?

        public var status: Int32?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["enable"] = self.enable!
            }
            if self.enableRules != nil {
                map["enableRules"] = self.enableRules!
            }
            if self.entryRule != nil {
                map["entryRule"] = self.entryRule!
            }
            if self.entryRules != nil {
                var tmp : [Any] = []
                for k in self.entryRules! {
                    tmp.append(k.toMap())
                }
                map["entryRules"] = tmp
            }
            if self.gatewaySwimmingLaneRouteJson != nil {
                map["gatewaySwimmingLaneRouteJson"] = self.gatewaySwimmingLaneRouteJson!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.groupId != nil {
                map["groupId"] = self.groupId!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.pathIndependentPercentageEnable != nil {
                map["pathIndependentPercentageEnable"] = self.pathIndependentPercentageEnable!
            }
            if self.regionId != nil {
                map["regionId"] = self.regionId!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.tag != nil {
                map["tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("enable") {
                self.enable = dict["enable"] as! Bool
            }
            if dict.keys.contains("enableRules") {
                self.enableRules = dict["enableRules"] as! Bool
            }
            if dict.keys.contains("entryRule") {
                self.entryRule = dict["entryRule"] as! String
            }
            if dict.keys.contains("entryRules") {
                var tmp : [CreateOrUpdateSwimmingLaneResponseBody.Data.EntryRules] = []
                for v in dict["entryRules"] as! [Any] {
                    var model = CreateOrUpdateSwimmingLaneResponseBody.Data.EntryRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.entryRules = tmp
            }
            if dict.keys.contains("gatewaySwimmingLaneRouteJson") {
                self.gatewaySwimmingLaneRouteJson = dict["gatewaySwimmingLaneRouteJson"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! String
            }
            if dict.keys.contains("groupId") {
                self.groupId = dict["groupId"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("pathIndependentPercentageEnable") {
                self.pathIndependentPercentageEnable = dict["pathIndependentPercentageEnable"] as! Bool
            }
            if dict.keys.contains("regionId") {
                self.regionId = dict["regionId"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! Int32
            }
            if dict.keys.contains("tag") {
                self.tag = dict["tag"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: CreateOrUpdateSwimmingLaneResponseBody.Data?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = CreateOrUpdateSwimmingLaneResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateOrUpdateSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrUpdateSwimmingLaneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appIds: String?

    public var canaryModel: Int32?

    public var dbGrayEnable: Bool?

    public var entryApp: String?

    public var id: Int64?

    public var messageQueueFilterSide: String?

    public var messageQueueGrayEnable: Bool?

    public var name: String?

    public var namespace: String?

    public var paths: [String]?

    public var recordCanaryDetail: Bool?

    public var region: String?

    public var routeIds: [Int64]?

    public var status: Int32?

    public var swimVersion: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.canaryModel != nil {
            map["CanaryModel"] = self.canaryModel!
        }
        if self.dbGrayEnable != nil {
            map["DbGrayEnable"] = self.dbGrayEnable!
        }
        if self.entryApp != nil {
            map["EntryApp"] = self.entryApp!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.messageQueueFilterSide != nil {
            map["MessageQueueFilterSide"] = self.messageQueueFilterSide!
        }
        if self.messageQueueGrayEnable != nil {
            map["MessageQueueGrayEnable"] = self.messageQueueGrayEnable!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.paths != nil {
            map["Paths"] = self.paths!
        }
        if self.recordCanaryDetail != nil {
            map["RecordCanaryDetail"] = self.recordCanaryDetail!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.routeIds != nil {
            map["RouteIds"] = self.routeIds!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.swimVersion != nil {
            map["SwimVersion"] = self.swimVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppIds") {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("CanaryModel") {
            self.canaryModel = dict["CanaryModel"] as! Int32
        }
        if dict.keys.contains("DbGrayEnable") {
            self.dbGrayEnable = dict["DbGrayEnable"] as! Bool
        }
        if dict.keys.contains("EntryApp") {
            self.entryApp = dict["EntryApp"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MessageQueueFilterSide") {
            self.messageQueueFilterSide = dict["MessageQueueFilterSide"] as! String
        }
        if dict.keys.contains("MessageQueueGrayEnable") {
            self.messageQueueGrayEnable = dict["MessageQueueGrayEnable"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Paths") {
            self.paths = dict["Paths"] as! [String]
        }
        if dict.keys.contains("RecordCanaryDetail") {
            self.recordCanaryDetail = dict["RecordCanaryDetail"] as! Bool
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RouteIds") {
            self.routeIds = dict["RouteIds"] as! [Int64]
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("SwimVersion") {
            self.swimVersion = dict["SwimVersion"] as! Int32
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appIds: String?

    public var canaryModel: Int32?

    public var dbGrayEnable: Bool?

    public var entryApp: String?

    public var id: Int64?

    public var messageQueueFilterSide: String?

    public var messageQueueGrayEnable: Bool?

    public var name: String?

    public var namespace: String?

    public var pathsShrink: String?

    public var recordCanaryDetail: Bool?

    public var region: String?

    public var routeIdsShrink: String?

    public var status: Int32?

    public var swimVersion: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.canaryModel != nil {
            map["CanaryModel"] = self.canaryModel!
        }
        if self.dbGrayEnable != nil {
            map["DbGrayEnable"] = self.dbGrayEnable!
        }
        if self.entryApp != nil {
            map["EntryApp"] = self.entryApp!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.messageQueueFilterSide != nil {
            map["MessageQueueFilterSide"] = self.messageQueueFilterSide!
        }
        if self.messageQueueGrayEnable != nil {
            map["MessageQueueGrayEnable"] = self.messageQueueGrayEnable!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pathsShrink != nil {
            map["Paths"] = self.pathsShrink!
        }
        if self.recordCanaryDetail != nil {
            map["RecordCanaryDetail"] = self.recordCanaryDetail!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.routeIdsShrink != nil {
            map["RouteIds"] = self.routeIdsShrink!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.swimVersion != nil {
            map["SwimVersion"] = self.swimVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppIds") {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("CanaryModel") {
            self.canaryModel = dict["CanaryModel"] as! Int32
        }
        if dict.keys.contains("DbGrayEnable") {
            self.dbGrayEnable = dict["DbGrayEnable"] as! Bool
        }
        if dict.keys.contains("EntryApp") {
            self.entryApp = dict["EntryApp"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MessageQueueFilterSide") {
            self.messageQueueFilterSide = dict["MessageQueueFilterSide"] as! String
        }
        if dict.keys.contains("MessageQueueGrayEnable") {
            self.messageQueueGrayEnable = dict["MessageQueueGrayEnable"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Paths") {
            self.pathsShrink = dict["Paths"] as! String
        }
        if dict.keys.contains("RecordCanaryDetail") {
            self.recordCanaryDetail = dict["RecordCanaryDetail"] as! Bool
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RouteIds") {
            self.routeIdsShrink = dict["RouteIds"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("SwimVersion") {
            self.swimVersion = dict["SwimVersion"] as! Int32
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appIds: String?

        public var canaryModel: Int32?

        public var dbGrayEnable: String?

        public var entryApp: String?

        public var id: Int64?

        public var messageQueueFilterSide: String?

        public var messageQueueGrayEnable: Bool?

        public var name: String?

        public var namespace: String?

        public var paths: String?

        public var recordCanaryDetail: Bool?

        public var region: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appIds != nil {
                map["AppIds"] = self.appIds!
            }
            if self.canaryModel != nil {
                map["CanaryModel"] = self.canaryModel!
            }
            if self.dbGrayEnable != nil {
                map["DbGrayEnable"] = self.dbGrayEnable!
            }
            if self.entryApp != nil {
                map["EntryApp"] = self.entryApp!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.messageQueueFilterSide != nil {
                map["MessageQueueFilterSide"] = self.messageQueueFilterSide!
            }
            if self.messageQueueGrayEnable != nil {
                map["MessageQueueGrayEnable"] = self.messageQueueGrayEnable!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.paths != nil {
                map["Paths"] = self.paths!
            }
            if self.recordCanaryDetail != nil {
                map["RecordCanaryDetail"] = self.recordCanaryDetail!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppIds") {
                self.appIds = dict["AppIds"] as! String
            }
            if dict.keys.contains("CanaryModel") {
                self.canaryModel = dict["CanaryModel"] as! Int32
            }
            if dict.keys.contains("DbGrayEnable") {
                self.dbGrayEnable = dict["DbGrayEnable"] as! String
            }
            if dict.keys.contains("EntryApp") {
                self.entryApp = dict["EntryApp"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MessageQueueFilterSide") {
                self.messageQueueFilterSide = dict["MessageQueueFilterSide"] as! String
            }
            if dict.keys.contains("MessageQueueGrayEnable") {
                self.messageQueueGrayEnable = dict["MessageQueueGrayEnable"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Paths") {
                self.paths = dict["Paths"] as! String
            }
            if dict.keys.contains("RecordCanaryDetail") {
                self.recordCanaryDetail = dict["RecordCanaryDetail"] as! Bool
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var data: CreateOrUpdateSwimmingLaneGroupResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateOrUpdateSwimmingLaneGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrUpdateSwimmingLaneGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePluginConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var config: String?

    public var configLevel: Int32?

    public var enable: Bool?

    public var gatewayUniqueId: String?

    public var pluginId: Int64?

    public var resourceIdList: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.configLevel != nil {
            map["ConfigLevel"] = self.configLevel!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.resourceIdList != nil {
            map["ResourceIdList"] = self.resourceIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("ConfigLevel") {
            self.configLevel = dict["ConfigLevel"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! Int64
        }
        if dict.keys.contains("ResourceIdList") {
            self.resourceIdList = dict["ResourceIdList"] as! [Int64]
        }
    }
}

public class CreatePluginConfigShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var config: String?

    public var configLevel: Int32?

    public var enable: Bool?

    public var gatewayUniqueId: String?

    public var pluginId: Int64?

    public var resourceIdListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.configLevel != nil {
            map["ConfigLevel"] = self.configLevel!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.resourceIdListShrink != nil {
            map["ResourceIdList"] = self.resourceIdListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("ConfigLevel") {
            self.configLevel = dict["ConfigLevel"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! Int64
        }
        if dict.keys.contains("ResourceIdList") {
            self.resourceIdListShrink = dict["ResourceIdList"] as! String
        }
    }
}

public class CreatePluginConfigResponseBody : Tea.TeaModel {
    public var pluginConfigID: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pluginConfigID != nil {
            map["PluginConfigID"] = self.pluginConfigID!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PluginConfigID") {
            self.pluginConfigID = dict["PluginConfigID"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePluginConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePluginConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePluginConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateZnodeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var data: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
    }
}

public class CreateZnodeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var dir: Bool?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Dir") {
                self.dir = dict["Dir"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var data: CreateZnodeResponseBody.Data?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateZnodeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateZnodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateZnodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateZnodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAuthResourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteAuthResourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var authId: Int64?

        public var domainId: Int64?

        public var domainName: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var isWhite: Bool?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authId != nil {
                map["AuthId"] = self.authId!
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isWhite != nil {
                map["IsWhite"] = self.isWhite!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthId") {
                self.authId = dict["AuthId"] as! Int64
            }
            if dict.keys.contains("DomainId") {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IsWhite") {
                self.isWhite = dict["IsWhite"] as! Bool
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteAuthResourceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DeleteAuthResourceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteAuthResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAuthResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAuthResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCircuitBreakerRulesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var ids: [Int64]?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int64]
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteCircuitBreakerRulesShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var idsShrink: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteCircuitBreakerRulesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [Int64]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [Int64]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCircuitBreakerRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCircuitBreakerRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCircuitBreakerRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DeleteClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEngineNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var id: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DeleteEngineNamespaceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteEngineNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEngineNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEngineNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFlowRulesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var ids: [Int64]?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int64]
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteFlowRulesShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var idsShrink: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteFlowRulesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [Int64]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [Int64]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteFlowRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFlowRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var deleteSlb: Bool?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.deleteSlb != nil {
            map["DeleteSlb"] = self.deleteSlb!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DeleteSlb") {
            self.deleteSlb = dict["DeleteSlb"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class DeleteGatewayResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var name: String?

        public var primaryUser: String?

        public var region: String?

        public var replica: Int32?

        public var securityGroup: String?

        public var spec: String?

        public var status: Int32?

        public var vpc: String?

        public var vswitch: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.replica != nil {
                map["Replica"] = self.replica!
            }
            if self.securityGroup != nil {
                map["SecurityGroup"] = self.securityGroup!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vpc != nil {
                map["Vpc"] = self.vpc!
            }
            if self.vswitch != nil {
                map["Vswitch"] = self.vswitch!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PrimaryUser") {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Replica") {
                self.replica = dict["Replica"] as! Int32
            }
            if dict.keys.contains("SecurityGroup") {
                self.securityGroup = dict["SecurityGroup"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Vpc") {
                self.vpc = dict["Vpc"] as! String
            }
            if dict.keys.contains("Vswitch") {
                self.vswitch = dict["Vswitch"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteGatewayResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DeleteGatewayResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayAuthConsumerRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteGatewayAuthConsumerResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayAuthConsumerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayAuthConsumerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayAuthConsumerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayAuthConsumerResourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerId: Int64?

    public var gatewayUniqueId: String?

    public var idList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerId != nil {
            map["ConsumerId"] = self.consumerId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.idList != nil {
            map["IdList"] = self.idList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerId") {
            self.consumerId = dict["ConsumerId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IdList") {
            self.idList = dict["IdList"] as! String
        }
    }
}

public class DeleteGatewayAuthConsumerResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayAuthConsumerResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayAuthConsumerResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayAuthConsumerResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayCircuitBreakerRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var routeId: Int64?

    public var ruleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! Int64
        }
    }
}

public class DeleteGatewayCircuitBreakerRuleResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteGatewayCircuitBreakerRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayCircuitBreakerRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayCircuitBreakerRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayDomainRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DeleteGatewayDomainResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var certIdentifier: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var mustHttps: Bool?

        public var name: String?

        public var protocol_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certIdentifier != nil {
                map["CertIdentifier"] = self.certIdentifier!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.mustHttps != nil {
                map["MustHttps"] = self.mustHttps!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertIdentifier") {
                self.certIdentifier = dict["CertIdentifier"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MustHttps") {
                self.mustHttps = dict["MustHttps"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteGatewayDomainResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DeleteGatewayDomainResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayFlowRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var routeId: Int64?

    public var ruleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! Int64
        }
    }
}

public class DeleteGatewayFlowRuleResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteGatewayFlowRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayFlowRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayFlowRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayIsolationRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var routeId: Int64?

    public var ruleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! Int64
        }
    }
}

public class DeleteGatewayIsolationRuleResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteGatewayIsolationRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayIsolationRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayIsolationRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var routeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! String
        }
    }
}

public class DeleteGatewayRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var defaultServiceId: Int64?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var name: String?

        public var predicates: String?

        public var routeOrder: Int32?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultServiceId != nil {
                map["DefaultServiceId"] = self.defaultServiceId!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.predicates != nil {
                map["Predicates"] = self.predicates!
            }
            if self.routeOrder != nil {
                map["RouteOrder"] = self.routeOrder!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultServiceId") {
                self.defaultServiceId = dict["DefaultServiceId"] as! Int64
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Predicates") {
                self.predicates = dict["Predicates"] as! String
            }
            if dict.keys.contains("RouteOrder") {
                self.routeOrder = dict["RouteOrder"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: DeleteGatewayRouteResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DeleteGatewayRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayServiceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var serviceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! String
        }
    }
}

public class DeleteGatewayServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var groupName: String?

        public var id: Int64?

        public var ips: [String]?

        public var metaInfo: String?

        public var name: String?

        public var namespace: String?

        public var serviceNameInRegistry: String?

        public var sourceId: Int64?

        public var sourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.metaInfo != nil {
                map["MetaInfo"] = self.metaInfo!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.serviceNameInRegistry != nil {
                map["ServiceNameInRegistry"] = self.serviceNameInRegistry!
            }
            if self.sourceId != nil {
                map["SourceId"] = self.sourceId!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Ips") {
                self.ips = dict["Ips"] as! [String]
            }
            if dict.keys.contains("MetaInfo") {
                self.metaInfo = dict["MetaInfo"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ServiceNameInRegistry") {
                self.serviceNameInRegistry = dict["ServiceNameInRegistry"] as! String
            }
            if dict.keys.contains("SourceId") {
                self.sourceId = dict["SourceId"] as! Int64
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteGatewayServiceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DeleteGatewayServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewayServiceVersionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var serviceId: Int64?

    public var serviceVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceVersion != nil {
            map["ServiceVersion"] = self.serviceVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! Int64
        }
        if dict.keys.contains("ServiceVersion") {
            self.serviceVersion = dict["ServiceVersion"] as! String
        }
    }
}

public class DeleteGatewayServiceVersionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewayServiceVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewayServiceVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewayServiceVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGatewaySlbRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var deleteSlb: Bool?

    public var gatewayUniqueId: String?

    public var id: String?

    public var slbId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.deleteSlb != nil {
            map["DeleteSlb"] = self.deleteSlb!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DeleteSlb") {
            self.deleteSlb = dict["DeleteSlb"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("SlbId") {
            self.slbId = dict["SlbId"] as! String
        }
    }
}

public class DeleteGatewaySlbResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGatewaySlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGatewaySlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGatewaySlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIsolationRulesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var ids: [Int64]?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int64]
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteIsolationRulesShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var idsShrink: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteIsolationRulesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [Int64]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [Int64]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteIsolationRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIsolationRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIsolationRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMigrationTaskRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var id: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class DeleteMigrationTaskResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteMigrationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMigrationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMigrationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var beta: Bool?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.beta != nil {
            map["Beta"] = self.beta!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Beta") {
            self.beta = dict["Beta"] as! Bool
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class DeleteNacosConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNacosConfigsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ids: String?

    public var instanceId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class DeleteNacosConfigsResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNacosConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNacosConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNacosConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNacosInstanceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterName: String?

    public var ephemeral: Bool?

    public var groupName: String?

    public var instanceId: String?

    public var ip: String?

    public var namespaceId: String?

    public var port: Int32?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.ephemeral != nil {
            map["Ephemeral"] = self.ephemeral!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("Ephemeral") {
            self.ephemeral = dict["Ephemeral"] as! Bool
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class DeleteNacosInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNacosInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNacosInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNacosInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNacosServiceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupName: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class DeleteNacosServiceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNacosServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNacosServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNacosServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var name: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class DeleteNamespaceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePluginConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var pluginConfigId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.pluginConfigId != nil {
            map["PluginConfigId"] = self.pluginConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("PluginConfigId") {
            self.pluginConfigId = dict["PluginConfigId"] as! Int64
        }
    }
}

public class DeletePluginConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePluginConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePluginConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePluginConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSecurityGroupRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var cascadingDelete: Bool?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.cascadingDelete != nil {
            map["CascadingDelete"] = self.cascadingDelete!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CascadingDelete") {
            self.cascadingDelete = dict["CascadingDelete"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteSecurityGroupRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var description_: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var ipProtocol: String?

        public var portRange: String?

        public var securityGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: DeleteSecurityGroupRuleResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = DeleteSecurityGroupRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteSecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSecurityGroupRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteServiceSourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var sourceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.sourceId != nil {
            map["SourceId"] = self.sourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("SourceId") {
            self.sourceId = dict["SourceId"] as! Int64
        }
    }
}

public class DeleteServiceSourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteServiceSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteServiceSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteServiceSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSwimmingLaneRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var laneId: Int64?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("LaneId") {
            self.laneId = dict["LaneId"] as! Int64
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteSwimmingLaneResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSwimmingLaneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSwimmingLaneGroupRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var name: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class DeleteSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSwimmingLaneGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteZnodeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var path: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class DeleteZnodeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var dir: Bool?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Dir") {
                self.dir = dict["Dir"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var data: DeleteZnodeResponseBody.Data?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DeleteZnodeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteZnodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteZnodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteZnodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableHttp2Request : Tea.TeaModel {
    public var acceptLanguage: String?

    public var enableHttp2: Bool?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.enableHttp2 != nil {
            map["EnableHttp2"] = self.enableHttp2!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("EnableHttp2") {
            self.enableHttp2 = dict["EnableHttp2"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class EnableHttp2ResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EnableHttp2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableHttp2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableHttp2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableProxyProtocolRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var enableProxyProtocol: Bool?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.enableProxyProtocol != nil {
            map["EnableProxyProtocol"] = self.enableProxyProtocol!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("EnableProxyProtocol") {
            self.enableProxyProtocol = dict["EnableProxyProtocol"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class EnableProxyProtocolResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class EnableProxyProtocolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableProxyProtocolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableProxyProtocolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var dataId: String?

    public var dataIds: String?

    public var group: String?

    public var ids: String?

    public var instanceId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.dataIds != nil {
            map["DataIds"] = self.dataIds!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("DataIds") {
            self.dataIds = dict["DataIds"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class ExportNacosConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: ExportNacosConfigResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ExportNacosConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExportNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportZookeeperDataRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var exportType: String?

    public var instanceId: String?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.exportType != nil {
            map["ExportType"] = self.exportType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ExportType") {
            self.exportType = dict["ExportType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ExportZookeeperDataResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var contentMap: [String: Any]?

        public var createTime: Int64?

        public var exportType: String?

        public var extend: String?

        public var id: Int32?

        public var instanceId: String?

        public var kubeoneTaskIds: String?

        public var status: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contentMap != nil {
                map["ContentMap"] = self.contentMap!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.exportType != nil {
                map["ExportType"] = self.exportType!
            }
            if self.extend != nil {
                map["Extend"] = self.extend!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.kubeoneTaskIds != nil {
                map["KubeoneTaskIds"] = self.kubeoneTaskIds!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContentMap") {
                self.contentMap = dict["ContentMap"] as! [String: Any]
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ExportType") {
                self.exportType = dict["ExportType"] as! String
            }
            if dict.keys.contains("Extend") {
                self.extend = dict["Extend"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("KubeoneTaskIds") {
                self.kubeoneTaskIds = dict["KubeoneTaskIds"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var data: ExportZookeeperDataResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ExportZookeeperDataResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExportZookeeperDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportZookeeperDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportZookeeperDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FetchLosslessRuleListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class FetchLosslessRuleListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Results : Tea.TeaModel {
            public var aligned: Bool?

            public var appId: String?

            public var appName: String?

            public var count: Int32?

            public var delayTime: Int32?

            public var enable: Bool?

            public var funcType: Int32?

            public var lossLessDetail: Bool?

            public var notice: Bool?

            public var related: Bool?

            public var warmupTime: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aligned != nil {
                    map["Aligned"] = self.aligned!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.delayTime != nil {
                    map["DelayTime"] = self.delayTime!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.funcType != nil {
                    map["FuncType"] = self.funcType!
                }
                if self.lossLessDetail != nil {
                    map["LossLessDetail"] = self.lossLessDetail!
                }
                if self.notice != nil {
                    map["Notice"] = self.notice!
                }
                if self.related != nil {
                    map["Related"] = self.related!
                }
                if self.warmupTime != nil {
                    map["WarmupTime"] = self.warmupTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Aligned") {
                    self.aligned = dict["Aligned"] as! Bool
                }
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("DelayTime") {
                    self.delayTime = dict["DelayTime"] as! Int32
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("FuncType") {
                    self.funcType = dict["FuncType"] as! Int32
                }
                if dict.keys.contains("LossLessDetail") {
                    self.lossLessDetail = dict["LossLessDetail"] as! Bool
                }
                if dict.keys.contains("Notice") {
                    self.notice = dict["Notice"] as! Bool
                }
                if dict.keys.contains("Related") {
                    self.related = dict["Related"] as! Bool
                }
                if dict.keys.contains("WarmupTime") {
                    self.warmupTime = dict["WarmupTime"] as! Int32
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var results: [FetchLosslessRuleListResponseBody.Data.Results]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.results != nil {
                var tmp : [Any] = []
                for k in self.results! {
                    tmp.append(k.toMap())
                }
                map["Results"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Results") {
                var tmp : [FetchLosslessRuleListResponseBody.Data.Results] = []
                for v in dict["Results"] as! [Any] {
                    var model = FetchLosslessRuleListResponseBody.Data.Results()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.results = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: FetchLosslessRuleListResponseBody.Data?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = FetchLosslessRuleListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class FetchLosslessRuleListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FetchLosslessRuleListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = FetchLosslessRuleListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GatewayBlackWhiteListRequest : Tea.TeaModel {
    public class FilterParams : Tea.TeaModel {
        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var isWhite: Bool?

        public var resourceType: String?

        public var searchContent: String?

        public var searchType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.isWhite != nil {
                map["IsWhite"] = self.isWhite!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.searchContent != nil {
                map["SearchContent"] = self.searchContent!
            }
            if self.searchType != nil {
                map["SearchType"] = self.searchType!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("IsWhite") {
                self.isWhite = dict["IsWhite"] as! Bool
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("SearchContent") {
                self.searchContent = dict["SearchContent"] as! String
            }
            if dict.keys.contains("SearchType") {
                self.searchType = dict["SearchType"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParams: GatewayBlackWhiteListRequest.FilterParams?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filterParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParams != nil {
            map["FilterParams"] = self.filterParams?.toMap()
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            var model = GatewayBlackWhiteListRequest.FilterParams()
            model.fromMap(dict["FilterParams"] as! [String: Any])
            self.filterParams = model
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class GatewayBlackWhiteListShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParamsShrink: String?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParamsShrink != nil {
            map["FilterParams"] = self.filterParamsShrink!
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            self.filterParamsShrink = dict["FilterParams"] as! String
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class GatewayBlackWhiteListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var content: String?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var isWhite: Bool?

            public var name: String?

            public var note: String?

            public var resourceId: Int64?

            public var resourceIdJsonList: String?

            public var resourceIdNameJson: String?

            public var resourceType: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isWhite != nil {
                    map["IsWhite"] = self.isWhite!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.note != nil {
                    map["Note"] = self.note!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceIdJsonList != nil {
                    map["ResourceIdJsonList"] = self.resourceIdJsonList!
                }
                if self.resourceIdNameJson != nil {
                    map["ResourceIdNameJson"] = self.resourceIdNameJson!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsWhite") {
                    self.isWhite = dict["IsWhite"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Note") {
                    self.note = dict["Note"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! Int64
                }
                if dict.keys.contains("ResourceIdJsonList") {
                    self.resourceIdJsonList = dict["ResourceIdJsonList"] as! String
                }
                if dict.keys.contains("ResourceIdNameJson") {
                    self.resourceIdNameJson = dict["ResourceIdNameJson"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [GatewayBlackWhiteListResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [GatewayBlackWhiteListResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = GatewayBlackWhiteListResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: GatewayBlackWhiteListResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GatewayBlackWhiteListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GatewayBlackWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GatewayBlackWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GatewayBlackWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAppMessageQueueRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class GetAppMessageQueueRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var enable: Bool?

        public var filterSide: String?

        public var region: String?

        public var tags: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.filterSide != nil {
                map["FilterSide"] = self.filterSide!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("FilterSide") {
                self.filterSide = dict["FilterSide"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! [String]
            }
        }
    }
    public var code: Int32?

    public var data: GetAppMessageQueueRouteResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetAppMessageQueueRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAppMessageQueueRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAppMessageQueueRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAppMessageQueueRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetApplicationInstanceListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class GetApplicationInstanceListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var tag: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        map["Tag"] = self.tag!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! String
                    }
                }
            }
            public var ip: String?

            public var port: String?

            public var tags: [GetApplicationInstanceListResponseBody.Data.Result.Tags]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("Tags") {
                    var tmp : [GetApplicationInstanceListResponseBody.Data.Result.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = GetApplicationInstanceListResponseBody.Data.Result.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [GetApplicationInstanceListResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [GetApplicationInstanceListResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = GetApplicationInstanceListResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: GetApplicationInstanceListResponseBody.Data?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetApplicationInstanceListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
    }
}

public class GetApplicationInstanceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationInstanceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetApplicationInstanceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetApplicationListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var language: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var sentinelEnable: Bool?

    public var source: String?

    public var switchEnable: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.sentinelEnable != nil {
            map["SentinelEnable"] = self.sentinelEnable!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.switchEnable != nil {
            map["SwitchEnable"] = self.switchEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("SentinelEnable") {
            self.sentinelEnable = dict["SentinelEnable"] as! Bool
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SwitchEnable") {
            self.switchEnable = dict["SwitchEnable"] as! Bool
        }
    }
}

public class GetApplicationListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var extraInfo: String?

            public var instancesNumber: Int32?

            public var language: String?

            public var namespace: String?

            public var regionId: String?

            public var source: String?

            public var status: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.extraInfo != nil {
                    map["ExtraInfo"] = self.extraInfo!
                }
                if self.instancesNumber != nil {
                    map["InstancesNumber"] = self.instancesNumber!
                }
                if self.language != nil {
                    map["Language"] = self.language!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("ExtraInfo") {
                    self.extraInfo = dict["ExtraInfo"] as! String
                }
                if dict.keys.contains("InstancesNumber") {
                    self.instancesNumber = dict["InstancesNumber"] as! Int32
                }
                if dict.keys.contains("Language") {
                    self.language = dict["Language"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [GetApplicationListResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [GetApplicationListResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = GetApplicationListResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: GetApplicationListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetApplicationListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetApplicationListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetApplicationListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBlackWhiteListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var isWhite: Bool?

    public var resourceType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.isWhite != nil {
            map["IsWhite"] = self.isWhite!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IsWhite") {
            self.isWhite = dict["IsWhite"] as! Bool
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetBlackWhiteListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var content: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var isWhite: Bool?

        public var resourceId: Int64?

        public var resourceType: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isWhite != nil {
                map["IsWhite"] = self.isWhite!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IsWhite") {
                self.isWhite = dict["IsWhite"] as! Bool
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! Int64
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetBlackWhiteListResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetBlackWhiteListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetBlackWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBlackWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBlackWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEngineNamepaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var id: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetEngineNamepaceResponseBody : Tea.TeaModel {
    public var configCount: String?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var namespace: String?

    public var namespaceDesc: String?

    public var namespaceShowName: String?

    public var quota: String?

    public var requestId: String?

    public var success: Bool?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configCount != nil {
            map["ConfigCount"] = self.configCount!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.namespaceDesc != nil {
            map["NamespaceDesc"] = self.namespaceDesc!
        }
        if self.namespaceShowName != nil {
            map["NamespaceShowName"] = self.namespaceShowName!
        }
        if self.quota != nil {
            map["Quota"] = self.quota!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigCount") {
            self.configCount = dict["ConfigCount"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NamespaceDesc") {
            self.namespaceDesc = dict["NamespaceDesc"] as! String
        }
        if dict.keys.contains("NamespaceShowName") {
            self.namespaceShowName = dict["NamespaceShowName"] as! String
        }
        if dict.keys.contains("Quota") {
            self.quota = dict["Quota"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetEngineNamepaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEngineNamepaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEngineNamepaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class GetGatewayResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ElasticPolicy : Tea.TeaModel {
            public class TimePolicyList : Tea.TeaModel {
                public var desiredReplica: Int32?

                public var endTime: String?

                public var startTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.desiredReplica != nil {
                        map["DesiredReplica"] = self.desiredReplica!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DesiredReplica") {
                        self.desiredReplica = dict["DesiredReplica"] as! Int32
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                }
            }
            public var elasticType: String?

            public var maxReplica: Int32?

            public var timePolicyList: [GetGatewayResponseBody.Data.ElasticPolicy.TimePolicyList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.elasticType != nil {
                    map["ElasticType"] = self.elasticType!
                }
                if self.maxReplica != nil {
                    map["MaxReplica"] = self.maxReplica!
                }
                if self.timePolicyList != nil {
                    var tmp : [Any] = []
                    for k in self.timePolicyList! {
                        tmp.append(k.toMap())
                    }
                    map["TimePolicyList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ElasticType") {
                    self.elasticType = dict["ElasticType"] as! String
                }
                if dict.keys.contains("MaxReplica") {
                    self.maxReplica = dict["MaxReplica"] as! Int32
                }
                if dict.keys.contains("TimePolicyList") {
                    var tmp : [GetGatewayResponseBody.Data.ElasticPolicy.TimePolicyList] = []
                    for v in dict["TimePolicyList"] as! [Any] {
                        var model = GetGatewayResponseBody.Data.ElasticPolicy.TimePolicyList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.timePolicyList = tmp
                }
            }
        }
        public class LogConfigDetails : Tea.TeaModel {
            public var logEnabled: Bool?

            public var logStoreName: String?

            public var projectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logEnabled != nil {
                    map["LogEnabled"] = self.logEnabled!
                }
                if self.logStoreName != nil {
                    map["LogStoreName"] = self.logStoreName!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LogEnabled") {
                    self.logEnabled = dict["LogEnabled"] as! Bool
                }
                if dict.keys.contains("LogStoreName") {
                    self.logStoreName = dict["LogStoreName"] as! String
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
            }
        }
        public class XtraceDetails : Tea.TeaModel {
            public var sample: Int32?

            public var traceOn: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sample != nil {
                    map["Sample"] = self.sample!
                }
                if self.traceOn != nil {
                    map["TraceOn"] = self.traceOn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Sample") {
                    self.sample = dict["Sample"] as! Int32
                }
                if dict.keys.contains("TraceOn") {
                    self.traceOn = dict["TraceOn"] as! Bool
                }
            }
        }
        public var chargeType: String?

        public var elastic: Bool?

        public var elasticPolicy: GetGatewayResponseBody.Data.ElasticPolicy?

        public var elasticReplica: Int32?

        public var elasticType: String?

        public var endDate: String?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var instanceId: String?

        public var logConfigDetails: GetGatewayResponseBody.Data.LogConfigDetails?

        public var mseTag: String?

        public var name: String?

        public var primaryUser: String?

        public var region: String?

        public var replica: Int32?

        public var resourceGroupId: String?

        public var securityGroup: String?

        public var spec: String?

        public var status: Int32?

        public var statusDesc: String?

        public var totalReplica: Int32?

        public var vpc: String?

        public var vswitch: String?

        public var vswitch2: String?

        public var xtraceDetails: GetGatewayResponseBody.Data.XtraceDetails?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.elasticPolicy?.validate()
            try self.logConfigDetails?.validate()
            try self.xtraceDetails?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.elastic != nil {
                map["Elastic"] = self.elastic!
            }
            if self.elasticPolicy != nil {
                map["ElasticPolicy"] = self.elasticPolicy?.toMap()
            }
            if self.elasticReplica != nil {
                map["ElasticReplica"] = self.elasticReplica!
            }
            if self.elasticType != nil {
                map["ElasticType"] = self.elasticType!
            }
            if self.endDate != nil {
                map["EndDate"] = self.endDate!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.logConfigDetails != nil {
                map["LogConfigDetails"] = self.logConfigDetails?.toMap()
            }
            if self.mseTag != nil {
                map["MseTag"] = self.mseTag!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.replica != nil {
                map["Replica"] = self.replica!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.securityGroup != nil {
                map["SecurityGroup"] = self.securityGroup!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.totalReplica != nil {
                map["TotalReplica"] = self.totalReplica!
            }
            if self.vpc != nil {
                map["Vpc"] = self.vpc!
            }
            if self.vswitch != nil {
                map["Vswitch"] = self.vswitch!
            }
            if self.vswitch2 != nil {
                map["Vswitch2"] = self.vswitch2!
            }
            if self.xtraceDetails != nil {
                map["XtraceDetails"] = self.xtraceDetails?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChargeType") {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("Elastic") {
                self.elastic = dict["Elastic"] as! Bool
            }
            if dict.keys.contains("ElasticPolicy") {
                var model = GetGatewayResponseBody.Data.ElasticPolicy()
                model.fromMap(dict["ElasticPolicy"] as! [String: Any])
                self.elasticPolicy = model
            }
            if dict.keys.contains("ElasticReplica") {
                self.elasticReplica = dict["ElasticReplica"] as! Int32
            }
            if dict.keys.contains("ElasticType") {
                self.elasticType = dict["ElasticType"] as! String
            }
            if dict.keys.contains("EndDate") {
                self.endDate = dict["EndDate"] as! String
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("LogConfigDetails") {
                var model = GetGatewayResponseBody.Data.LogConfigDetails()
                model.fromMap(dict["LogConfigDetails"] as! [String: Any])
                self.logConfigDetails = model
            }
            if dict.keys.contains("MseTag") {
                self.mseTag = dict["MseTag"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PrimaryUser") {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Replica") {
                self.replica = dict["Replica"] as! Int32
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroup") {
                self.securityGroup = dict["SecurityGroup"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("TotalReplica") {
                self.totalReplica = dict["TotalReplica"] as! Int32
            }
            if dict.keys.contains("Vpc") {
                self.vpc = dict["Vpc"] as! String
            }
            if dict.keys.contains("Vswitch") {
                self.vswitch = dict["Vswitch"] as! String
            }
            if dict.keys.contains("Vswitch2") {
                self.vswitch2 = dict["Vswitch2"] as! String
            }
            if dict.keys.contains("XtraceDetails") {
                var model = GetGatewayResponseBody.Data.XtraceDetails()
                model.fromMap(dict["XtraceDetails"] as! [String: Any])
                self.xtraceDetails = model
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetGatewayResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayAuthConsumerDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetGatewayAuthConsumerDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ResourceList : Tea.TeaModel {
            public var consumerId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var resourceStatus: Bool?

            public var routeId: Int64?

            public var routeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consumerId != nil {
                    map["ConsumerId"] = self.consumerId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.resourceStatus != nil {
                    map["ResourceStatus"] = self.resourceStatus!
                }
                if self.routeId != nil {
                    map["RouteId"] = self.routeId!
                }
                if self.routeName != nil {
                    map["RouteName"] = self.routeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsumerId") {
                    self.consumerId = dict["ConsumerId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ResourceStatus") {
                    self.resourceStatus = dict["ResourceStatus"] as! Bool
                }
                if dict.keys.contains("RouteId") {
                    self.routeId = dict["RouteId"] as! Int64
                }
                if dict.keys.contains("RouteName") {
                    self.routeName = dict["RouteName"] as! String
                }
            }
        }
        public var consumerStatus: Bool?

        public var description_: String?

        public var encodeType: String?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var jwks: String?

        public var keyName: String?

        public var keyValue: String?

        public var name: String?

        public var primaryUser: String?

        public var resourceList: [GetGatewayAuthConsumerDetailResponseBody.Data.ResourceList]?

        public var tokenName: String?

        public var tokenPass: Bool?

        public var tokenPosition: String?

        public var tokenPrefix: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consumerStatus != nil {
                map["ConsumerStatus"] = self.consumerStatus!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.encodeType != nil {
                map["EncodeType"] = self.encodeType!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.jwks != nil {
                map["Jwks"] = self.jwks!
            }
            if self.keyName != nil {
                map["KeyName"] = self.keyName!
            }
            if self.keyValue != nil {
                map["KeyValue"] = self.keyValue!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.resourceList != nil {
                var tmp : [Any] = []
                for k in self.resourceList! {
                    tmp.append(k.toMap())
                }
                map["ResourceList"] = tmp
            }
            if self.tokenName != nil {
                map["TokenName"] = self.tokenName!
            }
            if self.tokenPass != nil {
                map["TokenPass"] = self.tokenPass!
            }
            if self.tokenPosition != nil {
                map["TokenPosition"] = self.tokenPosition!
            }
            if self.tokenPrefix != nil {
                map["TokenPrefix"] = self.tokenPrefix!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsumerStatus") {
                self.consumerStatus = dict["ConsumerStatus"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EncodeType") {
                self.encodeType = dict["EncodeType"] as! String
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Jwks") {
                self.jwks = dict["Jwks"] as! String
            }
            if dict.keys.contains("KeyName") {
                self.keyName = dict["KeyName"] as! String
            }
            if dict.keys.contains("KeyValue") {
                self.keyValue = dict["KeyValue"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PrimaryUser") {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("ResourceList") {
                var tmp : [GetGatewayAuthConsumerDetailResponseBody.Data.ResourceList] = []
                for v in dict["ResourceList"] as! [Any] {
                    var model = GetGatewayAuthConsumerDetailResponseBody.Data.ResourceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resourceList = tmp
            }
            if dict.keys.contains("TokenName") {
                self.tokenName = dict["TokenName"] as! String
            }
            if dict.keys.contains("TokenPass") {
                self.tokenPass = dict["TokenPass"] as! Bool
            }
            if dict.keys.contains("TokenPosition") {
                self.tokenPosition = dict["TokenPosition"] as! String
            }
            if dict.keys.contains("TokenPrefix") {
                self.tokenPrefix = dict["TokenPrefix"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayAuthConsumerDetailResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetGatewayAuthConsumerDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayAuthConsumerDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayAuthConsumerDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGatewayAuthConsumerDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayAuthDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetGatewayAuthDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ExternalAuthZ : Tea.TeaModel {
            public class Service : Tea.TeaModel {
                public var groupName: String?

                public var name: String?

                public var namespace: String?

                public var sourceType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.namespace != nil {
                        map["Namespace"] = self.namespace!
                    }
                    if self.sourceType != nil {
                        map["SourceType"] = self.sourceType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GroupName") {
                        self.groupName = dict["GroupName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Namespace") {
                        self.namespace = dict["Namespace"] as! String
                    }
                    if dict.keys.contains("SourceType") {
                        self.sourceType = dict["SourceType"] as! String
                    }
                }
            }
            public var allowRequestHeaders: [String]?

            public var allowUpstreamHeaders: [String]?

            public var bodyMaxBytes: Int32?

            public var isRestrict: Bool?

            public var prefixPath: String?

            public var service: GetGatewayAuthDetailResponseBody.Data.ExternalAuthZ.Service?

            public var serviceId: Int64?

            public var timeout: Int32?

            public var tokenKey: String?

            public var withRematchRoute: Bool?

            public var withRequestBody: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.service?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowRequestHeaders != nil {
                    map["AllowRequestHeaders"] = self.allowRequestHeaders!
                }
                if self.allowUpstreamHeaders != nil {
                    map["AllowUpstreamHeaders"] = self.allowUpstreamHeaders!
                }
                if self.bodyMaxBytes != nil {
                    map["BodyMaxBytes"] = self.bodyMaxBytes!
                }
                if self.isRestrict != nil {
                    map["IsRestrict"] = self.isRestrict!
                }
                if self.prefixPath != nil {
                    map["PrefixPath"] = self.prefixPath!
                }
                if self.service != nil {
                    map["Service"] = self.service?.toMap()
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.tokenKey != nil {
                    map["TokenKey"] = self.tokenKey!
                }
                if self.withRematchRoute != nil {
                    map["WithRematchRoute"] = self.withRematchRoute!
                }
                if self.withRequestBody != nil {
                    map["WithRequestBody"] = self.withRequestBody!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowRequestHeaders") {
                    self.allowRequestHeaders = dict["AllowRequestHeaders"] as! [String]
                }
                if dict.keys.contains("AllowUpstreamHeaders") {
                    self.allowUpstreamHeaders = dict["AllowUpstreamHeaders"] as! [String]
                }
                if dict.keys.contains("BodyMaxBytes") {
                    self.bodyMaxBytes = dict["BodyMaxBytes"] as! Int32
                }
                if dict.keys.contains("IsRestrict") {
                    self.isRestrict = dict["IsRestrict"] as! Bool
                }
                if dict.keys.contains("PrefixPath") {
                    self.prefixPath = dict["PrefixPath"] as! String
                }
                if dict.keys.contains("Service") {
                    var model = GetGatewayAuthDetailResponseBody.Data.ExternalAuthZ.Service()
                    model.fromMap(dict["Service"] as! [String: Any])
                    self.service = model
                }
                if dict.keys.contains("ServiceId") {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int32
                }
                if dict.keys.contains("TokenKey") {
                    self.tokenKey = dict["TokenKey"] as! String
                }
                if dict.keys.contains("WithRematchRoute") {
                    self.withRematchRoute = dict["WithRematchRoute"] as! Bool
                }
                if dict.keys.contains("WithRequestBody") {
                    self.withRequestBody = dict["WithRequestBody"] as! Bool
                }
            }
        }
        public class ResourceList : Tea.TeaModel {
            public class AuthResourceHeaderList : Tea.TeaModel {
                public var headerKey: String?

                public var headerMethod: String?

                public var headerValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerKey != nil {
                        map["HeaderKey"] = self.headerKey!
                    }
                    if self.headerMethod != nil {
                        map["HeaderMethod"] = self.headerMethod!
                    }
                    if self.headerValue != nil {
                        map["HeaderValue"] = self.headerValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderKey") {
                        self.headerKey = dict["HeaderKey"] as! String
                    }
                    if dict.keys.contains("HeaderMethod") {
                        self.headerMethod = dict["HeaderMethod"] as! String
                    }
                    if dict.keys.contains("HeaderValue") {
                        self.headerValue = dict["HeaderValue"] as! String
                    }
                }
            }
            public var authId: Int64?

            public var authResourceHeaderList: [GetGatewayAuthDetailResponseBody.Data.ResourceList.AuthResourceHeaderList]?

            public var domainId: Int64?

            public var domainName: String?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var ignoreCase: Bool?

            public var isWhite: Bool?

            public var matchType: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authId != nil {
                    map["AuthId"] = self.authId!
                }
                if self.authResourceHeaderList != nil {
                    var tmp : [Any] = []
                    for k in self.authResourceHeaderList! {
                        tmp.append(k.toMap())
                    }
                    map["AuthResourceHeaderList"] = tmp
                }
                if self.domainId != nil {
                    map["DomainId"] = self.domainId!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.ignoreCase != nil {
                    map["IgnoreCase"] = self.ignoreCase!
                }
                if self.isWhite != nil {
                    map["IsWhite"] = self.isWhite!
                }
                if self.matchType != nil {
                    map["MatchType"] = self.matchType!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthId") {
                    self.authId = dict["AuthId"] as! Int64
                }
                if dict.keys.contains("AuthResourceHeaderList") {
                    var tmp : [GetGatewayAuthDetailResponseBody.Data.ResourceList.AuthResourceHeaderList] = []
                    for v in dict["AuthResourceHeaderList"] as! [Any] {
                        var model = GetGatewayAuthDetailResponseBody.Data.ResourceList.AuthResourceHeaderList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.authResourceHeaderList = tmp
                }
                if dict.keys.contains("DomainId") {
                    self.domainId = dict["DomainId"] as! Int64
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IgnoreCase") {
                    self.ignoreCase = dict["IgnoreCase"] as! Bool
                }
                if dict.keys.contains("IsWhite") {
                    self.isWhite = dict["IsWhite"] as! Bool
                }
                if dict.keys.contains("MatchType") {
                    self.matchType = dict["MatchType"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var authResourceConfig: String?

        public var authResourceMode: Int32?

        public var clientId: String?

        public var clientSecret: String?

        public var cookieDomain: String?

        public var externalAuthZ: GetGatewayAuthDetailResponseBody.Data.ExternalAuthZ?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var isWhite: Bool?

        public var issuer: String?

        public var jwks: String?

        public var loginUrl: String?

        public var name: String?

        public var redirectUrl: String?

        public var resourceList: [GetGatewayAuthDetailResponseBody.Data.ResourceList]?

        public var scopesList: String?

        public var status: Bool?

        public var sub: String?

        public var tokenName: String?

        public var tokenNamePrefix: String?

        public var tokenPass: Bool?

        public var tokenPosition: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.externalAuthZ?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authResourceConfig != nil {
                map["AuthResourceConfig"] = self.authResourceConfig!
            }
            if self.authResourceMode != nil {
                map["AuthResourceMode"] = self.authResourceMode!
            }
            if self.clientId != nil {
                map["ClientId"] = self.clientId!
            }
            if self.clientSecret != nil {
                map["ClientSecret"] = self.clientSecret!
            }
            if self.cookieDomain != nil {
                map["CookieDomain"] = self.cookieDomain!
            }
            if self.externalAuthZ != nil {
                map["ExternalAuthZ"] = self.externalAuthZ?.toMap()
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isWhite != nil {
                map["IsWhite"] = self.isWhite!
            }
            if self.issuer != nil {
                map["Issuer"] = self.issuer!
            }
            if self.jwks != nil {
                map["Jwks"] = self.jwks!
            }
            if self.loginUrl != nil {
                map["LoginUrl"] = self.loginUrl!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.redirectUrl != nil {
                map["RedirectUrl"] = self.redirectUrl!
            }
            if self.resourceList != nil {
                var tmp : [Any] = []
                for k in self.resourceList! {
                    tmp.append(k.toMap())
                }
                map["ResourceList"] = tmp
            }
            if self.scopesList != nil {
                map["ScopesList"] = self.scopesList!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.sub != nil {
                map["Sub"] = self.sub!
            }
            if self.tokenName != nil {
                map["TokenName"] = self.tokenName!
            }
            if self.tokenNamePrefix != nil {
                map["TokenNamePrefix"] = self.tokenNamePrefix!
            }
            if self.tokenPass != nil {
                map["TokenPass"] = self.tokenPass!
            }
            if self.tokenPosition != nil {
                map["TokenPosition"] = self.tokenPosition!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthResourceConfig") {
                self.authResourceConfig = dict["AuthResourceConfig"] as! String
            }
            if dict.keys.contains("AuthResourceMode") {
                self.authResourceMode = dict["AuthResourceMode"] as! Int32
            }
            if dict.keys.contains("ClientId") {
                self.clientId = dict["ClientId"] as! String
            }
            if dict.keys.contains("ClientSecret") {
                self.clientSecret = dict["ClientSecret"] as! String
            }
            if dict.keys.contains("CookieDomain") {
                self.cookieDomain = dict["CookieDomain"] as! String
            }
            if dict.keys.contains("ExternalAuthZ") {
                var model = GetGatewayAuthDetailResponseBody.Data.ExternalAuthZ()
                model.fromMap(dict["ExternalAuthZ"] as! [String: Any])
                self.externalAuthZ = model
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IsWhite") {
                self.isWhite = dict["IsWhite"] as! Bool
            }
            if dict.keys.contains("Issuer") {
                self.issuer = dict["Issuer"] as! String
            }
            if dict.keys.contains("Jwks") {
                self.jwks = dict["Jwks"] as! String
            }
            if dict.keys.contains("LoginUrl") {
                self.loginUrl = dict["LoginUrl"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RedirectUrl") {
                self.redirectUrl = dict["RedirectUrl"] as! String
            }
            if dict.keys.contains("ResourceList") {
                var tmp : [GetGatewayAuthDetailResponseBody.Data.ResourceList] = []
                for v in dict["ResourceList"] as! [Any] {
                    var model = GetGatewayAuthDetailResponseBody.Data.ResourceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resourceList = tmp
            }
            if dict.keys.contains("ScopesList") {
                self.scopesList = dict["ScopesList"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Bool
            }
            if dict.keys.contains("Sub") {
                self.sub = dict["Sub"] as! String
            }
            if dict.keys.contains("TokenName") {
                self.tokenName = dict["TokenName"] as! String
            }
            if dict.keys.contains("TokenNamePrefix") {
                self.tokenNamePrefix = dict["TokenNamePrefix"] as! String
            }
            if dict.keys.contains("TokenPass") {
                self.tokenPass = dict["TokenPass"] as! Bool
            }
            if dict.keys.contains("TokenPosition") {
                self.tokenPosition = dict["TokenPosition"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayAuthDetailResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetGatewayAuthDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayAuthDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayAuthDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGatewayAuthDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class GetGatewayConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EnableK8sSourceWorkloadFilter : Tea.TeaModel {
            public var enable: Bool?

            public var filterOpt: String?

            public var labelKey: String?

            public var labelValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.filterOpt != nil {
                    map["FilterOpt"] = self.filterOpt!
                }
                if self.labelKey != nil {
                    map["LabelKey"] = self.labelKey!
                }
                if self.labelValue != nil {
                    map["LabelValue"] = self.labelValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("FilterOpt") {
                    self.filterOpt = dict["FilterOpt"] as! String
                }
                if dict.keys.contains("LabelKey") {
                    self.labelKey = dict["LabelKey"] as! String
                }
                if dict.keys.contains("LabelValue") {
                    self.labelValue = dict["LabelValue"] as! String
                }
            }
        }
        public class EnableXffTrustedCidrs : Tea.TeaModel {
            public var enable: Bool?

            public var ipListContent: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.ipListContent != nil {
                    map["IpListContent"] = self.ipListContent!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("IpListContent") {
                    self.ipListContent = dict["IpListContent"] as! String
                }
            }
        }
        public class SlsConfigDetails : Tea.TeaModel {
            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var logOn: Bool?

            public var logStoreName: String?

            public var nginxCompatible: Bool?

            public var projectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.logOn != nil {
                    map["LogOn"] = self.logOn!
                }
                if self.logStoreName != nil {
                    map["LogStoreName"] = self.logStoreName!
                }
                if self.nginxCompatible != nil {
                    map["NginxCompatible"] = self.nginxCompatible!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("LogOn") {
                    self.logOn = dict["LogOn"] as! Bool
                }
                if dict.keys.contains("LogStoreName") {
                    self.logStoreName = dict["LogStoreName"] as! String
                }
                if dict.keys.contains("NginxCompatible") {
                    self.nginxCompatible = dict["NginxCompatible"] as! Bool
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
            }
        }
        public class XtraceDetails : Tea.TeaModel {
            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var sample: Int32?

            public var serviceId: Int64?

            public var servicePort: String?

            public var traceOn: Bool?

            public var traceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.sample != nil {
                    map["Sample"] = self.sample!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.servicePort != nil {
                    map["ServicePort"] = self.servicePort!
                }
                if self.traceOn != nil {
                    map["TraceOn"] = self.traceOn!
                }
                if self.traceType != nil {
                    map["TraceType"] = self.traceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Sample") {
                    self.sample = dict["Sample"] as! Int32
                }
                if dict.keys.contains("ServiceId") {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("ServicePort") {
                    self.servicePort = dict["ServicePort"] as! String
                }
                if dict.keys.contains("TraceOn") {
                    self.traceOn = dict["TraceOn"] as! Bool
                }
                if dict.keys.contains("TraceType") {
                    self.traceType = dict["TraceType"] as! String
                }
            }
        }
        public var accessLogHeader: String?

        public var downstreamConnectionBufferLimits: Int32?

        public var downstreamHttp2MaxConcurrentStream: Int32?

        public var downstreamIdleTime: Int32?

        public var enableCustomAuthConfigPush: String?

        public var enableGenerateRequestId: Bool?

        public var enableGzip: Bool?

        public var enableHardwareAccelerate: Bool?

        public var enableHttp2: Bool?

        public var enableHttp3: Bool?

        public var enableK8sSourceWorkloadFilter: GetGatewayConfigResponseBody.Data.EnableK8sSourceWorkloadFilter?

        public var enableProxyProtocol: Bool?

        public var enableSlashMerge: Bool?

        public var enableWaf: Bool?

        public var enableXffTrustedCidrs: GetGatewayConfigResponseBody.Data.EnableXffTrustedCidrs?

        public var gatewayUniqueId: String?

        public var initialConnectionWindowSize: Int32?

        public var initialStreamWindowSize: Int32?

        public var keepaliveHeaderTimeout: Int32?

        public var logFilterConfig: String?

        public var noSupportedConfigList: String?

        public var pathWithEscapedSlashes: String?

        public var preserveHeaderFormat: Bool?

        public var slsConfigDetails: GetGatewayConfigResponseBody.Data.SlsConfigDetails?

        public var supportWaf: Bool?

        public var upstreamIdleTimeout: Int32?

        public var websocketTermGracePeriod: Int32?

        public var xffTrustedNum: Int32?

        public var xtraceDetails: GetGatewayConfigResponseBody.Data.XtraceDetails?

        public var zipAlgorithm: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.enableK8sSourceWorkloadFilter?.validate()
            try self.enableXffTrustedCidrs?.validate()
            try self.slsConfigDetails?.validate()
            try self.xtraceDetails?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLogHeader != nil {
                map["AccessLogHeader"] = self.accessLogHeader!
            }
            if self.downstreamConnectionBufferLimits != nil {
                map["DownstreamConnectionBufferLimits"] = self.downstreamConnectionBufferLimits!
            }
            if self.downstreamHttp2MaxConcurrentStream != nil {
                map["DownstreamHttp2MaxConcurrentStream"] = self.downstreamHttp2MaxConcurrentStream!
            }
            if self.downstreamIdleTime != nil {
                map["DownstreamIdleTime"] = self.downstreamIdleTime!
            }
            if self.enableCustomAuthConfigPush != nil {
                map["EnableCustomAuthConfigPush"] = self.enableCustomAuthConfigPush!
            }
            if self.enableGenerateRequestId != nil {
                map["EnableGenerateRequestId"] = self.enableGenerateRequestId!
            }
            if self.enableGzip != nil {
                map["EnableGzip"] = self.enableGzip!
            }
            if self.enableHardwareAccelerate != nil {
                map["EnableHardwareAccelerate"] = self.enableHardwareAccelerate!
            }
            if self.enableHttp2 != nil {
                map["EnableHttp2"] = self.enableHttp2!
            }
            if self.enableHttp3 != nil {
                map["EnableHttp3"] = self.enableHttp3!
            }
            if self.enableK8sSourceWorkloadFilter != nil {
                map["EnableK8sSourceWorkloadFilter"] = self.enableK8sSourceWorkloadFilter?.toMap()
            }
            if self.enableProxyProtocol != nil {
                map["EnableProxyProtocol"] = self.enableProxyProtocol!
            }
            if self.enableSlashMerge != nil {
                map["EnableSlashMerge"] = self.enableSlashMerge!
            }
            if self.enableWaf != nil {
                map["EnableWaf"] = self.enableWaf!
            }
            if self.enableXffTrustedCidrs != nil {
                map["EnableXffTrustedCidrs"] = self.enableXffTrustedCidrs?.toMap()
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.initialConnectionWindowSize != nil {
                map["InitialConnectionWindowSize"] = self.initialConnectionWindowSize!
            }
            if self.initialStreamWindowSize != nil {
                map["InitialStreamWindowSize"] = self.initialStreamWindowSize!
            }
            if self.keepaliveHeaderTimeout != nil {
                map["KeepaliveHeaderTimeout"] = self.keepaliveHeaderTimeout!
            }
            if self.logFilterConfig != nil {
                map["LogFilterConfig"] = self.logFilterConfig!
            }
            if self.noSupportedConfigList != nil {
                map["NoSupportedConfigList"] = self.noSupportedConfigList!
            }
            if self.pathWithEscapedSlashes != nil {
                map["PathWithEscapedSlashes"] = self.pathWithEscapedSlashes!
            }
            if self.preserveHeaderFormat != nil {
                map["PreserveHeaderFormat"] = self.preserveHeaderFormat!
            }
            if self.slsConfigDetails != nil {
                map["SlsConfigDetails"] = self.slsConfigDetails?.toMap()
            }
            if self.supportWaf != nil {
                map["SupportWaf"] = self.supportWaf!
            }
            if self.upstreamIdleTimeout != nil {
                map["UpstreamIdleTimeout"] = self.upstreamIdleTimeout!
            }
            if self.websocketTermGracePeriod != nil {
                map["WebsocketTermGracePeriod"] = self.websocketTermGracePeriod!
            }
            if self.xffTrustedNum != nil {
                map["XffTrustedNum"] = self.xffTrustedNum!
            }
            if self.xtraceDetails != nil {
                map["XtraceDetails"] = self.xtraceDetails?.toMap()
            }
            if self.zipAlgorithm != nil {
                map["ZipAlgorithm"] = self.zipAlgorithm!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessLogHeader") {
                self.accessLogHeader = dict["AccessLogHeader"] as! String
            }
            if dict.keys.contains("DownstreamConnectionBufferLimits") {
                self.downstreamConnectionBufferLimits = dict["DownstreamConnectionBufferLimits"] as! Int32
            }
            if dict.keys.contains("DownstreamHttp2MaxConcurrentStream") {
                self.downstreamHttp2MaxConcurrentStream = dict["DownstreamHttp2MaxConcurrentStream"] as! Int32
            }
            if dict.keys.contains("DownstreamIdleTime") {
                self.downstreamIdleTime = dict["DownstreamIdleTime"] as! Int32
            }
            if dict.keys.contains("EnableCustomAuthConfigPush") {
                self.enableCustomAuthConfigPush = dict["EnableCustomAuthConfigPush"] as! String
            }
            if dict.keys.contains("EnableGenerateRequestId") {
                self.enableGenerateRequestId = dict["EnableGenerateRequestId"] as! Bool
            }
            if dict.keys.contains("EnableGzip") {
                self.enableGzip = dict["EnableGzip"] as! Bool
            }
            if dict.keys.contains("EnableHardwareAccelerate") {
                self.enableHardwareAccelerate = dict["EnableHardwareAccelerate"] as! Bool
            }
            if dict.keys.contains("EnableHttp2") {
                self.enableHttp2 = dict["EnableHttp2"] as! Bool
            }
            if dict.keys.contains("EnableHttp3") {
                self.enableHttp3 = dict["EnableHttp3"] as! Bool
            }
            if dict.keys.contains("EnableK8sSourceWorkloadFilter") {
                var model = GetGatewayConfigResponseBody.Data.EnableK8sSourceWorkloadFilter()
                model.fromMap(dict["EnableK8sSourceWorkloadFilter"] as! [String: Any])
                self.enableK8sSourceWorkloadFilter = model
            }
            if dict.keys.contains("EnableProxyProtocol") {
                self.enableProxyProtocol = dict["EnableProxyProtocol"] as! Bool
            }
            if dict.keys.contains("EnableSlashMerge") {
                self.enableSlashMerge = dict["EnableSlashMerge"] as! Bool
            }
            if dict.keys.contains("EnableWaf") {
                self.enableWaf = dict["EnableWaf"] as! Bool
            }
            if dict.keys.contains("EnableXffTrustedCidrs") {
                var model = GetGatewayConfigResponseBody.Data.EnableXffTrustedCidrs()
                model.fromMap(dict["EnableXffTrustedCidrs"] as! [String: Any])
                self.enableXffTrustedCidrs = model
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("InitialConnectionWindowSize") {
                self.initialConnectionWindowSize = dict["InitialConnectionWindowSize"] as! Int32
            }
            if dict.keys.contains("InitialStreamWindowSize") {
                self.initialStreamWindowSize = dict["InitialStreamWindowSize"] as! Int32
            }
            if dict.keys.contains("KeepaliveHeaderTimeout") {
                self.keepaliveHeaderTimeout = dict["KeepaliveHeaderTimeout"] as! Int32
            }
            if dict.keys.contains("LogFilterConfig") {
                self.logFilterConfig = dict["LogFilterConfig"] as! String
            }
            if dict.keys.contains("NoSupportedConfigList") {
                self.noSupportedConfigList = dict["NoSupportedConfigList"] as! String
            }
            if dict.keys.contains("PathWithEscapedSlashes") {
                self.pathWithEscapedSlashes = dict["PathWithEscapedSlashes"] as! String
            }
            if dict.keys.contains("PreserveHeaderFormat") {
                self.preserveHeaderFormat = dict["PreserveHeaderFormat"] as! Bool
            }
            if dict.keys.contains("SlsConfigDetails") {
                var model = GetGatewayConfigResponseBody.Data.SlsConfigDetails()
                model.fromMap(dict["SlsConfigDetails"] as! [String: Any])
                self.slsConfigDetails = model
            }
            if dict.keys.contains("SupportWaf") {
                self.supportWaf = dict["SupportWaf"] as! Bool
            }
            if dict.keys.contains("UpstreamIdleTimeout") {
                self.upstreamIdleTimeout = dict["UpstreamIdleTimeout"] as! Int32
            }
            if dict.keys.contains("WebsocketTermGracePeriod") {
                self.websocketTermGracePeriod = dict["WebsocketTermGracePeriod"] as! Int32
            }
            if dict.keys.contains("XffTrustedNum") {
                self.xffTrustedNum = dict["XffTrustedNum"] as! Int32
            }
            if dict.keys.contains("XtraceDetails") {
                var model = GetGatewayConfigResponseBody.Data.XtraceDetails()
                model.fromMap(dict["XtraceDetails"] as! [String: Any])
                self.xtraceDetails = model
            }
            if dict.keys.contains("ZipAlgorithm") {
                self.zipAlgorithm = dict["ZipAlgorithm"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayConfigResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetGatewayConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGatewayConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayDomainDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class GetGatewayDomainDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var afterDate: Int64?

        public var algorithm: String?

        public var beforeDate: Int64?

        public var certIdentifier: String?

        public var certName: String?

        public var commonName: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtAfter: String?

        public var gmtBefore: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var http2: String?

        public var id: Int64?

        public var issuer: String?

        public var mustHttps: Bool?

        public var name: String?

        public var protocol_: String?

        public var sans: String?

        public var tlsMax: String?

        public var tlsMin: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.afterDate != nil {
                map["AfterDate"] = self.afterDate!
            }
            if self.algorithm != nil {
                map["Algorithm"] = self.algorithm!
            }
            if self.beforeDate != nil {
                map["BeforeDate"] = self.beforeDate!
            }
            if self.certIdentifier != nil {
                map["CertIdentifier"] = self.certIdentifier!
            }
            if self.certName != nil {
                map["CertName"] = self.certName!
            }
            if self.commonName != nil {
                map["CommonName"] = self.commonName!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtAfter != nil {
                map["GmtAfter"] = self.gmtAfter!
            }
            if self.gmtBefore != nil {
                map["GmtBefore"] = self.gmtBefore!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.http2 != nil {
                map["Http2"] = self.http2!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.issuer != nil {
                map["Issuer"] = self.issuer!
            }
            if self.mustHttps != nil {
                map["MustHttps"] = self.mustHttps!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.sans != nil {
                map["Sans"] = self.sans!
            }
            if self.tlsMax != nil {
                map["TlsMax"] = self.tlsMax!
            }
            if self.tlsMin != nil {
                map["TlsMin"] = self.tlsMin!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AfterDate") {
                self.afterDate = dict["AfterDate"] as! Int64
            }
            if dict.keys.contains("Algorithm") {
                self.algorithm = dict["Algorithm"] as! String
            }
            if dict.keys.contains("BeforeDate") {
                self.beforeDate = dict["BeforeDate"] as! Int64
            }
            if dict.keys.contains("CertIdentifier") {
                self.certIdentifier = dict["CertIdentifier"] as! String
            }
            if dict.keys.contains("CertName") {
                self.certName = dict["CertName"] as! String
            }
            if dict.keys.contains("CommonName") {
                self.commonName = dict["CommonName"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtAfter") {
                self.gmtAfter = dict["GmtAfter"] as! String
            }
            if dict.keys.contains("GmtBefore") {
                self.gmtBefore = dict["GmtBefore"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Http2") {
                self.http2 = dict["Http2"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Issuer") {
                self.issuer = dict["Issuer"] as! String
            }
            if dict.keys.contains("MustHttps") {
                self.mustHttps = dict["MustHttps"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("Sans") {
                self.sans = dict["Sans"] as! String
            }
            if dict.keys.contains("TlsMax") {
                self.tlsMax = dict["TlsMax"] as! String
            }
            if dict.keys.contains("TlsMin") {
                self.tlsMin = dict["TlsMin"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayDomainDetailResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetGatewayDomainDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayDomainDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayDomainDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGatewayDomainDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayOptionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class GetGatewayOptionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: GatewayOption?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GatewayOption()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayOptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayOptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGatewayOptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayRouteDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var routeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
    }
}

public class GetGatewayRouteDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Cors : Tea.TeaModel {
            public var allowCredentials: Bool?

            public var allowHeaders: String?

            public var allowMethods: String?

            public var allowOrigins: String?

            public var exposeHeaders: String?

            public var status: String?

            public var timeUnit: String?

            public var unitNum: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowCredentials != nil {
                    map["AllowCredentials"] = self.allowCredentials!
                }
                if self.allowHeaders != nil {
                    map["AllowHeaders"] = self.allowHeaders!
                }
                if self.allowMethods != nil {
                    map["AllowMethods"] = self.allowMethods!
                }
                if self.allowOrigins != nil {
                    map["AllowOrigins"] = self.allowOrigins!
                }
                if self.exposeHeaders != nil {
                    map["ExposeHeaders"] = self.exposeHeaders!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowCredentials") {
                    self.allowCredentials = dict["AllowCredentials"] as! Bool
                }
                if dict.keys.contains("AllowHeaders") {
                    self.allowHeaders = dict["AllowHeaders"] as! String
                }
                if dict.keys.contains("AllowMethods") {
                    self.allowMethods = dict["AllowMethods"] as! String
                }
                if dict.keys.contains("AllowOrigins") {
                    self.allowOrigins = dict["AllowOrigins"] as! String
                }
                if dict.keys.contains("ExposeHeaders") {
                    self.exposeHeaders = dict["ExposeHeaders"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeUnit") {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
                if dict.keys.contains("UnitNum") {
                    self.unitNum = dict["UnitNum"] as! Int64
                }
            }
        }
        public class DirectResponse : Tea.TeaModel {
            public var body: String?

            public var code: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body!
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    self.body = dict["Body"] as! String
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! Int32
                }
            }
        }
        public class FallbackServices : Tea.TeaModel {
            public var agreementType: String?

            public var groupName: String?

            public var name: String?

            public var namespace: String?

            public var percent: Int32?

            public var serviceId: Int64?

            public var serviceName: String?

            public var servicePort: Int32?

            public var sourceType: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agreementType != nil {
                    map["AgreementType"] = self.agreementType!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.servicePort != nil {
                    map["ServicePort"] = self.servicePort!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgreementType") {
                    self.agreementType = dict["AgreementType"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! Int32
                }
                if dict.keys.contains("ServiceId") {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("ServicePort") {
                    self.servicePort = dict["ServicePort"] as! Int32
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class FlowMirror : Tea.TeaModel {
            public var percentage: Int32?

            public var port: Int32?

            public var status: String?

            public var targetServiceId: Int64?

            public var targetServiceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.percentage != nil {
                    map["Percentage"] = self.percentage!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.targetServiceId != nil {
                    map["TargetServiceId"] = self.targetServiceId!
                }
                if self.targetServiceName != nil {
                    map["TargetServiceName"] = self.targetServiceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Percentage") {
                    self.percentage = dict["Percentage"] as! Int32
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TargetServiceId") {
                    self.targetServiceId = dict["TargetServiceId"] as! Int64
                }
                if dict.keys.contains("TargetServiceName") {
                    self.targetServiceName = dict["TargetServiceName"] as! String
                }
            }
        }
        public class HTTPRewrite : Tea.TeaModel {
            public var host: String?

            public var path: String?

            public var pathType: String?

            public var pattern: String?

            public var status: String?

            public var substitution: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.pathType != nil {
                    map["PathType"] = self.pathType!
                }
                if self.pattern != nil {
                    map["Pattern"] = self.pattern!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.substitution != nil {
                    map["Substitution"] = self.substitution!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("PathType") {
                    self.pathType = dict["PathType"] as! String
                }
                if dict.keys.contains("Pattern") {
                    self.pattern = dict["Pattern"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Substitution") {
                    self.substitution = dict["Substitution"] as! String
                }
            }
        }
        public class HeaderOp : Tea.TeaModel {
            public class HeaderOpItems : Tea.TeaModel {
                public var directionType: String?

                public var key: String?

                public var opType: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.directionType != nil {
                        map["DirectionType"] = self.directionType!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.opType != nil {
                        map["OpType"] = self.opType!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DirectionType") {
                        self.directionType = dict["DirectionType"] as! String
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("OpType") {
                        self.opType = dict["OpType"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var headerOpItems: [GetGatewayRouteDetailResponseBody.Data.HeaderOp.HeaderOpItems]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.headerOpItems != nil {
                    var tmp : [Any] = []
                    for k in self.headerOpItems! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderOpItems"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HeaderOpItems") {
                    var tmp : [GetGatewayRouteDetailResponseBody.Data.HeaderOp.HeaderOpItems] = []
                    for v in dict["HeaderOpItems"] as! [Any] {
                        var model = GetGatewayRouteDetailResponseBody.Data.HeaderOp.HeaderOpItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerOpItems = tmp
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Redirect : Tea.TeaModel {
            public var code: Int32?

            public var host: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! Int32
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public class Retry : Tea.TeaModel {
            public var attempts: Int32?

            public var httpCodes: [String]?

            public var retryOn: [String]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attempts != nil {
                    map["Attempts"] = self.attempts!
                }
                if self.httpCodes != nil {
                    map["HttpCodes"] = self.httpCodes!
                }
                if self.retryOn != nil {
                    map["RetryOn"] = self.retryOn!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Attempts") {
                    self.attempts = dict["Attempts"] as! Int32
                }
                if dict.keys.contains("HttpCodes") {
                    self.httpCodes = dict["HttpCodes"] as! [String]
                }
                if dict.keys.contains("RetryOn") {
                    self.retryOn = dict["RetryOn"] as! [String]
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class RoutePredicates : Tea.TeaModel {
            public class HeaderPredicates : Tea.TeaModel {
                public var key: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class PathPredicates : Tea.TeaModel {
                public var ignoreCase: Bool?

                public var path: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ignoreCase != nil {
                        map["IgnoreCase"] = self.ignoreCase!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IgnoreCase") {
                        self.ignoreCase = dict["IgnoreCase"] as! Bool
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class QueryPredicates : Tea.TeaModel {
                public var key: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var headerPredicates: [GetGatewayRouteDetailResponseBody.Data.RoutePredicates.HeaderPredicates]?

            public var methodPredicates: [String]?

            public var pathPredicates: GetGatewayRouteDetailResponseBody.Data.RoutePredicates.PathPredicates?

            public var queryPredicates: [GetGatewayRouteDetailResponseBody.Data.RoutePredicates.QueryPredicates]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pathPredicates?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.headerPredicates != nil {
                    var tmp : [Any] = []
                    for k in self.headerPredicates! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderPredicates"] = tmp
                }
                if self.methodPredicates != nil {
                    map["MethodPredicates"] = self.methodPredicates!
                }
                if self.pathPredicates != nil {
                    map["PathPredicates"] = self.pathPredicates?.toMap()
                }
                if self.queryPredicates != nil {
                    var tmp : [Any] = []
                    for k in self.queryPredicates! {
                        tmp.append(k.toMap())
                    }
                    map["QueryPredicates"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HeaderPredicates") {
                    var tmp : [GetGatewayRouteDetailResponseBody.Data.RoutePredicates.HeaderPredicates] = []
                    for v in dict["HeaderPredicates"] as! [Any] {
                        var model = GetGatewayRouteDetailResponseBody.Data.RoutePredicates.HeaderPredicates()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerPredicates = tmp
                }
                if dict.keys.contains("MethodPredicates") {
                    self.methodPredicates = dict["MethodPredicates"] as! [String]
                }
                if dict.keys.contains("PathPredicates") {
                    var model = GetGatewayRouteDetailResponseBody.Data.RoutePredicates.PathPredicates()
                    model.fromMap(dict["PathPredicates"] as! [String: Any])
                    self.pathPredicates = model
                }
                if dict.keys.contains("QueryPredicates") {
                    var tmp : [GetGatewayRouteDetailResponseBody.Data.RoutePredicates.QueryPredicates] = []
                    for v in dict["QueryPredicates"] as! [Any] {
                        var model = GetGatewayRouteDetailResponseBody.Data.RoutePredicates.QueryPredicates()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.queryPredicates = tmp
                }
            }
        }
        public class RouteServices : Tea.TeaModel {
            public class HttpDubboTranscoder : Tea.TeaModel {
                public class MothedMapList : Tea.TeaModel {
                    public class ParamMapsList : Tea.TeaModel {
                        public var extractKey: String?

                        public var extractKeySpec: String?

                        public var mappingType: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extractKey != nil {
                                map["ExtractKey"] = self.extractKey!
                            }
                            if self.extractKeySpec != nil {
                                map["ExtractKeySpec"] = self.extractKeySpec!
                            }
                            if self.mappingType != nil {
                                map["MappingType"] = self.mappingType!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ExtractKey") {
                                self.extractKey = dict["ExtractKey"] as! String
                            }
                            if dict.keys.contains("ExtractKeySpec") {
                                self.extractKeySpec = dict["ExtractKeySpec"] as! String
                            }
                            if dict.keys.contains("MappingType") {
                                self.mappingType = dict["MappingType"] as! String
                            }
                        }
                    }
                    public var dubboMothedName: String?

                    public var httpMothed: String?

                    public var mothedpath: String?

                    public var paramMapsList: [GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList]?

                    public var passThroughAllHeaders: String?

                    public var passThroughList: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dubboMothedName != nil {
                            map["DubboMothedName"] = self.dubboMothedName!
                        }
                        if self.httpMothed != nil {
                            map["HttpMothed"] = self.httpMothed!
                        }
                        if self.mothedpath != nil {
                            map["Mothedpath"] = self.mothedpath!
                        }
                        if self.paramMapsList != nil {
                            var tmp : [Any] = []
                            for k in self.paramMapsList! {
                                tmp.append(k.toMap())
                            }
                            map["ParamMapsList"] = tmp
                        }
                        if self.passThroughAllHeaders != nil {
                            map["PassThroughAllHeaders"] = self.passThroughAllHeaders!
                        }
                        if self.passThroughList != nil {
                            map["PassThroughList"] = self.passThroughList!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DubboMothedName") {
                            self.dubboMothedName = dict["DubboMothedName"] as! String
                        }
                        if dict.keys.contains("HttpMothed") {
                            self.httpMothed = dict["HttpMothed"] as! String
                        }
                        if dict.keys.contains("Mothedpath") {
                            self.mothedpath = dict["Mothedpath"] as! String
                        }
                        if dict.keys.contains("ParamMapsList") {
                            var tmp : [GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList] = []
                            for v in dict["ParamMapsList"] as! [Any] {
                                var model = GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.paramMapsList = tmp
                        }
                        if dict.keys.contains("PassThroughAllHeaders") {
                            self.passThroughAllHeaders = dict["PassThroughAllHeaders"] as! String
                        }
                        if dict.keys.contains("PassThroughList") {
                            self.passThroughList = dict["PassThroughList"] as! [String]
                        }
                    }
                }
                public var dubboServiceGroup: String?

                public var dubboServiceName: String?

                public var dubboServiceVersion: String?

                public var mothedMapList: [GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder.MothedMapList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dubboServiceGroup != nil {
                        map["DubboServiceGroup"] = self.dubboServiceGroup!
                    }
                    if self.dubboServiceName != nil {
                        map["DubboServiceName"] = self.dubboServiceName!
                    }
                    if self.dubboServiceVersion != nil {
                        map["DubboServiceVersion"] = self.dubboServiceVersion!
                    }
                    if self.mothedMapList != nil {
                        var tmp : [Any] = []
                        for k in self.mothedMapList! {
                            tmp.append(k.toMap())
                        }
                        map["MothedMapList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DubboServiceGroup") {
                        self.dubboServiceGroup = dict["DubboServiceGroup"] as! String
                    }
                    if dict.keys.contains("DubboServiceName") {
                        self.dubboServiceName = dict["DubboServiceName"] as! String
                    }
                    if dict.keys.contains("DubboServiceVersion") {
                        self.dubboServiceVersion = dict["DubboServiceVersion"] as! String
                    }
                    if dict.keys.contains("MothedMapList") {
                        var tmp : [GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder.MothedMapList] = []
                        for v in dict["MothedMapList"] as! [Any] {
                            var model = GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder.MothedMapList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.mothedMapList = tmp
                    }
                }
            }
            public var agreementType: String?

            public var groupName: String?

            public var healthStatus: String?

            public var httpDubboTranscoder: GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder?

            public var name: String?

            public var namespace: String?

            public var percent: Int32?

            public var serviceId: Int64?

            public var serviceName: String?

            public var servicePort: Int32?

            public var sourceType: String?

            public var unhealthyEndpoints: [String]?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.httpDubboTranscoder?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agreementType != nil {
                    map["AgreementType"] = self.agreementType!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.httpDubboTranscoder != nil {
                    map["HttpDubboTranscoder"] = self.httpDubboTranscoder?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.servicePort != nil {
                    map["ServicePort"] = self.servicePort!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.unhealthyEndpoints != nil {
                    map["UnhealthyEndpoints"] = self.unhealthyEndpoints!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgreementType") {
                    self.agreementType = dict["AgreementType"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("HttpDubboTranscoder") {
                    var model = GetGatewayRouteDetailResponseBody.Data.RouteServices.HttpDubboTranscoder()
                    model.fromMap(dict["HttpDubboTranscoder"] as! [String: Any])
                    self.httpDubboTranscoder = model
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! Int32
                }
                if dict.keys.contains("ServiceId") {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("ServicePort") {
                    self.servicePort = dict["ServicePort"] as! Int32
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("UnhealthyEndpoints") {
                    self.unhealthyEndpoints = dict["UnhealthyEndpoints"] as! [String]
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class Timeout : Tea.TeaModel {
            public var status: String?

            public var timeUnit: String?

            public var unitNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeUnit") {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
                if dict.keys.contains("UnitNum") {
                    self.unitNum = dict["UnitNum"] as! Int32
                }
            }
        }
        public var ahasStatus: Int32?

        public var cors: GetGatewayRouteDetailResponseBody.Data.Cors?

        public var defaultServiceId: Int64?

        public var defaultServiceName: String?

        public var description_: String?

        public var destinationType: String?

        public var directResponse: GetGatewayRouteDetailResponseBody.Data.DirectResponse?

        public var domainId: Int64?

        public var domainIdList: [Int64]?

        public var domainName: String?

        public var domainNameList: [String]?

        public var enableWaf: Bool?

        public var fallback: Bool?

        public var fallbackServices: [GetGatewayRouteDetailResponseBody.Data.FallbackServices]?

        public var flowMirror: GetGatewayRouteDetailResponseBody.Data.FlowMirror?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var HTTPRewrite: GetGatewayRouteDetailResponseBody.Data.HTTPRewrite?

        public var headerOp: GetGatewayRouteDetailResponseBody.Data.HeaderOp?

        public var id: Int64?

        public var name: String?

        public var policies: String?

        public var predicates: String?

        public var redirect: GetGatewayRouteDetailResponseBody.Data.Redirect?

        public var retry: GetGatewayRouteDetailResponseBody.Data.Retry?

        public var routeOrder: Int32?

        public var routePredicates: GetGatewayRouteDetailResponseBody.Data.RoutePredicates?

        public var routeServices: [GetGatewayRouteDetailResponseBody.Data.RouteServices]?

        public var services: String?

        public var status: Int32?

        public var timeout: GetGatewayRouteDetailResponseBody.Data.Timeout?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cors?.validate()
            try self.directResponse?.validate()
            try self.flowMirror?.validate()
            try self.HTTPRewrite?.validate()
            try self.headerOp?.validate()
            try self.redirect?.validate()
            try self.retry?.validate()
            try self.routePredicates?.validate()
            try self.timeout?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ahasStatus != nil {
                map["AhasStatus"] = self.ahasStatus!
            }
            if self.cors != nil {
                map["Cors"] = self.cors?.toMap()
            }
            if self.defaultServiceId != nil {
                map["DefaultServiceId"] = self.defaultServiceId!
            }
            if self.defaultServiceName != nil {
                map["DefaultServiceName"] = self.defaultServiceName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationType != nil {
                map["DestinationType"] = self.destinationType!
            }
            if self.directResponse != nil {
                map["DirectResponse"] = self.directResponse?.toMap()
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainIdList != nil {
                map["DomainIdList"] = self.domainIdList!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainNameList != nil {
                map["DomainNameList"] = self.domainNameList!
            }
            if self.enableWaf != nil {
                map["EnableWaf"] = self.enableWaf!
            }
            if self.fallback != nil {
                map["Fallback"] = self.fallback!
            }
            if self.fallbackServices != nil {
                var tmp : [Any] = []
                for k in self.fallbackServices! {
                    tmp.append(k.toMap())
                }
                map["FallbackServices"] = tmp
            }
            if self.flowMirror != nil {
                map["FlowMirror"] = self.flowMirror?.toMap()
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.HTTPRewrite != nil {
                map["HTTPRewrite"] = self.HTTPRewrite?.toMap()
            }
            if self.headerOp != nil {
                map["HeaderOp"] = self.headerOp?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.policies != nil {
                map["Policies"] = self.policies!
            }
            if self.predicates != nil {
                map["Predicates"] = self.predicates!
            }
            if self.redirect != nil {
                map["Redirect"] = self.redirect?.toMap()
            }
            if self.retry != nil {
                map["Retry"] = self.retry?.toMap()
            }
            if self.routeOrder != nil {
                map["RouteOrder"] = self.routeOrder!
            }
            if self.routePredicates != nil {
                map["RoutePredicates"] = self.routePredicates?.toMap()
            }
            if self.routeServices != nil {
                var tmp : [Any] = []
                for k in self.routeServices! {
                    tmp.append(k.toMap())
                }
                map["RouteServices"] = tmp
            }
            if self.services != nil {
                map["Services"] = self.services!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AhasStatus") {
                self.ahasStatus = dict["AhasStatus"] as! Int32
            }
            if dict.keys.contains("Cors") {
                var model = GetGatewayRouteDetailResponseBody.Data.Cors()
                model.fromMap(dict["Cors"] as! [String: Any])
                self.cors = model
            }
            if dict.keys.contains("DefaultServiceId") {
                self.defaultServiceId = dict["DefaultServiceId"] as! Int64
            }
            if dict.keys.contains("DefaultServiceName") {
                self.defaultServiceName = dict["DefaultServiceName"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestinationType") {
                self.destinationType = dict["DestinationType"] as! String
            }
            if dict.keys.contains("DirectResponse") {
                var model = GetGatewayRouteDetailResponseBody.Data.DirectResponse()
                model.fromMap(dict["DirectResponse"] as! [String: Any])
                self.directResponse = model
            }
            if dict.keys.contains("DomainId") {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainIdList") {
                self.domainIdList = dict["DomainIdList"] as! [Int64]
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainNameList") {
                self.domainNameList = dict["DomainNameList"] as! [String]
            }
            if dict.keys.contains("EnableWaf") {
                self.enableWaf = dict["EnableWaf"] as! Bool
            }
            if dict.keys.contains("Fallback") {
                self.fallback = dict["Fallback"] as! Bool
            }
            if dict.keys.contains("FallbackServices") {
                var tmp : [GetGatewayRouteDetailResponseBody.Data.FallbackServices] = []
                for v in dict["FallbackServices"] as! [Any] {
                    var model = GetGatewayRouteDetailResponseBody.Data.FallbackServices()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fallbackServices = tmp
            }
            if dict.keys.contains("FlowMirror") {
                var model = GetGatewayRouteDetailResponseBody.Data.FlowMirror()
                model.fromMap(dict["FlowMirror"] as! [String: Any])
                self.flowMirror = model
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("HTTPRewrite") {
                var model = GetGatewayRouteDetailResponseBody.Data.HTTPRewrite()
                model.fromMap(dict["HTTPRewrite"] as! [String: Any])
                self.HTTPRewrite = model
            }
            if dict.keys.contains("HeaderOp") {
                var model = GetGatewayRouteDetailResponseBody.Data.HeaderOp()
                model.fromMap(dict["HeaderOp"] as! [String: Any])
                self.headerOp = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Policies") {
                self.policies = dict["Policies"] as! String
            }
            if dict.keys.contains("Predicates") {
                self.predicates = dict["Predicates"] as! String
            }
            if dict.keys.contains("Redirect") {
                var model = GetGatewayRouteDetailResponseBody.Data.Redirect()
                model.fromMap(dict["Redirect"] as! [String: Any])
                self.redirect = model
            }
            if dict.keys.contains("Retry") {
                var model = GetGatewayRouteDetailResponseBody.Data.Retry()
                model.fromMap(dict["Retry"] as! [String: Any])
                self.retry = model
            }
            if dict.keys.contains("RouteOrder") {
                self.routeOrder = dict["RouteOrder"] as! Int32
            }
            if dict.keys.contains("RoutePredicates") {
                var model = GetGatewayRouteDetailResponseBody.Data.RoutePredicates()
                model.fromMap(dict["RoutePredicates"] as! [String: Any])
                self.routePredicates = model
            }
            if dict.keys.contains("RouteServices") {
                var tmp : [GetGatewayRouteDetailResponseBody.Data.RouteServices] = []
                for v in dict["RouteServices"] as! [Any] {
                    var model = GetGatewayRouteDetailResponseBody.Data.RouteServices()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.routeServices = tmp
            }
            if dict.keys.contains("Services") {
                self.services = dict["Services"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Timeout") {
                var model = GetGatewayRouteDetailResponseBody.Data.Timeout()
                model.fromMap(dict["Timeout"] as! [String: Any])
                self.timeout = model
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayRouteDetailResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetGatewayRouteDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayRouteDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayRouteDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGatewayRouteDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGatewayServiceDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var serviceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! Int64
        }
    }
}

public class GetGatewayServiceDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class LabelDetails : Tea.TeaModel {
            public var key: String?

            public var values: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.values != nil {
                    map["Values"] = self.values!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Values") {
                    self.values = dict["Values"] as! [String]
                }
            }
        }
        public class PortTrafficPolicyList : Tea.TeaModel {
            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var serviceId: Int64?

            public var servicePort: Int32?

            public var trafficPolicy: TrafficPolicy?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.trafficPolicy?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.servicePort != nil {
                    map["ServicePort"] = self.servicePort!
                }
                if self.trafficPolicy != nil {
                    map["TrafficPolicy"] = self.trafficPolicy?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ServiceId") {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("ServicePort") {
                    self.servicePort = dict["ServicePort"] as! Int32
                }
                if dict.keys.contains("TrafficPolicy") {
                    var model = TrafficPolicy()
                    model.fromMap(dict["TrafficPolicy"] as! [String: Any])
                    self.trafficPolicy = model
                }
            }
        }
        public class VersionDetails : Tea.TeaModel {
            public class ServiceVersion : Tea.TeaModel {
                public class Labels : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var labels: [GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion.Labels]?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.labels != nil {
                        var tmp : [Any] = []
                        for k in self.labels! {
                            tmp.append(k.toMap())
                        }
                        map["Labels"] = tmp
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Labels") {
                        var tmp : [GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion.Labels] = []
                        for v in dict["Labels"] as! [Any] {
                            var model = GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion.Labels()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.labels = tmp
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var endpointNum: Int32?

            public var endpointNumPercent: String?

            public var serviceVersion: GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.serviceVersion?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpointNum != nil {
                    map["EndpointNum"] = self.endpointNum!
                }
                if self.endpointNumPercent != nil {
                    map["EndpointNumPercent"] = self.endpointNumPercent!
                }
                if self.serviceVersion != nil {
                    map["ServiceVersion"] = self.serviceVersion?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndpointNum") {
                    self.endpointNum = dict["EndpointNum"] as! Int32
                }
                if dict.keys.contains("EndpointNumPercent") {
                    self.endpointNumPercent = dict["EndpointNumPercent"] as! String
                }
                if dict.keys.contains("ServiceVersion") {
                    var model = GetGatewayServiceDetailResponseBody.Data.VersionDetails.ServiceVersion()
                    model.fromMap(dict["ServiceVersion"] as! [String: Any])
                    self.serviceVersion = model
                }
            }
        }
        public class Versions : Tea.TeaModel {
            public var label: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dnsServerList: [String]?

        public var gatewayId: Int64?

        public var gatewayTrafficPolicy: TrafficPolicy?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var groupName: String?

        public var healthCheck: String?

        public var healthStatus: String?

        public var id: Int64?

        public var ips: [String]?

        public var labelDetails: [GetGatewayServiceDetailResponseBody.Data.LabelDetails]?

        public var metaInfo: String?

        public var name: String?

        public var namespace: String?

        public var portTrafficPolicyList: [GetGatewayServiceDetailResponseBody.Data.PortTrafficPolicyList]?

        public var ports: [Int32]?

        public var serviceFQDN: String?

        public var serviceNameInRegistry: String?

        public var servicePort: Int32?

        public var serviceProtocol: String?

        public var sourceId: Int64?

        public var sourceType: String?

        public var versionDetails: [GetGatewayServiceDetailResponseBody.Data.VersionDetails]?

        public var versions: [GetGatewayServiceDetailResponseBody.Data.Versions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.gatewayTrafficPolicy?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServerList != nil {
                map["DnsServerList"] = self.dnsServerList!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayTrafficPolicy != nil {
                map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicy?.toMap()
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.healthCheck != nil {
                map["HealthCheck"] = self.healthCheck!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.labelDetails != nil {
                var tmp : [Any] = []
                for k in self.labelDetails! {
                    tmp.append(k.toMap())
                }
                map["LabelDetails"] = tmp
            }
            if self.metaInfo != nil {
                map["MetaInfo"] = self.metaInfo!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.portTrafficPolicyList != nil {
                var tmp : [Any] = []
                for k in self.portTrafficPolicyList! {
                    tmp.append(k.toMap())
                }
                map["PortTrafficPolicyList"] = tmp
            }
            if self.ports != nil {
                map["Ports"] = self.ports!
            }
            if self.serviceFQDN != nil {
                map["ServiceFQDN"] = self.serviceFQDN!
            }
            if self.serviceNameInRegistry != nil {
                map["ServiceNameInRegistry"] = self.serviceNameInRegistry!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.sourceId != nil {
                map["SourceId"] = self.sourceId!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.versionDetails != nil {
                var tmp : [Any] = []
                for k in self.versionDetails! {
                    tmp.append(k.toMap())
                }
                map["VersionDetails"] = tmp
            }
            if self.versions != nil {
                var tmp : [Any] = []
                for k in self.versions! {
                    tmp.append(k.toMap())
                }
                map["Versions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServerList") {
                self.dnsServerList = dict["DnsServerList"] as! [String]
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayTrafficPolicy") {
                var model = TrafficPolicy()
                model.fromMap(dict["GatewayTrafficPolicy"] as! [String: Any])
                self.gatewayTrafficPolicy = model
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("HealthCheck") {
                self.healthCheck = dict["HealthCheck"] as! String
            }
            if dict.keys.contains("HealthStatus") {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Ips") {
                self.ips = dict["Ips"] as! [String]
            }
            if dict.keys.contains("LabelDetails") {
                var tmp : [GetGatewayServiceDetailResponseBody.Data.LabelDetails] = []
                for v in dict["LabelDetails"] as! [Any] {
                    var model = GetGatewayServiceDetailResponseBody.Data.LabelDetails()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labelDetails = tmp
            }
            if dict.keys.contains("MetaInfo") {
                self.metaInfo = dict["MetaInfo"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("PortTrafficPolicyList") {
                var tmp : [GetGatewayServiceDetailResponseBody.Data.PortTrafficPolicyList] = []
                for v in dict["PortTrafficPolicyList"] as! [Any] {
                    var model = GetGatewayServiceDetailResponseBody.Data.PortTrafficPolicyList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.portTrafficPolicyList = tmp
            }
            if dict.keys.contains("Ports") {
                self.ports = dict["Ports"] as! [Int32]
            }
            if dict.keys.contains("ServiceFQDN") {
                self.serviceFQDN = dict["ServiceFQDN"] as! String
            }
            if dict.keys.contains("ServiceNameInRegistry") {
                self.serviceNameInRegistry = dict["ServiceNameInRegistry"] as! String
            }
            if dict.keys.contains("ServicePort") {
                self.servicePort = dict["ServicePort"] as! Int32
            }
            if dict.keys.contains("ServiceProtocol") {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
            if dict.keys.contains("SourceId") {
                self.sourceId = dict["SourceId"] as! Int64
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("VersionDetails") {
                var tmp : [GetGatewayServiceDetailResponseBody.Data.VersionDetails] = []
                for v in dict["VersionDetails"] as! [Any] {
                    var model = GetGatewayServiceDetailResponseBody.Data.VersionDetails()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.versionDetails = tmp
            }
            if dict.keys.contains("Versions") {
                var tmp : [GetGatewayServiceDetailResponseBody.Data.Versions] = []
                for v in dict["Versions"] as! [Any] {
                    var model = GetGatewayServiceDetailResponseBody.Data.Versions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.versions = tmp
            }
        }
    }
    public var code: Int32?

    public var data: GetGatewayServiceDetailResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetGatewayServiceDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGatewayServiceDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGatewayServiceDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGatewayServiceDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGovernanceKubernetesClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetGovernanceKubernetesClusterResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Namespaces : Tea.TeaModel {
            public var mseNamespace: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mseNamespace != nil {
                    map["MseNamespace"] = self.mseNamespace!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MseNamespace") {
                    self.mseNamespace = dict["MseNamespace"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var clusterId: String?

        public var clusterName: String?

        public var k8sVersion: String?

        public var namespaceInfos: String?

        public var namespaces: [GetGovernanceKubernetesClusterResponseBody.Data.Namespaces]?

        public var pilotStartTime: String?

        public var region: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.k8sVersion != nil {
                map["K8sVersion"] = self.k8sVersion!
            }
            if self.namespaceInfos != nil {
                map["NamespaceInfos"] = self.namespaceInfos!
            }
            if self.namespaces != nil {
                var tmp : [Any] = []
                for k in self.namespaces! {
                    tmp.append(k.toMap())
                }
                map["Namespaces"] = tmp
            }
            if self.pilotStartTime != nil {
                map["PilotStartTime"] = self.pilotStartTime!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("K8sVersion") {
                self.k8sVersion = dict["K8sVersion"] as! String
            }
            if dict.keys.contains("NamespaceInfos") {
                self.namespaceInfos = dict["NamespaceInfos"] as! String
            }
            if dict.keys.contains("Namespaces") {
                var tmp : [GetGovernanceKubernetesClusterResponseBody.Data.Namespaces] = []
                for v in dict["Namespaces"] as! [Any] {
                    var model = GetGovernanceKubernetesClusterResponseBody.Data.Namespaces()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.namespaces = tmp
            }
            if dict.keys.contains("PilotStartTime") {
                self.pilotStartTime = dict["PilotStartTime"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var data: GetGovernanceKubernetesClusterResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetGovernanceKubernetesClusterResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetGovernanceKubernetesClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGovernanceKubernetesClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGovernanceKubernetesClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetImageRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
    }
}

public class GetImageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var currentVersionFullShowName: String?

        public var maxVersionChangelogUrl: String?

        public var maxVersionCode: String?

        public var maxVersionFullShowName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentVersionFullShowName != nil {
                map["CurrentVersionFullShowName"] = self.currentVersionFullShowName!
            }
            if self.maxVersionChangelogUrl != nil {
                map["MaxVersionChangelogUrl"] = self.maxVersionChangelogUrl!
            }
            if self.maxVersionCode != nil {
                map["MaxVersionCode"] = self.maxVersionCode!
            }
            if self.maxVersionFullShowName != nil {
                map["MaxVersionFullShowName"] = self.maxVersionFullShowName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentVersionFullShowName") {
                self.currentVersionFullShowName = dict["CurrentVersionFullShowName"] as! String
            }
            if dict.keys.contains("MaxVersionChangelogUrl") {
                self.maxVersionChangelogUrl = dict["MaxVersionChangelogUrl"] as! String
            }
            if dict.keys.contains("MaxVersionCode") {
                self.maxVersionCode = dict["MaxVersionCode"] as! String
            }
            if dict.keys.contains("MaxVersionFullShowName") {
                self.maxVersionFullShowName = dict["MaxVersionFullShowName"] as! String
            }
        }
    }
    public var data: GetImageResponseBody.Data?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetImageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetImportFileUrlRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var contentType: String?

    public var instanceId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ContentType") {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class GetImportFileUrlResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetImportFileUrlResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetImportFileUrlResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetImportFileUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetImportFileUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetImportFileUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetKubernetesSourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var isAll: Bool?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.isAll != nil {
            map["IsAll"] = self.isAll!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IsAll") {
            self.isAll = dict["IsAll"] as! Bool
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class GetKubernetesSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var cluster: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cluster != nil {
                map["Cluster"] = self.cluster!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cluster") {
                self.cluster = dict["Cluster"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [GetKubernetesSourceResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [GetKubernetesSourceResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetKubernetesSourceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetKubernetesSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetKubernetesSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetKubernetesSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLocalityRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var region: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
    }
}

public class GetLocalityRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetLocalityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLocalityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLocalityRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLosslessRuleByAppRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetLosslessRuleByAppResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var aligned: Bool?

        public var appId: String?

        public var appName: String?

        public var count: Int32?

        public var delayTime: Int32?

        public var enable: Bool?

        public var funcType: Int32?

        public var lossLessDetail: Bool?

        public var notice: Bool?

        public var related: Bool?

        public var warmupTime: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aligned != nil {
                map["Aligned"] = self.aligned!
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.delayTime != nil {
                map["DelayTime"] = self.delayTime!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.funcType != nil {
                map["FuncType"] = self.funcType!
            }
            if self.lossLessDetail != nil {
                map["LossLessDetail"] = self.lossLessDetail!
            }
            if self.notice != nil {
                map["Notice"] = self.notice!
            }
            if self.related != nil {
                map["Related"] = self.related!
            }
            if self.warmupTime != nil {
                map["WarmupTime"] = self.warmupTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Aligned") {
                self.aligned = dict["Aligned"] as! Bool
            }
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("DelayTime") {
                self.delayTime = dict["DelayTime"] as! Int32
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("FuncType") {
                self.funcType = dict["FuncType"] as! Int32
            }
            if dict.keys.contains("LossLessDetail") {
                self.lossLessDetail = dict["LossLessDetail"] as! Bool
            }
            if dict.keys.contains("Notice") {
                self.notice = dict["Notice"] as! Bool
            }
            if dict.keys.contains("Related") {
                self.related = dict["Related"] as! Bool
            }
            if dict.keys.contains("WarmupTime") {
                self.warmupTime = dict["WarmupTime"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: GetLosslessRuleByAppResponseBody.Data?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetLosslessRuleByAppResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetLosslessRuleByAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLosslessRuleByAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLosslessRuleByAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMseFeatureSwitchRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class GetMseFeatureSwitchResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var result: [String: Any]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String: Any]
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMseFeatureSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMseFeatureSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMseFeatureSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMseSourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var type: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class GetMseSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var address: String?

        public var clusterId: String?

        public var instanceId: String?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [GetMseSourceResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [GetMseSourceResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetMseSourceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMseSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMseSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMseSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var beta: Bool?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.beta != nil {
            map["Beta"] = self.beta!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Beta") {
            self.beta = dict["Beta"] as! Bool
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class GetNacosConfigResponseBody : Tea.TeaModel {
    public class Configuration : Tea.TeaModel {
        public class GrayVersions : Tea.TeaModel {
            public var name: String?

            public var priority: Int32?

            public var rule: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.rule != nil {
                    map["Rule"] = self.rule!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("Rule") {
                    self.rule = dict["Rule"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var appName: String?

        public var betaIps: String?

        public var content: String?

        public var dataId: String?

        public var desc: String?

        public var encryptedDataKey: String?

        public var grayVersions: [GetNacosConfigResponseBody.Configuration.GrayVersions]?

        public var group: String?

        public var md5: String?

        public var tags: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.betaIps != nil {
                map["BetaIps"] = self.betaIps!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.encryptedDataKey != nil {
                map["EncryptedDataKey"] = self.encryptedDataKey!
            }
            if self.grayVersions != nil {
                var tmp : [Any] = []
                for k in self.grayVersions! {
                    tmp.append(k.toMap())
                }
                map["GrayVersions"] = tmp
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("BetaIps") {
                self.betaIps = dict["BetaIps"] as! String
            }
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("DataId") {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Desc") {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("EncryptedDataKey") {
                self.encryptedDataKey = dict["EncryptedDataKey"] as! String
            }
            if dict.keys.contains("GrayVersions") {
                var tmp : [GetNacosConfigResponseBody.Configuration.GrayVersions] = []
                for v in dict["GrayVersions"] as! [Any] {
                    var model = GetNacosConfigResponseBody.Configuration.GrayVersions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.grayVersions = tmp
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Md5") {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var configuration: GetNacosConfigResponseBody.Configuration?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configuration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configuration != nil {
            map["Configuration"] = self.configuration?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Configuration") {
            var model = GetNacosConfigResponseBody.Configuration()
            model.fromMap(dict["Configuration"] as! [String: Any])
            self.configuration = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNacosHistoryConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var nid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.nid != nil {
            map["Nid"] = self.nid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Nid") {
            self.nid = dict["Nid"] as! String
        }
    }
}

public class GetNacosHistoryConfigResponseBody : Tea.TeaModel {
    public class Configuration : Tea.TeaModel {
        public var appName: String?

        public var content: String?

        public var dataId: String?

        public var encryptedDataKey: String?

        public var group: String?

        public var md5: String?

        public var opType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.encryptedDataKey != nil {
                map["EncryptedDataKey"] = self.encryptedDataKey!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.opType != nil {
                map["OpType"] = self.opType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("DataId") {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("EncryptedDataKey") {
                self.encryptedDataKey = dict["EncryptedDataKey"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Md5") {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("OpType") {
                self.opType = dict["OpType"] as! String
            }
        }
    }
    public var configuration: GetNacosHistoryConfigResponseBody.Configuration?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configuration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configuration != nil {
            map["Configuration"] = self.configuration?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Configuration") {
            var model = GetNacosHistoryConfigResponseBody.Configuration()
            model.fromMap(dict["Configuration"] as! [String: Any])
            self.configuration = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetNacosHistoryConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNacosHistoryConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNacosHistoryConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOverviewRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var period: Int32?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class GetOverviewResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetOverviewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOverviewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOverviewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPluginConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var pluginId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! Int64
        }
    }
}

public class GetPluginConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class GatewayConfigList : Tea.TeaModel {
            public class ResourceList : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var config: String?

            public var configLevel: Int32?

            public var enable: Bool?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var pluginId: Int64?

            public var resourceList: [GetPluginConfigResponseBody.Data.GatewayConfigList.ResourceList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.config != nil {
                    map["Config"] = self.config!
                }
                if self.configLevel != nil {
                    map["ConfigLevel"] = self.configLevel!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.pluginId != nil {
                    map["PluginId"] = self.pluginId!
                }
                if self.resourceList != nil {
                    var tmp : [Any] = []
                    for k in self.resourceList! {
                        tmp.append(k.toMap())
                    }
                    map["ResourceList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Config") {
                    self.config = dict["Config"] as! String
                }
                if dict.keys.contains("ConfigLevel") {
                    self.configLevel = dict["ConfigLevel"] as! Int32
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("PluginId") {
                    self.pluginId = dict["PluginId"] as! Int64
                }
                if dict.keys.contains("ResourceList") {
                    var tmp : [GetPluginConfigResponseBody.Data.GatewayConfigList.ResourceList] = []
                    for v in dict["ResourceList"] as! [Any] {
                        var model = GetPluginConfigResponseBody.Data.GatewayConfigList.ResourceList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.resourceList = tmp
                }
            }
        }
        public var category: Int32?

        public var configCheck: String?

        public var configExample: String?

        public var domainConfigStartIndex: Int32?

        public var gatewayConfigList: [GetPluginConfigResponseBody.Data.GatewayConfigList]?

        public var gatewayConfigStartIndex: Int32?

        public var id: Int64?

        public var imageName: String?

        public var mode: Int32?

        public var name: String?

        public var phase: Int32?

        public var primaryUser: String?

        public var priority: Int32?

        public var publishState: Int32?

        public var readme: String?

        public var readmeEn: String?

        public var routeConfigStartIndex: Int32?

        public var status: String?

        public var summary: String?

        public var summaryEn: String?

        public var type: Int32?

        public var version: String?

        public var versionJson: String?

        public var wasmLang: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.configCheck != nil {
                map["ConfigCheck"] = self.configCheck!
            }
            if self.configExample != nil {
                map["ConfigExample"] = self.configExample!
            }
            if self.domainConfigStartIndex != nil {
                map["DomainConfigStartIndex"] = self.domainConfigStartIndex!
            }
            if self.gatewayConfigList != nil {
                var tmp : [Any] = []
                for k in self.gatewayConfigList! {
                    tmp.append(k.toMap())
                }
                map["GatewayConfigList"] = tmp
            }
            if self.gatewayConfigStartIndex != nil {
                map["GatewayConfigStartIndex"] = self.gatewayConfigStartIndex!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.phase != nil {
                map["Phase"] = self.phase!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.publishState != nil {
                map["PublishState"] = self.publishState!
            }
            if self.readme != nil {
                map["Readme"] = self.readme!
            }
            if self.readmeEn != nil {
                map["ReadmeEn"] = self.readmeEn!
            }
            if self.routeConfigStartIndex != nil {
                map["RouteConfigStartIndex"] = self.routeConfigStartIndex!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.summaryEn != nil {
                map["SummaryEn"] = self.summaryEn!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.versionJson != nil {
                map["VersionJson"] = self.versionJson!
            }
            if self.wasmLang != nil {
                map["WasmLang"] = self.wasmLang!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! Int32
            }
            if dict.keys.contains("ConfigCheck") {
                self.configCheck = dict["ConfigCheck"] as! String
            }
            if dict.keys.contains("ConfigExample") {
                self.configExample = dict["ConfigExample"] as! String
            }
            if dict.keys.contains("DomainConfigStartIndex") {
                self.domainConfigStartIndex = dict["DomainConfigStartIndex"] as! Int32
            }
            if dict.keys.contains("GatewayConfigList") {
                var tmp : [GetPluginConfigResponseBody.Data.GatewayConfigList] = []
                for v in dict["GatewayConfigList"] as! [Any] {
                    var model = GetPluginConfigResponseBody.Data.GatewayConfigList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.gatewayConfigList = tmp
            }
            if dict.keys.contains("GatewayConfigStartIndex") {
                self.gatewayConfigStartIndex = dict["GatewayConfigStartIndex"] as! Int32
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ImageName") {
                self.imageName = dict["ImageName"] as! String
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Phase") {
                self.phase = dict["Phase"] as! Int32
            }
            if dict.keys.contains("PrimaryUser") {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("PublishState") {
                self.publishState = dict["PublishState"] as! Int32
            }
            if dict.keys.contains("Readme") {
                self.readme = dict["Readme"] as! String
            }
            if dict.keys.contains("ReadmeEn") {
                self.readmeEn = dict["ReadmeEn"] as! String
            }
            if dict.keys.contains("RouteConfigStartIndex") {
                self.routeConfigStartIndex = dict["RouteConfigStartIndex"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Summary") {
                self.summary = dict["Summary"] as! String
            }
            if dict.keys.contains("SummaryEn") {
                self.summaryEn = dict["SummaryEn"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("VersionJson") {
                self.versionJson = dict["VersionJson"] as! String
            }
            if dict.keys.contains("WasmLang") {
                self.wasmLang = dict["WasmLang"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: GetPluginConfigResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetPluginConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPluginConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPluginConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPluginConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPluginsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var category: Int32?

    public var enableOnly: Bool?

    public var gatewayUniqueId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.enableOnly != nil {
            map["EnableOnly"] = self.enableOnly!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! Int32
        }
        if dict.keys.contains("EnableOnly") {
            self.enableOnly = dict["EnableOnly"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class GetPluginsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var category: Int32?

        public var configCheck: String?

        public var id: Int64?

        public var maxVersion: String?

        public var mode: Int32?

        public var name: String?

        public var newVersionPublishingFlag: Bool?

        public var phase: Int32?

        public var primaryUser: String?

        public var priority: Int32?

        public var publishState: Int32?

        public var status: String?

        public var summary: String?

        public var summaryEn: String?

        public var version: String?

        public var wasmFile: String?

        public var wasmLang: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.configCheck != nil {
                map["ConfigCheck"] = self.configCheck!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.maxVersion != nil {
                map["MaxVersion"] = self.maxVersion!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.newVersionPublishingFlag != nil {
                map["NewVersionPublishingFlag"] = self.newVersionPublishingFlag!
            }
            if self.phase != nil {
                map["Phase"] = self.phase!
            }
            if self.primaryUser != nil {
                map["PrimaryUser"] = self.primaryUser!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.publishState != nil {
                map["PublishState"] = self.publishState!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.summaryEn != nil {
                map["SummaryEn"] = self.summaryEn!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.wasmFile != nil {
                map["WasmFile"] = self.wasmFile!
            }
            if self.wasmLang != nil {
                map["WasmLang"] = self.wasmLang!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! Int32
            }
            if dict.keys.contains("ConfigCheck") {
                self.configCheck = dict["ConfigCheck"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MaxVersion") {
                self.maxVersion = dict["MaxVersion"] as! String
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NewVersionPublishingFlag") {
                self.newVersionPublishingFlag = dict["NewVersionPublishingFlag"] as! Bool
            }
            if dict.keys.contains("Phase") {
                self.phase = dict["Phase"] as! Int32
            }
            if dict.keys.contains("PrimaryUser") {
                self.primaryUser = dict["PrimaryUser"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("PublishState") {
                self.publishState = dict["PublishState"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Summary") {
                self.summary = dict["Summary"] as! String
            }
            if dict.keys.contains("SummaryEn") {
                self.summaryEn = dict["SummaryEn"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("WasmFile") {
                self.wasmFile = dict["WasmFile"] as! String
            }
            if dict.keys.contains("WasmLang") {
                self.wasmLang = dict["WasmLang"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: [GetPluginsResponseBody.Data]?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [GetPluginsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetPluginsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPluginsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPluginsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPluginsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var ip: String?

    public var region: String?

    public var serviceName: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("ServiceType") {
            self.serviceType = dict["ServiceType"] as! String
        }
    }
}

public class GetServiceListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Methods : Tea.TeaModel {
            public var methodController: String?

            public var name: String?

            public var parameterTypes: [String]?

            public var paths: [String]?

            public var requestMethods: [String]?

            public var returnType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.methodController != nil {
                    map["MethodController"] = self.methodController!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parameterTypes != nil {
                    map["ParameterTypes"] = self.parameterTypes!
                }
                if self.paths != nil {
                    map["Paths"] = self.paths!
                }
                if self.requestMethods != nil {
                    map["RequestMethods"] = self.requestMethods!
                }
                if self.returnType != nil {
                    map["ReturnType"] = self.returnType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MethodController") {
                    self.methodController = dict["MethodController"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ParameterTypes") {
                    self.parameterTypes = dict["ParameterTypes"] as! [String]
                }
                if dict.keys.contains("Paths") {
                    self.paths = dict["Paths"] as! [String]
                }
                if dict.keys.contains("RequestMethods") {
                    self.requestMethods = dict["RequestMethods"] as! [String]
                }
                if dict.keys.contains("ReturnType") {
                    self.returnType = dict["ReturnType"] as! String
                }
            }
        }
        public var dubboApplicationName: String?

        public var edasAppName: String?

        public var group: String?

        public var metadata: [String: Any]?

        public var methods: [GetServiceListResponseBody.Data.Methods]?

        public var registryType: String?

        public var serviceName: String?

        public var serviceType: String?

        public var springApplicationName: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dubboApplicationName != nil {
                map["DubboApplicationName"] = self.dubboApplicationName!
            }
            if self.edasAppName != nil {
                map["EdasAppName"] = self.edasAppName!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.methods != nil {
                var tmp : [Any] = []
                for k in self.methods! {
                    tmp.append(k.toMap())
                }
                map["Methods"] = tmp
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.springApplicationName != nil {
                map["SpringApplicationName"] = self.springApplicationName!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DubboApplicationName") {
                self.dubboApplicationName = dict["DubboApplicationName"] as! String
            }
            if dict.keys.contains("EdasAppName") {
                self.edasAppName = dict["EdasAppName"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Metadata") {
                self.metadata = dict["Metadata"] as! [String: Any]
            }
            if dict.keys.contains("Methods") {
                var tmp : [GetServiceListResponseBody.Data.Methods] = []
                for v in dict["Methods"] as! [Any] {
                    var model = GetServiceListResponseBody.Data.Methods()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.methods = tmp
            }
            if dict.keys.contains("RegistryType") {
                self.registryType = dict["RegistryType"] as! String
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("ServiceType") {
                self.serviceType = dict["ServiceType"] as! String
            }
            if dict.keys.contains("SpringApplicationName") {
                self.springApplicationName = dict["SpringApplicationName"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [GetServiceListResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [GetServiceListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetServiceListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetServiceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetServiceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceListPageRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var ip: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var serviceName: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("ServiceType") {
            self.serviceType = dict["ServiceType"] as! String
        }
    }
}

public class GetServiceListPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var gmtModifyTime: String?

            public var group: String?

            public var instanceNum: Int32?

            public var serviceName: String?

            public var serviceType: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.gmtModifyTime != nil {
                    map["GmtModifyTime"] = self.gmtModifyTime!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                if self.instanceNum != nil {
                    map["InstanceNum"] = self.instanceNum!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.serviceType != nil {
                    map["ServiceType"] = self.serviceType!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("GmtModifyTime") {
                    self.gmtModifyTime = dict["GmtModifyTime"] as! String
                }
                if dict.keys.contains("Group") {
                    self.group = dict["Group"] as! String
                }
                if dict.keys.contains("InstanceNum") {
                    self.instanceNum = dict["InstanceNum"] as! Int32
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("ServiceType") {
                    self.serviceType = dict["ServiceType"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var pageNumber: String?

        public var pageSize: String?

        public var result: [GetServiceListPageResponseBody.Data.Result]?

        public var totalSize: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! String
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("Result") {
                var tmp : [GetServiceListPageResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = GetServiceListPageResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! String
            }
        }
    }
    public var data: GetServiceListPageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetServiceListPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetServiceListPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceListPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetServiceListPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceListenersRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var groupName: String?

    public var hasIpCount: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.hasIpCount != nil {
            map["HasIpCount"] = self.hasIpCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("HasIpCount") {
            self.hasIpCount = dict["HasIpCount"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class GetServiceListenersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var addr: String?

        public var agent: String?

        public var app: String?

        public var cluster: String?

        public var IP: String?

        public var namespaceId: String?

        public var port: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                map["Addr"] = self.addr!
            }
            if self.agent != nil {
                map["Agent"] = self.agent!
            }
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.cluster != nil {
                map["Cluster"] = self.cluster!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Addr") {
                self.addr = dict["Addr"] as! String
            }
            if dict.keys.contains("Agent") {
                self.agent = dict["Agent"] as! String
            }
            if dict.keys.contains("App") {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("Cluster") {
                self.cluster = dict["Cluster"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
        }
    }
    public var data: [GetServiceListenersResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [GetServiceListenersResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetServiceListenersResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class GetServiceListenersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceListenersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetServiceListenersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceMethodPageRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var ip: String?

    public var methodController: String?

    public var name: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var path: String?

    public var region: String?

    public var serviceGroup: String?

    public var serviceName: String?

    public var serviceType: String?

    public var serviceVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.methodController != nil {
            map["MethodController"] = self.methodController!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.serviceGroup != nil {
            map["ServiceGroup"] = self.serviceGroup!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        if self.serviceVersion != nil {
            map["ServiceVersion"] = self.serviceVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("MethodController") {
            self.methodController = dict["MethodController"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("ServiceGroup") {
            self.serviceGroup = dict["ServiceGroup"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("ServiceType") {
            self.serviceType = dict["ServiceType"] as! String
        }
        if dict.keys.contains("ServiceVersion") {
            self.serviceVersion = dict["ServiceVersion"] as! String
        }
    }
}

public class GetServiceMethodPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class ParameterDefinitions : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var methodController: String?

            public var name: String?

            public var nameDetail: String?

            public var parameterDefinitions: [GetServiceMethodPageResponseBody.Data.Result.ParameterDefinitions]?

            public var parameterDetails: [String]?

            public var parameterTypes: [String]?

            public var paths: [String]?

            public var requestMethods: [String]?

            public var returnDetails: String?

            public var returnType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.methodController != nil {
                    map["MethodController"] = self.methodController!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameDetail != nil {
                    map["NameDetail"] = self.nameDetail!
                }
                if self.parameterDefinitions != nil {
                    var tmp : [Any] = []
                    for k in self.parameterDefinitions! {
                        tmp.append(k.toMap())
                    }
                    map["ParameterDefinitions"] = tmp
                }
                if self.parameterDetails != nil {
                    map["ParameterDetails"] = self.parameterDetails!
                }
                if self.parameterTypes != nil {
                    map["ParameterTypes"] = self.parameterTypes!
                }
                if self.paths != nil {
                    map["Paths"] = self.paths!
                }
                if self.requestMethods != nil {
                    map["RequestMethods"] = self.requestMethods!
                }
                if self.returnDetails != nil {
                    map["ReturnDetails"] = self.returnDetails!
                }
                if self.returnType != nil {
                    map["ReturnType"] = self.returnType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MethodController") {
                    self.methodController = dict["MethodController"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NameDetail") {
                    self.nameDetail = dict["NameDetail"] as! String
                }
                if dict.keys.contains("ParameterDefinitions") {
                    var tmp : [GetServiceMethodPageResponseBody.Data.Result.ParameterDefinitions] = []
                    for v in dict["ParameterDefinitions"] as! [Any] {
                        var model = GetServiceMethodPageResponseBody.Data.Result.ParameterDefinitions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.parameterDefinitions = tmp
                }
                if dict.keys.contains("ParameterDetails") {
                    self.parameterDetails = dict["ParameterDetails"] as! [String]
                }
                if dict.keys.contains("ParameterTypes") {
                    self.parameterTypes = dict["ParameterTypes"] as! [String]
                }
                if dict.keys.contains("Paths") {
                    self.paths = dict["Paths"] as! [String]
                }
                if dict.keys.contains("RequestMethods") {
                    self.requestMethods = dict["RequestMethods"] as! [String]
                }
                if dict.keys.contains("ReturnDetails") {
                    self.returnDetails = dict["ReturnDetails"] as! String
                }
                if dict.keys.contains("ReturnType") {
                    self.returnType = dict["ReturnType"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [GetServiceMethodPageResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [GetServiceMethodPageResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = GetServiceMethodPageResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: GetServiceMethodPageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetServiceMethodPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetServiceMethodPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceMethodPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetServiceMethodPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTagsBySwimmingLaneGroupIdRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class GetTagsBySwimmingLaneGroupIdResponseBody : Tea.TeaModel {
    public var data: [String]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetTagsBySwimmingLaneGroupIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTagsBySwimmingLaneGroupIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTagsBySwimmingLaneGroupIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetZookeeperDataImportUrlRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var contentType: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ContentType") {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetZookeeperDataImportUrlResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var maxSize: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxSize != nil {
                map["MaxSize"] = self.maxSize!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MaxSize") {
                self.maxSize = dict["MaxSize"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: GetZookeeperDataImportUrlResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GetZookeeperDataImportUrlResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetZookeeperDataImportUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetZookeeperDataImportUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetZookeeperDataImportUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var fileUrl: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var policy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("FileUrl") {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
    }
}

public class ImportNacosConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FailData : Tea.TeaModel {
            public var dataId: String?

            public var group: String?

            public var reason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataId != nil {
                    map["DataId"] = self.dataId!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataId") {
                    self.dataId = dict["DataId"] as! String
                }
                if dict.keys.contains("Group") {
                    self.group = dict["Group"] as! String
                }
                if dict.keys.contains("Reason") {
                    self.reason = dict["Reason"] as! String
                }
            }
        }
        public class SkipData : Tea.TeaModel {
            public var dataId: String?

            public var group: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataId != nil {
                    map["DataId"] = self.dataId!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataId") {
                    self.dataId = dict["DataId"] as! String
                }
                if dict.keys.contains("Group") {
                    self.group = dict["Group"] as! String
                }
            }
        }
        public var failData: [ImportNacosConfigResponseBody.Data.FailData]?

        public var skipCount: Int32?

        public var skipData: [ImportNacosConfigResponseBody.Data.SkipData]?

        public var succCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failData != nil {
                var tmp : [Any] = []
                for k in self.failData! {
                    tmp.append(k.toMap())
                }
                map["FailData"] = tmp
            }
            if self.skipCount != nil {
                map["SkipCount"] = self.skipCount!
            }
            if self.skipData != nil {
                var tmp : [Any] = []
                for k in self.skipData! {
                    tmp.append(k.toMap())
                }
                map["SkipData"] = tmp
            }
            if self.succCount != nil {
                map["SuccCount"] = self.succCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailData") {
                var tmp : [ImportNacosConfigResponseBody.Data.FailData] = []
                for v in dict["FailData"] as! [Any] {
                    var model = ImportNacosConfigResponseBody.Data.FailData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.failData = tmp
            }
            if dict.keys.contains("SkipCount") {
                self.skipCount = dict["SkipCount"] as! Int32
            }
            if dict.keys.contains("SkipData") {
                var tmp : [ImportNacosConfigResponseBody.Data.SkipData] = []
                for v in dict["SkipData"] as! [Any] {
                    var model = ImportNacosConfigResponseBody.Data.SkipData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.skipData = tmp
            }
            if dict.keys.contains("SuccCount") {
                self.succCount = dict["SuccCount"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: ImportNacosConfigResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ImportNacosConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ImportNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportServicesRequest : Tea.TeaModel {
    public class ServiceList : Tea.TeaModel {
        public var dnsServerList: [String]?

        public var groupName: String?

        public var ips: [String]?

        public var name: String?

        public var namespace: String?

        public var servicePort: Int64?

        public var serviceProtocol: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServerList != nil {
                map["DnsServerList"] = self.dnsServerList!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServerList") {
                self.dnsServerList = dict["DnsServerList"] as! [String]
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Ips") {
                self.ips = dict["Ips"] as! [String]
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ServicePort") {
                self.servicePort = dict["ServicePort"] as! Int64
            }
            if dict.keys.contains("ServiceProtocol") {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var fcAlias: String?

    public var fcServiceName: String?

    public var fcVersion: String?

    public var gatewayUniqueId: String?

    public var serviceList: [ImportServicesRequest.ServiceList]?

    public var sourceId: Int64?

    public var sourceType: String?

    public var tlsSetting: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.fcAlias != nil {
            map["FcAlias"] = self.fcAlias!
        }
        if self.fcServiceName != nil {
            map["FcServiceName"] = self.fcServiceName!
        }
        if self.fcVersion != nil {
            map["FcVersion"] = self.fcVersion!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceList != nil {
            var tmp : [Any] = []
            for k in self.serviceList! {
                tmp.append(k.toMap())
            }
            map["ServiceList"] = tmp
        }
        if self.sourceId != nil {
            map["SourceId"] = self.sourceId!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.tlsSetting != nil {
            map["TlsSetting"] = self.tlsSetting!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("FcAlias") {
            self.fcAlias = dict["FcAlias"] as! String
        }
        if dict.keys.contains("FcServiceName") {
            self.fcServiceName = dict["FcServiceName"] as! String
        }
        if dict.keys.contains("FcVersion") {
            self.fcVersion = dict["FcVersion"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceList") {
            var tmp : [ImportServicesRequest.ServiceList] = []
            for v in dict["ServiceList"] as! [Any] {
                var model = ImportServicesRequest.ServiceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceList = tmp
        }
        if dict.keys.contains("SourceId") {
            self.sourceId = dict["SourceId"] as! Int64
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("TlsSetting") {
            self.tlsSetting = dict["TlsSetting"] as! String
        }
    }
}

public class ImportServicesShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var fcAlias: String?

    public var fcServiceName: String?

    public var fcVersion: String?

    public var gatewayUniqueId: String?

    public var serviceListShrink: String?

    public var sourceId: Int64?

    public var sourceType: String?

    public var tlsSetting: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.fcAlias != nil {
            map["FcAlias"] = self.fcAlias!
        }
        if self.fcServiceName != nil {
            map["FcServiceName"] = self.fcServiceName!
        }
        if self.fcVersion != nil {
            map["FcVersion"] = self.fcVersion!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceListShrink != nil {
            map["ServiceList"] = self.serviceListShrink!
        }
        if self.sourceId != nil {
            map["SourceId"] = self.sourceId!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.tlsSetting != nil {
            map["TlsSetting"] = self.tlsSetting!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("FcAlias") {
            self.fcAlias = dict["FcAlias"] as! String
        }
        if dict.keys.contains("FcServiceName") {
            self.fcServiceName = dict["FcServiceName"] as! String
        }
        if dict.keys.contains("FcVersion") {
            self.fcVersion = dict["FcVersion"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceList") {
            self.serviceListShrink = dict["ServiceList"] as! String
        }
        if dict.keys.contains("SourceId") {
            self.sourceId = dict["SourceId"] as! Int64
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("TlsSetting") {
            self.tlsSetting = dict["TlsSetting"] as! String
        }
    }
}

public class ImportServicesResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ImportServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportZookeeperDataRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var fileName: String?

    public var fileUrl: String?

    public var instanceId: String?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileUrl") {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ImportZookeeperDataResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ImportZookeeperDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportZookeeperDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportZookeeperDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InitializeServiceLinkRoleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var roleName: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.roleName != nil {
            map["RoleName"] = self.roleName!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("RoleName") {
            self.roleName = dict["RoleName"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class InitializeServiceLinkRoleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var requiredPermission: String?

        public var roleName: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.requiredPermission != nil {
                map["RequiredPermission"] = self.requiredPermission!
            }
            if self.roleName != nil {
                map["RoleName"] = self.roleName!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RequiredPermission") {
                self.requiredPermission = dict["RequiredPermission"] as! String
            }
            if dict.keys.contains("RoleName") {
                self.roleName = dict["RoleName"] as! String
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
        }
    }
    public var code: String?

    public var data: InitializeServiceLinkRoleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = InitializeServiceLinkRoleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InitializeServiceLinkRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitializeServiceLinkRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InitializeServiceLinkRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAnsInstancesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var groupName: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestPars: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListAnsInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var app: String?

        public var clusterName: String?

        public var datumKey: String?

        public var defaultKey: String?

        public var enabled: Bool?

        public var ephemeral: Bool?

        public var failCount: Int32?

        public var healthy: Bool?

        public var instanceHeartBeatInterval: Int32?

        public var instanceHeartBeatTimeOut: Int32?

        public var instanceId: String?

        public var ip: String?

        public var ipDeleteTimeout: Int32?

        public var lastBeat: Int64?

        public var marked: Bool?

        public var metadata: [String: Any]?

        public var okCount: Int32?

        public var port: Int32?

        public var serviceName: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.datumKey != nil {
                map["DatumKey"] = self.datumKey!
            }
            if self.defaultKey != nil {
                map["DefaultKey"] = self.defaultKey!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.ephemeral != nil {
                map["Ephemeral"] = self.ephemeral!
            }
            if self.failCount != nil {
                map["FailCount"] = self.failCount!
            }
            if self.healthy != nil {
                map["Healthy"] = self.healthy!
            }
            if self.instanceHeartBeatInterval != nil {
                map["InstanceHeartBeatInterval"] = self.instanceHeartBeatInterval!
            }
            if self.instanceHeartBeatTimeOut != nil {
                map["InstanceHeartBeatTimeOut"] = self.instanceHeartBeatTimeOut!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.ipDeleteTimeout != nil {
                map["IpDeleteTimeout"] = self.ipDeleteTimeout!
            }
            if self.lastBeat != nil {
                map["LastBeat"] = self.lastBeat!
            }
            if self.marked != nil {
                map["Marked"] = self.marked!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.okCount != nil {
                map["OkCount"] = self.okCount!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("App") {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("DatumKey") {
                self.datumKey = dict["DatumKey"] as! String
            }
            if dict.keys.contains("DefaultKey") {
                self.defaultKey = dict["DefaultKey"] as! String
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("Ephemeral") {
                self.ephemeral = dict["Ephemeral"] as! Bool
            }
            if dict.keys.contains("FailCount") {
                self.failCount = dict["FailCount"] as! Int32
            }
            if dict.keys.contains("Healthy") {
                self.healthy = dict["Healthy"] as! Bool
            }
            if dict.keys.contains("InstanceHeartBeatInterval") {
                self.instanceHeartBeatInterval = dict["InstanceHeartBeatInterval"] as! Int32
            }
            if dict.keys.contains("InstanceHeartBeatTimeOut") {
                self.instanceHeartBeatTimeOut = dict["InstanceHeartBeatTimeOut"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("IpDeleteTimeout") {
                self.ipDeleteTimeout = dict["IpDeleteTimeout"] as! Int32
            }
            if dict.keys.contains("LastBeat") {
                self.lastBeat = dict["LastBeat"] as! Int64
            }
            if dict.keys.contains("Marked") {
                self.marked = dict["Marked"] as! Bool
            }
            if dict.keys.contains("Metadata") {
                self.metadata = dict["Metadata"] as! [String: Any]
            }
            if dict.keys.contains("OkCount") {
                self.okCount = dict["OkCount"] as! Int32
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var data: [ListAnsInstancesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListAnsInstancesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAnsInstancesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListAnsInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAnsInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAnsInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAnsServiceClustersRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var groupName: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListAnsServiceClustersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AppDetail : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var checkInternal: Int32?

            public var checkPath: String?

            public var checkTimeout: Int32?

            public var checkType: String?

            public var healthyCheckTimes: Int32?

            public var port: Int32?

            public var unhealthyCheckTimes: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.checkInternal != nil {
                    map["CheckInternal"] = self.checkInternal!
                }
                if self.checkPath != nil {
                    map["CheckPath"] = self.checkPath!
                }
                if self.checkTimeout != nil {
                    map["CheckTimeout"] = self.checkTimeout!
                }
                if self.checkType != nil {
                    map["CheckType"] = self.checkType!
                }
                if self.healthyCheckTimes != nil {
                    map["HealthyCheckTimes"] = self.healthyCheckTimes!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.unhealthyCheckTimes != nil {
                    map["UnhealthyCheckTimes"] = self.unhealthyCheckTimes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CheckInternal") {
                    self.checkInternal = dict["CheckInternal"] as! Int32
                }
                if dict.keys.contains("CheckPath") {
                    self.checkPath = dict["CheckPath"] as! String
                }
                if dict.keys.contains("CheckTimeout") {
                    self.checkTimeout = dict["CheckTimeout"] as! Int32
                }
                if dict.keys.contains("CheckType") {
                    self.checkType = dict["CheckType"] as! String
                }
                if dict.keys.contains("HealthyCheckTimes") {
                    self.healthyCheckTimes = dict["HealthyCheckTimes"] as! Int32
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("UnhealthyCheckTimes") {
                    self.unhealthyCheckTimes = dict["UnhealthyCheckTimes"] as! Int32
                }
            }
        }
        public class Clusters : Tea.TeaModel {
            public var defaultCheckPort: Int32?

            public var defaultPort: Int32?

            public var healthCheckerType: String?

            public var metadata: [String: Any]?

            public var name: String?

            public var serviceName: String?

            public var useIPPort4Check: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.defaultCheckPort != nil {
                    map["DefaultCheckPort"] = self.defaultCheckPort!
                }
                if self.defaultPort != nil {
                    map["DefaultPort"] = self.defaultPort!
                }
                if self.healthCheckerType != nil {
                    map["HealthCheckerType"] = self.healthCheckerType!
                }
                if self.metadata != nil {
                    map["Metadata"] = self.metadata!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.useIPPort4Check != nil {
                    map["UseIPPort4Check"] = self.useIPPort4Check!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DefaultCheckPort") {
                    self.defaultCheckPort = dict["DefaultCheckPort"] as! Int32
                }
                if dict.keys.contains("DefaultPort") {
                    self.defaultPort = dict["DefaultPort"] as! Int32
                }
                if dict.keys.contains("HealthCheckerType") {
                    self.healthCheckerType = dict["HealthCheckerType"] as! String
                }
                if dict.keys.contains("Metadata") {
                    self.metadata = dict["Metadata"] as! [String: Any]
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("UseIPPort4Check") {
                    self.useIPPort4Check = dict["UseIPPort4Check"] as! Bool
                }
            }
        }
        public var appDetail: ListAnsServiceClustersResponseBody.Data.AppDetail?

        public var clusters: [ListAnsServiceClustersResponseBody.Data.Clusters]?

        public var ephemeral: Bool?

        public var groupName: String?

        public var metadata: [String: Any]?

        public var name: String?

        public var protectThreshold: Double?

        public var selectorType: String?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.appDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appDetail != nil {
                map["AppDetail"] = self.appDetail?.toMap()
            }
            if self.clusters != nil {
                var tmp : [Any] = []
                for k in self.clusters! {
                    tmp.append(k.toMap())
                }
                map["Clusters"] = tmp
            }
            if self.ephemeral != nil {
                map["Ephemeral"] = self.ephemeral!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protectThreshold != nil {
                map["ProtectThreshold"] = self.protectThreshold!
            }
            if self.selectorType != nil {
                map["SelectorType"] = self.selectorType!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppDetail") {
                var model = ListAnsServiceClustersResponseBody.Data.AppDetail()
                model.fromMap(dict["AppDetail"] as! [String: Any])
                self.appDetail = model
            }
            if dict.keys.contains("Clusters") {
                var tmp : [ListAnsServiceClustersResponseBody.Data.Clusters] = []
                for v in dict["Clusters"] as! [Any] {
                    var model = ListAnsServiceClustersResponseBody.Data.Clusters()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clusters = tmp
            }
            if dict.keys.contains("Ephemeral") {
                self.ephemeral = dict["Ephemeral"] as! Bool
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Metadata") {
                self.metadata = dict["Metadata"] as! [String: Any]
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProtectThreshold") {
                self.protectThreshold = dict["ProtectThreshold"] as! Double
            }
            if dict.keys.contains("SelectorType") {
                self.selectorType = dict["SelectorType"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
        }
    }
    public var data: ListAnsServiceClustersResponseBody.Data?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListAnsServiceClustersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAnsServiceClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAnsServiceClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAnsServiceClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAnsServicesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var groupName: String?

    public var hasIpCount: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.hasIpCount != nil {
            map["HasIpCount"] = self.hasIpCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("HasIpCount") {
            self.hasIpCount = dict["HasIpCount"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListAnsServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterCount: Int32?

        public var groupName: String?

        public var healthyInstanceCount: Int32?

        public var ipCount: Int32?

        public var name: String?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterCount != nil {
                map["ClusterCount"] = self.clusterCount!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.healthyInstanceCount != nil {
                map["HealthyInstanceCount"] = self.healthyInstanceCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterCount") {
                self.clusterCount = dict["ClusterCount"] as! Int32
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("HealthyInstanceCount") {
                self.healthyInstanceCount = dict["HealthyInstanceCount"] as! Int32
            }
            if dict.keys.contains("IpCount") {
                self.ipCount = dict["IpCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
        }
    }
    public var data: [ListAnsServicesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListAnsServicesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAnsServicesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListAnsServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAnsServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAnsServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAppBySwimmingLaneGroupTagRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var namespace: String?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class ListAppBySwimmingLaneGroupTagResponseBody : Tea.TeaModel {
    public var data: Any?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAppBySwimmingLaneGroupTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppBySwimmingLaneGroupTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAppBySwimmingLaneGroupTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAppBySwimmingLaneGroupTagsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var namespace: String?

    public var tags: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! [String]
        }
    }
}

public class ListAppBySwimmingLaneGroupTagsShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var namespace: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class ListAppBySwimmingLaneGroupTagsResponseBody : Tea.TeaModel {
    public var data: [String: [DataValue]]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.data! {
                var l1 : [Any] = []
                for k1 in v {
                    l1.append(k1.toMap())
                }
                tmp[k] = l1
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [String: [DataValue]] = [:]
            for (k, v) in dict["Data"] as! [String: Any] {
                var l1 : [DataValue] = []
                for v1 in v as! [Any] {
                    var model = DataValue()
                    if v1 != nil {
                        model.fromMap(v1 as! [String: Any])
                    }
                    l1.append(model)
                }
                tmp[k] = l1
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAppBySwimmingLaneGroupTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppBySwimmingLaneGroupTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAppBySwimmingLaneGroupTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationsWithTagRulesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
    }
}

public class ListApplicationsWithTagRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class RouteRules : Tea.TeaModel {
                public class Rules : Tea.TeaModel {
                    public class Dubbo : Tea.TeaModel {
                        public class ArgumentItems : Tea.TeaModel {
                            public var cond: String?

                            public var datum: String?

                            public var divisor: Int32?

                            public var expr: String?

                            public var index: Int32?

                            public var nameList: [String]?

                            public var operator_: String?

                            public var rate: Int32?

                            public var remainder: Int32?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.cond != nil {
                                    map["cond"] = self.cond!
                                }
                                if self.datum != nil {
                                    map["datum"] = self.datum!
                                }
                                if self.divisor != nil {
                                    map["divisor"] = self.divisor!
                                }
                                if self.expr != nil {
                                    map["expr"] = self.expr!
                                }
                                if self.index != nil {
                                    map["index"] = self.index!
                                }
                                if self.nameList != nil {
                                    map["nameList"] = self.nameList!
                                }
                                if self.operator_ != nil {
                                    map["operator"] = self.operator_!
                                }
                                if self.rate != nil {
                                    map["rate"] = self.rate!
                                }
                                if self.remainder != nil {
                                    map["remainder"] = self.remainder!
                                }
                                if self.value != nil {
                                    map["value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("cond") {
                                    self.cond = dict["cond"] as! String
                                }
                                if dict.keys.contains("datum") {
                                    self.datum = dict["datum"] as! String
                                }
                                if dict.keys.contains("divisor") {
                                    self.divisor = dict["divisor"] as! Int32
                                }
                                if dict.keys.contains("expr") {
                                    self.expr = dict["expr"] as! String
                                }
                                if dict.keys.contains("index") {
                                    self.index = dict["index"] as! Int32
                                }
                                if dict.keys.contains("nameList") {
                                    self.nameList = dict["nameList"] as! [String]
                                }
                                if dict.keys.contains("operator") {
                                    self.operator_ = dict["operator"] as! String
                                }
                                if dict.keys.contains("rate") {
                                    self.rate = dict["rate"] as! Int32
                                }
                                if dict.keys.contains("remainder") {
                                    self.remainder = dict["remainder"] as! Int32
                                }
                                if dict.keys.contains("value") {
                                    self.value = dict["value"] as! String
                                }
                            }
                        }
                        public var appId: String?

                        public var argumentItems: [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Dubbo.ArgumentItems]?

                        public var condition: String?

                        public var group: String?

                        public var methodName: String?

                        public var paramTypes: [String]?

                        public var serviceName: String?

                        public var tags: [String]?

                        public var triggerPolicy: String?

                        public var version: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.appId != nil {
                                map["appId"] = self.appId!
                            }
                            if self.argumentItems != nil {
                                var tmp : [Any] = []
                                for k in self.argumentItems! {
                                    tmp.append(k.toMap())
                                }
                                map["argumentItems"] = tmp
                            }
                            if self.condition != nil {
                                map["condition"] = self.condition!
                            }
                            if self.group != nil {
                                map["group"] = self.group!
                            }
                            if self.methodName != nil {
                                map["methodName"] = self.methodName!
                            }
                            if self.paramTypes != nil {
                                map["paramTypes"] = self.paramTypes!
                            }
                            if self.serviceName != nil {
                                map["serviceName"] = self.serviceName!
                            }
                            if self.tags != nil {
                                map["tags"] = self.tags!
                            }
                            if self.triggerPolicy != nil {
                                map["triggerPolicy"] = self.triggerPolicy!
                            }
                            if self.version != nil {
                                map["version"] = self.version!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("appId") {
                                self.appId = dict["appId"] as! String
                            }
                            if dict.keys.contains("argumentItems") {
                                var tmp : [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Dubbo.ArgumentItems] = []
                                for v in dict["argumentItems"] as! [Any] {
                                    var model = ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Dubbo.ArgumentItems()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.argumentItems = tmp
                            }
                            if dict.keys.contains("condition") {
                                self.condition = dict["condition"] as! String
                            }
                            if dict.keys.contains("group") {
                                self.group = dict["group"] as! String
                            }
                            if dict.keys.contains("methodName") {
                                self.methodName = dict["methodName"] as! String
                            }
                            if dict.keys.contains("paramTypes") {
                                self.paramTypes = dict["paramTypes"] as! [String]
                            }
                            if dict.keys.contains("serviceName") {
                                self.serviceName = dict["serviceName"] as! String
                            }
                            if dict.keys.contains("tags") {
                                self.tags = dict["tags"] as! [String]
                            }
                            if dict.keys.contains("triggerPolicy") {
                                self.triggerPolicy = dict["triggerPolicy"] as! String
                            }
                            if dict.keys.contains("version") {
                                self.version = dict["version"] as! String
                            }
                        }
                    }
                    public class Springcloud : Tea.TeaModel {
                        public class RestItems : Tea.TeaModel {
                            public var cond: String?

                            public var datum: String?

                            public var divisor: Int32?

                            public var name: String?

                            public var nameList: [String]?

                            public var operator_: String?

                            public var rate: Int32?

                            public var remainder: Int32?

                            public var type: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.cond != nil {
                                    map["cond"] = self.cond!
                                }
                                if self.datum != nil {
                                    map["datum"] = self.datum!
                                }
                                if self.divisor != nil {
                                    map["divisor"] = self.divisor!
                                }
                                if self.name != nil {
                                    map["name"] = self.name!
                                }
                                if self.nameList != nil {
                                    map["nameList"] = self.nameList!
                                }
                                if self.operator_ != nil {
                                    map["operator"] = self.operator_!
                                }
                                if self.rate != nil {
                                    map["rate"] = self.rate!
                                }
                                if self.remainder != nil {
                                    map["remainder"] = self.remainder!
                                }
                                if self.type != nil {
                                    map["type"] = self.type!
                                }
                                if self.value != nil {
                                    map["value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("cond") {
                                    self.cond = dict["cond"] as! String
                                }
                                if dict.keys.contains("datum") {
                                    self.datum = dict["datum"] as! String
                                }
                                if dict.keys.contains("divisor") {
                                    self.divisor = dict["divisor"] as! Int32
                                }
                                if dict.keys.contains("name") {
                                    self.name = dict["name"] as! String
                                }
                                if dict.keys.contains("nameList") {
                                    self.nameList = dict["nameList"] as! [String]
                                }
                                if dict.keys.contains("operator") {
                                    self.operator_ = dict["operator"] as! String
                                }
                                if dict.keys.contains("rate") {
                                    self.rate = dict["rate"] as! Int32
                                }
                                if dict.keys.contains("remainder") {
                                    self.remainder = dict["remainder"] as! Int32
                                }
                                if dict.keys.contains("type") {
                                    self.type = dict["type"] as! String
                                }
                                if dict.keys.contains("value") {
                                    self.value = dict["value"] as! String
                                }
                            }
                        }
                        public var appId: String?

                        public var condition: String?

                        public var enable: Bool?

                        public var path: String?

                        public var paths: [String]?

                        public var priority: Int32?

                        public var restItems: [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Springcloud.RestItems]?

                        public var tags: [String]?

                        public var triggerPolicy: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.appId != nil {
                                map["appId"] = self.appId!
                            }
                            if self.condition != nil {
                                map["condition"] = self.condition!
                            }
                            if self.enable != nil {
                                map["enable"] = self.enable!
                            }
                            if self.path != nil {
                                map["path"] = self.path!
                            }
                            if self.paths != nil {
                                map["paths"] = self.paths!
                            }
                            if self.priority != nil {
                                map["priority"] = self.priority!
                            }
                            if self.restItems != nil {
                                var tmp : [Any] = []
                                for k in self.restItems! {
                                    tmp.append(k.toMap())
                                }
                                map["restItems"] = tmp
                            }
                            if self.tags != nil {
                                map["tags"] = self.tags!
                            }
                            if self.triggerPolicy != nil {
                                map["triggerPolicy"] = self.triggerPolicy!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("appId") {
                                self.appId = dict["appId"] as! String
                            }
                            if dict.keys.contains("condition") {
                                self.condition = dict["condition"] as! String
                            }
                            if dict.keys.contains("enable") {
                                self.enable = dict["enable"] as! Bool
                            }
                            if dict.keys.contains("path") {
                                self.path = dict["path"] as! String
                            }
                            if dict.keys.contains("paths") {
                                self.paths = dict["paths"] as! [String]
                            }
                            if dict.keys.contains("priority") {
                                self.priority = dict["priority"] as! Int32
                            }
                            if dict.keys.contains("restItems") {
                                var tmp : [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Springcloud.RestItems] = []
                                for v in dict["restItems"] as! [Any] {
                                    var model = ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Springcloud.RestItems()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.restItems = tmp
                            }
                            if dict.keys.contains("tags") {
                                self.tags = dict["tags"] as! [String]
                            }
                            if dict.keys.contains("triggerPolicy") {
                                self.triggerPolicy = dict["triggerPolicy"] as! String
                            }
                        }
                    }
                    public var dubbo: [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Dubbo]?

                    public var springcloud: [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Springcloud]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dubbo != nil {
                            var tmp : [Any] = []
                            for k in self.dubbo! {
                                tmp.append(k.toMap())
                            }
                            map["dubbo"] = tmp
                        }
                        if self.springcloud != nil {
                            var tmp : [Any] = []
                            for k in self.springcloud! {
                                tmp.append(k.toMap())
                            }
                            map["springcloud"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("dubbo") {
                            var tmp : [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Dubbo] = []
                            for v in dict["dubbo"] as! [Any] {
                                var model = ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Dubbo()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.dubbo = tmp
                        }
                        if dict.keys.contains("springcloud") {
                            var tmp : [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Springcloud] = []
                            for v in dict["springcloud"] as! [Any] {
                                var model = ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules.Springcloud()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.springcloud = tmp
                        }
                    }
                }
                public var enable: Bool?

                public var id: Int64?

                public var instanceNum: Int32?

                public var name: String?

                public var rate: Int32?

                public var rules: ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules?

                public var status: Int32?

                public var tag: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.rules?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enable != nil {
                        map["Enable"] = self.enable!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.instanceNum != nil {
                        map["InstanceNum"] = self.instanceNum!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.rules != nil {
                        map["Rules"] = self.rules?.toMap()
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.tag != nil {
                        map["Tag"] = self.tag!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Enable") {
                        self.enable = dict["Enable"] as! Bool
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("InstanceNum") {
                        self.instanceNum = dict["InstanceNum"] as! Int32
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! Int32
                    }
                    if dict.keys.contains("Rules") {
                        var model = ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules.Rules()
                        model.fromMap(dict["Rules"] as! [String: Any])
                        self.rules = model
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! Int32
                    }
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! String
                    }
                }
            }
            public var appId: String?

            public var appName: String?

            public var namespace: String?

            public var routeRules: [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules]?

            public var routeStatus: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.routeRules != nil {
                    var tmp : [Any] = []
                    for k in self.routeRules! {
                        tmp.append(k.toMap())
                    }
                    map["RouteRules"] = tmp
                }
                if self.routeStatus != nil {
                    map["RouteStatus"] = self.routeStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RouteRules") {
                    var tmp : [ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules] = []
                    for v in dict["RouteRules"] as! [Any] {
                        var model = ListApplicationsWithTagRulesResponseBody.Data.Result.RouteRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.routeRules = tmp
                }
                if dict.keys.contains("RouteStatus") {
                    self.routeStatus = dict["RouteStatus"] as! Int64
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListApplicationsWithTagRulesResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListApplicationsWithTagRulesResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListApplicationsWithTagRulesResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: ListApplicationsWithTagRulesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListApplicationsWithTagRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListApplicationsWithTagRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsWithTagRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListApplicationsWithTagRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAuthPolicyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var name: String?

    public var namespace: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var protocol_: String?

    public var region: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
    }
}

public class ListAuthPolicyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class AuthRule : Tea.TeaModel {
                public class Method : Tea.TeaModel {
                    public var group: String?

                    public var name: String?

                    public var parameterTypes: [String]?

                    public var returnType: String?

                    public var serviceName: String?

                    public var version: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.group != nil {
                            map["Group"] = self.group!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.parameterTypes != nil {
                            map["ParameterTypes"] = self.parameterTypes!
                        }
                        if self.returnType != nil {
                            map["ReturnType"] = self.returnType!
                        }
                        if self.serviceName != nil {
                            map["ServiceName"] = self.serviceName!
                        }
                        if self.version != nil {
                            map["Version"] = self.version!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Group") {
                            self.group = dict["Group"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("ParameterTypes") {
                            self.parameterTypes = dict["ParameterTypes"] as! [String]
                        }
                        if dict.keys.contains("ReturnType") {
                            self.returnType = dict["ReturnType"] as! String
                        }
                        if dict.keys.contains("ServiceName") {
                            self.serviceName = dict["ServiceName"] as! String
                        }
                        if dict.keys.contains("Version") {
                            self.version = dict["Version"] as! String
                        }
                    }
                }
                public var appIds: [String]?

                public var authType: Int32?

                public var black: Bool?

                public var k8sNamespaces: [String]?

                public var method: ListAuthPolicyResponseBody.Data.Result.AuthRule.Method?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.method?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appIds != nil {
                        map["AppIds"] = self.appIds!
                    }
                    if self.authType != nil {
                        map["AuthType"] = self.authType!
                    }
                    if self.black != nil {
                        map["Black"] = self.black!
                    }
                    if self.k8sNamespaces != nil {
                        map["K8sNamespaces"] = self.k8sNamespaces!
                    }
                    if self.method != nil {
                        map["Method"] = self.method?.toMap()
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppIds") {
                        self.appIds = dict["AppIds"] as! [String]
                    }
                    if dict.keys.contains("AuthType") {
                        self.authType = dict["AuthType"] as! Int32
                    }
                    if dict.keys.contains("Black") {
                        self.black = dict["Black"] as! Bool
                    }
                    if dict.keys.contains("K8sNamespaces") {
                        self.k8sNamespaces = dict["K8sNamespaces"] as! [String]
                    }
                    if dict.keys.contains("Method") {
                        var model = ListAuthPolicyResponseBody.Data.Result.AuthRule.Method()
                        model.fromMap(dict["Method"] as! [String: Any])
                        self.method = model
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                }
            }
            public var accountId: String?

            public var appId: String?

            public var appName: String?

            public var authRule: [ListAuthPolicyResponseBody.Data.Result.AuthRule]?

            public var authType: Int32?

            public var enable: Bool?

            public var id: Int32?

            public var k8sNamespace: String?

            public var name: String?

            public var namespaceId: String?

            public var protocol_: String?

            public var regionId: String?

            public var source: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.authRule != nil {
                    var tmp : [Any] = []
                    for k in self.authRule! {
                        tmp.append(k.toMap())
                    }
                    map["AuthRule"] = tmp
                }
                if self.authType != nil {
                    map["AuthType"] = self.authType!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.k8sNamespace != nil {
                    map["K8sNamespace"] = self.k8sNamespace!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccountId") {
                    self.accountId = dict["AccountId"] as! String
                }
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("AuthRule") {
                    var tmp : [ListAuthPolicyResponseBody.Data.Result.AuthRule] = []
                    for v in dict["AuthRule"] as! [Any] {
                        var model = ListAuthPolicyResponseBody.Data.Result.AuthRule()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.authRule = tmp
                }
                if dict.keys.contains("AuthType") {
                    self.authType = dict["AuthType"] as! Int32
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("K8sNamespace") {
                    self.k8sNamespace = dict["K8sNamespace"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NamespaceId") {
                    self.namespaceId = dict["NamespaceId"] as! String
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListAuthPolicyResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListAuthPolicyResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListAuthPolicyResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: ListAuthPolicyResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListAuthPolicyResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAuthPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAuthPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAuthPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCircuitBreakerRulesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var resource: String?

    public var resourceSearchKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceSearchKey != nil {
            map["ResourceSearchKey"] = self.resourceSearchKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageIndex") {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Resource") {
            self.resource = dict["Resource"] as! String
        }
        if dict.keys.contains("ResourceSearchKey") {
            self.resourceSearchKey = dict["ResourceSearchKey"] as! String
        }
    }
}

public class ListCircuitBreakerRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var enable: Bool?

            public var fallbackObject: String?

            public var halfOpenBaseAmountPerStep: Int32?

            public var halfOpenRecoveryStepNum: Int32?

            public var maxAllowedRtMs: Int32?

            public var minRequestAmount: Int32?

            public var namespace: String?

            public var regionId: String?

            public var resource: String?

            public var resourceType: Int32?

            public var retryTimeoutMs: Int32?

            public var ruleId: Int64?

            public var statIntervalMs: Int32?

            public var strategy: Int32?

            public var threshold: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.fallbackObject != nil {
                    map["FallbackObject"] = self.fallbackObject!
                }
                if self.halfOpenBaseAmountPerStep != nil {
                    map["HalfOpenBaseAmountPerStep"] = self.halfOpenBaseAmountPerStep!
                }
                if self.halfOpenRecoveryStepNum != nil {
                    map["HalfOpenRecoveryStepNum"] = self.halfOpenRecoveryStepNum!
                }
                if self.maxAllowedRtMs != nil {
                    map["MaxAllowedRtMs"] = self.maxAllowedRtMs!
                }
                if self.minRequestAmount != nil {
                    map["MinRequestAmount"] = self.minRequestAmount!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resource != nil {
                    map["Resource"] = self.resource!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.retryTimeoutMs != nil {
                    map["RetryTimeoutMs"] = self.retryTimeoutMs!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.statIntervalMs != nil {
                    map["StatIntervalMs"] = self.statIntervalMs!
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("FallbackObject") {
                    self.fallbackObject = dict["FallbackObject"] as! String
                }
                if dict.keys.contains("HalfOpenBaseAmountPerStep") {
                    self.halfOpenBaseAmountPerStep = dict["HalfOpenBaseAmountPerStep"] as! Int32
                }
                if dict.keys.contains("HalfOpenRecoveryStepNum") {
                    self.halfOpenRecoveryStepNum = dict["HalfOpenRecoveryStepNum"] as! Int32
                }
                if dict.keys.contains("MaxAllowedRtMs") {
                    self.maxAllowedRtMs = dict["MaxAllowedRtMs"] as! Int32
                }
                if dict.keys.contains("MinRequestAmount") {
                    self.minRequestAmount = dict["MinRequestAmount"] as! Int32
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Resource") {
                    self.resource = dict["Resource"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! Int32
                }
                if dict.keys.contains("RetryTimeoutMs") {
                    self.retryTimeoutMs = dict["RetryTimeoutMs"] as! Int32
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! Int64
                }
                if dict.keys.contains("StatIntervalMs") {
                    self.statIntervalMs = dict["StatIntervalMs"] as! Int32
                }
                if dict.keys.contains("Strategy") {
                    self.strategy = dict["Strategy"] as! Int32
                }
                if dict.keys.contains("Threshold") {
                    self.threshold = dict["Threshold"] as! Double
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListCircuitBreakerRulesResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListCircuitBreakerRulesResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListCircuitBreakerRulesResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: ListCircuitBreakerRulesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListCircuitBreakerRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListCircuitBreakerRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCircuitBreakerRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCircuitBreakerRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterConnectionTypesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class ListClusterConnectionTypesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var showName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ShowName") {
                self.showName = dict["ShowName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListClusterConnectionTypesResponseBody.Data]?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListClusterConnectionTypesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListClusterConnectionTypesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListClusterConnectionTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterConnectionTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClusterConnectionTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterHealthCheckTaskRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListClusterHealthCheckTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class RiskList : Tea.TeaModel {
                public var description_: String?

                public var descriptionEn: String?

                public var id: Int32?

                public var module: String?

                public var mute: Bool?

                public var noticeFeature: Bool?

                public var primaryUser: String?

                public var riskCode: String?

                public var riskLevel: String?

                public var riskName: String?

                public var riskNameEn: String?

                public var riskType: String?

                public var situation: String?

                public var situationEn: String?

                public var suggestion: String?

                public var suggestionEn: String?

                public var taskId: Int64?

                public var type: Int32?

                public var values: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.descriptionEn != nil {
                        map["DescriptionEn"] = self.descriptionEn!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.module != nil {
                        map["Module"] = self.module!
                    }
                    if self.mute != nil {
                        map["Mute"] = self.mute!
                    }
                    if self.noticeFeature != nil {
                        map["NoticeFeature"] = self.noticeFeature!
                    }
                    if self.primaryUser != nil {
                        map["PrimaryUser"] = self.primaryUser!
                    }
                    if self.riskCode != nil {
                        map["RiskCode"] = self.riskCode!
                    }
                    if self.riskLevel != nil {
                        map["RiskLevel"] = self.riskLevel!
                    }
                    if self.riskName != nil {
                        map["RiskName"] = self.riskName!
                    }
                    if self.riskNameEn != nil {
                        map["RiskNameEn"] = self.riskNameEn!
                    }
                    if self.riskType != nil {
                        map["RiskType"] = self.riskType!
                    }
                    if self.situation != nil {
                        map["Situation"] = self.situation!
                    }
                    if self.situationEn != nil {
                        map["SituationEn"] = self.situationEn!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.suggestionEn != nil {
                        map["SuggestionEn"] = self.suggestionEn!
                    }
                    if self.taskId != nil {
                        map["TaskId"] = self.taskId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.values != nil {
                        map["Values"] = self.values!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("DescriptionEn") {
                        self.descriptionEn = dict["DescriptionEn"] as! String
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int32
                    }
                    if dict.keys.contains("Module") {
                        self.module = dict["Module"] as! String
                    }
                    if dict.keys.contains("Mute") {
                        self.mute = dict["Mute"] as! Bool
                    }
                    if dict.keys.contains("NoticeFeature") {
                        self.noticeFeature = dict["NoticeFeature"] as! Bool
                    }
                    if dict.keys.contains("PrimaryUser") {
                        self.primaryUser = dict["PrimaryUser"] as! String
                    }
                    if dict.keys.contains("RiskCode") {
                        self.riskCode = dict["RiskCode"] as! String
                    }
                    if dict.keys.contains("RiskLevel") {
                        self.riskLevel = dict["RiskLevel"] as! String
                    }
                    if dict.keys.contains("RiskName") {
                        self.riskName = dict["RiskName"] as! String
                    }
                    if dict.keys.contains("RiskNameEn") {
                        self.riskNameEn = dict["RiskNameEn"] as! String
                    }
                    if dict.keys.contains("RiskType") {
                        self.riskType = dict["RiskType"] as! String
                    }
                    if dict.keys.contains("Situation") {
                        self.situation = dict["Situation"] as! String
                    }
                    if dict.keys.contains("SituationEn") {
                        self.situationEn = dict["SituationEn"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("SuggestionEn") {
                        self.suggestionEn = dict["SuggestionEn"] as! String
                    }
                    if dict.keys.contains("TaskId") {
                        self.taskId = dict["TaskId"] as! Int64
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! Int32
                    }
                    if dict.keys.contains("Values") {
                        self.values = dict["Values"] as! String
                    }
                }
            }
            public var appVersion: String?

            public var chargeType: String?

            public var clusterType: String?

            public var createTime: String?

            public var id: Int32?

            public var imageVersion: String?

            public var instanceId: String?

            public var primaryUser: String?

            public var replica: String?

            public var riskList: [ListClusterHealthCheckTaskResponseBody.Data.Result.RiskList]?

            public var score: Int32?

            public var spec: String?

            public var status: String?

            public var totalItem: Int32?

            public var totalRisk: Int32?

            public var type: String?

            public var updateTime: String?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appVersion != nil {
                    map["AppVersion"] = self.appVersion!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.clusterType != nil {
                    map["ClusterType"] = self.clusterType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.imageVersion != nil {
                    map["ImageVersion"] = self.imageVersion!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.primaryUser != nil {
                    map["PrimaryUser"] = self.primaryUser!
                }
                if self.replica != nil {
                    map["Replica"] = self.replica!
                }
                if self.riskList != nil {
                    var tmp : [Any] = []
                    for k in self.riskList! {
                        tmp.append(k.toMap())
                    }
                    map["RiskList"] = tmp
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.totalItem != nil {
                    map["TotalItem"] = self.totalItem!
                }
                if self.totalRisk != nil {
                    map["TotalRisk"] = self.totalRisk!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppVersion") {
                    self.appVersion = dict["AppVersion"] as! String
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("ClusterType") {
                    self.clusterType = dict["ClusterType"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("ImageVersion") {
                    self.imageVersion = dict["ImageVersion"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PrimaryUser") {
                    self.primaryUser = dict["PrimaryUser"] as! String
                }
                if dict.keys.contains("Replica") {
                    self.replica = dict["Replica"] as! String
                }
                if dict.keys.contains("RiskList") {
                    var tmp : [ListClusterHealthCheckTaskResponseBody.Data.Result.RiskList] = []
                    for v in dict["RiskList"] as! [Any] {
                        var model = ListClusterHealthCheckTaskResponseBody.Data.Result.RiskList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.riskList = tmp
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Int32
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TotalItem") {
                    self.totalItem = dict["TotalItem"] as! Int32
                }
                if dict.keys.contains("TotalRisk") {
                    self.totalRisk = dict["TotalRisk"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("VersionCode") {
                    self.versionCode = dict["VersionCode"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListClusterHealthCheckTaskResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListClusterHealthCheckTaskResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListClusterHealthCheckTaskResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: ListClusterHealthCheckTaskResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListClusterHealthCheckTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListClusterHealthCheckTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterHealthCheckTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClusterHealthCheckTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterTypesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var connectType: String?

    public var mseVersion: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.connectType != nil {
            map["ConnectType"] = self.connectType!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConnectType") {
            self.connectType = dict["ConnectType"] as! String
        }
        if dict.keys.contains("MseVersion") {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListClusterTypesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var code: String?

        public var showName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ShowName") {
                self.showName = dict["ShowName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListClusterTypesResponseBody.Data]?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListClusterTypesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListClusterTypesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListClusterTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClusterTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterVersionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterType: String?

    public var mseVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("MseVersion") {
            self.mseVersion = dict["MseVersion"] as! String
        }
    }
}

public class ListClusterVersionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterType: String?

        public var code: String?

        public var showName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterType") {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ShowName") {
                self.showName = dict["ShowName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListClusterVersionsResponseBody.Data]?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListClusterVersionsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListClusterVersionsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListClusterVersionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterVersionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClusterVersionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClustersRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var clusterAliasName: String?

    public var keyId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public var resourceGroupId: String?

    public var tag: [ListClustersRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterAliasName != nil {
            map["ClusterAliasName"] = self.clusterAliasName!
        }
        if self.keyId != nil {
            map["KeyId"] = self.keyId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterAliasName") {
            self.clusterAliasName = dict["ClusterAliasName"] as! String
        }
        if dict.keys.contains("KeyId") {
            self.keyId = dict["KeyId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ListClustersRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListClustersRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListClustersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class MaintenancePeriod : Tea.TeaModel {
            public var endTime: String?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var appVersion: String?

        public var canUpdate: Bool?

        public var chargeType: String?

        public var clusterAliasName: String?

        public var clusterName: String?

        public var clusterType: String?

        public var createTime: String?

        public var endDate: String?

        public var initStatus: String?

        public var instanceCount: Int64?

        public var instanceId: String?

        public var internetAddress: String?

        public var internetDomain: String?

        public var intranetAddress: String?

        public var intranetDomain: String?

        public var maintenancePeriod: ListClustersResponseBody.Data.MaintenancePeriod?

        public var mseVersion: String?

        public var resourceGroupId: String?

        public var tags: [String: Any]?

        public var versionCode: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.maintenancePeriod?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.canUpdate != nil {
                map["CanUpdate"] = self.canUpdate!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.clusterAliasName != nil {
                map["ClusterAliasName"] = self.clusterAliasName!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.endDate != nil {
                map["EndDate"] = self.endDate!
            }
            if self.initStatus != nil {
                map["InitStatus"] = self.initStatus!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.internetAddress != nil {
                map["InternetAddress"] = self.internetAddress!
            }
            if self.internetDomain != nil {
                map["InternetDomain"] = self.internetDomain!
            }
            if self.intranetAddress != nil {
                map["IntranetAddress"] = self.intranetAddress!
            }
            if self.intranetDomain != nil {
                map["IntranetDomain"] = self.intranetDomain!
            }
            if self.maintenancePeriod != nil {
                map["MaintenancePeriod"] = self.maintenancePeriod?.toMap()
            }
            if self.mseVersion != nil {
                map["MseVersion"] = self.mseVersion!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppVersion") {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("CanUpdate") {
                self.canUpdate = dict["CanUpdate"] as! Bool
            }
            if dict.keys.contains("ChargeType") {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ClusterAliasName") {
                self.clusterAliasName = dict["ClusterAliasName"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterType") {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EndDate") {
                self.endDate = dict["EndDate"] as! String
            }
            if dict.keys.contains("InitStatus") {
                self.initStatus = dict["InitStatus"] as! String
            }
            if dict.keys.contains("InstanceCount") {
                self.instanceCount = dict["InstanceCount"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InternetAddress") {
                self.internetAddress = dict["InternetAddress"] as! String
            }
            if dict.keys.contains("InternetDomain") {
                self.internetDomain = dict["InternetDomain"] as! String
            }
            if dict.keys.contains("IntranetAddress") {
                self.intranetAddress = dict["IntranetAddress"] as! String
            }
            if dict.keys.contains("IntranetDomain") {
                self.intranetDomain = dict["IntranetDomain"] as! String
            }
            if dict.keys.contains("MaintenancePeriod") {
                var model = ListClustersResponseBody.Data.MaintenancePeriod()
                model.fromMap(dict["MaintenancePeriod"] as! [String: Any])
                self.maintenancePeriod = model
            }
            if dict.keys.contains("MseVersion") {
                self.mseVersion = dict["MseVersion"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! [String: Any]
            }
            if dict.keys.contains("VersionCode") {
                self.versionCode = dict["VersionCode"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var data: [ListClustersResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListClustersResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListClustersResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListConfigTrackRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dataId: String?

    public var endTs: Int64?

    public var group: String?

    public var instanceId: String?

    public var ip: String?

    public var namespaceId: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var requestPars: String?

    public var reverse: Bool?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("Reverse") {
            self.reverse = dict["Reverse"] as! Bool
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class ListConfigTrackResponseBody : Tea.TeaModel {
    public class Traces : Tea.TeaModel {
        public var client: Bool?

        public var dataId: String?

        public var delay: String?

        public var event: String?

        public var group: String?

        public var logDate: String?

        public var md5: String?

        public var push: Bool?

        public var requestIp: String?

        public var responseIp: String?

        public var result: String?

        public var ts: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.client != nil {
                map["Client"] = self.client!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.event != nil {
                map["Event"] = self.event!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.logDate != nil {
                map["LogDate"] = self.logDate!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.push != nil {
                map["Push"] = self.push!
            }
            if self.requestIp != nil {
                map["RequestIp"] = self.requestIp!
            }
            if self.responseIp != nil {
                map["ResponseIp"] = self.responseIp!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.ts != nil {
                map["Ts"] = self.ts!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Client") {
                self.client = dict["Client"] as! Bool
            }
            if dict.keys.contains("DataId") {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Delay") {
                self.delay = dict["Delay"] as! String
            }
            if dict.keys.contains("Event") {
                self.event = dict["Event"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("LogDate") {
                self.logDate = dict["LogDate"] as! String
            }
            if dict.keys.contains("Md5") {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("Push") {
                self.push = dict["Push"] as! Bool
            }
            if dict.keys.contains("RequestIp") {
                self.requestIp = dict["RequestIp"] as! String
            }
            if dict.keys.contains("ResponseIp") {
                self.responseIp = dict["ResponseIp"] as! String
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("Ts") {
                self.ts = dict["Ts"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var traces: [ListConfigTrackResponseBody.Traces]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.traces != nil {
            var tmp : [Any] = []
            for k in self.traces! {
                tmp.append(k.toMap())
            }
            map["Traces"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("Traces") {
            var tmp : [ListConfigTrackResponseBody.Traces] = []
            for v in dict["Traces"] as! [Any] {
                var model = ListConfigTrackResponseBody.Traces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.traces = tmp
        }
    }
}

public class ListConfigTrackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConfigTrackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListConfigTrackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEngineNamespacesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ListEngineNamespacesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configCount: Int32?

        public var namespace: String?

        public var namespaceDesc: String?

        public var namespaceShowName: String?

        public var quota: Int32?

        public var serviceCount: String?

        public var sourceType: String?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configCount != nil {
                map["ConfigCount"] = self.configCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.namespaceDesc != nil {
                map["NamespaceDesc"] = self.namespaceDesc!
            }
            if self.namespaceShowName != nil {
                map["NamespaceShowName"] = self.namespaceShowName!
            }
            if self.quota != nil {
                map["Quota"] = self.quota!
            }
            if self.serviceCount != nil {
                map["ServiceCount"] = self.serviceCount!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigCount") {
                self.configCount = dict["ConfigCount"] as! Int32
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NamespaceDesc") {
                self.namespaceDesc = dict["NamespaceDesc"] as! String
            }
            if dict.keys.contains("NamespaceShowName") {
                self.namespaceShowName = dict["NamespaceShowName"] as! String
            }
            if dict.keys.contains("Quota") {
                self.quota = dict["Quota"] as! Int32
            }
            if dict.keys.contains("ServiceCount") {
                self.serviceCount = dict["ServiceCount"] as! String
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var data: [ListEngineNamespacesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListEngineNamespacesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEngineNamespacesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListEngineNamespacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEngineNamespacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEngineNamespacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEurekaInstancesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestPars: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListEurekaInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var app: String?

        public var durationInSecs: Int32?

        public var homePageUrl: String?

        public var hostName: String?

        public var instanceId: String?

        public var ipAddr: String?

        public var lastDirtyTimestamp: Int64?

        public var lastUpdatedTimestamp: Int64?

        public var metadata: [String: Any]?

        public var port: Int32?

        public var renewalIntervalInSecs: Int32?

        public var securePort: Int32?

        public var status: String?

        public var vipAddress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.durationInSecs != nil {
                map["DurationInSecs"] = self.durationInSecs!
            }
            if self.homePageUrl != nil {
                map["HomePageUrl"] = self.homePageUrl!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ipAddr != nil {
                map["IpAddr"] = self.ipAddr!
            }
            if self.lastDirtyTimestamp != nil {
                map["LastDirtyTimestamp"] = self.lastDirtyTimestamp!
            }
            if self.lastUpdatedTimestamp != nil {
                map["LastUpdatedTimestamp"] = self.lastUpdatedTimestamp!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.renewalIntervalInSecs != nil {
                map["RenewalIntervalInSecs"] = self.renewalIntervalInSecs!
            }
            if self.securePort != nil {
                map["SecurePort"] = self.securePort!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vipAddress != nil {
                map["VipAddress"] = self.vipAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("App") {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("DurationInSecs") {
                self.durationInSecs = dict["DurationInSecs"] as! Int32
            }
            if dict.keys.contains("HomePageUrl") {
                self.homePageUrl = dict["HomePageUrl"] as! String
            }
            if dict.keys.contains("HostName") {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("IpAddr") {
                self.ipAddr = dict["IpAddr"] as! String
            }
            if dict.keys.contains("LastDirtyTimestamp") {
                self.lastDirtyTimestamp = dict["LastDirtyTimestamp"] as! Int64
            }
            if dict.keys.contains("LastUpdatedTimestamp") {
                self.lastUpdatedTimestamp = dict["LastUpdatedTimestamp"] as! Int64
            }
            if dict.keys.contains("Metadata") {
                self.metadata = dict["Metadata"] as! [String: Any]
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("RenewalIntervalInSecs") {
                self.renewalIntervalInSecs = dict["RenewalIntervalInSecs"] as! Int32
            }
            if dict.keys.contains("SecurePort") {
                self.securePort = dict["SecurePort"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("VipAddress") {
                self.vipAddress = dict["VipAddress"] as! String
            }
        }
    }
    public var data: [ListEurekaInstancesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListEurekaInstancesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEurekaInstancesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListEurekaInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEurekaInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEurekaInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEurekaServicesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListEurekaServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instancesId: [String]?

        public var name: String?

        public var upStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instancesId != nil {
                map["InstancesId"] = self.instancesId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.upStatus != nil {
                map["UpStatus"] = self.upStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstancesId") {
                self.instancesId = dict["InstancesId"] as! [String]
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("UpStatus") {
                self.upStatus = dict["UpStatus"] as! String
            }
        }
    }
    public var data: [ListEurekaServicesResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListEurekaServicesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListEurekaServicesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListEurekaServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEurekaServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEurekaServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListExportZookeeperDataRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListExportZookeeperDataResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var contentMap: String?

        public var createTime: Int64?

        public var exportType: String?

        public var extend: String?

        public var id: Int32?

        public var instanceId: String?

        public var kubeoneTaskIds: String?

        public var status: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contentMap != nil {
                map["ContentMap"] = self.contentMap!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.exportType != nil {
                map["ExportType"] = self.exportType!
            }
            if self.extend != nil {
                map["Extend"] = self.extend!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.kubeoneTaskIds != nil {
                map["KubeoneTaskIds"] = self.kubeoneTaskIds!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContentMap") {
                self.contentMap = dict["ContentMap"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ExportType") {
                self.exportType = dict["ExportType"] as! String
            }
            if dict.keys.contains("Extend") {
                self.extend = dict["Extend"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("KubeoneTaskIds") {
                self.kubeoneTaskIds = dict["KubeoneTaskIds"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var data: [ListExportZookeeperDataResponseBody.Data]?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListExportZookeeperDataResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListExportZookeeperDataResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListExportZookeeperDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListExportZookeeperDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListExportZookeeperDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowRulesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var resource: String?

    public var resourceSearchKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceSearchKey != nil {
            map["ResourceSearchKey"] = self.resourceSearchKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageIndex") {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Resource") {
            self.resource = dict["Resource"] as! String
        }
        if dict.keys.contains("ResourceSearchKey") {
            self.resourceSearchKey = dict["ResourceSearchKey"] as! String
        }
    }
}

public class ListFlowRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var controlBehavior: Int32?

            public var enable: Bool?

            public var fallbackObject: String?

            public var limitApp: String?

            public var maxQueueingTimeMs: Int32?

            public var metricType: Int32?

            public var namespace: String?

            public var regionId: String?

            public var resource: String?

            public var resourceType: Int32?

            public var ruleId: Int64?

            public var threshold: Double?

            public var trafficTags: [String: Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.controlBehavior != nil {
                    map["ControlBehavior"] = self.controlBehavior!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.fallbackObject != nil {
                    map["FallbackObject"] = self.fallbackObject!
                }
                if self.limitApp != nil {
                    map["LimitApp"] = self.limitApp!
                }
                if self.maxQueueingTimeMs != nil {
                    map["MaxQueueingTimeMs"] = self.maxQueueingTimeMs!
                }
                if self.metricType != nil {
                    map["MetricType"] = self.metricType!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resource != nil {
                    map["Resource"] = self.resource!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                if self.trafficTags != nil {
                    map["TrafficTags"] = self.trafficTags!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("ControlBehavior") {
                    self.controlBehavior = dict["ControlBehavior"] as! Int32
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("FallbackObject") {
                    self.fallbackObject = dict["FallbackObject"] as! String
                }
                if dict.keys.contains("LimitApp") {
                    self.limitApp = dict["LimitApp"] as! String
                }
                if dict.keys.contains("MaxQueueingTimeMs") {
                    self.maxQueueingTimeMs = dict["MaxQueueingTimeMs"] as! Int32
                }
                if dict.keys.contains("MetricType") {
                    self.metricType = dict["MetricType"] as! Int32
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Resource") {
                    self.resource = dict["Resource"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! Int32
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! Int64
                }
                if dict.keys.contains("Threshold") {
                    self.threshold = dict["Threshold"] as! Double
                }
                if dict.keys.contains("TrafficTags") {
                    self.trafficTags = dict["TrafficTags"] as! [String: Any]
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListFlowRulesResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListFlowRulesResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListFlowRulesResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: ListFlowRulesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListFlowRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListFlowRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFlowRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayRequest : Tea.TeaModel {
    public class FilterParams : Tea.TeaModel {
        public var gatewayType: String?

        public var gatewayUniqueId: String?

        public var instanceId: String?

        public var mseTag: String?

        public var name: String?

        public var resourceGroupId: String?

        public var vpc: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayType != nil {
                map["GatewayType"] = self.gatewayType!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.mseTag != nil {
                map["MseTag"] = self.mseTag!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.vpc != nil {
                map["Vpc"] = self.vpc!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayType") {
                self.gatewayType = dict["GatewayType"] as! String
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MseTag") {
                self.mseTag = dict["MseTag"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Vpc") {
                self.vpc = dict["Vpc"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParams: ListGatewayRequest.FilterParams?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filterParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParams != nil {
            map["FilterParams"] = self.filterParams?.toMap()
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            var model = ListGatewayRequest.FilterParams()
            model.fromMap(dict["FilterParams"] as! [String: Any])
            self.filterParams = model
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParamsShrink: String?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParamsShrink != nil {
            map["FilterParams"] = self.filterParamsShrink!
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            self.filterParamsShrink = dict["FilterParams"] as! String
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class ElasticPolicy : Tea.TeaModel {
                public class EnableScaleTimePolicyList : Tea.TeaModel {
                    public var endTime: String?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EndTime") {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public class TimePolicyList : Tea.TeaModel {
                    public var desiredReplica: Int32?

                    public var endTime: String?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.desiredReplica != nil {
                            map["DesiredReplica"] = self.desiredReplica!
                        }
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DesiredReplica") {
                            self.desiredReplica = dict["DesiredReplica"] as! Int32
                        }
                        if dict.keys.contains("EndTime") {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public var elastic: Bool?

                public var elasticType: String?

                public var enableScaleTimePolicyList: [ListGatewayResponseBody.Data.Result.ElasticPolicy.EnableScaleTimePolicyList]?

                public var loadWarningThreshold: Bool?

                public var maxReplica: Int32?

                public var timePolicyList: [ListGatewayResponseBody.Data.Result.ElasticPolicy.TimePolicyList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.elastic != nil {
                        map["Elastic"] = self.elastic!
                    }
                    if self.elasticType != nil {
                        map["ElasticType"] = self.elasticType!
                    }
                    if self.enableScaleTimePolicyList != nil {
                        var tmp : [Any] = []
                        for k in self.enableScaleTimePolicyList! {
                            tmp.append(k.toMap())
                        }
                        map["EnableScaleTimePolicyList"] = tmp
                    }
                    if self.loadWarningThreshold != nil {
                        map["LoadWarningThreshold"] = self.loadWarningThreshold!
                    }
                    if self.maxReplica != nil {
                        map["MaxReplica"] = self.maxReplica!
                    }
                    if self.timePolicyList != nil {
                        var tmp : [Any] = []
                        for k in self.timePolicyList! {
                            tmp.append(k.toMap())
                        }
                        map["TimePolicyList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Elastic") {
                        self.elastic = dict["Elastic"] as! Bool
                    }
                    if dict.keys.contains("ElasticType") {
                        self.elasticType = dict["ElasticType"] as! String
                    }
                    if dict.keys.contains("EnableScaleTimePolicyList") {
                        var tmp : [ListGatewayResponseBody.Data.Result.ElasticPolicy.EnableScaleTimePolicyList] = []
                        for v in dict["EnableScaleTimePolicyList"] as! [Any] {
                            var model = ListGatewayResponseBody.Data.Result.ElasticPolicy.EnableScaleTimePolicyList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.enableScaleTimePolicyList = tmp
                    }
                    if dict.keys.contains("LoadWarningThreshold") {
                        self.loadWarningThreshold = dict["LoadWarningThreshold"] as! Bool
                    }
                    if dict.keys.contains("MaxReplica") {
                        self.maxReplica = dict["MaxReplica"] as! Int32
                    }
                    if dict.keys.contains("TimePolicyList") {
                        var tmp : [ListGatewayResponseBody.Data.Result.ElasticPolicy.TimePolicyList] = []
                        for v in dict["TimePolicyList"] as! [Any] {
                            var model = ListGatewayResponseBody.Data.Result.ElasticPolicy.TimePolicyList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.timePolicyList = tmp
                    }
                }
            }
            public class InitConfig : Tea.TeaModel {
                public var enableWaf: Bool?

                public var supportWaf: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enableWaf != nil {
                        map["EnableWaf"] = self.enableWaf!
                    }
                    if self.supportWaf != nil {
                        map["SupportWaf"] = self.supportWaf!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EnableWaf") {
                        self.enableWaf = dict["EnableWaf"] as! Bool
                    }
                    if dict.keys.contains("SupportWaf") {
                        self.supportWaf = dict["SupportWaf"] as! Bool
                    }
                }
            }
            public class InternetSlb : Tea.TeaModel {
                public var gatewaySlbMode: String?

                public var gatewaySlbStatus: String?

                public var internetNetworkFlow: String?

                public var slbId: String?

                public var slbIp: String?

                public var slbPort: String?

                public var slbSpec: String?

                public var statusDesc: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gatewaySlbMode != nil {
                        map["GatewaySlbMode"] = self.gatewaySlbMode!
                    }
                    if self.gatewaySlbStatus != nil {
                        map["GatewaySlbStatus"] = self.gatewaySlbStatus!
                    }
                    if self.internetNetworkFlow != nil {
                        map["InternetNetworkFlow"] = self.internetNetworkFlow!
                    }
                    if self.slbId != nil {
                        map["SlbId"] = self.slbId!
                    }
                    if self.slbIp != nil {
                        map["SlbIp"] = self.slbIp!
                    }
                    if self.slbPort != nil {
                        map["SlbPort"] = self.slbPort!
                    }
                    if self.slbSpec != nil {
                        map["SlbSpec"] = self.slbSpec!
                    }
                    if self.statusDesc != nil {
                        map["StatusDesc"] = self.statusDesc!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GatewaySlbMode") {
                        self.gatewaySlbMode = dict["GatewaySlbMode"] as! String
                    }
                    if dict.keys.contains("GatewaySlbStatus") {
                        self.gatewaySlbStatus = dict["GatewaySlbStatus"] as! String
                    }
                    if dict.keys.contains("InternetNetworkFlow") {
                        self.internetNetworkFlow = dict["InternetNetworkFlow"] as! String
                    }
                    if dict.keys.contains("SlbId") {
                        self.slbId = dict["SlbId"] as! String
                    }
                    if dict.keys.contains("SlbIp") {
                        self.slbIp = dict["SlbIp"] as! String
                    }
                    if dict.keys.contains("SlbPort") {
                        self.slbPort = dict["SlbPort"] as! String
                    }
                    if dict.keys.contains("SlbSpec") {
                        self.slbSpec = dict["SlbSpec"] as! String
                    }
                    if dict.keys.contains("StatusDesc") {
                        self.statusDesc = dict["StatusDesc"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class MaintenancePeriod : Tea.TeaModel {
                public var endTime: String?

                public var startTime: String?

                public var timeZone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timeZone != nil {
                        map["TimeZone"] = self.timeZone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("TimeZone") {
                        self.timeZone = dict["TimeZone"] as! String
                    }
                }
            }
            public class Slb : Tea.TeaModel {
                public var gatewaySlbMode: String?

                public var gatewaySlbStatus: String?

                public var slbId: String?

                public var slbIp: String?

                public var slbPort: String?

                public var slbSpec: String?

                public var statusDesc: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gatewaySlbMode != nil {
                        map["GatewaySlbMode"] = self.gatewaySlbMode!
                    }
                    if self.gatewaySlbStatus != nil {
                        map["GatewaySlbStatus"] = self.gatewaySlbStatus!
                    }
                    if self.slbId != nil {
                        map["SlbId"] = self.slbId!
                    }
                    if self.slbIp != nil {
                        map["SlbIp"] = self.slbIp!
                    }
                    if self.slbPort != nil {
                        map["SlbPort"] = self.slbPort!
                    }
                    if self.slbSpec != nil {
                        map["SlbSpec"] = self.slbSpec!
                    }
                    if self.statusDesc != nil {
                        map["StatusDesc"] = self.statusDesc!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GatewaySlbMode") {
                        self.gatewaySlbMode = dict["GatewaySlbMode"] as! String
                    }
                    if dict.keys.contains("GatewaySlbStatus") {
                        self.gatewaySlbStatus = dict["GatewaySlbStatus"] as! String
                    }
                    if dict.keys.contains("SlbId") {
                        self.slbId = dict["SlbId"] as! String
                    }
                    if dict.keys.contains("SlbIp") {
                        self.slbIp = dict["SlbIp"] as! String
                    }
                    if dict.keys.contains("SlbPort") {
                        self.slbPort = dict["SlbPort"] as! String
                    }
                    if dict.keys.contains("SlbSpec") {
                        self.slbSpec = dict["SlbSpec"] as! String
                    }
                    if dict.keys.contains("StatusDesc") {
                        self.statusDesc = dict["StatusDesc"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var ahasOn: Bool?

            public var appVersion: String?

            public var armsOn: Bool?

            public var chargeType: String?

            public var currentVersion: String?

            public var elastic: Bool?

            public var elasticInstanceId: String?

            public var elasticPolicy: ListGatewayResponseBody.Data.Result.ElasticPolicy?

            public var elasticReplica: Int32?

            public var elasticType: String?

            public var endDate: String?

            public var gatewayType: String?

            public var gatewayUniqueId: String?

            public var gatewayVersion: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var initConfig: ListGatewayResponseBody.Data.Result.InitConfig?

            public var instanceId: String?

            public var internetSlb: [ListGatewayResponseBody.Data.Result.InternetSlb]?

            public var latestVersion: String?

            public var maintenancePeriod: ListGatewayResponseBody.Data.Result.MaintenancePeriod?

            public var mseTag: String?

            public var mseVersion: String?

            public var mustUpgrade: Bool?

            public var name: String?

            public var primaryUser: String?

            public var region: String?

            public var replica: Int32?

            public var resourceGroupId: String?

            public var rollBack: Bool?

            public var slb: [ListGatewayResponseBody.Data.Result.Slb]?

            public var spec: String?

            public var status: Int32?

            public var statusDesc: String?

            public var supportWasm: Bool?

            public var tag: String?

            public var totalReplica: Int32?

            public var upgrade: Bool?

            public var vpcId: String?

            public var vswitch2: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.elasticPolicy?.validate()
                try self.initConfig?.validate()
                try self.maintenancePeriod?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ahasOn != nil {
                    map["AhasOn"] = self.ahasOn!
                }
                if self.appVersion != nil {
                    map["AppVersion"] = self.appVersion!
                }
                if self.armsOn != nil {
                    map["ArmsOn"] = self.armsOn!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.currentVersion != nil {
                    map["CurrentVersion"] = self.currentVersion!
                }
                if self.elastic != nil {
                    map["Elastic"] = self.elastic!
                }
                if self.elasticInstanceId != nil {
                    map["ElasticInstanceId"] = self.elasticInstanceId!
                }
                if self.elasticPolicy != nil {
                    map["ElasticPolicy"] = self.elasticPolicy?.toMap()
                }
                if self.elasticReplica != nil {
                    map["ElasticReplica"] = self.elasticReplica!
                }
                if self.elasticType != nil {
                    map["ElasticType"] = self.elasticType!
                }
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.gatewayType != nil {
                    map["GatewayType"] = self.gatewayType!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gatewayVersion != nil {
                    map["GatewayVersion"] = self.gatewayVersion!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.initConfig != nil {
                    map["InitConfig"] = self.initConfig?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.internetSlb != nil {
                    var tmp : [Any] = []
                    for k in self.internetSlb! {
                        tmp.append(k.toMap())
                    }
                    map["InternetSlb"] = tmp
                }
                if self.latestVersion != nil {
                    map["LatestVersion"] = self.latestVersion!
                }
                if self.maintenancePeriod != nil {
                    map["MaintenancePeriod"] = self.maintenancePeriod?.toMap()
                }
                if self.mseTag != nil {
                    map["MseTag"] = self.mseTag!
                }
                if self.mseVersion != nil {
                    map["MseVersion"] = self.mseVersion!
                }
                if self.mustUpgrade != nil {
                    map["MustUpgrade"] = self.mustUpgrade!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.primaryUser != nil {
                    map["PrimaryUser"] = self.primaryUser!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.replica != nil {
                    map["Replica"] = self.replica!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.rollBack != nil {
                    map["RollBack"] = self.rollBack!
                }
                if self.slb != nil {
                    var tmp : [Any] = []
                    for k in self.slb! {
                        tmp.append(k.toMap())
                    }
                    map["Slb"] = tmp
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.statusDesc != nil {
                    map["StatusDesc"] = self.statusDesc!
                }
                if self.supportWasm != nil {
                    map["SupportWasm"] = self.supportWasm!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.totalReplica != nil {
                    map["TotalReplica"] = self.totalReplica!
                }
                if self.upgrade != nil {
                    map["Upgrade"] = self.upgrade!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vswitch2 != nil {
                    map["Vswitch2"] = self.vswitch2!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AhasOn") {
                    self.ahasOn = dict["AhasOn"] as! Bool
                }
                if dict.keys.contains("AppVersion") {
                    self.appVersion = dict["AppVersion"] as! String
                }
                if dict.keys.contains("ArmsOn") {
                    self.armsOn = dict["ArmsOn"] as! Bool
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("CurrentVersion") {
                    self.currentVersion = dict["CurrentVersion"] as! String
                }
                if dict.keys.contains("Elastic") {
                    self.elastic = dict["Elastic"] as! Bool
                }
                if dict.keys.contains("ElasticInstanceId") {
                    self.elasticInstanceId = dict["ElasticInstanceId"] as! String
                }
                if dict.keys.contains("ElasticPolicy") {
                    var model = ListGatewayResponseBody.Data.Result.ElasticPolicy()
                    model.fromMap(dict["ElasticPolicy"] as! [String: Any])
                    self.elasticPolicy = model
                }
                if dict.keys.contains("ElasticReplica") {
                    self.elasticReplica = dict["ElasticReplica"] as! Int32
                }
                if dict.keys.contains("ElasticType") {
                    self.elasticType = dict["ElasticType"] as! String
                }
                if dict.keys.contains("EndDate") {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("GatewayType") {
                    self.gatewayType = dict["GatewayType"] as! String
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GatewayVersion") {
                    self.gatewayVersion = dict["GatewayVersion"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InitConfig") {
                    var model = ListGatewayResponseBody.Data.Result.InitConfig()
                    model.fromMap(dict["InitConfig"] as! [String: Any])
                    self.initConfig = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InternetSlb") {
                    var tmp : [ListGatewayResponseBody.Data.Result.InternetSlb] = []
                    for v in dict["InternetSlb"] as! [Any] {
                        var model = ListGatewayResponseBody.Data.Result.InternetSlb()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.internetSlb = tmp
                }
                if dict.keys.contains("LatestVersion") {
                    self.latestVersion = dict["LatestVersion"] as! String
                }
                if dict.keys.contains("MaintenancePeriod") {
                    var model = ListGatewayResponseBody.Data.Result.MaintenancePeriod()
                    model.fromMap(dict["MaintenancePeriod"] as! [String: Any])
                    self.maintenancePeriod = model
                }
                if dict.keys.contains("MseTag") {
                    self.mseTag = dict["MseTag"] as! String
                }
                if dict.keys.contains("MseVersion") {
                    self.mseVersion = dict["MseVersion"] as! String
                }
                if dict.keys.contains("MustUpgrade") {
                    self.mustUpgrade = dict["MustUpgrade"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PrimaryUser") {
                    self.primaryUser = dict["PrimaryUser"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Replica") {
                    self.replica = dict["Replica"] as! Int32
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RollBack") {
                    self.rollBack = dict["RollBack"] as! Bool
                }
                if dict.keys.contains("Slb") {
                    var tmp : [ListGatewayResponseBody.Data.Result.Slb] = []
                    for v in dict["Slb"] as! [Any] {
                        var model = ListGatewayResponseBody.Data.Result.Slb()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.slb = tmp
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("StatusDesc") {
                    self.statusDesc = dict["StatusDesc"] as! String
                }
                if dict.keys.contains("SupportWasm") {
                    self.supportWasm = dict["SupportWasm"] as! Bool
                }
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("TotalReplica") {
                    self.totalReplica = dict["TotalReplica"] as! Int32
                }
                if dict.keys.contains("Upgrade") {
                    self.upgrade = dict["Upgrade"] as! Bool
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("Vswitch2") {
                    self.vswitch2 = dict["Vswitch2"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListGatewayResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGatewayResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListGatewayResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListGatewayResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayAuthConsumerRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerStatus: Bool?

    public var gatewayUniqueId: String?

    public var name: String?

    public var pageNum: String?

    public var pageSize: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerStatus != nil {
            map["ConsumerStatus"] = self.consumerStatus!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerStatus") {
            self.consumerStatus = dict["ConsumerStatus"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListGatewayAuthConsumerResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var consumerStatus: Bool?

            public var description_: String?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var name: String?

            public var primaryUser: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consumerStatus != nil {
                    map["ConsumerStatus"] = self.consumerStatus!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.primaryUser != nil {
                    map["PrimaryUser"] = self.primaryUser!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsumerStatus") {
                    self.consumerStatus = dict["ConsumerStatus"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PrimaryUser") {
                    self.primaryUser = dict["PrimaryUser"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayAuthConsumerResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListGatewayAuthConsumerResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGatewayAuthConsumerResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListGatewayAuthConsumerResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListGatewayAuthConsumerResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayAuthConsumerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayAuthConsumerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayAuthConsumerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayAuthConsumerResourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerId: Int64?

    public var gatewayUniqueId: String?

    public var pageNum: String?

    public var pageSize: String?

    public var resourceStatus: Bool?

    public var routeName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerId != nil {
            map["ConsumerId"] = self.consumerId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceStatus != nil {
            map["ResourceStatus"] = self.resourceStatus!
        }
        if self.routeName != nil {
            map["RouteName"] = self.routeName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerId") {
            self.consumerId = dict["ConsumerId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("ResourceStatus") {
            self.resourceStatus = dict["ResourceStatus"] as! Bool
        }
        if dict.keys.contains("RouteName") {
            self.routeName = dict["RouteName"] as! String
        }
    }
}

public class ListGatewayAuthConsumerResourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var consumerId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var resourceStatus: Bool?

            public var routeId: Int64?

            public var routeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consumerId != nil {
                    map["ConsumerId"] = self.consumerId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.resourceStatus != nil {
                    map["ResourceStatus"] = self.resourceStatus!
                }
                if self.routeId != nil {
                    map["RouteId"] = self.routeId!
                }
                if self.routeName != nil {
                    map["RouteName"] = self.routeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsumerId") {
                    self.consumerId = dict["ConsumerId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ResourceStatus") {
                    self.resourceStatus = dict["ResourceStatus"] as! Bool
                }
                if dict.keys.contains("RouteId") {
                    self.routeId = dict["RouteId"] as! Int64
                }
                if dict.keys.contains("RouteName") {
                    self.routeName = dict["RouteName"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayAuthConsumerResourceResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListGatewayAuthConsumerResourceResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGatewayAuthConsumerResourceResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListGatewayAuthConsumerResourceResponseBody.Data?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListGatewayAuthConsumerResourceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayAuthConsumerResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayAuthConsumerResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayAuthConsumerResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayCircuitBreakerRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var filterParams: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.filterParams != nil {
            map["FilterParams"] = self.filterParams!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("FilterParams") {
            self.filterParams = dict["FilterParams"] as! String
        }
    }
}

public class ListGatewayCircuitBreakerRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var behaviorType: Int32?

            public var bodyEncoding: Int32?

            public var enable: Int32?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var id: Int64?

            public var idList: [Int64]?

            public var limitMode: Int32?

            public var maxAllowedMs: Int32?

            public var minRequestAmount: Int32?

            public var recoveryTimeoutSec: Int32?

            public var responseAdditionalHeaders: String?

            public var responseContentBody: String?

            public var responseRedirectUrl: String?

            public var responseStatusCode: Int32?

            public var routeId: Int64?

            public var routeName: String?

            public var statDurationSec: Int32?

            public var strategy: Int32?

            public var triggerRatio: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.behaviorType != nil {
                    map["BehaviorType"] = self.behaviorType!
                }
                if self.bodyEncoding != nil {
                    map["BodyEncoding"] = self.bodyEncoding!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.idList != nil {
                    map["IdList"] = self.idList!
                }
                if self.limitMode != nil {
                    map["LimitMode"] = self.limitMode!
                }
                if self.maxAllowedMs != nil {
                    map["MaxAllowedMs"] = self.maxAllowedMs!
                }
                if self.minRequestAmount != nil {
                    map["MinRequestAmount"] = self.minRequestAmount!
                }
                if self.recoveryTimeoutSec != nil {
                    map["RecoveryTimeoutSec"] = self.recoveryTimeoutSec!
                }
                if self.responseAdditionalHeaders != nil {
                    map["ResponseAdditionalHeaders"] = self.responseAdditionalHeaders!
                }
                if self.responseContentBody != nil {
                    map["ResponseContentBody"] = self.responseContentBody!
                }
                if self.responseRedirectUrl != nil {
                    map["ResponseRedirectUrl"] = self.responseRedirectUrl!
                }
                if self.responseStatusCode != nil {
                    map["ResponseStatusCode"] = self.responseStatusCode!
                }
                if self.routeId != nil {
                    map["RouteId"] = self.routeId!
                }
                if self.routeName != nil {
                    map["RouteName"] = self.routeName!
                }
                if self.statDurationSec != nil {
                    map["StatDurationSec"] = self.statDurationSec!
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy!
                }
                if self.triggerRatio != nil {
                    map["TriggerRatio"] = self.triggerRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BehaviorType") {
                    self.behaviorType = dict["BehaviorType"] as! Int32
                }
                if dict.keys.contains("BodyEncoding") {
                    self.bodyEncoding = dict["BodyEncoding"] as! Int32
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Int32
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IdList") {
                    self.idList = dict["IdList"] as! [Int64]
                }
                if dict.keys.contains("LimitMode") {
                    self.limitMode = dict["LimitMode"] as! Int32
                }
                if dict.keys.contains("MaxAllowedMs") {
                    self.maxAllowedMs = dict["MaxAllowedMs"] as! Int32
                }
                if dict.keys.contains("MinRequestAmount") {
                    self.minRequestAmount = dict["MinRequestAmount"] as! Int32
                }
                if dict.keys.contains("RecoveryTimeoutSec") {
                    self.recoveryTimeoutSec = dict["RecoveryTimeoutSec"] as! Int32
                }
                if dict.keys.contains("ResponseAdditionalHeaders") {
                    self.responseAdditionalHeaders = dict["ResponseAdditionalHeaders"] as! String
                }
                if dict.keys.contains("ResponseContentBody") {
                    self.responseContentBody = dict["ResponseContentBody"] as! String
                }
                if dict.keys.contains("ResponseRedirectUrl") {
                    self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
                }
                if dict.keys.contains("ResponseStatusCode") {
                    self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
                }
                if dict.keys.contains("RouteId") {
                    self.routeId = dict["RouteId"] as! Int64
                }
                if dict.keys.contains("RouteName") {
                    self.routeName = dict["RouteName"] as! String
                }
                if dict.keys.contains("StatDurationSec") {
                    self.statDurationSec = dict["StatDurationSec"] as! Int32
                }
                if dict.keys.contains("Strategy") {
                    self.strategy = dict["Strategy"] as! Int32
                }
                if dict.keys.contains("TriggerRatio") {
                    self.triggerRatio = dict["TriggerRatio"] as! Int32
                }
            }
        }
        public class Results : Tea.TeaModel {
            public var behaviorType: Int32?

            public var bodyEncoding: Int32?

            public var enable: Int32?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var id: Int64?

            public var idList: [Int64]?

            public var limitMode: Int32?

            public var maxAllowedMs: Int32?

            public var minRequestAmount: Int32?

            public var recoveryTimeoutSec: Int32?

            public var responseAdditionalHeaders: String?

            public var responseContentBody: String?

            public var responseRedirectUrl: String?

            public var responseStatusCode: Int32?

            public var routeId: Int64?

            public var routeName: String?

            public var statDurationSec: Int32?

            public var strategy: Int32?

            public var triggerRatio: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.behaviorType != nil {
                    map["BehaviorType"] = self.behaviorType!
                }
                if self.bodyEncoding != nil {
                    map["BodyEncoding"] = self.bodyEncoding!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.idList != nil {
                    map["IdList"] = self.idList!
                }
                if self.limitMode != nil {
                    map["LimitMode"] = self.limitMode!
                }
                if self.maxAllowedMs != nil {
                    map["MaxAllowedMs"] = self.maxAllowedMs!
                }
                if self.minRequestAmount != nil {
                    map["MinRequestAmount"] = self.minRequestAmount!
                }
                if self.recoveryTimeoutSec != nil {
                    map["RecoveryTimeoutSec"] = self.recoveryTimeoutSec!
                }
                if self.responseAdditionalHeaders != nil {
                    map["ResponseAdditionalHeaders"] = self.responseAdditionalHeaders!
                }
                if self.responseContentBody != nil {
                    map["ResponseContentBody"] = self.responseContentBody!
                }
                if self.responseRedirectUrl != nil {
                    map["ResponseRedirectUrl"] = self.responseRedirectUrl!
                }
                if self.responseStatusCode != nil {
                    map["ResponseStatusCode"] = self.responseStatusCode!
                }
                if self.routeId != nil {
                    map["RouteId"] = self.routeId!
                }
                if self.routeName != nil {
                    map["RouteName"] = self.routeName!
                }
                if self.statDurationSec != nil {
                    map["StatDurationSec"] = self.statDurationSec!
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy!
                }
                if self.triggerRatio != nil {
                    map["TriggerRatio"] = self.triggerRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BehaviorType") {
                    self.behaviorType = dict["BehaviorType"] as! Int32
                }
                if dict.keys.contains("BodyEncoding") {
                    self.bodyEncoding = dict["BodyEncoding"] as! Int32
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Int32
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IdList") {
                    self.idList = dict["IdList"] as! [Int64]
                }
                if dict.keys.contains("LimitMode") {
                    self.limitMode = dict["LimitMode"] as! Int32
                }
                if dict.keys.contains("MaxAllowedMs") {
                    self.maxAllowedMs = dict["MaxAllowedMs"] as! Int32
                }
                if dict.keys.contains("MinRequestAmount") {
                    self.minRequestAmount = dict["MinRequestAmount"] as! Int32
                }
                if dict.keys.contains("RecoveryTimeoutSec") {
                    self.recoveryTimeoutSec = dict["RecoveryTimeoutSec"] as! Int32
                }
                if dict.keys.contains("ResponseAdditionalHeaders") {
                    self.responseAdditionalHeaders = dict["ResponseAdditionalHeaders"] as! String
                }
                if dict.keys.contains("ResponseContentBody") {
                    self.responseContentBody = dict["ResponseContentBody"] as! String
                }
                if dict.keys.contains("ResponseRedirectUrl") {
                    self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
                }
                if dict.keys.contains("ResponseStatusCode") {
                    self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
                }
                if dict.keys.contains("RouteId") {
                    self.routeId = dict["RouteId"] as! Int64
                }
                if dict.keys.contains("RouteName") {
                    self.routeName = dict["RouteName"] as! String
                }
                if dict.keys.contains("StatDurationSec") {
                    self.statDurationSec = dict["StatDurationSec"] as! Int32
                }
                if dict.keys.contains("Strategy") {
                    self.strategy = dict["Strategy"] as! Int32
                }
                if dict.keys.contains("TriggerRatio") {
                    self.triggerRatio = dict["TriggerRatio"] as! Int32
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayCircuitBreakerRuleResponseBody.Data.Result]?

        public var results: [ListGatewayCircuitBreakerRuleResponseBody.Data.Results]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.results != nil {
                var tmp : [Any] = []
                for k in self.results! {
                    tmp.append(k.toMap())
                }
                map["Results"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListGatewayCircuitBreakerRuleResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGatewayCircuitBreakerRuleResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("Results") {
                var tmp : [ListGatewayCircuitBreakerRuleResponseBody.Data.Results] = []
                for v in dict["Results"] as! [Any] {
                    var model = ListGatewayCircuitBreakerRuleResponseBody.Data.Results()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.results = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: ListGatewayCircuitBreakerRuleResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListGatewayCircuitBreakerRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListGatewayCircuitBreakerRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayCircuitBreakerRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayCircuitBreakerRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayDomainRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var domainName: String?

    public var gatewayUniqueId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListGatewayDomainResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Comment : Tea.TeaModel {
            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var certBeforeDate: String?

        public var certIdentifier: String?

        public var comment: ListGatewayDomainResponseBody.Data.Comment?

        public var gatewayId: Int64?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var http2: String?

        public var id: Int64?

        public var mustHttps: Bool?

        public var name: String?

        public var protocol_: String?

        public var status: Int32?

        public var tlsMax: String?

        public var tlsMin: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.comment?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certBeforeDate != nil {
                map["CertBeforeDate"] = self.certBeforeDate!
            }
            if self.certIdentifier != nil {
                map["CertIdentifier"] = self.certIdentifier!
            }
            if self.comment != nil {
                map["Comment"] = self.comment?.toMap()
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.http2 != nil {
                map["Http2"] = self.http2!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.mustHttps != nil {
                map["MustHttps"] = self.mustHttps!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tlsMax != nil {
                map["TlsMax"] = self.tlsMax!
            }
            if self.tlsMin != nil {
                map["TlsMin"] = self.tlsMin!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertBeforeDate") {
                self.certBeforeDate = dict["CertBeforeDate"] as! String
            }
            if dict.keys.contains("CertIdentifier") {
                self.certIdentifier = dict["CertIdentifier"] as! String
            }
            if dict.keys.contains("Comment") {
                var model = ListGatewayDomainResponseBody.Data.Comment()
                model.fromMap(dict["Comment"] as! [String: Any])
                self.comment = model
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Http2") {
                self.http2 = dict["Http2"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MustHttps") {
                self.mustHttps = dict["MustHttps"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("TlsMax") {
                self.tlsMax = dict["TlsMax"] as! String
            }
            if dict.keys.contains("TlsMin") {
                self.tlsMin = dict["TlsMin"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListGatewayDomainResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListGatewayDomainResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListGatewayDomainResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayFlowRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var filterParams: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.filterParams != nil {
            map["FilterParams"] = self.filterParams!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("FilterParams") {
            self.filterParams = dict["FilterParams"] as! String
        }
    }
}

public class ListGatewayFlowRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var behaviorType: Int32?

            public var bodyEncoding: Int32?

            public var enable: Int32?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var id: Int64?

            public var responseContentBody: String?

            public var responseRedirectUrl: String?

            public var responseStatusCode: Int32?

            public var routeId: Int64?

            public var routeName: String?

            public var threshold: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.behaviorType != nil {
                    map["BehaviorType"] = self.behaviorType!
                }
                if self.bodyEncoding != nil {
                    map["BodyEncoding"] = self.bodyEncoding!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.responseContentBody != nil {
                    map["ResponseContentBody"] = self.responseContentBody!
                }
                if self.responseRedirectUrl != nil {
                    map["ResponseRedirectUrl"] = self.responseRedirectUrl!
                }
                if self.responseStatusCode != nil {
                    map["ResponseStatusCode"] = self.responseStatusCode!
                }
                if self.routeId != nil {
                    map["RouteId"] = self.routeId!
                }
                if self.routeName != nil {
                    map["RouteName"] = self.routeName!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BehaviorType") {
                    self.behaviorType = dict["BehaviorType"] as! Int32
                }
                if dict.keys.contains("BodyEncoding") {
                    self.bodyEncoding = dict["BodyEncoding"] as! Int32
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Int32
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ResponseContentBody") {
                    self.responseContentBody = dict["ResponseContentBody"] as! String
                }
                if dict.keys.contains("ResponseRedirectUrl") {
                    self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
                }
                if dict.keys.contains("ResponseStatusCode") {
                    self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
                }
                if dict.keys.contains("RouteId") {
                    self.routeId = dict["RouteId"] as! Int64
                }
                if dict.keys.contains("RouteName") {
                    self.routeName = dict["RouteName"] as! String
                }
                if dict.keys.contains("Threshold") {
                    self.threshold = dict["Threshold"] as! Int32
                }
            }
        }
        public class Results : Tea.TeaModel {
            public var behaviorType: Int32?

            public var bodyEncoding: Int32?

            public var enable: Int32?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var id: Int64?

            public var idList: [Int64]?

            public var limitMode: Int32?

            public var responseAdditionalHeaders: String?

            public var responseContentBody: String?

            public var responseRedirectUrl: String?

            public var responseStatusCode: Int32?

            public var routeId: Int64?

            public var routeName: String?

            public var statDurationMs: Int32?

            public var threshold: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.behaviorType != nil {
                    map["BehaviorType"] = self.behaviorType!
                }
                if self.bodyEncoding != nil {
                    map["BodyEncoding"] = self.bodyEncoding!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.idList != nil {
                    map["IdList"] = self.idList!
                }
                if self.limitMode != nil {
                    map["LimitMode"] = self.limitMode!
                }
                if self.responseAdditionalHeaders != nil {
                    map["ResponseAdditionalHeaders"] = self.responseAdditionalHeaders!
                }
                if self.responseContentBody != nil {
                    map["ResponseContentBody"] = self.responseContentBody!
                }
                if self.responseRedirectUrl != nil {
                    map["ResponseRedirectUrl"] = self.responseRedirectUrl!
                }
                if self.responseStatusCode != nil {
                    map["ResponseStatusCode"] = self.responseStatusCode!
                }
                if self.routeId != nil {
                    map["RouteId"] = self.routeId!
                }
                if self.routeName != nil {
                    map["RouteName"] = self.routeName!
                }
                if self.statDurationMs != nil {
                    map["StatDurationMs"] = self.statDurationMs!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BehaviorType") {
                    self.behaviorType = dict["BehaviorType"] as! Int32
                }
                if dict.keys.contains("BodyEncoding") {
                    self.bodyEncoding = dict["BodyEncoding"] as! Int32
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Int32
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IdList") {
                    self.idList = dict["IdList"] as! [Int64]
                }
                if dict.keys.contains("LimitMode") {
                    self.limitMode = dict["LimitMode"] as! Int32
                }
                if dict.keys.contains("ResponseAdditionalHeaders") {
                    self.responseAdditionalHeaders = dict["ResponseAdditionalHeaders"] as! String
                }
                if dict.keys.contains("ResponseContentBody") {
                    self.responseContentBody = dict["ResponseContentBody"] as! String
                }
                if dict.keys.contains("ResponseRedirectUrl") {
                    self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
                }
                if dict.keys.contains("ResponseStatusCode") {
                    self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
                }
                if dict.keys.contains("RouteId") {
                    self.routeId = dict["RouteId"] as! Int64
                }
                if dict.keys.contains("RouteName") {
                    self.routeName = dict["RouteName"] as! String
                }
                if dict.keys.contains("StatDurationMs") {
                    self.statDurationMs = dict["StatDurationMs"] as! Int32
                }
                if dict.keys.contains("Threshold") {
                    self.threshold = dict["Threshold"] as! Int32
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayFlowRuleResponseBody.Data.Result]?

        public var results: [ListGatewayFlowRuleResponseBody.Data.Results]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.results != nil {
                var tmp : [Any] = []
                for k in self.results! {
                    tmp.append(k.toMap())
                }
                map["Results"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListGatewayFlowRuleResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGatewayFlowRuleResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("Results") {
                var tmp : [ListGatewayFlowRuleResponseBody.Data.Results] = []
                for v in dict["Results"] as! [Any] {
                    var model = ListGatewayFlowRuleResponseBody.Data.Results()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.results = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: ListGatewayFlowRuleResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListGatewayFlowRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListGatewayFlowRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayFlowRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayFlowRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayIsolationRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var filterParams: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.filterParams != nil {
            map["FilterParams"] = self.filterParams!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("FilterParams") {
            self.filterParams = dict["FilterParams"] as! String
        }
    }
}

public class ListGatewayIsolationRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var behaviorType: Int32?

            public var bodyEncoding: Int32?

            public var enable: Int32?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var id: Int64?

            public var idList: [Int64]?

            public var limitMode: Int32?

            public var maxConcurrency: Int32?

            public var responseAdditionalHeaders: String?

            public var responseContentBody: String?

            public var responseRedirectUrl: String?

            public var responseStatusCode: Int32?

            public var routeId: Int64?

            public var routeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.behaviorType != nil {
                    map["BehaviorType"] = self.behaviorType!
                }
                if self.bodyEncoding != nil {
                    map["BodyEncoding"] = self.bodyEncoding!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.idList != nil {
                    map["IdList"] = self.idList!
                }
                if self.limitMode != nil {
                    map["LimitMode"] = self.limitMode!
                }
                if self.maxConcurrency != nil {
                    map["MaxConcurrency"] = self.maxConcurrency!
                }
                if self.responseAdditionalHeaders != nil {
                    map["ResponseAdditionalHeaders"] = self.responseAdditionalHeaders!
                }
                if self.responseContentBody != nil {
                    map["ResponseContentBody"] = self.responseContentBody!
                }
                if self.responseRedirectUrl != nil {
                    map["ResponseRedirectUrl"] = self.responseRedirectUrl!
                }
                if self.responseStatusCode != nil {
                    map["ResponseStatusCode"] = self.responseStatusCode!
                }
                if self.routeId != nil {
                    map["RouteId"] = self.routeId!
                }
                if self.routeName != nil {
                    map["RouteName"] = self.routeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BehaviorType") {
                    self.behaviorType = dict["BehaviorType"] as! Int32
                }
                if dict.keys.contains("BodyEncoding") {
                    self.bodyEncoding = dict["BodyEncoding"] as! Int32
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Int32
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IdList") {
                    self.idList = dict["IdList"] as! [Int64]
                }
                if dict.keys.contains("LimitMode") {
                    self.limitMode = dict["LimitMode"] as! Int32
                }
                if dict.keys.contains("MaxConcurrency") {
                    self.maxConcurrency = dict["MaxConcurrency"] as! Int32
                }
                if dict.keys.contains("ResponseAdditionalHeaders") {
                    self.responseAdditionalHeaders = dict["ResponseAdditionalHeaders"] as! String
                }
                if dict.keys.contains("ResponseContentBody") {
                    self.responseContentBody = dict["ResponseContentBody"] as! String
                }
                if dict.keys.contains("ResponseRedirectUrl") {
                    self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
                }
                if dict.keys.contains("ResponseStatusCode") {
                    self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
                }
                if dict.keys.contains("RouteId") {
                    self.routeId = dict["RouteId"] as! Int64
                }
                if dict.keys.contains("RouteName") {
                    self.routeName = dict["RouteName"] as! String
                }
            }
        }
        public class Results : Tea.TeaModel {
            public var behaviorType: Int32?

            public var bodyEncoding: Int32?

            public var enable: Int32?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var id: Int64?

            public var idList: [Int64]?

            public var limitMode: Int32?

            public var maxConcurrency: Int32?

            public var responseAdditionalHeaders: String?

            public var responseContentBody: String?

            public var responseRedirectUrl: String?

            public var responseStatusCode: Int32?

            public var routeId: Int64?

            public var routeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.behaviorType != nil {
                    map["BehaviorType"] = self.behaviorType!
                }
                if self.bodyEncoding != nil {
                    map["BodyEncoding"] = self.bodyEncoding!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.idList != nil {
                    map["IdList"] = self.idList!
                }
                if self.limitMode != nil {
                    map["LimitMode"] = self.limitMode!
                }
                if self.maxConcurrency != nil {
                    map["MaxConcurrency"] = self.maxConcurrency!
                }
                if self.responseAdditionalHeaders != nil {
                    map["ResponseAdditionalHeaders"] = self.responseAdditionalHeaders!
                }
                if self.responseContentBody != nil {
                    map["ResponseContentBody"] = self.responseContentBody!
                }
                if self.responseRedirectUrl != nil {
                    map["ResponseRedirectUrl"] = self.responseRedirectUrl!
                }
                if self.responseStatusCode != nil {
                    map["ResponseStatusCode"] = self.responseStatusCode!
                }
                if self.routeId != nil {
                    map["RouteId"] = self.routeId!
                }
                if self.routeName != nil {
                    map["RouteName"] = self.routeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BehaviorType") {
                    self.behaviorType = dict["BehaviorType"] as! Int32
                }
                if dict.keys.contains("BodyEncoding") {
                    self.bodyEncoding = dict["BodyEncoding"] as! Int32
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Int32
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IdList") {
                    self.idList = dict["IdList"] as! [Int64]
                }
                if dict.keys.contains("LimitMode") {
                    self.limitMode = dict["LimitMode"] as! Int32
                }
                if dict.keys.contains("MaxConcurrency") {
                    self.maxConcurrency = dict["MaxConcurrency"] as! Int32
                }
                if dict.keys.contains("ResponseAdditionalHeaders") {
                    self.responseAdditionalHeaders = dict["ResponseAdditionalHeaders"] as! String
                }
                if dict.keys.contains("ResponseContentBody") {
                    self.responseContentBody = dict["ResponseContentBody"] as! String
                }
                if dict.keys.contains("ResponseRedirectUrl") {
                    self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
                }
                if dict.keys.contains("ResponseStatusCode") {
                    self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
                }
                if dict.keys.contains("RouteId") {
                    self.routeId = dict["RouteId"] as! Int64
                }
                if dict.keys.contains("RouteName") {
                    self.routeName = dict["RouteName"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayIsolationRuleResponseBody.Data.Result]?

        public var results: [ListGatewayIsolationRuleResponseBody.Data.Results]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.results != nil {
                var tmp : [Any] = []
                for k in self.results! {
                    tmp.append(k.toMap())
                }
                map["Results"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListGatewayIsolationRuleResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGatewayIsolationRuleResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("Results") {
                var tmp : [ListGatewayIsolationRuleResponseBody.Data.Results] = []
                for v in dict["Results"] as! [Any] {
                    var model = ListGatewayIsolationRuleResponseBody.Data.Results()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.results = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: ListGatewayIsolationRuleResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListGatewayIsolationRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListGatewayIsolationRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayIsolationRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayIsolationRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayRouteRequest : Tea.TeaModel {
    public class FilterParams : Tea.TeaModel {
        public var defaultServiceId: Int64?

        public var domainId: Int64?

        public var domainName: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var name: String?

        public var path: String?

        public var routeOrder: Int32?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultServiceId != nil {
                map["DefaultServiceId"] = self.defaultServiceId!
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.routeOrder != nil {
                map["RouteOrder"] = self.routeOrder!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultServiceId") {
                self.defaultServiceId = dict["DefaultServiceId"] as! Int64
            }
            if dict.keys.contains("DomainId") {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("RouteOrder") {
                self.routeOrder = dict["RouteOrder"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParams: ListGatewayRouteRequest.FilterParams?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filterParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParams != nil {
            map["FilterParams"] = self.filterParams?.toMap()
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            var model = ListGatewayRouteRequest.FilterParams()
            model.fromMap(dict["FilterParams"] as! [String: Any])
            self.filterParams = model
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayRouteShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParamsShrink: String?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParamsShrink != nil {
            map["FilterParams"] = self.filterParamsShrink!
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            self.filterParamsShrink = dict["FilterParams"] as! String
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class Comment : Tea.TeaModel {
                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DirectResponse : Tea.TeaModel {
                public var body: String?

                public var code: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.body != nil {
                        map["Body"] = self.body!
                    }
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Body") {
                        self.body = dict["Body"] as! String
                    }
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! Int32
                    }
                }
            }
            public class FallbackServices : Tea.TeaModel {
                public var agreementType: String?

                public var groupName: String?

                public var name: String?

                public var namespace: String?

                public var percent: Int32?

                public var serviceId: Int64?

                public var serviceName: String?

                public var servicePort: Int32?

                public var sourceType: String?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agreementType != nil {
                        map["AgreementType"] = self.agreementType!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.namespace != nil {
                        map["Namespace"] = self.namespace!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.serviceId != nil {
                        map["ServiceId"] = self.serviceId!
                    }
                    if self.serviceName != nil {
                        map["ServiceName"] = self.serviceName!
                    }
                    if self.servicePort != nil {
                        map["ServicePort"] = self.servicePort!
                    }
                    if self.sourceType != nil {
                        map["SourceType"] = self.sourceType!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AgreementType") {
                        self.agreementType = dict["AgreementType"] as! String
                    }
                    if dict.keys.contains("GroupName") {
                        self.groupName = dict["GroupName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Namespace") {
                        self.namespace = dict["Namespace"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! Int32
                    }
                    if dict.keys.contains("ServiceId") {
                        self.serviceId = dict["ServiceId"] as! Int64
                    }
                    if dict.keys.contains("ServiceName") {
                        self.serviceName = dict["ServiceName"] as! String
                    }
                    if dict.keys.contains("ServicePort") {
                        self.servicePort = dict["ServicePort"] as! Int32
                    }
                    if dict.keys.contains("SourceType") {
                        self.sourceType = dict["SourceType"] as! String
                    }
                    if dict.keys.contains("Version") {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public class Redirect : Tea.TeaModel {
                public var code: Int32?

                public var host: String?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.host != nil {
                        map["Host"] = self.host!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! Int32
                    }
                    if dict.keys.contains("Host") {
                        self.host = dict["Host"] as! String
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                }
            }
            public class RoutePredicates : Tea.TeaModel {
                public class HeaderPredicates : Tea.TeaModel {
                    public var key: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class PathPredicates : Tea.TeaModel {
                    public var ignoreCase: Bool?

                    public var path: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ignoreCase != nil {
                            map["IgnoreCase"] = self.ignoreCase!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IgnoreCase") {
                            self.ignoreCase = dict["IgnoreCase"] as! Bool
                        }
                        if dict.keys.contains("Path") {
                            self.path = dict["Path"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class QueryPredicates : Tea.TeaModel {
                    public var key: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var headerPredicates: [ListGatewayRouteResponseBody.Data.Result.RoutePredicates.HeaderPredicates]?

                public var methodPredicates: [String]?

                public var pathPredicates: ListGatewayRouteResponseBody.Data.Result.RoutePredicates.PathPredicates?

                public var queryPredicates: [ListGatewayRouteResponseBody.Data.Result.RoutePredicates.QueryPredicates]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.pathPredicates?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerPredicates != nil {
                        var tmp : [Any] = []
                        for k in self.headerPredicates! {
                            tmp.append(k.toMap())
                        }
                        map["HeaderPredicates"] = tmp
                    }
                    if self.methodPredicates != nil {
                        map["MethodPredicates"] = self.methodPredicates!
                    }
                    if self.pathPredicates != nil {
                        map["PathPredicates"] = self.pathPredicates?.toMap()
                    }
                    if self.queryPredicates != nil {
                        var tmp : [Any] = []
                        for k in self.queryPredicates! {
                            tmp.append(k.toMap())
                        }
                        map["QueryPredicates"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderPredicates") {
                        var tmp : [ListGatewayRouteResponseBody.Data.Result.RoutePredicates.HeaderPredicates] = []
                        for v in dict["HeaderPredicates"] as! [Any] {
                            var model = ListGatewayRouteResponseBody.Data.Result.RoutePredicates.HeaderPredicates()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.headerPredicates = tmp
                    }
                    if dict.keys.contains("MethodPredicates") {
                        self.methodPredicates = dict["MethodPredicates"] as! [String]
                    }
                    if dict.keys.contains("PathPredicates") {
                        var model = ListGatewayRouteResponseBody.Data.Result.RoutePredicates.PathPredicates()
                        model.fromMap(dict["PathPredicates"] as! [String: Any])
                        self.pathPredicates = model
                    }
                    if dict.keys.contains("QueryPredicates") {
                        var tmp : [ListGatewayRouteResponseBody.Data.Result.RoutePredicates.QueryPredicates] = []
                        for v in dict["QueryPredicates"] as! [Any] {
                            var model = ListGatewayRouteResponseBody.Data.Result.RoutePredicates.QueryPredicates()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.queryPredicates = tmp
                    }
                }
            }
            public class RouteServices : Tea.TeaModel {
                public class HttpDubboTranscoder : Tea.TeaModel {
                    public class MothedMapList : Tea.TeaModel {
                        public class ParamMapsList : Tea.TeaModel {
                            public var extractKey: String?

                            public var extractKeySpec: String?

                            public var mappingType: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.extractKey != nil {
                                    map["ExtractKey"] = self.extractKey!
                                }
                                if self.extractKeySpec != nil {
                                    map["ExtractKeySpec"] = self.extractKeySpec!
                                }
                                if self.mappingType != nil {
                                    map["MappingType"] = self.mappingType!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("ExtractKey") {
                                    self.extractKey = dict["ExtractKey"] as! String
                                }
                                if dict.keys.contains("ExtractKeySpec") {
                                    self.extractKeySpec = dict["ExtractKeySpec"] as! String
                                }
                                if dict.keys.contains("MappingType") {
                                    self.mappingType = dict["MappingType"] as! String
                                }
                            }
                        }
                        public var dubboMothedName: String?

                        public var httpMothed: String?

                        public var mothedpath: String?

                        public var paramMapsList: [ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList]?

                        public var passThroughAllHeaders: String?

                        public var passThroughList: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dubboMothedName != nil {
                                map["DubboMothedName"] = self.dubboMothedName!
                            }
                            if self.httpMothed != nil {
                                map["HttpMothed"] = self.httpMothed!
                            }
                            if self.mothedpath != nil {
                                map["Mothedpath"] = self.mothedpath!
                            }
                            if self.paramMapsList != nil {
                                var tmp : [Any] = []
                                for k in self.paramMapsList! {
                                    tmp.append(k.toMap())
                                }
                                map["ParamMapsList"] = tmp
                            }
                            if self.passThroughAllHeaders != nil {
                                map["PassThroughAllHeaders"] = self.passThroughAllHeaders!
                            }
                            if self.passThroughList != nil {
                                map["PassThroughList"] = self.passThroughList!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DubboMothedName") {
                                self.dubboMothedName = dict["DubboMothedName"] as! String
                            }
                            if dict.keys.contains("HttpMothed") {
                                self.httpMothed = dict["HttpMothed"] as! String
                            }
                            if dict.keys.contains("Mothedpath") {
                                self.mothedpath = dict["Mothedpath"] as! String
                            }
                            if dict.keys.contains("ParamMapsList") {
                                var tmp : [ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList] = []
                                for v in dict["ParamMapsList"] as! [Any] {
                                    var model = ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList.ParamMapsList()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.paramMapsList = tmp
                            }
                            if dict.keys.contains("PassThroughAllHeaders") {
                                self.passThroughAllHeaders = dict["PassThroughAllHeaders"] as! String
                            }
                            if dict.keys.contains("PassThroughList") {
                                self.passThroughList = dict["PassThroughList"] as! [String]
                            }
                        }
                    }
                    public var dubboServiceGroup: String?

                    public var dubboServiceName: String?

                    public var dubboServiceVersion: String?

                    public var mothedMapList: [ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dubboServiceGroup != nil {
                            map["DubboServiceGroup"] = self.dubboServiceGroup!
                        }
                        if self.dubboServiceName != nil {
                            map["DubboServiceName"] = self.dubboServiceName!
                        }
                        if self.dubboServiceVersion != nil {
                            map["DubboServiceVersion"] = self.dubboServiceVersion!
                        }
                        if self.mothedMapList != nil {
                            var tmp : [Any] = []
                            for k in self.mothedMapList! {
                                tmp.append(k.toMap())
                            }
                            map["MothedMapList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DubboServiceGroup") {
                            self.dubboServiceGroup = dict["DubboServiceGroup"] as! String
                        }
                        if dict.keys.contains("DubboServiceName") {
                            self.dubboServiceName = dict["DubboServiceName"] as! String
                        }
                        if dict.keys.contains("DubboServiceVersion") {
                            self.dubboServiceVersion = dict["DubboServiceVersion"] as! String
                        }
                        if dict.keys.contains("MothedMapList") {
                            var tmp : [ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList] = []
                            for v in dict["MothedMapList"] as! [Any] {
                                var model = ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder.MothedMapList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.mothedMapList = tmp
                        }
                    }
                }
                public var agreementType: String?

                public var groupName: String?

                public var healthStatus: String?

                public var httpDubboTranscoder: ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder?

                public var name: String?

                public var namespace: String?

                public var percent: Int32?

                public var serviceId: Int64?

                public var serviceName: String?

                public var servicePort: Int32?

                public var sourceType: String?

                public var unhealthyEndpoints: [String]?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.httpDubboTranscoder?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agreementType != nil {
                        map["AgreementType"] = self.agreementType!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.healthStatus != nil {
                        map["HealthStatus"] = self.healthStatus!
                    }
                    if self.httpDubboTranscoder != nil {
                        map["HttpDubboTranscoder"] = self.httpDubboTranscoder?.toMap()
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.namespace != nil {
                        map["Namespace"] = self.namespace!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.serviceId != nil {
                        map["ServiceId"] = self.serviceId!
                    }
                    if self.serviceName != nil {
                        map["ServiceName"] = self.serviceName!
                    }
                    if self.servicePort != nil {
                        map["ServicePort"] = self.servicePort!
                    }
                    if self.sourceType != nil {
                        map["SourceType"] = self.sourceType!
                    }
                    if self.unhealthyEndpoints != nil {
                        map["UnhealthyEndpoints"] = self.unhealthyEndpoints!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AgreementType") {
                        self.agreementType = dict["AgreementType"] as! String
                    }
                    if dict.keys.contains("GroupName") {
                        self.groupName = dict["GroupName"] as! String
                    }
                    if dict.keys.contains("HealthStatus") {
                        self.healthStatus = dict["HealthStatus"] as! String
                    }
                    if dict.keys.contains("HttpDubboTranscoder") {
                        var model = ListGatewayRouteResponseBody.Data.Result.RouteServices.HttpDubboTranscoder()
                        model.fromMap(dict["HttpDubboTranscoder"] as! [String: Any])
                        self.httpDubboTranscoder = model
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Namespace") {
                        self.namespace = dict["Namespace"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! Int32
                    }
                    if dict.keys.contains("ServiceId") {
                        self.serviceId = dict["ServiceId"] as! Int64
                    }
                    if dict.keys.contains("ServiceName") {
                        self.serviceName = dict["ServiceName"] as! String
                    }
                    if dict.keys.contains("ServicePort") {
                        self.servicePort = dict["ServicePort"] as! Int32
                    }
                    if dict.keys.contains("SourceType") {
                        self.sourceType = dict["SourceType"] as! String
                    }
                    if dict.keys.contains("UnhealthyEndpoints") {
                        self.unhealthyEndpoints = dict["UnhealthyEndpoints"] as! [String]
                    }
                    if dict.keys.contains("Version") {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public var comment: ListGatewayRouteResponseBody.Data.Result.Comment?

            public var defaultServiceId: Int64?

            public var defaultServiceName: String?

            public var destinationType: String?

            public var directResponse: ListGatewayRouteResponseBody.Data.Result.DirectResponse?

            public var domainId: Int64?

            public var domainIdList: [Int64]?

            public var domainName: String?

            public var domainNameList: [String]?

            public var dynamicRoute: Bool?

            public var enableWaf: String?

            public var fallback: Bool?

            public var fallbackServices: [ListGatewayRouteResponseBody.Data.Result.FallbackServices]?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var name: String?

            public var predicates: String?

            public var redirect: ListGatewayRouteResponseBody.Data.Result.Redirect?

            public var routeOrder: Int32?

            public var routePredicates: ListGatewayRouteResponseBody.Data.Result.RoutePredicates?

            public var routeServices: [ListGatewayRouteResponseBody.Data.Result.RouteServices]?

            public var services: String?

            public var status: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.comment?.validate()
                try self.directResponse?.validate()
                try self.redirect?.validate()
                try self.routePredicates?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comment != nil {
                    map["Comment"] = self.comment?.toMap()
                }
                if self.defaultServiceId != nil {
                    map["DefaultServiceId"] = self.defaultServiceId!
                }
                if self.defaultServiceName != nil {
                    map["DefaultServiceName"] = self.defaultServiceName!
                }
                if self.destinationType != nil {
                    map["DestinationType"] = self.destinationType!
                }
                if self.directResponse != nil {
                    map["DirectResponse"] = self.directResponse?.toMap()
                }
                if self.domainId != nil {
                    map["DomainId"] = self.domainId!
                }
                if self.domainIdList != nil {
                    map["DomainIdList"] = self.domainIdList!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.domainNameList != nil {
                    map["DomainNameList"] = self.domainNameList!
                }
                if self.dynamicRoute != nil {
                    map["DynamicRoute"] = self.dynamicRoute!
                }
                if self.enableWaf != nil {
                    map["EnableWaf"] = self.enableWaf!
                }
                if self.fallback != nil {
                    map["Fallback"] = self.fallback!
                }
                if self.fallbackServices != nil {
                    var tmp : [Any] = []
                    for k in self.fallbackServices! {
                        tmp.append(k.toMap())
                    }
                    map["FallbackServices"] = tmp
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.predicates != nil {
                    map["Predicates"] = self.predicates!
                }
                if self.redirect != nil {
                    map["Redirect"] = self.redirect?.toMap()
                }
                if self.routeOrder != nil {
                    map["RouteOrder"] = self.routeOrder!
                }
                if self.routePredicates != nil {
                    map["RoutePredicates"] = self.routePredicates?.toMap()
                }
                if self.routeServices != nil {
                    var tmp : [Any] = []
                    for k in self.routeServices! {
                        tmp.append(k.toMap())
                    }
                    map["RouteServices"] = tmp
                }
                if self.services != nil {
                    map["Services"] = self.services!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Comment") {
                    var model = ListGatewayRouteResponseBody.Data.Result.Comment()
                    model.fromMap(dict["Comment"] as! [String: Any])
                    self.comment = model
                }
                if dict.keys.contains("DefaultServiceId") {
                    self.defaultServiceId = dict["DefaultServiceId"] as! Int64
                }
                if dict.keys.contains("DefaultServiceName") {
                    self.defaultServiceName = dict["DefaultServiceName"] as! String
                }
                if dict.keys.contains("DestinationType") {
                    self.destinationType = dict["DestinationType"] as! String
                }
                if dict.keys.contains("DirectResponse") {
                    var model = ListGatewayRouteResponseBody.Data.Result.DirectResponse()
                    model.fromMap(dict["DirectResponse"] as! [String: Any])
                    self.directResponse = model
                }
                if dict.keys.contains("DomainId") {
                    self.domainId = dict["DomainId"] as! Int64
                }
                if dict.keys.contains("DomainIdList") {
                    self.domainIdList = dict["DomainIdList"] as! [Int64]
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("DomainNameList") {
                    self.domainNameList = dict["DomainNameList"] as! [String]
                }
                if dict.keys.contains("DynamicRoute") {
                    self.dynamicRoute = dict["DynamicRoute"] as! Bool
                }
                if dict.keys.contains("EnableWaf") {
                    self.enableWaf = dict["EnableWaf"] as! String
                }
                if dict.keys.contains("Fallback") {
                    self.fallback = dict["Fallback"] as! Bool
                }
                if dict.keys.contains("FallbackServices") {
                    var tmp : [ListGatewayRouteResponseBody.Data.Result.FallbackServices] = []
                    for v in dict["FallbackServices"] as! [Any] {
                        var model = ListGatewayRouteResponseBody.Data.Result.FallbackServices()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.fallbackServices = tmp
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Predicates") {
                    self.predicates = dict["Predicates"] as! String
                }
                if dict.keys.contains("Redirect") {
                    var model = ListGatewayRouteResponseBody.Data.Result.Redirect()
                    model.fromMap(dict["Redirect"] as! [String: Any])
                    self.redirect = model
                }
                if dict.keys.contains("RouteOrder") {
                    self.routeOrder = dict["RouteOrder"] as! Int32
                }
                if dict.keys.contains("RoutePredicates") {
                    var model = ListGatewayRouteResponseBody.Data.Result.RoutePredicates()
                    model.fromMap(dict["RoutePredicates"] as! [String: Any])
                    self.routePredicates = model
                }
                if dict.keys.contains("RouteServices") {
                    var tmp : [ListGatewayRouteResponseBody.Data.Result.RouteServices] = []
                    for v in dict["RouteServices"] as! [Any] {
                        var model = ListGatewayRouteResponseBody.Data.Result.RouteServices()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.routeServices = tmp
                }
                if dict.keys.contains("Services") {
                    self.services = dict["Services"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayRouteResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListGatewayRouteResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGatewayRouteResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListGatewayRouteResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListGatewayRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayRouteOnAuthRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListGatewayRouteOnAuthResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RoutePredicates : Tea.TeaModel {
            public class PathPredicates : Tea.TeaModel {
                public var path: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var pathPredicates: ListGatewayRouteOnAuthResponseBody.Data.RoutePredicates.PathPredicates?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pathPredicates?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pathPredicates != nil {
                    map["PathPredicates"] = self.pathPredicates?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PathPredicates") {
                    var model = ListGatewayRouteOnAuthResponseBody.Data.RoutePredicates.PathPredicates()
                    model.fromMap(dict["PathPredicates"] as! [String: Any])
                    self.pathPredicates = model
                }
            }
        }
        public var domainId: Int64?

        public var domainIdList: [Int64]?

        public var domainName: String?

        public var domainNameList: [String]?

        public var gatewayId: String?

        public var gatewayUniqueId: String?

        public var id: Int32?

        public var name: String?

        public var routePredicates: ListGatewayRouteOnAuthResponseBody.Data.RoutePredicates?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.routePredicates?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainIdList != nil {
                map["DomainIdList"] = self.domainIdList!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainNameList != nil {
                map["DomainNameList"] = self.domainNameList!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.routePredicates != nil {
                map["RoutePredicates"] = self.routePredicates?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainId") {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainIdList") {
                self.domainIdList = dict["DomainIdList"] as! [Int64]
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainNameList") {
                self.domainNameList = dict["DomainNameList"] as! [String]
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! String
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RoutePredicates") {
                var model = ListGatewayRouteOnAuthResponseBody.Data.RoutePredicates()
                model.fromMap(dict["RoutePredicates"] as! [String: Any])
                self.routePredicates = model
            }
        }
    }
    public var code: Int32?

    public var data: [ListGatewayRouteOnAuthResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListGatewayRouteOnAuthResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListGatewayRouteOnAuthResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayRouteOnAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayRouteOnAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayRouteOnAuthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayServiceRequest : Tea.TeaModel {
    public class FilterParams : Tea.TeaModel {
        public var gatewayUniqueId: String?

        public var groupName: String?

        public var name: String?

        public var namespace: String?

        public var serviceProtocol: String?

        public var sourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ServiceProtocol") {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParams: ListGatewayServiceRequest.FilterParams?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filterParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParams != nil {
            map["FilterParams"] = self.filterParams?.toMap()
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            var model = ListGatewayServiceRequest.FilterParams()
            model.fromMap(dict["FilterParams"] as! [String: Any])
            self.filterParams = model
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayServiceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var descSort: Bool?

    public var filterParamsShrink: String?

    public var orderItem: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.descSort != nil {
            map["DescSort"] = self.descSort!
        }
        if self.filterParamsShrink != nil {
            map["FilterParams"] = self.filterParamsShrink!
        }
        if self.orderItem != nil {
            map["OrderItem"] = self.orderItem!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DescSort") {
            self.descSort = dict["DescSort"] as! Bool
        }
        if dict.keys.contains("FilterParams") {
            self.filterParamsShrink = dict["FilterParams"] as! String
        }
        if dict.keys.contains("OrderItem") {
            self.orderItem = dict["OrderItem"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListGatewayServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class GatewayTrafficPolicy : Tea.TeaModel {
                public class LoadBalancerSettings : Tea.TeaModel {
                    public class ConsistentHashLBConfig : Tea.TeaModel {
                        public class HttpCookie : Tea.TeaModel {
                            public var name: String?

                            public var path: String?

                            public var ttl: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.name != nil {
                                    map["Name"] = self.name!
                                }
                                if self.path != nil {
                                    map["Path"] = self.path!
                                }
                                if self.ttl != nil {
                                    map["Ttl"] = self.ttl!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Name") {
                                    self.name = dict["Name"] as! String
                                }
                                if dict.keys.contains("Path") {
                                    self.path = dict["Path"] as! String
                                }
                                if dict.keys.contains("Ttl") {
                                    self.ttl = dict["Ttl"] as! String
                                }
                            }
                        }
                        public var consistentHashLBType: String?

                        public var httpCookie: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig.HttpCookie?

                        public var minimumRingSize: Int64?

                        public var parameterName: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.httpCookie?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.consistentHashLBType != nil {
                                map["ConsistentHashLBType"] = self.consistentHashLBType!
                            }
                            if self.httpCookie != nil {
                                map["HttpCookie"] = self.httpCookie?.toMap()
                            }
                            if self.minimumRingSize != nil {
                                map["MinimumRingSize"] = self.minimumRingSize!
                            }
                            if self.parameterName != nil {
                                map["ParameterName"] = self.parameterName!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ConsistentHashLBType") {
                                self.consistentHashLBType = dict["ConsistentHashLBType"] as! String
                            }
                            if dict.keys.contains("HttpCookie") {
                                var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig.HttpCookie()
                                model.fromMap(dict["HttpCookie"] as! [String: Any])
                                self.httpCookie = model
                            }
                            if dict.keys.contains("MinimumRingSize") {
                                self.minimumRingSize = dict["MinimumRingSize"] as! Int64
                            }
                            if dict.keys.contains("ParameterName") {
                                self.parameterName = dict["ParameterName"] as! String
                            }
                        }
                    }
                    public var consistentHashLBConfig: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig?

                    public var loadbalancerType: String?

                    public var warmupDuration: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.consistentHashLBConfig?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.consistentHashLBConfig != nil {
                            map["ConsistentHashLBConfig"] = self.consistentHashLBConfig?.toMap()
                        }
                        if self.loadbalancerType != nil {
                            map["LoadbalancerType"] = self.loadbalancerType!
                        }
                        if self.warmupDuration != nil {
                            map["WarmupDuration"] = self.warmupDuration!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConsistentHashLBConfig") {
                            var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings.ConsistentHashLBConfig()
                            model.fromMap(dict["ConsistentHashLBConfig"] as! [String: Any])
                            self.consistentHashLBConfig = model
                        }
                        if dict.keys.contains("LoadbalancerType") {
                            self.loadbalancerType = dict["LoadbalancerType"] as! String
                        }
                        if dict.keys.contains("WarmupDuration") {
                            self.warmupDuration = dict["WarmupDuration"] as! Int32
                        }
                    }
                }
                public class Tls : Tea.TeaModel {
                    public var caCertContent: String?

                    public var caCertId: String?

                    public var certId: String?

                    public var mode: String?

                    public var sni: String?

                    public var subjectAltNames: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.caCertContent != nil {
                            map["CaCertContent"] = self.caCertContent!
                        }
                        if self.caCertId != nil {
                            map["CaCertId"] = self.caCertId!
                        }
                        if self.certId != nil {
                            map["CertId"] = self.certId!
                        }
                        if self.mode != nil {
                            map["Mode"] = self.mode!
                        }
                        if self.sni != nil {
                            map["Sni"] = self.sni!
                        }
                        if self.subjectAltNames != nil {
                            map["SubjectAltNames"] = self.subjectAltNames!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CaCertContent") {
                            self.caCertContent = dict["CaCertContent"] as! String
                        }
                        if dict.keys.contains("CaCertId") {
                            self.caCertId = dict["CaCertId"] as! String
                        }
                        if dict.keys.contains("CertId") {
                            self.certId = dict["CertId"] as! String
                        }
                        if dict.keys.contains("Mode") {
                            self.mode = dict["Mode"] as! String
                        }
                        if dict.keys.contains("Sni") {
                            self.sni = dict["Sni"] as! String
                        }
                        if dict.keys.contains("SubjectAltNames") {
                            self.subjectAltNames = dict["SubjectAltNames"] as! [String]
                        }
                    }
                }
                public var loadBalancerSettings: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings?

                public var tls: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.Tls?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.loadBalancerSettings?.validate()
                    try self.tls?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.loadBalancerSettings != nil {
                        map["LoadBalancerSettings"] = self.loadBalancerSettings?.toMap()
                    }
                    if self.tls != nil {
                        map["Tls"] = self.tls?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LoadBalancerSettings") {
                        var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.LoadBalancerSettings()
                        model.fromMap(dict["LoadBalancerSettings"] as! [String: Any])
                        self.loadBalancerSettings = model
                    }
                    if dict.keys.contains("Tls") {
                        var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy.Tls()
                        model.fromMap(dict["Tls"] as! [String: Any])
                        self.tls = model
                    }
                }
            }
            public class HealthCheckInfo : Tea.TeaModel {
                public var check: Bool?

                public var expectedStatuses: [Int32]?

                public var healthyThreshold: Int32?

                public var httpHost: String?

                public var httpPath: String?

                public var interval: Int32?

                public var protocol_: String?

                public var timeout: Int32?

                public var unhealthyThreshold: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.check != nil {
                        map["Check"] = self.check!
                    }
                    if self.expectedStatuses != nil {
                        map["ExpectedStatuses"] = self.expectedStatuses!
                    }
                    if self.healthyThreshold != nil {
                        map["HealthyThreshold"] = self.healthyThreshold!
                    }
                    if self.httpHost != nil {
                        map["HttpHost"] = self.httpHost!
                    }
                    if self.httpPath != nil {
                        map["HttpPath"] = self.httpPath!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    if self.unhealthyThreshold != nil {
                        map["UnhealthyThreshold"] = self.unhealthyThreshold!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Check") {
                        self.check = dict["Check"] as! Bool
                    }
                    if dict.keys.contains("ExpectedStatuses") {
                        self.expectedStatuses = dict["ExpectedStatuses"] as! [Int32]
                    }
                    if dict.keys.contains("HealthyThreshold") {
                        self.healthyThreshold = dict["HealthyThreshold"] as! Int32
                    }
                    if dict.keys.contains("HttpHost") {
                        self.httpHost = dict["HttpHost"] as! String
                    }
                    if dict.keys.contains("HttpPath") {
                        self.httpPath = dict["HttpPath"] as! String
                    }
                    if dict.keys.contains("Interval") {
                        self.interval = dict["Interval"] as! Int32
                    }
                    if dict.keys.contains("Protocol") {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                    if dict.keys.contains("Timeout") {
                        self.timeout = dict["Timeout"] as! Int32
                    }
                    if dict.keys.contains("UnhealthyThreshold") {
                        self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
                    }
                }
            }
            public class Versions : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var dnsServerList: [String]?

            public var gatewayId: Int64?

            public var gatewayTrafficPolicy: ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy?

            public var gatewayUniqueId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var groupName: String?

            public var healehStatus: String?

            public var healthCheck: Bool?

            public var healthCheckInfo: ListGatewayServiceResponseBody.Data.Result.HealthCheckInfo?

            public var healthStatus: String?

            public var id: Int64?

            public var ips: [String]?

            public var metaInfo: String?

            public var name: String?

            public var namespace: String?

            public var ports: [Int32]?

            public var serviceFQDN: String?

            public var serviceNameInRegistry: String?

            public var servicePort: Int64?

            public var serviceProtocol: String?

            public var sourceId: Int64?

            public var sourceType: String?

            public var unhealthyEndpoints: [String]?

            public var versions: [ListGatewayServiceResponseBody.Data.Result.Versions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.gatewayTrafficPolicy?.validate()
                try self.healthCheckInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dnsServerList != nil {
                    map["DnsServerList"] = self.dnsServerList!
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayTrafficPolicy != nil {
                    map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicy?.toMap()
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.healehStatus != nil {
                    map["HealehStatus"] = self.healehStatus!
                }
                if self.healthCheck != nil {
                    map["HealthCheck"] = self.healthCheck!
                }
                if self.healthCheckInfo != nil {
                    map["HealthCheckInfo"] = self.healthCheckInfo?.toMap()
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips!
                }
                if self.metaInfo != nil {
                    map["MetaInfo"] = self.metaInfo!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.ports != nil {
                    map["Ports"] = self.ports!
                }
                if self.serviceFQDN != nil {
                    map["ServiceFQDN"] = self.serviceFQDN!
                }
                if self.serviceNameInRegistry != nil {
                    map["ServiceNameInRegistry"] = self.serviceNameInRegistry!
                }
                if self.servicePort != nil {
                    map["ServicePort"] = self.servicePort!
                }
                if self.serviceProtocol != nil {
                    map["ServiceProtocol"] = self.serviceProtocol!
                }
                if self.sourceId != nil {
                    map["SourceId"] = self.sourceId!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.unhealthyEndpoints != nil {
                    map["UnhealthyEndpoints"] = self.unhealthyEndpoints!
                }
                if self.versions != nil {
                    var tmp : [Any] = []
                    for k in self.versions! {
                        tmp.append(k.toMap())
                    }
                    map["Versions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DnsServerList") {
                    self.dnsServerList = dict["DnsServerList"] as! [String]
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayTrafficPolicy") {
                    var model = ListGatewayServiceResponseBody.Data.Result.GatewayTrafficPolicy()
                    model.fromMap(dict["GatewayTrafficPolicy"] as! [String: Any])
                    self.gatewayTrafficPolicy = model
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("HealehStatus") {
                    self.healehStatus = dict["HealehStatus"] as! String
                }
                if dict.keys.contains("HealthCheck") {
                    self.healthCheck = dict["HealthCheck"] as! Bool
                }
                if dict.keys.contains("HealthCheckInfo") {
                    var model = ListGatewayServiceResponseBody.Data.Result.HealthCheckInfo()
                    model.fromMap(dict["HealthCheckInfo"] as! [String: Any])
                    self.healthCheckInfo = model
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Ips") {
                    self.ips = dict["Ips"] as! [String]
                }
                if dict.keys.contains("MetaInfo") {
                    self.metaInfo = dict["MetaInfo"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Ports") {
                    self.ports = dict["Ports"] as! [Int32]
                }
                if dict.keys.contains("ServiceFQDN") {
                    self.serviceFQDN = dict["ServiceFQDN"] as! String
                }
                if dict.keys.contains("ServiceNameInRegistry") {
                    self.serviceNameInRegistry = dict["ServiceNameInRegistry"] as! String
                }
                if dict.keys.contains("ServicePort") {
                    self.servicePort = dict["ServicePort"] as! Int64
                }
                if dict.keys.contains("ServiceProtocol") {
                    self.serviceProtocol = dict["ServiceProtocol"] as! String
                }
                if dict.keys.contains("SourceId") {
                    self.sourceId = dict["SourceId"] as! Int64
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("UnhealthyEndpoints") {
                    self.unhealthyEndpoints = dict["UnhealthyEndpoints"] as! [String]
                }
                if dict.keys.contains("Versions") {
                    var tmp : [ListGatewayServiceResponseBody.Data.Result.Versions] = []
                    for v in dict["Versions"] as! [Any] {
                        var model = ListGatewayServiceResponseBody.Data.Result.Versions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.versions = tmp
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListGatewayServiceResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListGatewayServiceResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGatewayServiceResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: Int32?

    public var data: ListGatewayServiceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListGatewayServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewaySlbRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class ListGatewaySlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class VServiceList : Tea.TeaModel {
            public var port: String?

            public var protocol_: String?

            public var VServerGroupId: String?

            public var VServerGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.VServerGroupId != nil {
                    map["VServerGroupId"] = self.VServerGroupId!
                }
                if self.VServerGroupName != nil {
                    map["VServerGroupName"] = self.VServerGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("VServerGroupId") {
                    self.VServerGroupId = dict["VServerGroupId"] as! String
                }
                if dict.keys.contains("VServerGroupName") {
                    self.VServerGroupName = dict["VServerGroupName"] as! String
                }
            }
        }
        public var editEnable: Bool?

        public var gatewayId: String?

        public var gatewaySlbMode: String?

        public var gatewaySlbStatus: String?

        public var gmtCreate: String?

        public var httpPort: Int32?

        public var httpsPort: Int32?

        public var httpsVServerGroupId: String?

        public var id: String?

        public var serviceWeight: Int32?

        public var slbId: String?

        public var slbIp: String?

        public var slbPort: String?

        public var slbType: String?

        public var statusDesc: String?

        public var type: String?

        public var VServerGroupId: String?

        public var VServiceList: [ListGatewaySlbResponseBody.Data.VServiceList]?

        public var vsMetaInfo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.editEnable != nil {
                map["EditEnable"] = self.editEnable!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewaySlbMode != nil {
                map["GatewaySlbMode"] = self.gatewaySlbMode!
            }
            if self.gatewaySlbStatus != nil {
                map["GatewaySlbStatus"] = self.gatewaySlbStatus!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.httpPort != nil {
                map["HttpPort"] = self.httpPort!
            }
            if self.httpsPort != nil {
                map["HttpsPort"] = self.httpsPort!
            }
            if self.httpsVServerGroupId != nil {
                map["HttpsVServerGroupId"] = self.httpsVServerGroupId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.serviceWeight != nil {
                map["ServiceWeight"] = self.serviceWeight!
            }
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbIp != nil {
                map["SlbIp"] = self.slbIp!
            }
            if self.slbPort != nil {
                map["SlbPort"] = self.slbPort!
            }
            if self.slbType != nil {
                map["SlbType"] = self.slbType!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.VServerGroupId != nil {
                map["VServerGroupId"] = self.VServerGroupId!
            }
            if self.VServiceList != nil {
                var tmp : [Any] = []
                for k in self.VServiceList! {
                    tmp.append(k.toMap())
                }
                map["VServiceList"] = tmp
            }
            if self.vsMetaInfo != nil {
                map["VsMetaInfo"] = self.vsMetaInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EditEnable") {
                self.editEnable = dict["EditEnable"] as! Bool
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! String
            }
            if dict.keys.contains("GatewaySlbMode") {
                self.gatewaySlbMode = dict["GatewaySlbMode"] as! String
            }
            if dict.keys.contains("GatewaySlbStatus") {
                self.gatewaySlbStatus = dict["GatewaySlbStatus"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("HttpPort") {
                self.httpPort = dict["HttpPort"] as! Int32
            }
            if dict.keys.contains("HttpsPort") {
                self.httpsPort = dict["HttpsPort"] as! Int32
            }
            if dict.keys.contains("HttpsVServerGroupId") {
                self.httpsVServerGroupId = dict["HttpsVServerGroupId"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ServiceWeight") {
                self.serviceWeight = dict["ServiceWeight"] as! Int32
            }
            if dict.keys.contains("SlbId") {
                self.slbId = dict["SlbId"] as! String
            }
            if dict.keys.contains("SlbIp") {
                self.slbIp = dict["SlbIp"] as! String
            }
            if dict.keys.contains("SlbPort") {
                self.slbPort = dict["SlbPort"] as! String
            }
            if dict.keys.contains("SlbType") {
                self.slbType = dict["SlbType"] as! String
            }
            if dict.keys.contains("StatusDesc") {
                self.statusDesc = dict["StatusDesc"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("VServerGroupId") {
                self.VServerGroupId = dict["VServerGroupId"] as! String
            }
            if dict.keys.contains("VServiceList") {
                var tmp : [ListGatewaySlbResponseBody.Data.VServiceList] = []
                for v in dict["VServiceList"] as! [Any] {
                    var model = ListGatewaySlbResponseBody.Data.VServiceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VServiceList = tmp
            }
            if dict.keys.contains("VsMetaInfo") {
                self.vsMetaInfo = dict["VsMetaInfo"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListGatewaySlbResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListGatewaySlbResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListGatewaySlbResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewaySlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewaySlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewaySlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGatewayZoneRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class ListGatewayZoneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var localName: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LocalName") {
                self.localName = dict["LocalName"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListGatewayZoneResponseBody.Data]?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListGatewayZoneResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListGatewayZoneResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGatewayZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGatewayZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGatewayZoneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceCountRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterType: String?

    public var mseVersion: String?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("MseVersion") {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListInstanceCountResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [Int32]?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [Int32]
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListInstanceCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstanceCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIsolationRulesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var resource: String?

    public var resourceSearchKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceSearchKey != nil {
            map["ResourceSearchKey"] = self.resourceSearchKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageIndex") {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Resource") {
            self.resource = dict["Resource"] as! String
        }
        if dict.keys.contains("ResourceSearchKey") {
            self.resourceSearchKey = dict["ResourceSearchKey"] as! String
        }
    }
}

public class ListIsolationRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var enable: Bool?

            public var fallbackObject: String?

            public var limitApp: String?

            public var namespace: String?

            public var regionId: String?

            public var resource: String?

            public var ruleId: Int64?

            public var threshold: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.fallbackObject != nil {
                    map["FallbackObject"] = self.fallbackObject!
                }
                if self.limitApp != nil {
                    map["LimitApp"] = self.limitApp!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resource != nil {
                    map["Resource"] = self.resource!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("FallbackObject") {
                    self.fallbackObject = dict["FallbackObject"] as! String
                }
                if dict.keys.contains("LimitApp") {
                    self.limitApp = dict["LimitApp"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Resource") {
                    self.resource = dict["Resource"] as! String
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! Int64
                }
                if dict.keys.contains("Threshold") {
                    self.threshold = dict["Threshold"] as! Int32
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListIsolationRulesResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListIsolationRulesResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListIsolationRulesResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: ListIsolationRulesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListIsolationRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListIsolationRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIsolationRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIsolationRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListListenersByConfigRequest : Tea.TeaModel {
    public class ExtGrayRules : Tea.TeaModel {
        public var grayRule: String?

        public var grayRuleName: String?

        public var grayRulePriority: Int32?

        public var grayRuleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.grayRule != nil {
                map["GrayRule"] = self.grayRule!
            }
            if self.grayRuleName != nil {
                map["GrayRuleName"] = self.grayRuleName!
            }
            if self.grayRulePriority != nil {
                map["GrayRulePriority"] = self.grayRulePriority!
            }
            if self.grayRuleType != nil {
                map["GrayRuleType"] = self.grayRuleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GrayRule") {
                self.grayRule = dict["GrayRule"] as! String
            }
            if dict.keys.contains("GrayRuleName") {
                self.grayRuleName = dict["GrayRuleName"] as! String
            }
            if dict.keys.contains("GrayRulePriority") {
                self.grayRulePriority = dict["GrayRulePriority"] as! Int32
            }
            if dict.keys.contains("GrayRuleType") {
                self.grayRuleType = dict["GrayRuleType"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var dataId: String?

    public var extGrayRules: [ListListenersByConfigRequest.ExtGrayRules]?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.extGrayRules != nil {
            var tmp : [Any] = []
            for k in self.extGrayRules! {
                tmp.append(k.toMap())
            }
            map["ExtGrayRules"] = tmp
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("ExtGrayRules") {
            var tmp : [ListListenersByConfigRequest.ExtGrayRules] = []
            for v in dict["ExtGrayRules"] as! [Any] {
                var model = ListListenersByConfigRequest.ExtGrayRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.extGrayRules = tmp
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListListenersByConfigShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dataId: String?

    public var extGrayRulesShrink: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.extGrayRulesShrink != nil {
            map["ExtGrayRules"] = self.extGrayRulesShrink!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("ExtGrayRules") {
            self.extGrayRulesShrink = dict["ExtGrayRules"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListListenersByConfigResponseBody : Tea.TeaModel {
    public class Listeners : Tea.TeaModel {
        public var ip: String?

        public var labels: [String: String]?

        public var matchRuleName: String?

        public var matchRuleType: String?

        public var md5: String?

        public var status: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.labels != nil {
                map["Labels"] = self.labels!
            }
            if self.matchRuleName != nil {
                map["MatchRuleName"] = self.matchRuleName!
            }
            if self.matchRuleType != nil {
                map["MatchRuleType"] = self.matchRuleType!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Labels") {
                self.labels = dict["Labels"] as! [String: String]
            }
            if dict.keys.contains("MatchRuleName") {
                self.matchRuleName = dict["MatchRuleName"] as! String
            }
            if dict.keys.contains("MatchRuleType") {
                self.matchRuleType = dict["MatchRuleType"] as! String
            }
            if dict.keys.contains("Md5") {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var errorCode: String?

    public var httpCode: String?

    public var listeners: [ListListenersByConfigResponseBody.Listeners]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.listeners != nil {
            var tmp : [Any] = []
            for k in self.listeners! {
                tmp.append(k.toMap())
            }
            map["Listeners"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Listeners") {
            var tmp : [ListListenersByConfigResponseBody.Listeners] = []
            for v in dict["Listeners"] as! [Any] {
                var model = ListListenersByConfigResponseBody.Listeners()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.listeners = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListListenersByConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListListenersByConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListListenersByConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListListenersByIpRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var ip: String?

    public var namespaceId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListListenersByIpResponseBody : Tea.TeaModel {
    public class Listeners : Tea.TeaModel {
        public var dataId: String?

        public var group: String?

        public var md5: String?

        public var namespaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataId") {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Md5") {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
        }
    }
    public var errorCode: String?

    public var httpCode: String?

    public var listeners: [ListListenersByIpResponseBody.Listeners]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.listeners != nil {
            var tmp : [Any] = []
            for k in self.listeners! {
                tmp.append(k.toMap())
            }
            map["Listeners"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Listeners") {
            var tmp : [ListListenersByIpResponseBody.Listeners] = []
            for v in dict["Listeners"] as! [Any] {
                var model = ListListenersByIpResponseBody.Listeners()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.listeners = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListListenersByIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListListenersByIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListListenersByIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMigrationTaskRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var originInstanceName: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.originInstanceName != nil {
            map["OriginInstanceName"] = self.originInstanceName!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("OriginInstanceName") {
            self.originInstanceName = dict["OriginInstanceName"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListMigrationTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterType: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var originInstanceAddress: String?

        public var originInstanceName: String?

        public var originInstanceNamespace: String?

        public var projectDesc: String?

        public var syncType: String?

        public var targetClusterName: String?

        public var targetClusterUrl: String?

        public var targetInstanceId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.originInstanceAddress != nil {
                map["OriginInstanceAddress"] = self.originInstanceAddress!
            }
            if self.originInstanceName != nil {
                map["OriginInstanceName"] = self.originInstanceName!
            }
            if self.originInstanceNamespace != nil {
                map["OriginInstanceNamespace"] = self.originInstanceNamespace!
            }
            if self.projectDesc != nil {
                map["ProjectDesc"] = self.projectDesc!
            }
            if self.syncType != nil {
                map["SyncType"] = self.syncType!
            }
            if self.targetClusterName != nil {
                map["TargetClusterName"] = self.targetClusterName!
            }
            if self.targetClusterUrl != nil {
                map["TargetClusterUrl"] = self.targetClusterUrl!
            }
            if self.targetInstanceId != nil {
                map["TargetInstanceId"] = self.targetInstanceId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterType") {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("OriginInstanceAddress") {
                self.originInstanceAddress = dict["OriginInstanceAddress"] as! String
            }
            if dict.keys.contains("OriginInstanceName") {
                self.originInstanceName = dict["OriginInstanceName"] as! String
            }
            if dict.keys.contains("OriginInstanceNamespace") {
                self.originInstanceNamespace = dict["OriginInstanceNamespace"] as! String
            }
            if dict.keys.contains("ProjectDesc") {
                self.projectDesc = dict["ProjectDesc"] as! String
            }
            if dict.keys.contains("SyncType") {
                self.syncType = dict["SyncType"] as! String
            }
            if dict.keys.contains("TargetClusterName") {
                self.targetClusterName = dict["TargetClusterName"] as! String
            }
            if dict.keys.contains("TargetClusterUrl") {
                self.targetClusterUrl = dict["TargetClusterUrl"] as! String
            }
            if dict.keys.contains("TargetInstanceId") {
                self.targetInstanceId = dict["TargetInstanceId"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var data: [ListMigrationTaskResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListMigrationTaskResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListMigrationTaskResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListMigrationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMigrationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMigrationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNacosConfigsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class ListNacosConfigsResponseBody : Tea.TeaModel {
    public class Configurations : Tea.TeaModel {
        public var appName: String?

        public var dataId: String?

        public var group: String?

        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DataId") {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var code: Int32?

    public var configurations: [ListNacosConfigsResponseBody.Configurations]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.configurations != nil {
            var tmp : [Any] = []
            for k in self.configurations! {
                tmp.append(k.toMap())
            }
            map["Configurations"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Configurations") {
            var tmp : [ListNacosConfigsResponseBody.Configurations] = []
            for v in dict["Configurations"] as! [Any] {
                var model = ListNacosConfigsResponseBody.Configurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.configurations = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListNacosConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNacosConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNacosConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNacosHistoryConfigsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dataId: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class ListNacosHistoryConfigsResponseBody : Tea.TeaModel {
    public class HistoryItems : Tea.TeaModel {
        public var appName: String?

        public var dataId: String?

        public var group: String?

        public var id: Int64?

        public var lastModifiedTime: Int64?

        public var opType: String?

        public var srcUser: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lastModifiedTime != nil {
                map["LastModifiedTime"] = self.lastModifiedTime!
            }
            if self.opType != nil {
                map["OpType"] = self.opType!
            }
            if self.srcUser != nil {
                map["SrcUser"] = self.srcUser!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DataId") {
                self.dataId = dict["DataId"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("LastModifiedTime") {
                self.lastModifiedTime = dict["LastModifiedTime"] as! Int64
            }
            if dict.keys.contains("OpType") {
                self.opType = dict["OpType"] as! String
            }
            if dict.keys.contains("SrcUser") {
                self.srcUser = dict["SrcUser"] as! String
            }
        }
    }
    public var errorCode: String?

    public var historyItems: [ListNacosHistoryConfigsResponseBody.HistoryItems]?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.historyItems != nil {
            var tmp : [Any] = []
            for k in self.historyItems! {
                tmp.append(k.toMap())
            }
            map["HistoryItems"] = tmp
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HistoryItems") {
            var tmp : [ListNacosHistoryConfigsResponseBody.HistoryItems] = []
            for v in dict["HistoryItems"] as! [Any] {
                var model = ListNacosHistoryConfigsResponseBody.HistoryItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.historyItems = tmp
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListNacosHistoryConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNacosHistoryConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNacosHistoryConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNamespacesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class ListNamespacesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var appCount: Int32?

            public var createTime: Int64?

            public var describe: String?

            public var instanceCount: Int64?

            public var namespace: String?

            public var region: String?

            public var updateTime: Int64?

            public var userId: String?

            public var version: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCount != nil {
                    map["AppCount"] = self.appCount!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.describe != nil {
                    map["Describe"] = self.describe!
                }
                if self.instanceCount != nil {
                    map["InstanceCount"] = self.instanceCount!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCount") {
                    self.appCount = dict["AppCount"] as! Int32
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Describe") {
                    self.describe = dict["Describe"] as! String
                }
                if dict.keys.contains("InstanceCount") {
                    self.instanceCount = dict["InstanceCount"] as! Int64
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int32
                }
            }
        }
        public class Results : Tea.TeaModel {
            public var appCount: Int32?

            public var createTime: Int64?

            public var describe: String?

            public var instanceCount: Int64?

            public var namespace: String?

            public var region: String?

            public var updateTime: Int64?

            public var userId: String?

            public var version: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCount != nil {
                    map["AppCount"] = self.appCount!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.describe != nil {
                    map["Describe"] = self.describe!
                }
                if self.instanceCount != nil {
                    map["InstanceCount"] = self.instanceCount!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCount") {
                    self.appCount = dict["AppCount"] as! Int32
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Describe") {
                    self.describe = dict["Describe"] as! String
                }
                if dict.keys.contains("InstanceCount") {
                    self.instanceCount = dict["InstanceCount"] as! Int64
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int32
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [ListNamespacesResponseBody.Data.Result]?

        public var results: [ListNamespacesResponseBody.Data.Results]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.results != nil {
                var tmp : [Any] = []
                for k in self.results! {
                    tmp.append(k.toMap())
                }
                map["Results"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListNamespacesResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListNamespacesResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("Results") {
                var tmp : [ListNamespacesResponseBody.Data.Results] = []
                for v in dict["Results"] as! [Any] {
                    var model = ListNamespacesResponseBody.Data.Results()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.results = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: ListNamespacesResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ListNamespacesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListNamespacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNamespacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNamespacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNamingTrackRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var endTs: Int64?

    public var group: String?

    public var instanceId: String?

    public var ip: String?

    public var namespaceId: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var requestPars: String?

    public var reverse: Bool?

    public var serviceName: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("Reverse") {
            self.reverse = dict["Reverse"] as! Bool
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class ListNamingTrackResponseBody : Tea.TeaModel {
    public class Traces : Tea.TeaModel {
        public var clientIp: String?

        public var group: String?

        public var instanceSize: String?

        public var nodeName: String?

        public var pushTime: String?

        public var pushTimeAll: String?

        public var pushTimeNetwork: String?

        public var serverName: String?

        public var slaTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientIp != nil {
                map["ClientIp"] = self.clientIp!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.instanceSize != nil {
                map["InstanceSize"] = self.instanceSize!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.pushTime != nil {
                map["PushTime"] = self.pushTime!
            }
            if self.pushTimeAll != nil {
                map["PushTimeAll"] = self.pushTimeAll!
            }
            if self.pushTimeNetwork != nil {
                map["PushTimeNetwork"] = self.pushTimeNetwork!
            }
            if self.serverName != nil {
                map["ServerName"] = self.serverName!
            }
            if self.slaTime != nil {
                map["SlaTime"] = self.slaTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientIp") {
                self.clientIp = dict["ClientIp"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("InstanceSize") {
                self.instanceSize = dict["InstanceSize"] as! String
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("PushTime") {
                self.pushTime = dict["PushTime"] as! String
            }
            if dict.keys.contains("PushTimeAll") {
                self.pushTimeAll = dict["PushTimeAll"] as! String
            }
            if dict.keys.contains("PushTimeNetwork") {
                self.pushTimeNetwork = dict["PushTimeNetwork"] as! String
            }
            if dict.keys.contains("ServerName") {
                self.serverName = dict["ServerName"] as! String
            }
            if dict.keys.contains("SlaTime") {
                self.slaTime = dict["SlaTime"] as! String
            }
        }
    }
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var traces: [ListNamingTrackResponseBody.Traces]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.traces != nil {
            var tmp : [Any] = []
            for k in self.traces! {
                tmp.append(k.toMap())
            }
            map["Traces"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("Traces") {
            var tmp : [ListNamingTrackResponseBody.Traces] = []
            for v in dict["Traces"] as! [Any] {
                var model = ListNamingTrackResponseBody.Traces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.traces = tmp
        }
    }
}

public class ListNamingTrackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNamingTrackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNamingTrackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSSLCertRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certName: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certName != nil {
            map["CertName"] = self.certName!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertName") {
            self.certName = dict["CertName"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class ListSSLCertResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var afterDate: String?

        public var algorithm: String?

        public var beforeDate: String?

        public var certIdentifier: String?

        public var certName: String?

        public var commonName: String?

        public var gmtAfter: String?

        public var gmtBefore: String?

        public var issuer: String?

        public var sans: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.afterDate != nil {
                map["AfterDate"] = self.afterDate!
            }
            if self.algorithm != nil {
                map["Algorithm"] = self.algorithm!
            }
            if self.beforeDate != nil {
                map["BeforeDate"] = self.beforeDate!
            }
            if self.certIdentifier != nil {
                map["CertIdentifier"] = self.certIdentifier!
            }
            if self.certName != nil {
                map["CertName"] = self.certName!
            }
            if self.commonName != nil {
                map["CommonName"] = self.commonName!
            }
            if self.gmtAfter != nil {
                map["GmtAfter"] = self.gmtAfter!
            }
            if self.gmtBefore != nil {
                map["GmtBefore"] = self.gmtBefore!
            }
            if self.issuer != nil {
                map["Issuer"] = self.issuer!
            }
            if self.sans != nil {
                map["Sans"] = self.sans!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AfterDate") {
                self.afterDate = dict["AfterDate"] as! String
            }
            if dict.keys.contains("Algorithm") {
                self.algorithm = dict["Algorithm"] as! String
            }
            if dict.keys.contains("BeforeDate") {
                self.beforeDate = dict["BeforeDate"] as! String
            }
            if dict.keys.contains("CertIdentifier") {
                self.certIdentifier = dict["CertIdentifier"] as! String
            }
            if dict.keys.contains("CertName") {
                self.certName = dict["CertName"] as! String
            }
            if dict.keys.contains("CommonName") {
                self.commonName = dict["CommonName"] as! String
            }
            if dict.keys.contains("GmtAfter") {
                self.gmtAfter = dict["GmtAfter"] as! String
            }
            if dict.keys.contains("GmtBefore") {
                self.gmtBefore = dict["GmtBefore"] as! String
            }
            if dict.keys.contains("Issuer") {
                self.issuer = dict["Issuer"] as! String
            }
            if dict.keys.contains("Sans") {
                self.sans = dict["Sans"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListSSLCertResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListSSLCertResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListSSLCertResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSSLCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSSLCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSSLCertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSecurityGroupRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class ListSecurityGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var securityGroupId: String?

        public var securityGroupName: String?

        public var securityGroupType: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupName != nil {
                map["SecurityGroupName"] = self.securityGroupName!
            }
            if self.securityGroupType != nil {
                map["SecurityGroupType"] = self.securityGroupType!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupName") {
                self.securityGroupName = dict["SecurityGroupName"] as! String
            }
            if dict.keys.contains("SecurityGroupType") {
                self.securityGroupType = dict["SecurityGroupType"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListSecurityGroupResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListSecurityGroupResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListSecurityGroupResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSecurityGroupRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class ListSecurityGroupRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var authCidrs: [String]?

        public var description_: String?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: String?

        public var ipProtocol: String?

        public var portRange: String?

        public var securityGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authCidrs != nil {
                map["AuthCidrs"] = self.authCidrs!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthCidrs") {
                self.authCidrs = dict["AuthCidrs"] as! [String]
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListSecurityGroupRuleResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListSecurityGroupRuleResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListSecurityGroupRuleResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSecurityGroupRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSentinelBlockFallbackDefinitionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var classificationSet: [Int32]?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.classificationSet != nil {
            map["ClassificationSet"] = self.classificationSet!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ClassificationSet") {
            self.classificationSet = dict["ClassificationSet"] as! [Int32]
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class ListSentinelBlockFallbackDefinitionsShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var classificationSetShrink: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.classificationSetShrink != nil {
            map["ClassificationSet"] = self.classificationSetShrink!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ClassificationSet") {
            self.classificationSetShrink = dict["ClassificationSet"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class ListSentinelBlockFallbackDefinitionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appName: String?

        public var fallbackBehavior: [String: Any]?

        public var id: String?

        public var name: String?

        public var namespace: String?

        public var resourceClassification: String?

        public var targetMap: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.fallbackBehavior != nil {
                map["FallbackBehavior"] = self.fallbackBehavior!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.resourceClassification != nil {
                map["ResourceClassification"] = self.resourceClassification!
            }
            if self.targetMap != nil {
                map["TargetMap"] = self.targetMap!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("FallbackBehavior") {
                self.fallbackBehavior = dict["FallbackBehavior"] as! [String: Any]
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ResourceClassification") {
                self.resourceClassification = dict["ResourceClassification"] as! String
            }
            if dict.keys.contains("TargetMap") {
                self.targetMap = dict["TargetMap"] as! [String: Any]
            }
        }
    }
    public var data: [ListSentinelBlockFallbackDefinitionsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListSentinelBlockFallbackDefinitionsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListSentinelBlockFallbackDefinitionsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSentinelBlockFallbackDefinitionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSentinelBlockFallbackDefinitionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSentinelBlockFallbackDefinitionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListServiceSourceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
    }
}

public class ListServiceSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class IngressOptions : Tea.TeaModel {
            public var enableIngress: Bool?

            public var enableStatus: Bool?

            public var ingressClass: String?

            public var watchNamespace: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enableIngress != nil {
                    map["EnableIngress"] = self.enableIngress!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.ingressClass != nil {
                    map["IngressClass"] = self.ingressClass!
                }
                if self.watchNamespace != nil {
                    map["WatchNamespace"] = self.watchNamespace!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnableIngress") {
                    self.enableIngress = dict["EnableIngress"] as! Bool
                }
                if dict.keys.contains("EnableStatus") {
                    self.enableStatus = dict["EnableStatus"] as! Bool
                }
                if dict.keys.contains("IngressClass") {
                    self.ingressClass = dict["IngressClass"] as! String
                }
                if dict.keys.contains("WatchNamespace") {
                    self.watchNamespace = dict["WatchNamespace"] as! String
                }
            }
        }
        public var address: String?

        public var bindingWithGateway: Int32?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var groupList: [String]?

        public var id: Int64?

        public var ingressOptions: ListServiceSourceResponseBody.Data.IngressOptions?

        public var invalid: Bool?

        public var name: String?

        public var pathList: [String]?

        public var source: String?

        public var sourceUniqueId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ingressOptions?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.bindingWithGateway != nil {
                map["BindingWithGateway"] = self.bindingWithGateway!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.groupList != nil {
                map["GroupList"] = self.groupList!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ingressOptions != nil {
                map["IngressOptions"] = self.ingressOptions?.toMap()
            }
            if self.invalid != nil {
                map["Invalid"] = self.invalid!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pathList != nil {
                map["PathList"] = self.pathList!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.sourceUniqueId != nil {
                map["SourceUniqueId"] = self.sourceUniqueId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("BindingWithGateway") {
                self.bindingWithGateway = dict["BindingWithGateway"] as! Int32
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("GroupList") {
                self.groupList = dict["GroupList"] as! [String]
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IngressOptions") {
                var model = ListServiceSourceResponseBody.Data.IngressOptions()
                model.fromMap(dict["IngressOptions"] as! [String: Any])
                self.ingressOptions = model
            }
            if dict.keys.contains("Invalid") {
                self.invalid = dict["Invalid"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PathList") {
                self.pathList = dict["PathList"] as! [String]
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("SourceUniqueId") {
                self.sourceUniqueId = dict["SourceUniqueId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [ListServiceSourceResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [ListServiceSourceResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListServiceSourceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListServiceSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListServiceSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var nextToken: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListTagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in dict["TagResource"] as! [Any] {
                    var model = ListTagResourcesResponseBody.TagResources.TagResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagResource = tmp
            }
        }
    }
    public var errorCode: String?

    public var message: String?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagResources") {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListZkTrackRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var endTs: Int64?

    public var instanceId: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var path: String?

    public var requestPars: String?

    public var reverse: Bool?

    public var sessionId: String?

    public var startTs: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("EndTs") {
            self.endTs = dict["EndTs"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("Reverse") {
            self.reverse = dict["Reverse"] as! Bool
        }
        if dict.keys.contains("SessionId") {
            self.sessionId = dict["SessionId"] as! String
        }
        if dict.keys.contains("StartTs") {
            self.startTs = dict["StartTs"] as! Int64
        }
    }
}

public class ListZkTrackResponseBody : Tea.TeaModel {
    public class Traces : Tea.TeaModel {
        public var acl: String?

        public var dataType: String?

        public var eventType: String?

        public var finished: Bool?

        public var logDate: String?

        public var multiSize: Int64?

        public var opType: String?

        public var path: String?

        public var result: String?

        public var sessionId: String?

        public var timestamp: String?

        public var traceType: String?

        public var ttl: Int64?

        public var watch: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acl != nil {
                map["Acl"] = self.acl!
            }
            if self.dataType != nil {
                map["DataType"] = self.dataType!
            }
            if self.eventType != nil {
                map["EventType"] = self.eventType!
            }
            if self.finished != nil {
                map["Finished"] = self.finished!
            }
            if self.logDate != nil {
                map["LogDate"] = self.logDate!
            }
            if self.multiSize != nil {
                map["MultiSize"] = self.multiSize!
            }
            if self.opType != nil {
                map["OpType"] = self.opType!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.sessionId != nil {
                map["SessionId"] = self.sessionId!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.traceType != nil {
                map["TraceType"] = self.traceType!
            }
            if self.ttl != nil {
                map["Ttl"] = self.ttl!
            }
            if self.watch != nil {
                map["Watch"] = self.watch!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Acl") {
                self.acl = dict["Acl"] as! String
            }
            if dict.keys.contains("DataType") {
                self.dataType = dict["DataType"] as! String
            }
            if dict.keys.contains("EventType") {
                self.eventType = dict["EventType"] as! String
            }
            if dict.keys.contains("Finished") {
                self.finished = dict["Finished"] as! Bool
            }
            if dict.keys.contains("LogDate") {
                self.logDate = dict["LogDate"] as! String
            }
            if dict.keys.contains("MultiSize") {
                self.multiSize = dict["MultiSize"] as! Int64
            }
            if dict.keys.contains("OpType") {
                self.opType = dict["OpType"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("SessionId") {
                self.sessionId = dict["SessionId"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! String
            }
            if dict.keys.contains("TraceType") {
                self.traceType = dict["TraceType"] as! String
            }
            if dict.keys.contains("Ttl") {
                self.ttl = dict["Ttl"] as! Int64
            }
            if dict.keys.contains("Watch") {
                self.watch = dict["Watch"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var traces: [ListZkTrackResponseBody.Traces]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.traces != nil {
            var tmp : [Any] = []
            for k in self.traces! {
                tmp.append(k.toMap())
            }
            map["Traces"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("Traces") {
            var tmp : [ListZkTrackResponseBody.Traces] = []
            for v in dict["Traces"] as! [Any] {
                var model = ListZkTrackResponseBody.Traces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.traces = tmp
        }
    }
}

public class ListZkTrackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListZkTrackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListZkTrackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListZnodeChildrenRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
    }
}

public class ListZnodeChildrenResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var dir: Bool?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Dir") {
                self.dir = dict["Dir"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var data: [ListZnodeChildrenResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [ListZnodeChildrenResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListZnodeChildrenResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListZnodeChildrenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListZnodeChildrenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListZnodeChildrenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyGovernanceKubernetesClusterRequest : Tea.TeaModel {
    public class NamespaceInfos : Tea.TeaModel {
        public var mseNamespace: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mseNamespace != nil {
                map["MseNamespace"] = self.mseNamespace!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MseNamespace") {
                self.mseNamespace = dict["MseNamespace"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var clusterId: String?

    public var namespaceInfos: [ModifyGovernanceKubernetesClusterRequest.NamespaceInfos]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.namespaceInfos != nil {
            var tmp : [Any] = []
            for k in self.namespaceInfos! {
                tmp.append(k.toMap())
            }
            map["NamespaceInfos"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("NamespaceInfos") {
            var tmp : [ModifyGovernanceKubernetesClusterRequest.NamespaceInfos] = []
            for v in dict["NamespaceInfos"] as! [Any] {
                var model = ModifyGovernanceKubernetesClusterRequest.NamespaceInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.namespaceInfos = tmp
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyGovernanceKubernetesClusterShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var namespaceInfosShrink: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.namespaceInfosShrink != nil {
            map["NamespaceInfos"] = self.namespaceInfosShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("NamespaceInfos") {
            self.namespaceInfosShrink = dict["NamespaceInfos"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyGovernanceKubernetesClusterResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyGovernanceKubernetesClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyGovernanceKubernetesClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyGovernanceKubernetesClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLosslessRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var aligned: Bool?

    public var appId: String?

    public var appName: String?

    public var delayTime: Int32?

    public var enable: Bool?

    public var funcType: Int32?

    public var lossLessDetail: Bool?

    public var namespace: String?

    public var notice: Bool?

    public var regionId: String?

    public var related: Bool?

    public var warmupTime: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.aligned != nil {
            map["Aligned"] = self.aligned!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.delayTime != nil {
            map["DelayTime"] = self.delayTime!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.funcType != nil {
            map["FuncType"] = self.funcType!
        }
        if self.lossLessDetail != nil {
            map["LossLessDetail"] = self.lossLessDetail!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.notice != nil {
            map["Notice"] = self.notice!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.related != nil {
            map["Related"] = self.related!
        }
        if self.warmupTime != nil {
            map["WarmupTime"] = self.warmupTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Aligned") {
            self.aligned = dict["Aligned"] as! Bool
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DelayTime") {
            self.delayTime = dict["DelayTime"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("FuncType") {
            self.funcType = dict["FuncType"] as! Int32
        }
        if dict.keys.contains("LossLessDetail") {
            self.lossLessDetail = dict["LossLessDetail"] as! Bool
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Notice") {
            self.notice = dict["Notice"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Related") {
            self.related = dict["Related"] as! Bool
        }
        if dict.keys.contains("WarmupTime") {
            self.warmupTime = dict["WarmupTime"] as! Int32
        }
    }
}

public class ModifyLosslessRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Any?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyLosslessRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLosslessRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyLosslessRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OfflineGatewayRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var routeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! String
        }
    }
}

public class OfflineGatewayRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class OfflineGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OfflineGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OfflineGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OrderClusterHealthCheckRiskNoticeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var mute: Bool?

    public var noticeType: String?

    public var regionId: String?

    public var requestPars: String?

    public var riskCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mute != nil {
            map["Mute"] = self.mute!
        }
        if self.noticeType != nil {
            map["NoticeType"] = self.noticeType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.riskCode != nil {
            map["RiskCode"] = self.riskCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Mute") {
            self.mute = dict["Mute"] as! Bool
        }
        if dict.keys.contains("NoticeType") {
            self.noticeType = dict["NoticeType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("RiskCode") {
            self.riskCode = dict["RiskCode"] as! String
        }
    }
}

public class OrderClusterHealthCheckRiskNoticeResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class OrderClusterHealthCheckRiskNoticeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OrderClusterHealthCheckRiskNoticeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OrderClusterHealthCheckRiskNoticeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PreserveHeaderFormatRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var preserveHeaderFormat: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.preserveHeaderFormat != nil {
            map["PreserveHeaderFormat"] = self.preserveHeaderFormat!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("PreserveHeaderFormat") {
            self.preserveHeaderFormat = dict["PreserveHeaderFormat"] as! Bool
        }
    }
}

public class PreserveHeaderFormatResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PreserveHeaderFormatResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PreserveHeaderFormatResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PreserveHeaderFormatResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PullServicesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var namespace: String?

    public var sourceId: Int64?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.sourceId != nil {
            map["SourceId"] = self.sourceId!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("SourceId") {
            self.sourceId = dict["SourceId"] as! Int64
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class PullServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Services : Tea.TeaModel {
            public var groupName: String?

            public var name: String?

            public var namespace: String?

            public var sourceId: String?

            public var sourceIdList: [Int64]?

            public var sourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.sourceId != nil {
                    map["SourceId"] = self.sourceId!
                }
                if self.sourceIdList != nil {
                    map["SourceIdList"] = self.sourceIdList!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("SourceId") {
                    self.sourceId = dict["SourceId"] as! String
                }
                if dict.keys.contains("SourceIdList") {
                    self.sourceIdList = dict["SourceIdList"] as! [Int64]
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
            }
        }
        public var groupName: String?

        public var namespace: String?

        public var namespaceShowName: String?

        public var services: [PullServicesResponseBody.Data.Services]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.namespaceShowName != nil {
                map["NamespaceShowName"] = self.namespaceShowName!
            }
            if self.services != nil {
                var tmp : [Any] = []
                for k in self.services! {
                    tmp.append(k.toMap())
                }
                map["Services"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NamespaceShowName") {
                self.namespaceShowName = dict["NamespaceShowName"] as! String
            }
            if dict.keys.contains("Services") {
                var tmp : [PullServicesResponseBody.Data.Services] = []
                for v in dict["Services"] as! [Any] {
                    var model = PullServicesResponseBody.Data.Services()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.services = tmp
            }
        }
    }
    public var code: Int32?

    public var data: [PullServicesResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [PullServicesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = PullServicesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PullServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PullServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PullServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutClusterHealthCheckTaskRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class PutClusterHealthCheckTaskResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PutClusterHealthCheckTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutClusterHealthCheckTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PutClusterHealthCheckTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAllSwimmingLaneRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var groupId: Int64?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class QueryAllSwimmingLaneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EntryRules : Tea.TeaModel {
            public class RestItems : Tea.TeaModel {
                public var cond: String?

                public var datum: String?

                public var divisor: Int32?

                public var name: String?

                public var nameList: [String]?

                public var operator_: String?

                public var rate: Int32?

                public var remainder: Int32?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.datum != nil {
                        map["datum"] = self.datum!
                    }
                    if self.divisor != nil {
                        map["divisor"] = self.divisor!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.nameList != nil {
                        map["nameList"] = self.nameList!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.rate != nil {
                        map["rate"] = self.rate!
                    }
                    if self.remainder != nil {
                        map["remainder"] = self.remainder!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("cond") {
                        self.cond = dict["cond"] as! String
                    }
                    if dict.keys.contains("datum") {
                        self.datum = dict["datum"] as! String
                    }
                    if dict.keys.contains("divisor") {
                        self.divisor = dict["divisor"] as! Int32
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("nameList") {
                        self.nameList = dict["nameList"] as! [String]
                    }
                    if dict.keys.contains("operator") {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("rate") {
                        self.rate = dict["rate"] as! Int32
                    }
                    if dict.keys.contains("remainder") {
                        self.remainder = dict["remainder"] as! Int32
                    }
                    if dict.keys.contains("type") {
                        self.type = dict["type"] as! String
                    }
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var condition: String?

            public var path: String?

            public var paths: [String]?

            public var restItems: [QueryAllSwimmingLaneResponseBody.Data.EntryRules.RestItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.paths != nil {
                    map["paths"] = self.paths!
                }
                if self.restItems != nil {
                    var tmp : [Any] = []
                    for k in self.restItems! {
                        tmp.append(k.toMap())
                    }
                    map["restItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("condition") {
                    self.condition = dict["condition"] as! String
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("paths") {
                    self.paths = dict["paths"] as! [String]
                }
                if dict.keys.contains("restItems") {
                    var tmp : [QueryAllSwimmingLaneResponseBody.Data.EntryRules.RestItems] = []
                    for v in dict["restItems"] as! [Any] {
                        var model = QueryAllSwimmingLaneResponseBody.Data.EntryRules.RestItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.restItems = tmp
                }
            }
        }
        public class GatewaySwimmingLaneRoute : Tea.TeaModel {
            public class Conditions : Tea.TeaModel {
                public var cond: String?

                public var name: String?

                public var nameList: [String]?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cond != nil {
                        map["Cond"] = self.cond!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.nameList != nil {
                        map["NameList"] = self.nameList!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cond") {
                        self.cond = dict["Cond"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("NameList") {
                        self.nameList = dict["NameList"] as! [String]
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class RouteIndependentPercentageList : Tea.TeaModel {
                public var percentage: String?

                public var routeId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.percentage != nil {
                        map["Percentage"] = self.percentage!
                    }
                    if self.routeId != nil {
                        map["RouteId"] = self.routeId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Percentage") {
                        self.percentage = dict["Percentage"] as! String
                    }
                    if dict.keys.contains("RouteId") {
                        self.routeId = dict["RouteId"] as! String
                    }
                }
            }
            public var canaryModel: Int32?

            public var condition: String?

            public var conditions: [QueryAllSwimmingLaneResponseBody.Data.GatewaySwimmingLaneRoute.Conditions]?

            public var gatewayId: Int64?

            public var gatewayUniqueId: String?

            public var percentage: Int32?

            public var routeIdList: [Int64]?

            public var routeIndependentPercentageEnable: String?

            public var routeIndependentPercentageList: [QueryAllSwimmingLaneResponseBody.Data.GatewaySwimmingLaneRoute.RouteIndependentPercentageList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.canaryModel != nil {
                    map["CanaryModel"] = self.canaryModel!
                }
                if self.condition != nil {
                    map["Condition"] = self.condition!
                }
                if self.conditions != nil {
                    var tmp : [Any] = []
                    for k in self.conditions! {
                        tmp.append(k.toMap())
                    }
                    map["Conditions"] = tmp
                }
                if self.gatewayId != nil {
                    map["GatewayId"] = self.gatewayId!
                }
                if self.gatewayUniqueId != nil {
                    map["GatewayUniqueId"] = self.gatewayUniqueId!
                }
                if self.percentage != nil {
                    map["Percentage"] = self.percentage!
                }
                if self.routeIdList != nil {
                    map["RouteIdList"] = self.routeIdList!
                }
                if self.routeIndependentPercentageEnable != nil {
                    map["RouteIndependentPercentageEnable"] = self.routeIndependentPercentageEnable!
                }
                if self.routeIndependentPercentageList != nil {
                    var tmp : [Any] = []
                    for k in self.routeIndependentPercentageList! {
                        tmp.append(k.toMap())
                    }
                    map["RouteIndependentPercentageList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CanaryModel") {
                    self.canaryModel = dict["CanaryModel"] as! Int32
                }
                if dict.keys.contains("Condition") {
                    self.condition = dict["Condition"] as! String
                }
                if dict.keys.contains("Conditions") {
                    var tmp : [QueryAllSwimmingLaneResponseBody.Data.GatewaySwimmingLaneRoute.Conditions] = []
                    for v in dict["Conditions"] as! [Any] {
                        var model = QueryAllSwimmingLaneResponseBody.Data.GatewaySwimmingLaneRoute.Conditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.conditions = tmp
                }
                if dict.keys.contains("GatewayId") {
                    self.gatewayId = dict["GatewayId"] as! Int64
                }
                if dict.keys.contains("GatewayUniqueId") {
                    self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
                }
                if dict.keys.contains("Percentage") {
                    self.percentage = dict["Percentage"] as! Int32
                }
                if dict.keys.contains("RouteIdList") {
                    self.routeIdList = dict["RouteIdList"] as! [Int64]
                }
                if dict.keys.contains("RouteIndependentPercentageEnable") {
                    self.routeIndependentPercentageEnable = dict["RouteIndependentPercentageEnable"] as! String
                }
                if dict.keys.contains("RouteIndependentPercentageList") {
                    var tmp : [QueryAllSwimmingLaneResponseBody.Data.GatewaySwimmingLaneRoute.RouteIndependentPercentageList] = []
                    for v in dict["RouteIndependentPercentageList"] as! [Any] {
                        var model = QueryAllSwimmingLaneResponseBody.Data.GatewaySwimmingLaneRoute.RouteIndependentPercentageList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.routeIndependentPercentageList = tmp
                }
            }
        }
        public var enable: String?

        public var entryRules: [QueryAllSwimmingLaneResponseBody.Data.EntryRules]?

        public var gatewaySwimmingLaneRoute: QueryAllSwimmingLaneResponseBody.Data.GatewaySwimmingLaneRoute?

        public var gatewaySwimmingLaneRouteJson: String?

        public var groupId: String?

        public var id: Int64?

        public var messageQueueFilterSide: String?

        public var messageQueueGrayEnable: Bool?

        public var name: String?

        public var namespace: String?

        public var pathIndependentPercentageEnable: Bool?

        public var recordCanaryDetail: Bool?

        public var regionId: String?

        public var tag: String?

        public var userId: String?

        public var enableRules: Bool?

        public var gmtCreate: String?

        public var gmtModified: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.gatewaySwimmingLaneRoute?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.entryRules != nil {
                var tmp : [Any] = []
                for k in self.entryRules! {
                    tmp.append(k.toMap())
                }
                map["EntryRules"] = tmp
            }
            if self.gatewaySwimmingLaneRoute != nil {
                map["GatewaySwimmingLaneRoute"] = self.gatewaySwimmingLaneRoute?.toMap()
            }
            if self.gatewaySwimmingLaneRouteJson != nil {
                map["GatewaySwimmingLaneRouteJson"] = self.gatewaySwimmingLaneRouteJson!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.messageQueueFilterSide != nil {
                map["MessageQueueFilterSide"] = self.messageQueueFilterSide!
            }
            if self.messageQueueGrayEnable != nil {
                map["MessageQueueGrayEnable"] = self.messageQueueGrayEnable!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.pathIndependentPercentageEnable != nil {
                map["PathIndependentPercentageEnable"] = self.pathIndependentPercentageEnable!
            }
            if self.recordCanaryDetail != nil {
                map["RecordCanaryDetail"] = self.recordCanaryDetail!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.enableRules != nil {
                map["enableRules"] = self.enableRules!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! String
            }
            if dict.keys.contains("EntryRules") {
                var tmp : [QueryAllSwimmingLaneResponseBody.Data.EntryRules] = []
                for v in dict["EntryRules"] as! [Any] {
                    var model = QueryAllSwimmingLaneResponseBody.Data.EntryRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.entryRules = tmp
            }
            if dict.keys.contains("GatewaySwimmingLaneRoute") {
                var model = QueryAllSwimmingLaneResponseBody.Data.GatewaySwimmingLaneRoute()
                model.fromMap(dict["GatewaySwimmingLaneRoute"] as! [String: Any])
                self.gatewaySwimmingLaneRoute = model
            }
            if dict.keys.contains("GatewaySwimmingLaneRouteJson") {
                self.gatewaySwimmingLaneRouteJson = dict["GatewaySwimmingLaneRouteJson"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MessageQueueFilterSide") {
                self.messageQueueFilterSide = dict["MessageQueueFilterSide"] as! String
            }
            if dict.keys.contains("MessageQueueGrayEnable") {
                self.messageQueueGrayEnable = dict["MessageQueueGrayEnable"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("PathIndependentPercentageEnable") {
                self.pathIndependentPercentageEnable = dict["PathIndependentPercentageEnable"] as! Bool
            }
            if dict.keys.contains("RecordCanaryDetail") {
                self.recordCanaryDetail = dict["RecordCanaryDetail"] as! Bool
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Tag") {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("enableRules") {
                self.enableRules = dict["enableRules"] as! Bool
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! String
            }
        }
    }
    public var data: [QueryAllSwimmingLaneResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [QueryAllSwimmingLaneResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryAllSwimmingLaneResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryAllSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAllSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryAllSwimmingLaneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAllSwimmingLaneGroupRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class QueryAllSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appIds: String?

        public var canaryModel: Int32?

        public var entryApp: String?

        public var id: Int64?

        public var messageQueueFilterSide: String?

        public var messageQueueGrayEnable: Bool?

        public var name: String?

        public var namespace: String?

        public var paths: String?

        public var recordCanaryDetail: Bool?

        public var region: String?

        public var swimVersion: Int32?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appIds != nil {
                map["AppIds"] = self.appIds!
            }
            if self.canaryModel != nil {
                map["CanaryModel"] = self.canaryModel!
            }
            if self.entryApp != nil {
                map["EntryApp"] = self.entryApp!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.messageQueueFilterSide != nil {
                map["MessageQueueFilterSide"] = self.messageQueueFilterSide!
            }
            if self.messageQueueGrayEnable != nil {
                map["MessageQueueGrayEnable"] = self.messageQueueGrayEnable!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.paths != nil {
                map["Paths"] = self.paths!
            }
            if self.recordCanaryDetail != nil {
                map["RecordCanaryDetail"] = self.recordCanaryDetail!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.swimVersion != nil {
                map["SwimVersion"] = self.swimVersion!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppIds") {
                self.appIds = dict["AppIds"] as! String
            }
            if dict.keys.contains("CanaryModel") {
                self.canaryModel = dict["CanaryModel"] as! Int32
            }
            if dict.keys.contains("EntryApp") {
                self.entryApp = dict["EntryApp"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MessageQueueFilterSide") {
                self.messageQueueFilterSide = dict["MessageQueueFilterSide"] as! String
            }
            if dict.keys.contains("MessageQueueGrayEnable") {
                self.messageQueueGrayEnable = dict["MessageQueueGrayEnable"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Paths") {
                self.paths = dict["Paths"] as! String
            }
            if dict.keys.contains("RecordCanaryDetail") {
                self.recordCanaryDetail = dict["RecordCanaryDetail"] as! Bool
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("SwimVersion") {
                self.swimVersion = dict["SwimVersion"] as! Int32
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [QueryAllSwimmingLaneGroupResponseBody.Data]?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [QueryAllSwimmingLaneGroupResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryAllSwimmingLaneGroupResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryAllSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAllSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryAllSwimmingLaneGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryBusinessLocationsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class QueryBusinessLocationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var cnName: String?

        public var description_: String?

        public var districtCnName: String?

        public var districtEnName: String?

        public var districtId: String?

        public var districtOrdering: Int32?

        public var districtShowName: String?

        public var enDescription: String?

        public var enName: String?

        public var name: String?

        public var ordering: Int32?

        public var showName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cnName != nil {
                map["CnName"] = self.cnName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.districtCnName != nil {
                map["DistrictCnName"] = self.districtCnName!
            }
            if self.districtEnName != nil {
                map["DistrictEnName"] = self.districtEnName!
            }
            if self.districtId != nil {
                map["DistrictId"] = self.districtId!
            }
            if self.districtOrdering != nil {
                map["DistrictOrdering"] = self.districtOrdering!
            }
            if self.districtShowName != nil {
                map["DistrictShowName"] = self.districtShowName!
            }
            if self.enDescription != nil {
                map["EnDescription"] = self.enDescription!
            }
            if self.enName != nil {
                map["EnName"] = self.enName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ordering != nil {
                map["Ordering"] = self.ordering!
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CnName") {
                self.cnName = dict["CnName"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DistrictCnName") {
                self.districtCnName = dict["DistrictCnName"] as! String
            }
            if dict.keys.contains("DistrictEnName") {
                self.districtEnName = dict["DistrictEnName"] as! String
            }
            if dict.keys.contains("DistrictId") {
                self.districtId = dict["DistrictId"] as! String
            }
            if dict.keys.contains("DistrictOrdering") {
                self.districtOrdering = dict["DistrictOrdering"] as! Int32
            }
            if dict.keys.contains("DistrictShowName") {
                self.districtShowName = dict["DistrictShowName"] as! String
            }
            if dict.keys.contains("EnDescription") {
                self.enDescription = dict["EnDescription"] as! String
            }
            if dict.keys.contains("EnName") {
                self.enName = dict["EnName"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Ordering") {
                self.ordering = dict["Ordering"] as! Int32
            }
            if dict.keys.contains("ShowName") {
                self.showName = dict["ShowName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: [QueryBusinessLocationsResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [QueryBusinessLocationsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryBusinessLocationsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class QueryBusinessLocationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryBusinessLocationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryBusinessLocationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryClusterDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var aclSwitch: Bool?

    public var instanceId: String?

    public var orderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.aclSwitch != nil {
            map["AclSwitch"] = self.aclSwitch!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AclSwitch") {
            self.aclSwitch = dict["AclSwitch"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
    }
}

public class QueryClusterDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class InstanceModels : Tea.TeaModel {
            public var creationTimestamp: String?

            public var healthStatus: String?

            public var internetIp: String?

            public var ip: String?

            public var podName: String?

            public var role: String?

            public var singleTunnelVip: String?

            public var zone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTimestamp != nil {
                    map["CreationTimestamp"] = self.creationTimestamp!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.podName != nil {
                    map["PodName"] = self.podName!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.singleTunnelVip != nil {
                    map["SingleTunnelVip"] = self.singleTunnelVip!
                }
                if self.zone != nil {
                    map["Zone"] = self.zone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTimestamp") {
                    self.creationTimestamp = dict["CreationTimestamp"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("InternetIp") {
                    self.internetIp = dict["InternetIp"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("PodName") {
                    self.podName = dict["PodName"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("SingleTunnelVip") {
                    self.singleTunnelVip = dict["SingleTunnelVip"] as! String
                }
                if dict.keys.contains("Zone") {
                    self.zone = dict["Zone"] as! String
                }
            }
        }
        public var aclEntryList: String?

        public var aclId: String?

        public var appVersion: String?

        public var chargeType: String?

        public var clusterAliasName: String?

        public var clusterName: String?

        public var clusterSpecification: String?

        public var clusterType: String?

        public var clusterVersion: String?

        public var connectionType: String?

        public var cpu: Int32?

        public var createTime: String?

        public var diskCapacity: Int64?

        public var diskType: String?

        public var healthStatus: String?

        public var initCostTime: Int64?

        public var initStatus: String?

        public var instanceCount: Int32?

        public var instanceId: String?

        public var instanceModels: [QueryClusterDetailResponseBody.Data.InstanceModels]?

        public var internetAddress: String?

        public var internetDomain: String?

        public var internetPort: String?

        public var intranetAddress: String?

        public var intranetDomain: String?

        public var intranetPort: String?

        public var memoryCapacity: Int64?

        public var mseVersion: String?

        public var netType: String?

        public var orderClusterVersion: String?

        public var payInfo: String?

        public var pubNetworkFlow: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var tags: [String: Any]?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aclEntryList != nil {
                map["AclEntryList"] = self.aclEntryList!
            }
            if self.aclId != nil {
                map["AclId"] = self.aclId!
            }
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.clusterAliasName != nil {
                map["ClusterAliasName"] = self.clusterAliasName!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterSpecification != nil {
                map["ClusterSpecification"] = self.clusterSpecification!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.clusterVersion != nil {
                map["ClusterVersion"] = self.clusterVersion!
            }
            if self.connectionType != nil {
                map["ConnectionType"] = self.connectionType!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.diskCapacity != nil {
                map["DiskCapacity"] = self.diskCapacity!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.initCostTime != nil {
                map["InitCostTime"] = self.initCostTime!
            }
            if self.initStatus != nil {
                map["InitStatus"] = self.initStatus!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceModels != nil {
                var tmp : [Any] = []
                for k in self.instanceModels! {
                    tmp.append(k.toMap())
                }
                map["InstanceModels"] = tmp
            }
            if self.internetAddress != nil {
                map["InternetAddress"] = self.internetAddress!
            }
            if self.internetDomain != nil {
                map["InternetDomain"] = self.internetDomain!
            }
            if self.internetPort != nil {
                map["InternetPort"] = self.internetPort!
            }
            if self.intranetAddress != nil {
                map["IntranetAddress"] = self.intranetAddress!
            }
            if self.intranetDomain != nil {
                map["IntranetDomain"] = self.intranetDomain!
            }
            if self.intranetPort != nil {
                map["IntranetPort"] = self.intranetPort!
            }
            if self.memoryCapacity != nil {
                map["MemoryCapacity"] = self.memoryCapacity!
            }
            if self.mseVersion != nil {
                map["MseVersion"] = self.mseVersion!
            }
            if self.netType != nil {
                map["NetType"] = self.netType!
            }
            if self.orderClusterVersion != nil {
                map["OrderClusterVersion"] = self.orderClusterVersion!
            }
            if self.payInfo != nil {
                map["PayInfo"] = self.payInfo!
            }
            if self.pubNetworkFlow != nil {
                map["PubNetworkFlow"] = self.pubNetworkFlow!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AclEntryList") {
                self.aclEntryList = dict["AclEntryList"] as! String
            }
            if dict.keys.contains("AclId") {
                self.aclId = dict["AclId"] as! String
            }
            if dict.keys.contains("AppVersion") {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("ChargeType") {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ClusterAliasName") {
                self.clusterAliasName = dict["ClusterAliasName"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterSpecification") {
                self.clusterSpecification = dict["ClusterSpecification"] as! String
            }
            if dict.keys.contains("ClusterType") {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("ClusterVersion") {
                self.clusterVersion = dict["ClusterVersion"] as! String
            }
            if dict.keys.contains("ConnectionType") {
                self.connectionType = dict["ConnectionType"] as! String
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DiskCapacity") {
                self.diskCapacity = dict["DiskCapacity"] as! Int64
            }
            if dict.keys.contains("DiskType") {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("HealthStatus") {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("InitCostTime") {
                self.initCostTime = dict["InitCostTime"] as! Int64
            }
            if dict.keys.contains("InitStatus") {
                self.initStatus = dict["InitStatus"] as! String
            }
            if dict.keys.contains("InstanceCount") {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceModels") {
                var tmp : [QueryClusterDetailResponseBody.Data.InstanceModels] = []
                for v in dict["InstanceModels"] as! [Any] {
                    var model = QueryClusterDetailResponseBody.Data.InstanceModels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceModels = tmp
            }
            if dict.keys.contains("InternetAddress") {
                self.internetAddress = dict["InternetAddress"] as! String
            }
            if dict.keys.contains("InternetDomain") {
                self.internetDomain = dict["InternetDomain"] as! String
            }
            if dict.keys.contains("InternetPort") {
                self.internetPort = dict["InternetPort"] as! String
            }
            if dict.keys.contains("IntranetAddress") {
                self.intranetAddress = dict["IntranetAddress"] as! String
            }
            if dict.keys.contains("IntranetDomain") {
                self.intranetDomain = dict["IntranetDomain"] as! String
            }
            if dict.keys.contains("IntranetPort") {
                self.intranetPort = dict["IntranetPort"] as! String
            }
            if dict.keys.contains("MemoryCapacity") {
                self.memoryCapacity = dict["MemoryCapacity"] as! Int64
            }
            if dict.keys.contains("MseVersion") {
                self.mseVersion = dict["MseVersion"] as! String
            }
            if dict.keys.contains("NetType") {
                self.netType = dict["NetType"] as! String
            }
            if dict.keys.contains("OrderClusterVersion") {
                self.orderClusterVersion = dict["OrderClusterVersion"] as! String
            }
            if dict.keys.contains("PayInfo") {
                self.payInfo = dict["PayInfo"] as! String
            }
            if dict.keys.contains("PubNetworkFlow") {
                self.pubNetworkFlow = dict["PubNetworkFlow"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! [String: Any]
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var data: QueryClusterDetailResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QueryClusterDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryClusterDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryClusterDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryClusterDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryClusterDiskSpecificationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
    }
}

public class QueryClusterDiskSpecificationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var max: Int32?

        public var min: Int32?

        public var step: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.max != nil {
                map["Max"] = self.max!
            }
            if self.min != nil {
                map["Min"] = self.min!
            }
            if self.step != nil {
                map["Step"] = self.step!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Max") {
                self.max = dict["Max"] as! Int32
            }
            if dict.keys.contains("Min") {
                self.min = dict["Min"] as! Int32
            }
            if dict.keys.contains("Step") {
                self.step = dict["Step"] as! Int32
            }
        }
    }
    public var code: Int32?

    public var data: QueryClusterDiskSpecificationResponseBody.Data?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = QueryClusterDiskSpecificationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryClusterDiskSpecificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryClusterDiskSpecificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryClusterDiskSpecificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryClusterInfoRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var aclSwitch: Bool?

    public var clusterId: String?

    public var instanceId: String?

    public var orderId: String?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.aclSwitch != nil {
            map["AclSwitch"] = self.aclSwitch!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AclSwitch") {
            self.aclSwitch = dict["AclSwitch"] as! Bool
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class QueryClusterInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class InstanceModels : Tea.TeaModel {
            public var creationTimestamp: String?

            public var healthStatus: String?

            public var internetIp: String?

            public var ip: String?

            public var podName: String?

            public var role: String?

            public var singleTunnelVip: String?

            public var zone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTimestamp != nil {
                    map["CreationTimestamp"] = self.creationTimestamp!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.podName != nil {
                    map["PodName"] = self.podName!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.singleTunnelVip != nil {
                    map["SingleTunnelVip"] = self.singleTunnelVip!
                }
                if self.zone != nil {
                    map["Zone"] = self.zone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTimestamp") {
                    self.creationTimestamp = dict["CreationTimestamp"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("InternetIp") {
                    self.internetIp = dict["InternetIp"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("PodName") {
                    self.podName = dict["PodName"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("SingleTunnelVip") {
                    self.singleTunnelVip = dict["SingleTunnelVip"] as! String
                }
                if dict.keys.contains("Zone") {
                    self.zone = dict["Zone"] as! String
                }
            }
        }
        public class MaintenancePeriod : Tea.TeaModel {
            public var endTime: String?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var aclEntryList: String?

        public var aclId: String?

        public var appVersion: String?

        public var canUpdate: Bool?

        public var chargeType: String?

        public var clusterAliasName: String?

        public var clusterName: String?

        public var clusterSpecification: String?

        public var clusterType: String?

        public var clusterVersion: String?

        public var connectionType: String?

        public var cpu: Int32?

        public var createTime: String?

        public var diskCapacity: Int64?

        public var diskType: String?

        public var eipInstanceId: String?

        public var endDate: String?

        public var expectZones: [String]?

        public var healthStatus: String?

        public var initCostTime: Int64?

        public var initStatus: String?

        public var instanceCount: Int32?

        public var instanceId: String?

        public var instanceModels: [QueryClusterInfoResponseBody.Data.InstanceModels]?

        public var internetAddress: String?

        public var internetDomain: String?

        public var internetPort: String?

        public var intranetAddress: String?

        public var intranetDomain: String?

        public var intranetPort: String?

        public var maintenancePeriod: QueryClusterInfoResponseBody.Data.MaintenancePeriod?

        public var memoryCapacity: Int64?

        public var mseVersion: String?

        public var netType: String?

        public var payInfo: String?

        public var pubNetworkFlow: String?

        public var regionId: String?

        public var securityGroupId: String?

        public var securityGroupType: String?

        public var tags: [String: Any]?

        public var vSwitchId: String?

        public var versionCode: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.maintenancePeriod?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aclEntryList != nil {
                map["AclEntryList"] = self.aclEntryList!
            }
            if self.aclId != nil {
                map["AclId"] = self.aclId!
            }
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.canUpdate != nil {
                map["CanUpdate"] = self.canUpdate!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.clusterAliasName != nil {
                map["ClusterAliasName"] = self.clusterAliasName!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterSpecification != nil {
                map["ClusterSpecification"] = self.clusterSpecification!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.clusterVersion != nil {
                map["ClusterVersion"] = self.clusterVersion!
            }
            if self.connectionType != nil {
                map["ConnectionType"] = self.connectionType!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.diskCapacity != nil {
                map["DiskCapacity"] = self.diskCapacity!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.eipInstanceId != nil {
                map["EipInstanceId"] = self.eipInstanceId!
            }
            if self.endDate != nil {
                map["EndDate"] = self.endDate!
            }
            if self.expectZones != nil {
                map["ExpectZones"] = self.expectZones!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.initCostTime != nil {
                map["InitCostTime"] = self.initCostTime!
            }
            if self.initStatus != nil {
                map["InitStatus"] = self.initStatus!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceModels != nil {
                var tmp : [Any] = []
                for k in self.instanceModels! {
                    tmp.append(k.toMap())
                }
                map["InstanceModels"] = tmp
            }
            if self.internetAddress != nil {
                map["InternetAddress"] = self.internetAddress!
            }
            if self.internetDomain != nil {
                map["InternetDomain"] = self.internetDomain!
            }
            if self.internetPort != nil {
                map["InternetPort"] = self.internetPort!
            }
            if self.intranetAddress != nil {
                map["IntranetAddress"] = self.intranetAddress!
            }
            if self.intranetDomain != nil {
                map["IntranetDomain"] = self.intranetDomain!
            }
            if self.intranetPort != nil {
                map["IntranetPort"] = self.intranetPort!
            }
            if self.maintenancePeriod != nil {
                map["MaintenancePeriod"] = self.maintenancePeriod?.toMap()
            }
            if self.memoryCapacity != nil {
                map["MemoryCapacity"] = self.memoryCapacity!
            }
            if self.mseVersion != nil {
                map["MseVersion"] = self.mseVersion!
            }
            if self.netType != nil {
                map["NetType"] = self.netType!
            }
            if self.payInfo != nil {
                map["PayInfo"] = self.payInfo!
            }
            if self.pubNetworkFlow != nil {
                map["PubNetworkFlow"] = self.pubNetworkFlow!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupType != nil {
                map["SecurityGroupType"] = self.securityGroupType!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AclEntryList") {
                self.aclEntryList = dict["AclEntryList"] as! String
            }
            if dict.keys.contains("AclId") {
                self.aclId = dict["AclId"] as! String
            }
            if dict.keys.contains("AppVersion") {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("CanUpdate") {
                self.canUpdate = dict["CanUpdate"] as! Bool
            }
            if dict.keys.contains("ChargeType") {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ClusterAliasName") {
                self.clusterAliasName = dict["ClusterAliasName"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterSpecification") {
                self.clusterSpecification = dict["ClusterSpecification"] as! String
            }
            if dict.keys.contains("ClusterType") {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("ClusterVersion") {
                self.clusterVersion = dict["ClusterVersion"] as! String
            }
            if dict.keys.contains("ConnectionType") {
                self.connectionType = dict["ConnectionType"] as! String
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DiskCapacity") {
                self.diskCapacity = dict["DiskCapacity"] as! Int64
            }
            if dict.keys.contains("DiskType") {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("EipInstanceId") {
                self.eipInstanceId = dict["EipInstanceId"] as! String
            }
            if dict.keys.contains("EndDate") {
                self.endDate = dict["EndDate"] as! String
            }
            if dict.keys.contains("ExpectZones") {
                self.expectZones = dict["ExpectZones"] as! [String]
            }
            if dict.keys.contains("HealthStatus") {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("InitCostTime") {
                self.initCostTime = dict["InitCostTime"] as! Int64
            }
            if dict.keys.contains("InitStatus") {
                self.initStatus = dict["InitStatus"] as! String
            }
            if dict.keys.contains("InstanceCount") {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceModels") {
                var tmp : [QueryClusterInfoResponseBody.Data.InstanceModels] = []
                for v in dict["InstanceModels"] as! [Any] {
                    var model = QueryClusterInfoResponseBody.Data.InstanceModels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceModels = tmp
            }
            if dict.keys.contains("InternetAddress") {
                self.internetAddress = dict["InternetAddress"] as! String
            }
            if dict.keys.contains("InternetDomain") {
                self.internetDomain = dict["InternetDomain"] as! String
            }
            if dict.keys.contains("InternetPort") {
                self.internetPort = dict["InternetPort"] as! String
            }
            if dict.keys.contains("IntranetAddress") {
                self.intranetAddress = dict["IntranetAddress"] as! String
            }
            if dict.keys.contains("IntranetDomain") {
                self.intranetDomain = dict["IntranetDomain"] as! String
            }
            if dict.keys.contains("IntranetPort") {
                self.intranetPort = dict["IntranetPort"] as! String
            }
            if dict.keys.contains("MaintenancePeriod") {
                var model = QueryClusterInfoResponseBody.Data.MaintenancePeriod()
                model.fromMap(dict["MaintenancePeriod"] as! [String: Any])
                self.maintenancePeriod = model
            }
            if dict.keys.contains("MemoryCapacity") {
                self.memoryCapacity = dict["MemoryCapacity"] as! Int64
            }
            if dict.keys.contains("MseVersion") {
                self.mseVersion = dict["MseVersion"] as! String
            }
            if dict.keys.contains("NetType") {
                self.netType = dict["NetType"] as! String
            }
            if dict.keys.contains("PayInfo") {
                self.payInfo = dict["PayInfo"] as! String
            }
            if dict.keys.contains("PubNetworkFlow") {
                self.pubNetworkFlow = dict["PubNetworkFlow"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupType") {
                self.securityGroupType = dict["SecurityGroupType"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! [String: Any]
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VersionCode") {
                self.versionCode = dict["VersionCode"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var data: QueryClusterInfoResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QueryClusterInfoResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryClusterInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryClusterInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryClusterInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryClusterSpecificationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var connectType: String?

    public var mseVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.connectType != nil {
            map["ConnectType"] = self.connectType!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConnectType") {
            self.connectType = dict["ConnectType"] as! String
        }
        if dict.keys.contains("MseVersion") {
            self.mseVersion = dict["MseVersion"] as! String
        }
    }
}

public class QueryClusterSpecificationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterSpecificationName: String?

        public var cpuCapacity: String?

        public var memoryCapacity: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterSpecificationName != nil {
                map["ClusterSpecificationName"] = self.clusterSpecificationName!
            }
            if self.cpuCapacity != nil {
                map["CpuCapacity"] = self.cpuCapacity!
            }
            if self.memoryCapacity != nil {
                map["MemoryCapacity"] = self.memoryCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterSpecificationName") {
                self.clusterSpecificationName = dict["ClusterSpecificationName"] as! String
            }
            if dict.keys.contains("CpuCapacity") {
                self.cpuCapacity = dict["CpuCapacity"] as! String
            }
            if dict.keys.contains("MemoryCapacity") {
                self.memoryCapacity = dict["MemoryCapacity"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [QueryClusterSpecificationResponseBody.Data]?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [QueryClusterSpecificationResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryClusterSpecificationResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryClusterSpecificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryClusterSpecificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryClusterSpecificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var configType: String?

    public var instanceId: String?

    public var needRunningConf: Bool?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configType != nil {
            map["ConfigType"] = self.configType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.needRunningConf != nil {
            map["NeedRunningConf"] = self.needRunningConf!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigType") {
            self.configType = dict["ConfigType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NeedRunningConf") {
            self.needRunningConf = dict["NeedRunningConf"] as! Bool
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class QueryConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class NacosRunningEnv : Tea.TeaModel {
            public var emptyProtect: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.emptyProtect != nil {
                    map["emptyProtect"] = self.emptyProtect!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("emptyProtect") {
                    self.emptyProtect = dict["emptyProtect"] as! Bool
                }
            }
        }
        public var authEnabled: Bool?

        public var autopurgePurgeInterval: String?

        public var autopurgeSnapRetainCount: String?

        public var clusterName: String?

        public var configAuthEnabled: Bool?

        public var configAuthSupported: Bool?

        public var configContentLimit: Int64?

        public var configSecretEnabled: Bool?

        public var configSecretSupported: Bool?

        public var consoleUIEnabled: Bool?

        public var enable4lw: Bool?

        public var eurekaSupported: Bool?

        public var extendedTypesEnable: Bool?

        public var initLimit: String?

        public var juteMaxbuffer: String?

        public var jvmFlagsCustom: String?

        public var MCPEnabled: Bool?

        public var MCPSupported: Bool?

        public var maxClientCnxns: String?

        public var maxSessionTimeout: String?

        public var minSessionTimeout: String?

        public var nacosRunningEnv: QueryConfigResponseBody.Data.NacosRunningEnv?

        public var namingAuthEnabled: Bool?

        public var namingAuthSupported: Bool?

        public var namingCreateServiceSupported: Bool?

        public var openSuperAcl: Bool?

        public var passWord: String?

        public var restartFlag: Bool?

        public var snapshotCount: String?

        public var syncLimit: String?

        public var TLSEnabled: Bool?

        public var tickTime: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.nacosRunningEnv?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authEnabled != nil {
                map["AuthEnabled"] = self.authEnabled!
            }
            if self.autopurgePurgeInterval != nil {
                map["AutopurgePurgeInterval"] = self.autopurgePurgeInterval!
            }
            if self.autopurgeSnapRetainCount != nil {
                map["AutopurgeSnapRetainCount"] = self.autopurgeSnapRetainCount!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.configAuthEnabled != nil {
                map["ConfigAuthEnabled"] = self.configAuthEnabled!
            }
            if self.configAuthSupported != nil {
                map["ConfigAuthSupported"] = self.configAuthSupported!
            }
            if self.configContentLimit != nil {
                map["ConfigContentLimit"] = self.configContentLimit!
            }
            if self.configSecretEnabled != nil {
                map["ConfigSecretEnabled"] = self.configSecretEnabled!
            }
            if self.configSecretSupported != nil {
                map["ConfigSecretSupported"] = self.configSecretSupported!
            }
            if self.consoleUIEnabled != nil {
                map["ConsoleUIEnabled"] = self.consoleUIEnabled!
            }
            if self.enable4lw != nil {
                map["Enable4lw"] = self.enable4lw!
            }
            if self.eurekaSupported != nil {
                map["EurekaSupported"] = self.eurekaSupported!
            }
            if self.extendedTypesEnable != nil {
                map["ExtendedTypesEnable"] = self.extendedTypesEnable!
            }
            if self.initLimit != nil {
                map["InitLimit"] = self.initLimit!
            }
            if self.juteMaxbuffer != nil {
                map["JuteMaxbuffer"] = self.juteMaxbuffer!
            }
            if self.jvmFlagsCustom != nil {
                map["JvmFlagsCustom"] = self.jvmFlagsCustom!
            }
            if self.MCPEnabled != nil {
                map["MCPEnabled"] = self.MCPEnabled!
            }
            if self.MCPSupported != nil {
                map["MCPSupported"] = self.MCPSupported!
            }
            if self.maxClientCnxns != nil {
                map["MaxClientCnxns"] = self.maxClientCnxns!
            }
            if self.maxSessionTimeout != nil {
                map["MaxSessionTimeout"] = self.maxSessionTimeout!
            }
            if self.minSessionTimeout != nil {
                map["MinSessionTimeout"] = self.minSessionTimeout!
            }
            if self.nacosRunningEnv != nil {
                map["NacosRunningEnv"] = self.nacosRunningEnv?.toMap()
            }
            if self.namingAuthEnabled != nil {
                map["NamingAuthEnabled"] = self.namingAuthEnabled!
            }
            if self.namingAuthSupported != nil {
                map["NamingAuthSupported"] = self.namingAuthSupported!
            }
            if self.namingCreateServiceSupported != nil {
                map["NamingCreateServiceSupported"] = self.namingCreateServiceSupported!
            }
            if self.openSuperAcl != nil {
                map["OpenSuperAcl"] = self.openSuperAcl!
            }
            if self.passWord != nil {
                map["PassWord"] = self.passWord!
            }
            if self.restartFlag != nil {
                map["RestartFlag"] = self.restartFlag!
            }
            if self.snapshotCount != nil {
                map["SnapshotCount"] = self.snapshotCount!
            }
            if self.syncLimit != nil {
                map["SyncLimit"] = self.syncLimit!
            }
            if self.TLSEnabled != nil {
                map["TLSEnabled"] = self.TLSEnabled!
            }
            if self.tickTime != nil {
                map["TickTime"] = self.tickTime!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthEnabled") {
                self.authEnabled = dict["AuthEnabled"] as! Bool
            }
            if dict.keys.contains("AutopurgePurgeInterval") {
                self.autopurgePurgeInterval = dict["AutopurgePurgeInterval"] as! String
            }
            if dict.keys.contains("AutopurgeSnapRetainCount") {
                self.autopurgeSnapRetainCount = dict["AutopurgeSnapRetainCount"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ConfigAuthEnabled") {
                self.configAuthEnabled = dict["ConfigAuthEnabled"] as! Bool
            }
            if dict.keys.contains("ConfigAuthSupported") {
                self.configAuthSupported = dict["ConfigAuthSupported"] as! Bool
            }
            if dict.keys.contains("ConfigContentLimit") {
                self.configContentLimit = dict["ConfigContentLimit"] as! Int64
            }
            if dict.keys.contains("ConfigSecretEnabled") {
                self.configSecretEnabled = dict["ConfigSecretEnabled"] as! Bool
            }
            if dict.keys.contains("ConfigSecretSupported") {
                self.configSecretSupported = dict["ConfigSecretSupported"] as! Bool
            }
            if dict.keys.contains("ConsoleUIEnabled") {
                self.consoleUIEnabled = dict["ConsoleUIEnabled"] as! Bool
            }
            if dict.keys.contains("Enable4lw") {
                self.enable4lw = dict["Enable4lw"] as! Bool
            }
            if dict.keys.contains("EurekaSupported") {
                self.eurekaSupported = dict["EurekaSupported"] as! Bool
            }
            if dict.keys.contains("ExtendedTypesEnable") {
                self.extendedTypesEnable = dict["ExtendedTypesEnable"] as! Bool
            }
            if dict.keys.contains("InitLimit") {
                self.initLimit = dict["InitLimit"] as! String
            }
            if dict.keys.contains("JuteMaxbuffer") {
                self.juteMaxbuffer = dict["JuteMaxbuffer"] as! String
            }
            if dict.keys.contains("JvmFlagsCustom") {
                self.jvmFlagsCustom = dict["JvmFlagsCustom"] as! String
            }
            if dict.keys.contains("MCPEnabled") {
                self.MCPEnabled = dict["MCPEnabled"] as! Bool
            }
            if dict.keys.contains("MCPSupported") {
                self.MCPSupported = dict["MCPSupported"] as! Bool
            }
            if dict.keys.contains("MaxClientCnxns") {
                self.maxClientCnxns = dict["MaxClientCnxns"] as! String
            }
            if dict.keys.contains("MaxSessionTimeout") {
                self.maxSessionTimeout = dict["MaxSessionTimeout"] as! String
            }
            if dict.keys.contains("MinSessionTimeout") {
                self.minSessionTimeout = dict["MinSessionTimeout"] as! String
            }
            if dict.keys.contains("NacosRunningEnv") {
                var model = QueryConfigResponseBody.Data.NacosRunningEnv()
                model.fromMap(dict["NacosRunningEnv"] as! [String: Any])
                self.nacosRunningEnv = model
            }
            if dict.keys.contains("NamingAuthEnabled") {
                self.namingAuthEnabled = dict["NamingAuthEnabled"] as! Bool
            }
            if dict.keys.contains("NamingAuthSupported") {
                self.namingAuthSupported = dict["NamingAuthSupported"] as! Bool
            }
            if dict.keys.contains("NamingCreateServiceSupported") {
                self.namingCreateServiceSupported = dict["NamingCreateServiceSupported"] as! Bool
            }
            if dict.keys.contains("OpenSuperAcl") {
                self.openSuperAcl = dict["OpenSuperAcl"] as! Bool
            }
            if dict.keys.contains("PassWord") {
                self.passWord = dict["PassWord"] as! String
            }
            if dict.keys.contains("RestartFlag") {
                self.restartFlag = dict["RestartFlag"] as! Bool
            }
            if dict.keys.contains("SnapshotCount") {
                self.snapshotCount = dict["SnapshotCount"] as! String
            }
            if dict.keys.contains("SyncLimit") {
                self.syncLimit = dict["SyncLimit"] as! String
            }
            if dict.keys.contains("TLSEnabled") {
                self.TLSEnabled = dict["TLSEnabled"] as! Bool
            }
            if dict.keys.contains("TickTime") {
                self.tickTime = dict["TickTime"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: QueryConfigResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = QueryConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGatewayRegionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class QueryGatewayRegionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [String]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryGatewayRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGatewayRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryGatewayRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGatewayTypeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class QueryGatewayTypeResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: [String]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryGatewayTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGatewayTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryGatewayTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGovernanceKubernetesClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var clusterName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class QueryGovernanceKubernetesClusterResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var clusterId: String?

            public var clusterName: String?

            public var k8sVersion: String?

            public var namespaceInfos: String?

            public var pilotStartTime: String?

            public var region: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.k8sVersion != nil {
                    map["K8sVersion"] = self.k8sVersion!
                }
                if self.namespaceInfos != nil {
                    map["NamespaceInfos"] = self.namespaceInfos!
                }
                if self.pilotStartTime != nil {
                    map["PilotStartTime"] = self.pilotStartTime!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterName") {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("K8sVersion") {
                    self.k8sVersion = dict["K8sVersion"] as! String
                }
                if dict.keys.contains("NamespaceInfos") {
                    self.namespaceInfos = dict["NamespaceInfos"] as! String
                }
                if dict.keys.contains("PilotStartTime") {
                    self.pilotStartTime = dict["PilotStartTime"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var result: [QueryGovernanceKubernetesClusterResponseBody.Data.Result]?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [QueryGovernanceKubernetesClusterResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = QueryGovernanceKubernetesClusterResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var data: QueryGovernanceKubernetesClusterResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QueryGovernanceKubernetesClusterResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryGovernanceKubernetesClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGovernanceKubernetesClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryGovernanceKubernetesClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryInstancesInfoRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var instanceId: String?

    public var orderId: String?

    public var regionId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class QueryInstancesInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clientPort: String?

        public var creationTimestamp: String?

        public var healthStatus: String?

        public var internetIp: String?

        public var ip: String?

        public var podName: String?

        public var role: String?

        public var singleTunnelVip: String?

        public var zone: String?

        public var zoneDistributed: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientPort != nil {
                map["ClientPort"] = self.clientPort!
            }
            if self.creationTimestamp != nil {
                map["CreationTimestamp"] = self.creationTimestamp!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.podName != nil {
                map["PodName"] = self.podName!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.singleTunnelVip != nil {
                map["SingleTunnelVip"] = self.singleTunnelVip!
            }
            if self.zone != nil {
                map["Zone"] = self.zone!
            }
            if self.zoneDistributed != nil {
                map["ZoneDistributed"] = self.zoneDistributed!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientPort") {
                self.clientPort = dict["ClientPort"] as! String
            }
            if dict.keys.contains("CreationTimestamp") {
                self.creationTimestamp = dict["CreationTimestamp"] as! String
            }
            if dict.keys.contains("HealthStatus") {
                self.healthStatus = dict["HealthStatus"] as! String
            }
            if dict.keys.contains("InternetIp") {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("PodName") {
                self.podName = dict["PodName"] as! String
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("SingleTunnelVip") {
                self.singleTunnelVip = dict["SingleTunnelVip"] as! String
            }
            if dict.keys.contains("Zone") {
                self.zone = dict["Zone"] as! String
            }
            if dict.keys.contains("ZoneDistributed") {
                self.zoneDistributed = dict["ZoneDistributed"] as! Bool
            }
        }
    }
    public var data: [QueryInstancesInfoResponseBody.Data]?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [QueryInstancesInfoResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryInstancesInfoResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryInstancesInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryInstancesInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryInstancesInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMonitorRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var monitorType: String?

    public var requestPars: String?

    public var startTime: Int64?

    public var step: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.monitorType != nil {
            map["MonitorType"] = self.monitorType!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.step != nil {
            map["Step"] = self.step!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MonitorType") {
            self.monitorType = dict["MonitorType"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Step") {
            self.step = dict["Step"] as! Int64
        }
    }
}

public class QueryMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterNamePrefix: String?

        public var podName: String?

        public var values: [[String: Any]]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterNamePrefix != nil {
                map["clusterNamePrefix"] = self.clusterNamePrefix!
            }
            if self.podName != nil {
                map["podName"] = self.podName!
            }
            if self.values != nil {
                map["values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("clusterNamePrefix") {
                self.clusterNamePrefix = dict["clusterNamePrefix"] as! String
            }
            if dict.keys.contains("podName") {
                self.podName = dict["podName"] as! String
            }
            if dict.keys.contains("values") {
                self.values = dict["values"] as! [[String: Any]]
            }
        }
    }
    public var data: [QueryMonitorResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [QueryMonitorResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryMonitorResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var name: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class QueryNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var namespace: String?

        public var region: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
        }
    }
    public var data: [QueryNamespaceResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [QueryNamespaceResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryNamespaceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySlbSpecRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class QuerySlbSpecResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var id: Int32?

        public var maxConnection: String?

        public var name: String?

        public var newConnectionPerSecond: String?

        public var qps: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.maxConnection != nil {
                map["MaxConnection"] = self.maxConnection!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.newConnectionPerSecond != nil {
                map["NewConnectionPerSecond"] = self.newConnectionPerSecond!
            }
            if self.qps != nil {
                map["Qps"] = self.qps!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("MaxConnection") {
                self.maxConnection = dict["MaxConnection"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NewConnectionPerSecond") {
                self.newConnectionPerSecond = dict["NewConnectionPerSecond"] as! String
            }
            if dict.keys.contains("Qps") {
                self.qps = dict["Qps"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [QuerySlbSpecResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [QuerySlbSpecResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QuerySlbSpecResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QuerySlbSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySlbSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySlbSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySwimmingLaneByIdRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var laneId: Int64?

    public var namespace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("LaneId") {
            self.laneId = dict["LaneId"] as! Int64
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
    }
}

public class QuerySwimmingLaneByIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EntryRules : Tea.TeaModel {
            public class RestItems : Tea.TeaModel {
                public var cond: String?

                public var datum: String?

                public var divisor: Int32?

                public var name: String?

                public var nameList: [String]?

                public var operator_: String?

                public var rate: Int32?

                public var remainder: Int32?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.datum != nil {
                        map["datum"] = self.datum!
                    }
                    if self.divisor != nil {
                        map["divisor"] = self.divisor!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.nameList != nil {
                        map["nameList"] = self.nameList!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.rate != nil {
                        map["rate"] = self.rate!
                    }
                    if self.remainder != nil {
                        map["remainder"] = self.remainder!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("cond") {
                        self.cond = dict["cond"] as! String
                    }
                    if dict.keys.contains("datum") {
                        self.datum = dict["datum"] as! String
                    }
                    if dict.keys.contains("divisor") {
                        self.divisor = dict["divisor"] as! Int32
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("nameList") {
                        self.nameList = dict["nameList"] as! [String]
                    }
                    if dict.keys.contains("operator") {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("rate") {
                        self.rate = dict["rate"] as! Int32
                    }
                    if dict.keys.contains("remainder") {
                        self.remainder = dict["remainder"] as! Int32
                    }
                    if dict.keys.contains("type") {
                        self.type = dict["type"] as! String
                    }
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var condition: String?

            public var path: String?

            public var paths: [String]?

            public var restItems: [QuerySwimmingLaneByIdResponseBody.Data.EntryRules.RestItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.paths != nil {
                    map["paths"] = self.paths!
                }
                if self.restItems != nil {
                    var tmp : [Any] = []
                    for k in self.restItems! {
                        tmp.append(k.toMap())
                    }
                    map["restItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("condition") {
                    self.condition = dict["condition"] as! String
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("paths") {
                    self.paths = dict["paths"] as! [String]
                }
                if dict.keys.contains("restItems") {
                    var tmp : [QuerySwimmingLaneByIdResponseBody.Data.EntryRules.RestItems] = []
                    for v in dict["restItems"] as! [Any] {
                        var model = QuerySwimmingLaneByIdResponseBody.Data.EntryRules.RestItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.restItems = tmp
                }
            }
        }
        public var pathIndependentPercentageEnable: Bool?

        public var enable: Bool?

        public var enableRules: Bool?

        public var entryRule: String?

        public var entryRules: [QuerySwimmingLaneByIdResponseBody.Data.EntryRules]?

        public var gatewaySwimmingLaneRouteJson: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var groupId: Int64?

        public var id: Int64?

        public var name: String?

        public var regionId: String?

        public var status: Int32?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pathIndependentPercentageEnable != nil {
                map["PathIndependentPercentageEnable"] = self.pathIndependentPercentageEnable!
            }
            if self.enable != nil {
                map["enable"] = self.enable!
            }
            if self.enableRules != nil {
                map["enableRules"] = self.enableRules!
            }
            if self.entryRule != nil {
                map["entryRule"] = self.entryRule!
            }
            if self.entryRules != nil {
                var tmp : [Any] = []
                for k in self.entryRules! {
                    tmp.append(k.toMap())
                }
                map["entryRules"] = tmp
            }
            if self.gatewaySwimmingLaneRouteJson != nil {
                map["gatewaySwimmingLaneRouteJson"] = self.gatewaySwimmingLaneRouteJson!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.groupId != nil {
                map["groupId"] = self.groupId!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.regionId != nil {
                map["regionId"] = self.regionId!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.tag != nil {
                map["tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PathIndependentPercentageEnable") {
                self.pathIndependentPercentageEnable = dict["PathIndependentPercentageEnable"] as! Bool
            }
            if dict.keys.contains("enable") {
                self.enable = dict["enable"] as! Bool
            }
            if dict.keys.contains("enableRules") {
                self.enableRules = dict["enableRules"] as! Bool
            }
            if dict.keys.contains("entryRule") {
                self.entryRule = dict["entryRule"] as! String
            }
            if dict.keys.contains("entryRules") {
                var tmp : [QuerySwimmingLaneByIdResponseBody.Data.EntryRules] = []
                for v in dict["entryRules"] as! [Any] {
                    var model = QuerySwimmingLaneByIdResponseBody.Data.EntryRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.entryRules = tmp
            }
            if dict.keys.contains("gatewaySwimmingLaneRouteJson") {
                self.gatewaySwimmingLaneRouteJson = dict["gatewaySwimmingLaneRouteJson"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! String
            }
            if dict.keys.contains("groupId") {
                self.groupId = dict["groupId"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("regionId") {
                self.regionId = dict["regionId"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! Int32
            }
            if dict.keys.contains("tag") {
                self.tag = dict["tag"] as! String
            }
        }
    }
    public var data: QuerySwimmingLaneByIdResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QuerySwimmingLaneByIdResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QuerySwimmingLaneByIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySwimmingLaneByIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySwimmingLaneByIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryZnodeDetailRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var instanceId: String?

    public var path: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class QueryZnodeDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var data: String?

        public var dir: Bool?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Dir") {
                self.dir = dict["Dir"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var data: QueryZnodeDetailResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QueryZnodeDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class QueryZnodeDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryZnodeDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryZnodeDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveApplicationRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var namespace: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class RemoveApplicationResponseBody : Tea.TeaModel {
    public var data: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RemoveApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveAuthPolicyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var policyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("PolicyId") {
            self.policyId = dict["PolicyId"] as! String
        }
    }
}

public class RemoveAuthPolicyResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RemoveAuthPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveAuthPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveAuthPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var instanceId: String?

    public var podNameList: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.podNameList != nil {
            map["PodNameList"] = self.podNameList!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PodNameList") {
            self.podNameList = dict["PodNameList"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class RestartClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RestartClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestartClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetryClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class RetryClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RetryClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RetryClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SelectGatewaySlbRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var name: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class SelectGatewaySlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var slbId: String?

        public var slbName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbName != nil {
                map["SlbName"] = self.slbName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SlbId") {
                self.slbId = dict["SlbId"] as! String
            }
            if dict.keys.contains("SlbName") {
                self.slbName = dict["SlbName"] as! String
            }
        }
    }
    public var code: Int32?

    public var data: [SelectGatewaySlbResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [SelectGatewaySlbResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = SelectGatewaySlbResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SelectGatewaySlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SelectGatewaySlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SelectGatewaySlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var all: Bool?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAclRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var aclEntryList: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.aclEntryList != nil {
            map["AclEntryList"] = self.aclEntryList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AclEntryList") {
            self.aclEntryList = dict["AclEntryList"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class UpdateAclResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAuthPolicyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var authRule: String?

    public var enable: String?

    public var id: String?

    public var k8sNamespace: String?

    public var name: String?

    public var protocol_: String?

    public var region: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.authRule != nil {
            map["AuthRule"] = self.authRule!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.k8sNamespace != nil {
            map["K8sNamespace"] = self.k8sNamespace!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AuthRule") {
            self.authRule = dict["AuthRule"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("K8sNamespace") {
            self.k8sNamespace = dict["K8sNamespace"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
    }
}

public class UpdateAuthPolicyResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateAuthPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAuthPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAuthPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateBlackWhiteListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var content: String?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var isWhite: Bool?

    public var name: String?

    public var note: String?

    public var resourceIdJsonList: String?

    public var resourceType: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.isWhite != nil {
            map["IsWhite"] = self.isWhite!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.resourceIdJsonList != nil {
            map["ResourceIdJsonList"] = self.resourceIdJsonList!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IsWhite") {
            self.isWhite = dict["IsWhite"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Note") {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("ResourceIdJsonList") {
            self.resourceIdJsonList = dict["ResourceIdJsonList"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateBlackWhiteListResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateBlackWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBlackWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateBlackWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCircuitBreakerRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var halfOpenBaseAmountPerStep: Int32?

    public var halfOpenRecoveryStepNum: Int32?

    public var maxAllowedRtMs: Int32?

    public var minRequestAmount: Int32?

    public var namespace: String?

    public var retryTimeoutMs: Int32?

    public var ruleId: Int64?

    public var statIntervalMs: Int32?

    public var strategy: Int32?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.halfOpenBaseAmountPerStep != nil {
            map["HalfOpenBaseAmountPerStep"] = self.halfOpenBaseAmountPerStep!
        }
        if self.halfOpenRecoveryStepNum != nil {
            map["HalfOpenRecoveryStepNum"] = self.halfOpenRecoveryStepNum!
        }
        if self.maxAllowedRtMs != nil {
            map["MaxAllowedRtMs"] = self.maxAllowedRtMs!
        }
        if self.minRequestAmount != nil {
            map["MinRequestAmount"] = self.minRequestAmount!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.retryTimeoutMs != nil {
            map["RetryTimeoutMs"] = self.retryTimeoutMs!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.statIntervalMs != nil {
            map["StatIntervalMs"] = self.statIntervalMs!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("HalfOpenBaseAmountPerStep") {
            self.halfOpenBaseAmountPerStep = dict["HalfOpenBaseAmountPerStep"] as! Int32
        }
        if dict.keys.contains("HalfOpenRecoveryStepNum") {
            self.halfOpenRecoveryStepNum = dict["HalfOpenRecoveryStepNum"] as! Int32
        }
        if dict.keys.contains("MaxAllowedRtMs") {
            self.maxAllowedRtMs = dict["MaxAllowedRtMs"] as! Int32
        }
        if dict.keys.contains("MinRequestAmount") {
            self.minRequestAmount = dict["MinRequestAmount"] as! Int32
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RetryTimeoutMs") {
            self.retryTimeoutMs = dict["RetryTimeoutMs"] as! Int32
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! Int64
        }
        if dict.keys.contains("StatIntervalMs") {
            self.statIntervalMs = dict["StatIntervalMs"] as! Int32
        }
        if dict.keys.contains("Strategy") {
            self.strategy = dict["Strategy"] as! Int32
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Double
        }
    }
}

public class UpdateCircuitBreakerRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var enable: Bool?

        public var halfOpenBaseAmountPerStep: Int32?

        public var halfOpenRecoveryStepNum: Int32?

        public var id: Int64?

        public var maxAllowedRtMs: Int32?

        public var minRequestAmount: Int32?

        public var namespace: String?

        public var resource: String?

        public var retryTimeoutMs: Int32?

        public var statIntervalMs: Int32?

        public var strategy: Int32?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.halfOpenBaseAmountPerStep != nil {
                map["HalfOpenBaseAmountPerStep"] = self.halfOpenBaseAmountPerStep!
            }
            if self.halfOpenRecoveryStepNum != nil {
                map["HalfOpenRecoveryStepNum"] = self.halfOpenRecoveryStepNum!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.maxAllowedRtMs != nil {
                map["MaxAllowedRtMs"] = self.maxAllowedRtMs!
            }
            if self.minRequestAmount != nil {
                map["MinRequestAmount"] = self.minRequestAmount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            if self.retryTimeoutMs != nil {
                map["RetryTimeoutMs"] = self.retryTimeoutMs!
            }
            if self.statIntervalMs != nil {
                map["StatIntervalMs"] = self.statIntervalMs!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("HalfOpenBaseAmountPerStep") {
                self.halfOpenBaseAmountPerStep = dict["HalfOpenBaseAmountPerStep"] as! Int32
            }
            if dict.keys.contains("HalfOpenRecoveryStepNum") {
                self.halfOpenRecoveryStepNum = dict["HalfOpenRecoveryStepNum"] as! Int32
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MaxAllowedRtMs") {
                self.maxAllowedRtMs = dict["MaxAllowedRtMs"] as! Int32
            }
            if dict.keys.contains("MinRequestAmount") {
                self.minRequestAmount = dict["MinRequestAmount"] as! Int32
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Resource") {
                self.resource = dict["Resource"] as! String
            }
            if dict.keys.contains("RetryTimeoutMs") {
                self.retryTimeoutMs = dict["RetryTimeoutMs"] as! Int32
            }
            if dict.keys.contains("StatIntervalMs") {
                self.statIntervalMs = dict["StatIntervalMs"] as! Int32
            }
            if dict.keys.contains("Strategy") {
                self.strategy = dict["Strategy"] as! Int32
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var code: String?

    public var data: UpdateCircuitBreakerRuleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateCircuitBreakerRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCircuitBreakerRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCircuitBreakerRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCircuitBreakerRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterAliasName: String?

    public var instanceId: String?

    public var maintenanceEndTime: String?

    public var maintenanceStartTime: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterAliasName != nil {
            map["ClusterAliasName"] = self.clusterAliasName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maintenanceEndTime != nil {
            map["MaintenanceEndTime"] = self.maintenanceEndTime!
        }
        if self.maintenanceStartTime != nil {
            map["MaintenanceStartTime"] = self.maintenanceStartTime!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterAliasName") {
            self.clusterAliasName = dict["ClusterAliasName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaintenanceEndTime") {
            self.maintenanceEndTime = dict["MaintenanceEndTime"] as! String
        }
        if dict.keys.contains("MaintenanceStartTime") {
            self.maintenanceStartTime = dict["MaintenanceStartTime"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class UpdateClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateClusterSpecRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var autoPay: Bool?

    public var clusterId: String?

    public var clusterSpecification: String?

    public var instanceCount: Int32?

    public var instanceId: String?

    public var mseVersion: String?

    public var pubNetworkFlow: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterSpecification != nil {
            map["ClusterSpecification"] = self.clusterSpecification!
        }
        if self.instanceCount != nil {
            map["InstanceCount"] = self.instanceCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mseVersion != nil {
            map["MseVersion"] = self.mseVersion!
        }
        if self.pubNetworkFlow != nil {
            map["PubNetworkFlow"] = self.pubNetworkFlow!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterSpecification") {
            self.clusterSpecification = dict["ClusterSpecification"] as! String
        }
        if dict.keys.contains("InstanceCount") {
            self.instanceCount = dict["InstanceCount"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MseVersion") {
            self.mseVersion = dict["MseVersion"] as! String
        }
        if dict.keys.contains("PubNetworkFlow") {
            self.pubNetworkFlow = dict["PubNetworkFlow"] as! Int32
        }
    }
}

public class UpdateClusterSpecResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateClusterSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateClusterSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateClusterSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var authEnabled: Bool?

    public var autopurgePurgeInterval: String?

    public var autopurgeSnapRetainCount: String?

    public var clusterId: String?

    public var configAuthEnabled: Bool?

    public var configSecretEnabled: Bool?

    public var configType: String?

    public var consoleUIEnabled: Bool?

    public var enable4lw: Bool?

    public var eurekaSupported: Bool?

    public var extendedTypesEnable: String?

    public var initLimit: String?

    public var instanceId: String?

    public var juteMaxbuffer: String?

    public var MCPEnabled: Bool?

    public var maxClientCnxns: String?

    public var maxSessionTimeout: String?

    public var minSessionTimeout: String?

    public var namingAuthEnabled: Bool?

    public var openSuperAcl: String?

    public var passWord: String?

    public var requestPars: String?

    public var snapshotCount: String?

    public var syncLimit: String?

    public var TLSEnabled: Bool?

    public var tickTime: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.authEnabled != nil {
            map["AuthEnabled"] = self.authEnabled!
        }
        if self.autopurgePurgeInterval != nil {
            map["AutopurgePurgeInterval"] = self.autopurgePurgeInterval!
        }
        if self.autopurgeSnapRetainCount != nil {
            map["AutopurgeSnapRetainCount"] = self.autopurgeSnapRetainCount!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configAuthEnabled != nil {
            map["ConfigAuthEnabled"] = self.configAuthEnabled!
        }
        if self.configSecretEnabled != nil {
            map["ConfigSecretEnabled"] = self.configSecretEnabled!
        }
        if self.configType != nil {
            map["ConfigType"] = self.configType!
        }
        if self.consoleUIEnabled != nil {
            map["ConsoleUIEnabled"] = self.consoleUIEnabled!
        }
        if self.enable4lw != nil {
            map["Enable4lw"] = self.enable4lw!
        }
        if self.eurekaSupported != nil {
            map["EurekaSupported"] = self.eurekaSupported!
        }
        if self.extendedTypesEnable != nil {
            map["ExtendedTypesEnable"] = self.extendedTypesEnable!
        }
        if self.initLimit != nil {
            map["InitLimit"] = self.initLimit!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.juteMaxbuffer != nil {
            map["JuteMaxbuffer"] = self.juteMaxbuffer!
        }
        if self.MCPEnabled != nil {
            map["MCPEnabled"] = self.MCPEnabled!
        }
        if self.maxClientCnxns != nil {
            map["MaxClientCnxns"] = self.maxClientCnxns!
        }
        if self.maxSessionTimeout != nil {
            map["MaxSessionTimeout"] = self.maxSessionTimeout!
        }
        if self.minSessionTimeout != nil {
            map["MinSessionTimeout"] = self.minSessionTimeout!
        }
        if self.namingAuthEnabled != nil {
            map["NamingAuthEnabled"] = self.namingAuthEnabled!
        }
        if self.openSuperAcl != nil {
            map["OpenSuperAcl"] = self.openSuperAcl!
        }
        if self.passWord != nil {
            map["PassWord"] = self.passWord!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.snapshotCount != nil {
            map["SnapshotCount"] = self.snapshotCount!
        }
        if self.syncLimit != nil {
            map["SyncLimit"] = self.syncLimit!
        }
        if self.TLSEnabled != nil {
            map["TLSEnabled"] = self.TLSEnabled!
        }
        if self.tickTime != nil {
            map["TickTime"] = self.tickTime!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AuthEnabled") {
            self.authEnabled = dict["AuthEnabled"] as! Bool
        }
        if dict.keys.contains("AutopurgePurgeInterval") {
            self.autopurgePurgeInterval = dict["AutopurgePurgeInterval"] as! String
        }
        if dict.keys.contains("AutopurgeSnapRetainCount") {
            self.autopurgeSnapRetainCount = dict["AutopurgeSnapRetainCount"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigAuthEnabled") {
            self.configAuthEnabled = dict["ConfigAuthEnabled"] as! Bool
        }
        if dict.keys.contains("ConfigSecretEnabled") {
            self.configSecretEnabled = dict["ConfigSecretEnabled"] as! Bool
        }
        if dict.keys.contains("ConfigType") {
            self.configType = dict["ConfigType"] as! String
        }
        if dict.keys.contains("ConsoleUIEnabled") {
            self.consoleUIEnabled = dict["ConsoleUIEnabled"] as! Bool
        }
        if dict.keys.contains("Enable4lw") {
            self.enable4lw = dict["Enable4lw"] as! Bool
        }
        if dict.keys.contains("EurekaSupported") {
            self.eurekaSupported = dict["EurekaSupported"] as! Bool
        }
        if dict.keys.contains("ExtendedTypesEnable") {
            self.extendedTypesEnable = dict["ExtendedTypesEnable"] as! String
        }
        if dict.keys.contains("InitLimit") {
            self.initLimit = dict["InitLimit"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JuteMaxbuffer") {
            self.juteMaxbuffer = dict["JuteMaxbuffer"] as! String
        }
        if dict.keys.contains("MCPEnabled") {
            self.MCPEnabled = dict["MCPEnabled"] as! Bool
        }
        if dict.keys.contains("MaxClientCnxns") {
            self.maxClientCnxns = dict["MaxClientCnxns"] as! String
        }
        if dict.keys.contains("MaxSessionTimeout") {
            self.maxSessionTimeout = dict["MaxSessionTimeout"] as! String
        }
        if dict.keys.contains("MinSessionTimeout") {
            self.minSessionTimeout = dict["MinSessionTimeout"] as! String
        }
        if dict.keys.contains("NamingAuthEnabled") {
            self.namingAuthEnabled = dict["NamingAuthEnabled"] as! Bool
        }
        if dict.keys.contains("OpenSuperAcl") {
            self.openSuperAcl = dict["OpenSuperAcl"] as! String
        }
        if dict.keys.contains("PassWord") {
            self.passWord = dict["PassWord"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("SnapshotCount") {
            self.snapshotCount = dict["SnapshotCount"] as! String
        }
        if dict.keys.contains("SyncLimit") {
            self.syncLimit = dict["SyncLimit"] as! String
        }
        if dict.keys.contains("TLSEnabled") {
            self.TLSEnabled = dict["TLSEnabled"] as! Bool
        }
        if dict.keys.contains("TickTime") {
            self.tickTime = dict["TickTime"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class UpdateConfigResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEngineNamespaceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var desc: String?

    public var id: String?

    public var instanceId: String?

    public var name: String?

    public var serviceCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.serviceCount != nil {
            map["ServiceCount"] = self.serviceCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Desc") {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ServiceCount") {
            self.serviceCount = dict["ServiceCount"] as! Int32
        }
    }
}

public class UpdateEngineNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configCount: Int32?

        public var namespace: String?

        public var namespaceDesc: String?

        public var namespaceShowName: String?

        public var quota: Int32?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configCount != nil {
                map["ConfigCount"] = self.configCount!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.namespaceDesc != nil {
                map["NamespaceDesc"] = self.namespaceDesc!
            }
            if self.namespaceShowName != nil {
                map["NamespaceShowName"] = self.namespaceShowName!
            }
            if self.quota != nil {
                map["Quota"] = self.quota!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigCount") {
                self.configCount = dict["ConfigCount"] as! Int32
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NamespaceDesc") {
                self.namespaceDesc = dict["NamespaceDesc"] as! String
            }
            if dict.keys.contains("NamespaceShowName") {
                self.namespaceShowName = dict["NamespaceShowName"] as! String
            }
            if dict.keys.contains("Quota") {
                self.quota = dict["Quota"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var data: UpdateEngineNamespaceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = UpdateEngineNamespaceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateEngineNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEngineNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEngineNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFlowRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var controlBehavior: Int32?

    public var enable: Bool?

    public var limitApp: String?

    public var maxQueueingTimeMs: Int32?

    public var namespace: String?

    public var ruleId: Int64?

    public var threshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.controlBehavior != nil {
            map["ControlBehavior"] = self.controlBehavior!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.limitApp != nil {
            map["LimitApp"] = self.limitApp!
        }
        if self.maxQueueingTimeMs != nil {
            map["MaxQueueingTimeMs"] = self.maxQueueingTimeMs!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ControlBehavior") {
            self.controlBehavior = dict["ControlBehavior"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("LimitApp") {
            self.limitApp = dict["LimitApp"] as! String
        }
        if dict.keys.contains("MaxQueueingTimeMs") {
            self.maxQueueingTimeMs = dict["MaxQueueingTimeMs"] as! Int32
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! Int64
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Int32
        }
    }
}

public class UpdateFlowRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var controlBehavior: Int32?

        public var enable: Bool?

        public var id: Int64?

        public var limitApp: String?

        public var maxQueueingTimeMs: Int32?

        public var namespace: String?

        public var resource: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.controlBehavior != nil {
                map["ControlBehavior"] = self.controlBehavior!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.limitApp != nil {
                map["LimitApp"] = self.limitApp!
            }
            if self.maxQueueingTimeMs != nil {
                map["MaxQueueingTimeMs"] = self.maxQueueingTimeMs!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ControlBehavior") {
                self.controlBehavior = dict["ControlBehavior"] as! Int32
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("LimitApp") {
                self.limitApp = dict["LimitApp"] as! String
            }
            if dict.keys.contains("MaxQueueingTimeMs") {
                self.maxQueueingTimeMs = dict["MaxQueueingTimeMs"] as! Int32
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Resource") {
                self.resource = dict["Resource"] as! String
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var code: String?

    public var data: UpdateFlowRuleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateFlowRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateFlowRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFlowRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateFlowRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayAuthConsumerRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var description_: String?

    public var encodeType: String?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var jwks: String?

    public var keyName: String?

    public var keyValue: String?

    public var tokenName: String?

    public var tokenPass: Bool?

    public var tokenPosition: String?

    public var tokenPrefix: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.encodeType != nil {
            map["EncodeType"] = self.encodeType!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.jwks != nil {
            map["Jwks"] = self.jwks!
        }
        if self.keyName != nil {
            map["KeyName"] = self.keyName!
        }
        if self.keyValue != nil {
            map["KeyValue"] = self.keyValue!
        }
        if self.tokenName != nil {
            map["TokenName"] = self.tokenName!
        }
        if self.tokenPass != nil {
            map["TokenPass"] = self.tokenPass!
        }
        if self.tokenPosition != nil {
            map["TokenPosition"] = self.tokenPosition!
        }
        if self.tokenPrefix != nil {
            map["TokenPrefix"] = self.tokenPrefix!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EncodeType") {
            self.encodeType = dict["EncodeType"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Jwks") {
            self.jwks = dict["Jwks"] as! String
        }
        if dict.keys.contains("KeyName") {
            self.keyName = dict["KeyName"] as! String
        }
        if dict.keys.contains("KeyValue") {
            self.keyValue = dict["KeyValue"] as! String
        }
        if dict.keys.contains("TokenName") {
            self.tokenName = dict["TokenName"] as! String
        }
        if dict.keys.contains("TokenPass") {
            self.tokenPass = dict["TokenPass"] as! Bool
        }
        if dict.keys.contains("TokenPosition") {
            self.tokenPosition = dict["TokenPosition"] as! String
        }
        if dict.keys.contains("TokenPrefix") {
            self.tokenPrefix = dict["TokenPrefix"] as! String
        }
    }
}

public class UpdateGatewayAuthConsumerResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayAuthConsumerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayAuthConsumerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayAuthConsumerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayAuthConsumerResourceRequest : Tea.TeaModel {
    public class ResourceList : Tea.TeaModel {
        public var routeId: Int64?

        public var routeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeId != nil {
                map["RouteId"] = self.routeId!
            }
            if self.routeName != nil {
                map["RouteName"] = self.routeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RouteId") {
                self.routeId = dict["RouteId"] as! Int64
            }
            if dict.keys.contains("RouteName") {
                self.routeName = dict["RouteName"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var consumerId: Int64?

    public var gatewayUniqueId: String?

    public var resourceList: [UpdateGatewayAuthConsumerResourceRequest.ResourceList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerId != nil {
            map["ConsumerId"] = self.consumerId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.resourceList != nil {
            var tmp : [Any] = []
            for k in self.resourceList! {
                tmp.append(k.toMap())
            }
            map["ResourceList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerId") {
            self.consumerId = dict["ConsumerId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ResourceList") {
            var tmp : [UpdateGatewayAuthConsumerResourceRequest.ResourceList] = []
            for v in dict["ResourceList"] as! [Any] {
                var model = UpdateGatewayAuthConsumerResourceRequest.ResourceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceList = tmp
        }
    }
}

public class UpdateGatewayAuthConsumerResourceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerId: Int64?

    public var gatewayUniqueId: String?

    public var resourceListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerId != nil {
            map["ConsumerId"] = self.consumerId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.resourceListShrink != nil {
            map["ResourceList"] = self.resourceListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerId") {
            self.consumerId = dict["ConsumerId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ResourceList") {
            self.resourceListShrink = dict["ResourceList"] as! String
        }
    }
}

public class UpdateGatewayAuthConsumerResourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayAuthConsumerResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayAuthConsumerResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayAuthConsumerResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayAuthConsumerResourceStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerId: Int64?

    public var gatewayUniqueId: String?

    public var idList: String?

    public var resourceStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerId != nil {
            map["ConsumerId"] = self.consumerId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.idList != nil {
            map["IdList"] = self.idList!
        }
        if self.resourceStatus != nil {
            map["ResourceStatus"] = self.resourceStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerId") {
            self.consumerId = dict["ConsumerId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("IdList") {
            self.idList = dict["IdList"] as! String
        }
        if dict.keys.contains("ResourceStatus") {
            self.resourceStatus = dict["ResourceStatus"] as! Bool
        }
    }
}

public class UpdateGatewayAuthConsumerResourceStatusResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayAuthConsumerResourceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayAuthConsumerResourceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayAuthConsumerResourceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayAuthConsumerStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var consumerStatus: Bool?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.consumerStatus != nil {
            map["ConsumerStatus"] = self.consumerStatus!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConsumerStatus") {
            self.consumerStatus = dict["ConsumerStatus"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayAuthConsumerStatusResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayAuthConsumerStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayAuthConsumerStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayAuthConsumerStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayCircuitBreakerRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var behaviorType: Int32?

    public var bodyEncoding: Int32?

    public var enable: Int32?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var maxAllowedMs: Int32?

    public var minRequestAmount: Int32?

    public var recoveryTimeoutSec: Int32?

    public var responseContentBody: String?

    public var responseRedirectUrl: String?

    public var responseStatusCode: Int32?

    public var routeId: Int64?

    public var routeName: String?

    public var statDurationSec: Int32?

    public var strategy: Int32?

    public var triggerRatio: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.behaviorType != nil {
            map["BehaviorType"] = self.behaviorType!
        }
        if self.bodyEncoding != nil {
            map["BodyEncoding"] = self.bodyEncoding!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.maxAllowedMs != nil {
            map["MaxAllowedMs"] = self.maxAllowedMs!
        }
        if self.minRequestAmount != nil {
            map["MinRequestAmount"] = self.minRequestAmount!
        }
        if self.recoveryTimeoutSec != nil {
            map["RecoveryTimeoutSec"] = self.recoveryTimeoutSec!
        }
        if self.responseContentBody != nil {
            map["ResponseContentBody"] = self.responseContentBody!
        }
        if self.responseRedirectUrl != nil {
            map["ResponseRedirectUrl"] = self.responseRedirectUrl!
        }
        if self.responseStatusCode != nil {
            map["ResponseStatusCode"] = self.responseStatusCode!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        if self.routeName != nil {
            map["RouteName"] = self.routeName!
        }
        if self.statDurationSec != nil {
            map["StatDurationSec"] = self.statDurationSec!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        if self.triggerRatio != nil {
            map["TriggerRatio"] = self.triggerRatio!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("BehaviorType") {
            self.behaviorType = dict["BehaviorType"] as! Int32
        }
        if dict.keys.contains("BodyEncoding") {
            self.bodyEncoding = dict["BodyEncoding"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Int32
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MaxAllowedMs") {
            self.maxAllowedMs = dict["MaxAllowedMs"] as! Int32
        }
        if dict.keys.contains("MinRequestAmount") {
            self.minRequestAmount = dict["MinRequestAmount"] as! Int32
        }
        if dict.keys.contains("RecoveryTimeoutSec") {
            self.recoveryTimeoutSec = dict["RecoveryTimeoutSec"] as! Int32
        }
        if dict.keys.contains("ResponseContentBody") {
            self.responseContentBody = dict["ResponseContentBody"] as! String
        }
        if dict.keys.contains("ResponseRedirectUrl") {
            self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
        }
        if dict.keys.contains("ResponseStatusCode") {
            self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
        if dict.keys.contains("RouteName") {
            self.routeName = dict["RouteName"] as! String
        }
        if dict.keys.contains("StatDurationSec") {
            self.statDurationSec = dict["StatDurationSec"] as! Int32
        }
        if dict.keys.contains("Strategy") {
            self.strategy = dict["Strategy"] as! Int32
        }
        if dict.keys.contains("TriggerRatio") {
            self.triggerRatio = dict["TriggerRatio"] as! Int32
        }
    }
}

public class UpdateGatewayCircuitBreakerRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var behaviorType: Int32?

        public var bodyEncoding: Int32?

        public var enable: Int32?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var id: Int64?

        public var idList: [Int64]?

        public var limitMode: Int32?

        public var maxAllowedMs: Int32?

        public var minRequestAmount: Int32?

        public var recoveryTimeoutSec: Int32?

        public var responseAdditionalHeaders: String?

        public var responseContentBody: String?

        public var responseRedirectUrl: String?

        public var responseStatusCode: Int32?

        public var routeId: Int64?

        public var routeName: String?

        public var statDurationSec: Int32?

        public var strategy: Int32?

        public var triggerRatio: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.behaviorType != nil {
                map["BehaviorType"] = self.behaviorType!
            }
            if self.bodyEncoding != nil {
                map["BodyEncoding"] = self.bodyEncoding!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.idList != nil {
                map["IdList"] = self.idList!
            }
            if self.limitMode != nil {
                map["LimitMode"] = self.limitMode!
            }
            if self.maxAllowedMs != nil {
                map["MaxAllowedMs"] = self.maxAllowedMs!
            }
            if self.minRequestAmount != nil {
                map["MinRequestAmount"] = self.minRequestAmount!
            }
            if self.recoveryTimeoutSec != nil {
                map["RecoveryTimeoutSec"] = self.recoveryTimeoutSec!
            }
            if self.responseAdditionalHeaders != nil {
                map["ResponseAdditionalHeaders"] = self.responseAdditionalHeaders!
            }
            if self.responseContentBody != nil {
                map["ResponseContentBody"] = self.responseContentBody!
            }
            if self.responseRedirectUrl != nil {
                map["ResponseRedirectUrl"] = self.responseRedirectUrl!
            }
            if self.responseStatusCode != nil {
                map["ResponseStatusCode"] = self.responseStatusCode!
            }
            if self.routeId != nil {
                map["RouteId"] = self.routeId!
            }
            if self.routeName != nil {
                map["RouteName"] = self.routeName!
            }
            if self.statDurationSec != nil {
                map["StatDurationSec"] = self.statDurationSec!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy!
            }
            if self.triggerRatio != nil {
                map["TriggerRatio"] = self.triggerRatio!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BehaviorType") {
                self.behaviorType = dict["BehaviorType"] as! Int32
            }
            if dict.keys.contains("BodyEncoding") {
                self.bodyEncoding = dict["BodyEncoding"] as! Int32
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Int32
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IdList") {
                self.idList = dict["IdList"] as! [Int64]
            }
            if dict.keys.contains("LimitMode") {
                self.limitMode = dict["LimitMode"] as! Int32
            }
            if dict.keys.contains("MaxAllowedMs") {
                self.maxAllowedMs = dict["MaxAllowedMs"] as! Int32
            }
            if dict.keys.contains("MinRequestAmount") {
                self.minRequestAmount = dict["MinRequestAmount"] as! Int32
            }
            if dict.keys.contains("RecoveryTimeoutSec") {
                self.recoveryTimeoutSec = dict["RecoveryTimeoutSec"] as! Int32
            }
            if dict.keys.contains("ResponseAdditionalHeaders") {
                self.responseAdditionalHeaders = dict["ResponseAdditionalHeaders"] as! String
            }
            if dict.keys.contains("ResponseContentBody") {
                self.responseContentBody = dict["ResponseContentBody"] as! String
            }
            if dict.keys.contains("ResponseRedirectUrl") {
                self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
            }
            if dict.keys.contains("ResponseStatusCode") {
                self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
            }
            if dict.keys.contains("RouteId") {
                self.routeId = dict["RouteId"] as! Int64
            }
            if dict.keys.contains("RouteName") {
                self.routeName = dict["RouteName"] as! String
            }
            if dict.keys.contains("StatDurationSec") {
                self.statDurationSec = dict["StatDurationSec"] as! Int32
            }
            if dict.keys.contains("Strategy") {
                self.strategy = dict["Strategy"] as! Int32
            }
            if dict.keys.contains("TriggerRatio") {
                self.triggerRatio = dict["TriggerRatio"] as! Int32
            }
        }
    }
    public var data: UpdateGatewayCircuitBreakerRuleResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = UpdateGatewayCircuitBreakerRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGatewayCircuitBreakerRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayCircuitBreakerRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayCircuitBreakerRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var configName: String?

    public var configValue: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.configName != nil {
            map["ConfigName"] = self.configName!
        }
        if self.configValue != nil {
            map["ConfigValue"] = self.configValue!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ConfigName") {
            self.configName = dict["ConfigName"] as! String
        }
        if dict.keys.contains("ConfigValue") {
            self.configValue = dict["ConfigValue"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class UpdateGatewayConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGatewayConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayDomainRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certIdentifier: String?

    public var gatewayUniqueId: String?

    public var http2: String?

    public var id: Int64?

    public var mustHttps: Bool?

    public var protocol_: String?

    public var tlsMax: String?

    public var tlsMin: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.http2 != nil {
            map["Http2"] = self.http2!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.mustHttps != nil {
            map["MustHttps"] = self.mustHttps!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.tlsMax != nil {
            map["TlsMax"] = self.tlsMax!
        }
        if self.tlsMin != nil {
            map["TlsMin"] = self.tlsMin!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertIdentifier") {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Http2") {
            self.http2 = dict["Http2"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MustHttps") {
            self.mustHttps = dict["MustHttps"] as! Bool
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("TlsMax") {
            self.tlsMax = dict["TlsMax"] as! String
        }
        if dict.keys.contains("TlsMin") {
            self.tlsMin = dict["TlsMin"] as! String
        }
    }
}

public class UpdateGatewayDomainResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayFlowRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var behaviorType: Int32?

    public var bodyEncoding: Int32?

    public var enable: Int32?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var responseContentBody: String?

    public var responseRedirectUrl: String?

    public var responseStatusCode: Int32?

    public var routeId: Int64?

    public var routeName: String?

    public var threshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.behaviorType != nil {
            map["BehaviorType"] = self.behaviorType!
        }
        if self.bodyEncoding != nil {
            map["BodyEncoding"] = self.bodyEncoding!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.responseContentBody != nil {
            map["ResponseContentBody"] = self.responseContentBody!
        }
        if self.responseRedirectUrl != nil {
            map["ResponseRedirectUrl"] = self.responseRedirectUrl!
        }
        if self.responseStatusCode != nil {
            map["ResponseStatusCode"] = self.responseStatusCode!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        if self.routeName != nil {
            map["RouteName"] = self.routeName!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("BehaviorType") {
            self.behaviorType = dict["BehaviorType"] as! Int32
        }
        if dict.keys.contains("BodyEncoding") {
            self.bodyEncoding = dict["BodyEncoding"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Int32
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("ResponseContentBody") {
            self.responseContentBody = dict["ResponseContentBody"] as! String
        }
        if dict.keys.contains("ResponseRedirectUrl") {
            self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
        }
        if dict.keys.contains("ResponseStatusCode") {
            self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
        if dict.keys.contains("RouteName") {
            self.routeName = dict["RouteName"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Int32
        }
    }
}

public class UpdateGatewayFlowRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var behaviorType: Int32?

        public var bodyEncoding: Int32?

        public var enable: Int32?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var id: Int64?

        public var idList: [Int64]?

        public var limitMode: Int32?

        public var responseAdditionalHeaders: String?

        public var responseContentBody: String?

        public var responseRedirectUrl: String?

        public var responseStatusCode: Int32?

        public var routeId: Int64?

        public var routeName: String?

        public var statDurationMs: Int32?

        public var threshold: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.behaviorType != nil {
                map["BehaviorType"] = self.behaviorType!
            }
            if self.bodyEncoding != nil {
                map["BodyEncoding"] = self.bodyEncoding!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.idList != nil {
                map["IdList"] = self.idList!
            }
            if self.limitMode != nil {
                map["LimitMode"] = self.limitMode!
            }
            if self.responseAdditionalHeaders != nil {
                map["ResponseAdditionalHeaders"] = self.responseAdditionalHeaders!
            }
            if self.responseContentBody != nil {
                map["ResponseContentBody"] = self.responseContentBody!
            }
            if self.responseRedirectUrl != nil {
                map["ResponseRedirectUrl"] = self.responseRedirectUrl!
            }
            if self.responseStatusCode != nil {
                map["ResponseStatusCode"] = self.responseStatusCode!
            }
            if self.routeId != nil {
                map["RouteId"] = self.routeId!
            }
            if self.routeName != nil {
                map["RouteName"] = self.routeName!
            }
            if self.statDurationMs != nil {
                map["StatDurationMs"] = self.statDurationMs!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BehaviorType") {
                self.behaviorType = dict["BehaviorType"] as! Int32
            }
            if dict.keys.contains("BodyEncoding") {
                self.bodyEncoding = dict["BodyEncoding"] as! Int32
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Int32
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IdList") {
                self.idList = dict["IdList"] as! [Int64]
            }
            if dict.keys.contains("LimitMode") {
                self.limitMode = dict["LimitMode"] as! Int32
            }
            if dict.keys.contains("ResponseAdditionalHeaders") {
                self.responseAdditionalHeaders = dict["ResponseAdditionalHeaders"] as! String
            }
            if dict.keys.contains("ResponseContentBody") {
                self.responseContentBody = dict["ResponseContentBody"] as! String
            }
            if dict.keys.contains("ResponseRedirectUrl") {
                self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
            }
            if dict.keys.contains("ResponseStatusCode") {
                self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
            }
            if dict.keys.contains("RouteId") {
                self.routeId = dict["RouteId"] as! Int64
            }
            if dict.keys.contains("RouteName") {
                self.routeName = dict["RouteName"] as! String
            }
            if dict.keys.contains("StatDurationMs") {
                self.statDurationMs = dict["StatDurationMs"] as! Int32
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Int32
            }
        }
    }
    public var data: UpdateGatewayFlowRuleResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = UpdateGatewayFlowRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGatewayFlowRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayFlowRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayFlowRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayIsolationRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var behaviorType: Int32?

    public var bodyEncoding: Int32?

    public var enable: Int32?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var maxConcurrency: Int32?

    public var responseContentBody: String?

    public var responseRedirectUrl: String?

    public var responseStatusCode: Int32?

    public var routeId: Int64?

    public var routeName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.behaviorType != nil {
            map["BehaviorType"] = self.behaviorType!
        }
        if self.bodyEncoding != nil {
            map["BodyEncoding"] = self.bodyEncoding!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.maxConcurrency != nil {
            map["MaxConcurrency"] = self.maxConcurrency!
        }
        if self.responseContentBody != nil {
            map["ResponseContentBody"] = self.responseContentBody!
        }
        if self.responseRedirectUrl != nil {
            map["ResponseRedirectUrl"] = self.responseRedirectUrl!
        }
        if self.responseStatusCode != nil {
            map["ResponseStatusCode"] = self.responseStatusCode!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        if self.routeName != nil {
            map["RouteName"] = self.routeName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("BehaviorType") {
            self.behaviorType = dict["BehaviorType"] as! Int32
        }
        if dict.keys.contains("BodyEncoding") {
            self.bodyEncoding = dict["BodyEncoding"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Int32
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("MaxConcurrency") {
            self.maxConcurrency = dict["MaxConcurrency"] as! Int32
        }
        if dict.keys.contains("ResponseContentBody") {
            self.responseContentBody = dict["ResponseContentBody"] as! String
        }
        if dict.keys.contains("ResponseRedirectUrl") {
            self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
        }
        if dict.keys.contains("ResponseStatusCode") {
            self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
        if dict.keys.contains("RouteName") {
            self.routeName = dict["RouteName"] as! String
        }
    }
}

public class UpdateGatewayIsolationRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var behaviorType: Int32?

        public var bodyEncoding: Int32?

        public var enable: Int32?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var id: Int64?

        public var idList: [Int64]?

        public var limitMode: Int32?

        public var maxConcurrency: Int32?

        public var responseAdditionalHeaders: String?

        public var responseContentBody: String?

        public var responseRedirectUrl: String?

        public var responseStatusCode: Int32?

        public var routeId: Int64?

        public var routeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.behaviorType != nil {
                map["BehaviorType"] = self.behaviorType!
            }
            if self.bodyEncoding != nil {
                map["BodyEncoding"] = self.bodyEncoding!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.idList != nil {
                map["IdList"] = self.idList!
            }
            if self.limitMode != nil {
                map["LimitMode"] = self.limitMode!
            }
            if self.maxConcurrency != nil {
                map["MaxConcurrency"] = self.maxConcurrency!
            }
            if self.responseAdditionalHeaders != nil {
                map["ResponseAdditionalHeaders"] = self.responseAdditionalHeaders!
            }
            if self.responseContentBody != nil {
                map["ResponseContentBody"] = self.responseContentBody!
            }
            if self.responseRedirectUrl != nil {
                map["ResponseRedirectUrl"] = self.responseRedirectUrl!
            }
            if self.responseStatusCode != nil {
                map["ResponseStatusCode"] = self.responseStatusCode!
            }
            if self.routeId != nil {
                map["RouteId"] = self.routeId!
            }
            if self.routeName != nil {
                map["RouteName"] = self.routeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BehaviorType") {
                self.behaviorType = dict["BehaviorType"] as! Int32
            }
            if dict.keys.contains("BodyEncoding") {
                self.bodyEncoding = dict["BodyEncoding"] as! Int32
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Int32
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IdList") {
                self.idList = dict["IdList"] as! [Int64]
            }
            if dict.keys.contains("LimitMode") {
                self.limitMode = dict["LimitMode"] as! Int32
            }
            if dict.keys.contains("MaxConcurrency") {
                self.maxConcurrency = dict["MaxConcurrency"] as! Int32
            }
            if dict.keys.contains("ResponseAdditionalHeaders") {
                self.responseAdditionalHeaders = dict["ResponseAdditionalHeaders"] as! String
            }
            if dict.keys.contains("ResponseContentBody") {
                self.responseContentBody = dict["ResponseContentBody"] as! String
            }
            if dict.keys.contains("ResponseRedirectUrl") {
                self.responseRedirectUrl = dict["ResponseRedirectUrl"] as! String
            }
            if dict.keys.contains("ResponseStatusCode") {
                self.responseStatusCode = dict["ResponseStatusCode"] as! Int32
            }
            if dict.keys.contains("RouteId") {
                self.routeId = dict["RouteId"] as! Int64
            }
            if dict.keys.contains("RouteName") {
                self.routeName = dict["RouteName"] as! String
            }
        }
    }
    public var data: UpdateGatewayIsolationRuleResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = UpdateGatewayIsolationRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGatewayIsolationRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayIsolationRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayIsolationRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayNameRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class UpdateGatewayNameResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayOptionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayOption: GatewayOption?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gatewayOption?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayOption != nil {
            map["GatewayOption"] = self.gatewayOption?.toMap()
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayOption") {
            var model = GatewayOption()
            model.fromMap(dict["GatewayOption"] as! [String: Any])
            self.gatewayOption = model
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class UpdateGatewayOptionShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayOptionShrink: String?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayOptionShrink != nil {
            map["GatewayOption"] = self.gatewayOptionShrink!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayOption") {
            self.gatewayOptionShrink = dict["GatewayOption"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class UpdateGatewayOptionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: GatewayOption?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GatewayOption()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayOptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayOptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayOptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteRequest : Tea.TeaModel {
    public class DirectResponseJSON : Tea.TeaModel {
        public var body: String?

        public var code: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.body != nil {
                map["Body"] = self.body!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Body") {
                self.body = dict["Body"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! Int64
            }
        }
    }
    public class FallbackServices : Tea.TeaModel {
        public var agreementType: String?

        public var groupName: String?

        public var name: String?

        public var namespace: String?

        public var percent: Int32?

        public var serviceId: Int64?

        public var servicePort: Int32?

        public var sourceType: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agreementType != nil {
                map["AgreementType"] = self.agreementType!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgreementType") {
                self.agreementType = dict["AgreementType"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("ServiceId") {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") {
                self.servicePort = dict["ServicePort"] as! Int32
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public class Predicates : Tea.TeaModel {
        public class HeaderPredicates : Tea.TeaModel {
            public var key: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class PathPredicates : Tea.TeaModel {
            public var ignoreCase: Bool?

            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ignoreCase != nil {
                    map["IgnoreCase"] = self.ignoreCase!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IgnoreCase") {
                    self.ignoreCase = dict["IgnoreCase"] as! Bool
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class QueryPredicates : Tea.TeaModel {
            public var key: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var headerPredicates: [UpdateGatewayRouteRequest.Predicates.HeaderPredicates]?

        public var methodPredicates: [String]?

        public var pathPredicates: UpdateGatewayRouteRequest.Predicates.PathPredicates?

        public var queryPredicates: [UpdateGatewayRouteRequest.Predicates.QueryPredicates]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pathPredicates?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.headerPredicates != nil {
                var tmp : [Any] = []
                for k in self.headerPredicates! {
                    tmp.append(k.toMap())
                }
                map["HeaderPredicates"] = tmp
            }
            if self.methodPredicates != nil {
                map["MethodPredicates"] = self.methodPredicates!
            }
            if self.pathPredicates != nil {
                map["PathPredicates"] = self.pathPredicates?.toMap()
            }
            if self.queryPredicates != nil {
                var tmp : [Any] = []
                for k in self.queryPredicates! {
                    tmp.append(k.toMap())
                }
                map["QueryPredicates"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HeaderPredicates") {
                var tmp : [UpdateGatewayRouteRequest.Predicates.HeaderPredicates] = []
                for v in dict["HeaderPredicates"] as! [Any] {
                    var model = UpdateGatewayRouteRequest.Predicates.HeaderPredicates()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.headerPredicates = tmp
            }
            if dict.keys.contains("MethodPredicates") {
                self.methodPredicates = dict["MethodPredicates"] as! [String]
            }
            if dict.keys.contains("PathPredicates") {
                var model = UpdateGatewayRouteRequest.Predicates.PathPredicates()
                model.fromMap(dict["PathPredicates"] as! [String: Any])
                self.pathPredicates = model
            }
            if dict.keys.contains("QueryPredicates") {
                var tmp : [UpdateGatewayRouteRequest.Predicates.QueryPredicates] = []
                for v in dict["QueryPredicates"] as! [Any] {
                    var model = UpdateGatewayRouteRequest.Predicates.QueryPredicates()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.queryPredicates = tmp
            }
        }
    }
    public class RedirectJSON : Tea.TeaModel {
        public var code: Int32?

        public var host: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! Int32
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public class Services : Tea.TeaModel {
        public class HttpDubboTranscoder : Tea.TeaModel {
            public class MothedMapList : Tea.TeaModel {
                public class ParamMapsList : Tea.TeaModel {
                    public var extractKey: String?

                    public var extractKeySpec: String?

                    public var mappingType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extractKey != nil {
                            map["ExtractKey"] = self.extractKey!
                        }
                        if self.extractKeySpec != nil {
                            map["ExtractKeySpec"] = self.extractKeySpec!
                        }
                        if self.mappingType != nil {
                            map["MappingType"] = self.mappingType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExtractKey") {
                            self.extractKey = dict["ExtractKey"] as! String
                        }
                        if dict.keys.contains("ExtractKeySpec") {
                            self.extractKeySpec = dict["ExtractKeySpec"] as! String
                        }
                        if dict.keys.contains("MappingType") {
                            self.mappingType = dict["MappingType"] as! String
                        }
                    }
                }
                public var dubboMothedName: String?

                public var httpMothed: String?

                public var mothedpath: String?

                public var paramMapsList: [UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList]?

                public var passThroughAllHeaders: String?

                public var passThroughList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dubboMothedName != nil {
                        map["DubboMothedName"] = self.dubboMothedName!
                    }
                    if self.httpMothed != nil {
                        map["HttpMothed"] = self.httpMothed!
                    }
                    if self.mothedpath != nil {
                        map["Mothedpath"] = self.mothedpath!
                    }
                    if self.paramMapsList != nil {
                        var tmp : [Any] = []
                        for k in self.paramMapsList! {
                            tmp.append(k.toMap())
                        }
                        map["ParamMapsList"] = tmp
                    }
                    if self.passThroughAllHeaders != nil {
                        map["PassThroughAllHeaders"] = self.passThroughAllHeaders!
                    }
                    if self.passThroughList != nil {
                        map["PassThroughList"] = self.passThroughList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DubboMothedName") {
                        self.dubboMothedName = dict["DubboMothedName"] as! String
                    }
                    if dict.keys.contains("HttpMothed") {
                        self.httpMothed = dict["HttpMothed"] as! String
                    }
                    if dict.keys.contains("Mothedpath") {
                        self.mothedpath = dict["Mothedpath"] as! String
                    }
                    if dict.keys.contains("ParamMapsList") {
                        var tmp : [UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList] = []
                        for v in dict["ParamMapsList"] as! [Any] {
                            var model = UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList.ParamMapsList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.paramMapsList = tmp
                    }
                    if dict.keys.contains("PassThroughAllHeaders") {
                        self.passThroughAllHeaders = dict["PassThroughAllHeaders"] as! String
                    }
                    if dict.keys.contains("PassThroughList") {
                        self.passThroughList = dict["PassThroughList"] as! [String]
                    }
                }
            }
            public var dubboServiceGroup: String?

            public var dubboServiceName: String?

            public var dubboServiceVersion: String?

            public var mothedMapList: [UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dubboServiceGroup != nil {
                    map["DubboServiceGroup"] = self.dubboServiceGroup!
                }
                if self.dubboServiceName != nil {
                    map["DubboServiceName"] = self.dubboServiceName!
                }
                if self.dubboServiceVersion != nil {
                    map["DubboServiceVersion"] = self.dubboServiceVersion!
                }
                if self.mothedMapList != nil {
                    var tmp : [Any] = []
                    for k in self.mothedMapList! {
                        tmp.append(k.toMap())
                    }
                    map["MothedMapList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DubboServiceGroup") {
                    self.dubboServiceGroup = dict["DubboServiceGroup"] as! String
                }
                if dict.keys.contains("DubboServiceName") {
                    self.dubboServiceName = dict["DubboServiceName"] as! String
                }
                if dict.keys.contains("DubboServiceVersion") {
                    self.dubboServiceVersion = dict["DubboServiceVersion"] as! String
                }
                if dict.keys.contains("MothedMapList") {
                    var tmp : [UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList] = []
                    for v in dict["MothedMapList"] as! [Any] {
                        var model = UpdateGatewayRouteRequest.Services.HttpDubboTranscoder.MothedMapList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.mothedMapList = tmp
                }
            }
        }
        public var agreementType: String?

        public var groupName: String?

        public var httpDubboTranscoder: UpdateGatewayRouteRequest.Services.HttpDubboTranscoder?

        public var name: String?

        public var namespace: String?

        public var percent: Int32?

        public var serviceId: Int64?

        public var servicePort: Int32?

        public var sourceType: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.httpDubboTranscoder?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agreementType != nil {
                map["AgreementType"] = self.agreementType!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.httpDubboTranscoder != nil {
                map["HttpDubboTranscoder"] = self.httpDubboTranscoder?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgreementType") {
                self.agreementType = dict["AgreementType"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("HttpDubboTranscoder") {
                var model = UpdateGatewayRouteRequest.Services.HttpDubboTranscoder()
                model.fromMap(dict["HttpDubboTranscoder"] as! [String: Any])
                self.httpDubboTranscoder = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("ServiceId") {
                self.serviceId = dict["ServiceId"] as! Int64
            }
            if dict.keys.contains("ServicePort") {
                self.servicePort = dict["ServicePort"] as! Int32
            }
            if dict.keys.contains("SourceType") {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var description_: String?

    public var destinationType: String?

    public var directResponseJSON: UpdateGatewayRouteRequest.DirectResponseJSON?

    public var domainIdListJSON: String?

    public var enableWaf: Bool?

    public var fallback: Bool?

    public var fallbackServices: [UpdateGatewayRouteRequest.FallbackServices]?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var name: String?

    public var predicates: UpdateGatewayRouteRequest.Predicates?

    public var redirectJSON: UpdateGatewayRouteRequest.RedirectJSON?

    public var routeOrder: Int32?

    public var services: [UpdateGatewayRouteRequest.Services]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.directResponseJSON?.validate()
        try self.predicates?.validate()
        try self.redirectJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.directResponseJSON != nil {
            map["DirectResponseJSON"] = self.directResponseJSON?.toMap()
        }
        if self.domainIdListJSON != nil {
            map["DomainIdListJSON"] = self.domainIdListJSON!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.fallback != nil {
            map["Fallback"] = self.fallback!
        }
        if self.fallbackServices != nil {
            var tmp : [Any] = []
            for k in self.fallbackServices! {
                tmp.append(k.toMap())
            }
            map["FallbackServices"] = tmp
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.predicates != nil {
            map["Predicates"] = self.predicates?.toMap()
        }
        if self.redirectJSON != nil {
            map["RedirectJSON"] = self.redirectJSON?.toMap()
        }
        if self.routeOrder != nil {
            map["RouteOrder"] = self.routeOrder!
        }
        if self.services != nil {
            var tmp : [Any] = []
            for k in self.services! {
                tmp.append(k.toMap())
            }
            map["Services"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationType") {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("DirectResponseJSON") {
            var model = UpdateGatewayRouteRequest.DirectResponseJSON()
            model.fromMap(dict["DirectResponseJSON"] as! [String: Any])
            self.directResponseJSON = model
        }
        if dict.keys.contains("DomainIdListJSON") {
            self.domainIdListJSON = dict["DomainIdListJSON"] as! String
        }
        if dict.keys.contains("EnableWaf") {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("Fallback") {
            self.fallback = dict["Fallback"] as! Bool
        }
        if dict.keys.contains("FallbackServices") {
            var tmp : [UpdateGatewayRouteRequest.FallbackServices] = []
            for v in dict["FallbackServices"] as! [Any] {
                var model = UpdateGatewayRouteRequest.FallbackServices()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fallbackServices = tmp
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Predicates") {
            var model = UpdateGatewayRouteRequest.Predicates()
            model.fromMap(dict["Predicates"] as! [String: Any])
            self.predicates = model
        }
        if dict.keys.contains("RedirectJSON") {
            var model = UpdateGatewayRouteRequest.RedirectJSON()
            model.fromMap(dict["RedirectJSON"] as! [String: Any])
            self.redirectJSON = model
        }
        if dict.keys.contains("RouteOrder") {
            self.routeOrder = dict["RouteOrder"] as! Int32
        }
        if dict.keys.contains("Services") {
            var tmp : [UpdateGatewayRouteRequest.Services] = []
            for v in dict["Services"] as! [Any] {
                var model = UpdateGatewayRouteRequest.Services()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.services = tmp
        }
    }
}

public class UpdateGatewayRouteShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var description_: String?

    public var destinationType: String?

    public var directResponseJSONShrink: String?

    public var domainIdListJSON: String?

    public var enableWaf: Bool?

    public var fallback: Bool?

    public var fallbackServicesShrink: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var name: String?

    public var predicatesShrink: String?

    public var redirectJSONShrink: String?

    public var routeOrder: Int32?

    public var servicesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.directResponseJSONShrink != nil {
            map["DirectResponseJSON"] = self.directResponseJSONShrink!
        }
        if self.domainIdListJSON != nil {
            map["DomainIdListJSON"] = self.domainIdListJSON!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.fallback != nil {
            map["Fallback"] = self.fallback!
        }
        if self.fallbackServicesShrink != nil {
            map["FallbackServices"] = self.fallbackServicesShrink!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.predicatesShrink != nil {
            map["Predicates"] = self.predicatesShrink!
        }
        if self.redirectJSONShrink != nil {
            map["RedirectJSON"] = self.redirectJSONShrink!
        }
        if self.routeOrder != nil {
            map["RouteOrder"] = self.routeOrder!
        }
        if self.servicesShrink != nil {
            map["Services"] = self.servicesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationType") {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("DirectResponseJSON") {
            self.directResponseJSONShrink = dict["DirectResponseJSON"] as! String
        }
        if dict.keys.contains("DomainIdListJSON") {
            self.domainIdListJSON = dict["DomainIdListJSON"] as! String
        }
        if dict.keys.contains("EnableWaf") {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("Fallback") {
            self.fallback = dict["Fallback"] as! Bool
        }
        if dict.keys.contains("FallbackServices") {
            self.fallbackServicesShrink = dict["FallbackServices"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Predicates") {
            self.predicatesShrink = dict["Predicates"] as! String
        }
        if dict.keys.contains("RedirectJSON") {
            self.redirectJSONShrink = dict["RedirectJSON"] as! String
        }
        if dict.keys.contains("RouteOrder") {
            self.routeOrder = dict["RouteOrder"] as! Int32
        }
        if dict.keys.contains("Services") {
            self.servicesShrink = dict["Services"] as! String
        }
    }
}

public class UpdateGatewayRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteAuthRequest : Tea.TeaModel {
    public class AuthJSON : Tea.TeaModel {
        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var authJSON: UpdateGatewayRouteAuthRequest.AuthJSON?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.authJSON != nil {
            map["AuthJSON"] = self.authJSON?.toMap()
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AuthJSON") {
            var model = UpdateGatewayRouteAuthRequest.AuthJSON()
            model.fromMap(dict["AuthJSON"] as! [String: Any])
            self.authJSON = model
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayRouteAuthShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var authJSONShrink: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.authJSONShrink != nil {
            map["AuthJSON"] = self.authJSONShrink!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AuthJSON") {
            self.authJSONShrink = dict["AuthJSON"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayRouteAuthResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteAuthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteCORSRequest : Tea.TeaModel {
    public class CorsJSON : Tea.TeaModel {
        public var allowCredentials: Bool?

        public var allowHeaders: String?

        public var allowMethods: String?

        public var allowOrigins: String?

        public var exposeHeaders: String?

        public var status: String?

        public var timeUnit: String?

        public var unitNum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowCredentials != nil {
                map["AllowCredentials"] = self.allowCredentials!
            }
            if self.allowHeaders != nil {
                map["AllowHeaders"] = self.allowHeaders!
            }
            if self.allowMethods != nil {
                map["AllowMethods"] = self.allowMethods!
            }
            if self.allowOrigins != nil {
                map["AllowOrigins"] = self.allowOrigins!
            }
            if self.exposeHeaders != nil {
                map["ExposeHeaders"] = self.exposeHeaders!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeUnit != nil {
                map["TimeUnit"] = self.timeUnit!
            }
            if self.unitNum != nil {
                map["UnitNum"] = self.unitNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowCredentials") {
                self.allowCredentials = dict["AllowCredentials"] as! Bool
            }
            if dict.keys.contains("AllowHeaders") {
                self.allowHeaders = dict["AllowHeaders"] as! String
            }
            if dict.keys.contains("AllowMethods") {
                self.allowMethods = dict["AllowMethods"] as! String
            }
            if dict.keys.contains("AllowOrigins") {
                self.allowOrigins = dict["AllowOrigins"] as! String
            }
            if dict.keys.contains("ExposeHeaders") {
                self.exposeHeaders = dict["ExposeHeaders"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TimeUnit") {
                self.timeUnit = dict["TimeUnit"] as! String
            }
            if dict.keys.contains("UnitNum") {
                self.unitNum = dict["UnitNum"] as! Int64
            }
        }
    }
    public var acceptLanguage: String?

    public var corsJSON: UpdateGatewayRouteCORSRequest.CorsJSON?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.corsJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.corsJSON != nil {
            map["CorsJSON"] = self.corsJSON?.toMap()
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CorsJSON") {
            var model = UpdateGatewayRouteCORSRequest.CorsJSON()
            model.fromMap(dict["CorsJSON"] as! [String: Any])
            self.corsJSON = model
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayRouteCORSShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var corsJSONShrink: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.corsJSONShrink != nil {
            map["CorsJSON"] = self.corsJSONShrink!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CorsJSON") {
            self.corsJSONShrink = dict["CorsJSON"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayRouteCORSResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteCORSResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteCORSResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteCORSResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteHTTPRewriteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var httpRewriteJSON: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.httpRewriteJSON != nil {
            map["HttpRewriteJSON"] = self.httpRewriteJSON!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HttpRewriteJSON") {
            self.httpRewriteJSON = dict["HttpRewriteJSON"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayRouteHTTPRewriteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteHTTPRewriteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteHTTPRewriteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteHTTPRewriteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteHeaderOpRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var headerOpJSON: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.headerOpJSON != nil {
            map["HeaderOpJSON"] = self.headerOpJSON!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HeaderOpJSON") {
            self.headerOpJSON = dict["HeaderOpJSON"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateGatewayRouteHeaderOpResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteHeaderOpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteHeaderOpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteHeaderOpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteRetryRequest : Tea.TeaModel {
    public class RetryJSON : Tea.TeaModel {
        public var attempts: Int32?

        public var httpCodes: [String]?

        public var retryOn: [String]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attempts != nil {
                map["Attempts"] = self.attempts!
            }
            if self.httpCodes != nil {
                map["HttpCodes"] = self.httpCodes!
            }
            if self.retryOn != nil {
                map["RetryOn"] = self.retryOn!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attempts") {
                self.attempts = dict["Attempts"] as! Int32
            }
            if dict.keys.contains("HttpCodes") {
                self.httpCodes = dict["HttpCodes"] as! [String]
            }
            if dict.keys.contains("RetryOn") {
                self.retryOn = dict["RetryOn"] as! [String]
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var retryJSON: UpdateGatewayRouteRetryRequest.RetryJSON?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.retryJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.retryJSON != nil {
            map["RetryJSON"] = self.retryJSON?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RetryJSON") {
            var model = UpdateGatewayRouteRetryRequest.RetryJSON()
            model.fromMap(dict["RetryJSON"] as! [String: Any])
            self.retryJSON = model
        }
    }
}

public class UpdateGatewayRouteRetryShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var retryJSONShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.retryJSONShrink != nil {
            map["RetryJSON"] = self.retryJSONShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RetryJSON") {
            self.retryJSONShrink = dict["RetryJSON"] as! String
        }
    }
}

public class UpdateGatewayRouteRetryResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteRetryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteRetryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteRetryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteTimeoutRequest : Tea.TeaModel {
    public class TimeoutJSON : Tea.TeaModel {
        public var status: String?

        public var timeUnit: String?

        public var unitNum: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeUnit != nil {
                map["TimeUnit"] = self.timeUnit!
            }
            if self.unitNum != nil {
                map["UnitNum"] = self.unitNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TimeUnit") {
                self.timeUnit = dict["TimeUnit"] as! String
            }
            if dict.keys.contains("UnitNum") {
                self.unitNum = dict["UnitNum"] as! Int32
            }
        }
    }
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var timeoutJSON: UpdateGatewayRouteTimeoutRequest.TimeoutJSON?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.timeoutJSON?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.timeoutJSON != nil {
            map["TimeoutJSON"] = self.timeoutJSON?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("TimeoutJSON") {
            var model = UpdateGatewayRouteTimeoutRequest.TimeoutJSON()
            model.fromMap(dict["TimeoutJSON"] as! [String: Any])
            self.timeoutJSON = model
        }
    }
}

public class UpdateGatewayRouteTimeoutShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var timeoutJSONShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.timeoutJSONShrink != nil {
            map["TimeoutJSON"] = self.timeoutJSONShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("TimeoutJSON") {
            self.timeoutJSONShrink = dict["TimeoutJSON"] as! String
        }
    }
}

public class UpdateGatewayRouteTimeoutResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteTimeoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteTimeoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteTimeoutResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayRouteWafStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var enableWaf: Bool?

    public var gatewayUniqueId: String?

    public var routeId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.enableWaf != nil {
            map["EnableWaf"] = self.enableWaf!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("EnableWaf") {
            self.enableWaf = dict["EnableWaf"] as! Bool
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
    }
}

public class UpdateGatewayRouteWafStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Cors : Tea.TeaModel {
            public var allowCredentials: Bool?

            public var allowHeaders: String?

            public var allowMethods: String?

            public var allowOrigins: String?

            public var exposeHeaders: String?

            public var status: String?

            public var timeUnit: String?

            public var unitNum: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowCredentials != nil {
                    map["AllowCredentials"] = self.allowCredentials!
                }
                if self.allowHeaders != nil {
                    map["AllowHeaders"] = self.allowHeaders!
                }
                if self.allowMethods != nil {
                    map["AllowMethods"] = self.allowMethods!
                }
                if self.allowOrigins != nil {
                    map["AllowOrigins"] = self.allowOrigins!
                }
                if self.exposeHeaders != nil {
                    map["ExposeHeaders"] = self.exposeHeaders!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowCredentials") {
                    self.allowCredentials = dict["AllowCredentials"] as! Bool
                }
                if dict.keys.contains("AllowHeaders") {
                    self.allowHeaders = dict["AllowHeaders"] as! String
                }
                if dict.keys.contains("AllowMethods") {
                    self.allowMethods = dict["AllowMethods"] as! String
                }
                if dict.keys.contains("AllowOrigins") {
                    self.allowOrigins = dict["AllowOrigins"] as! String
                }
                if dict.keys.contains("ExposeHeaders") {
                    self.exposeHeaders = dict["ExposeHeaders"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeUnit") {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
                if dict.keys.contains("UnitNum") {
                    self.unitNum = dict["UnitNum"] as! Int64
                }
            }
        }
        public class DirectResponse : Tea.TeaModel {
            public var body: String?

            public var code: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["Body"] = self.body!
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Body") {
                    self.body = dict["Body"] as! String
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! Int32
                }
            }
        }
        public class HTTPRewrite : Tea.TeaModel {
            public var host: String?

            public var path: String?

            public var pathType: String?

            public var pattern: String?

            public var status: String?

            public var substitution: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.pathType != nil {
                    map["PathType"] = self.pathType!
                }
                if self.pattern != nil {
                    map["Pattern"] = self.pattern!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.substitution != nil {
                    map["Substitution"] = self.substitution!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("PathType") {
                    self.pathType = dict["PathType"] as! String
                }
                if dict.keys.contains("Pattern") {
                    self.pattern = dict["Pattern"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Substitution") {
                    self.substitution = dict["Substitution"] as! String
                }
            }
        }
        public class HeaderOp : Tea.TeaModel {
            public class HeaderOpItems : Tea.TeaModel {
                public var directionType: String?

                public var key: String?

                public var opType: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.directionType != nil {
                        map["DirectionType"] = self.directionType!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.opType != nil {
                        map["OpType"] = self.opType!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DirectionType") {
                        self.directionType = dict["DirectionType"] as! String
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("OpType") {
                        self.opType = dict["OpType"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var headerOpItems: [UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp.HeaderOpItems]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.headerOpItems != nil {
                    var tmp : [Any] = []
                    for k in self.headerOpItems! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderOpItems"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HeaderOpItems") {
                    var tmp : [UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp.HeaderOpItems] = []
                    for v in dict["HeaderOpItems"] as! [Any] {
                        var model = UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp.HeaderOpItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerOpItems = tmp
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Redirect : Tea.TeaModel {
            public var code: Int32?

            public var host: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! Int32
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public class Retry : Tea.TeaModel {
            public var attempts: Int32?

            public var httpCodes: [String]?

            public var retryOn: [String]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attempts != nil {
                    map["Attempts"] = self.attempts!
                }
                if self.httpCodes != nil {
                    map["HttpCodes"] = self.httpCodes!
                }
                if self.retryOn != nil {
                    map["RetryOn"] = self.retryOn!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Attempts") {
                    self.attempts = dict["Attempts"] as! Int32
                }
                if dict.keys.contains("HttpCodes") {
                    self.httpCodes = dict["HttpCodes"] as! [String]
                }
                if dict.keys.contains("RetryOn") {
                    self.retryOn = dict["RetryOn"] as! [String]
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class RoutePredicates : Tea.TeaModel {
            public class HeaderPredicates : Tea.TeaModel {
                public var key: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class PathPredicates : Tea.TeaModel {
                public var ignoreCase: Bool?

                public var path: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ignoreCase != nil {
                        map["IgnoreCase"] = self.ignoreCase!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IgnoreCase") {
                        self.ignoreCase = dict["IgnoreCase"] as! Bool
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class QueryPredicates : Tea.TeaModel {
                public var key: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var headerPredicates: [UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.HeaderPredicates]?

            public var methodPredicates: [String]?

            public var pathPredicates: UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.PathPredicates?

            public var queryPredicates: [UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.QueryPredicates]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pathPredicates?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.headerPredicates != nil {
                    var tmp : [Any] = []
                    for k in self.headerPredicates! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderPredicates"] = tmp
                }
                if self.methodPredicates != nil {
                    map["MethodPredicates"] = self.methodPredicates!
                }
                if self.pathPredicates != nil {
                    map["PathPredicates"] = self.pathPredicates?.toMap()
                }
                if self.queryPredicates != nil {
                    var tmp : [Any] = []
                    for k in self.queryPredicates! {
                        tmp.append(k.toMap())
                    }
                    map["QueryPredicates"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HeaderPredicates") {
                    var tmp : [UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.HeaderPredicates] = []
                    for v in dict["HeaderPredicates"] as! [Any] {
                        var model = UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.HeaderPredicates()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerPredicates = tmp
                }
                if dict.keys.contains("MethodPredicates") {
                    self.methodPredicates = dict["MethodPredicates"] as! [String]
                }
                if dict.keys.contains("PathPredicates") {
                    var model = UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.PathPredicates()
                    model.fromMap(dict["PathPredicates"] as! [String: Any])
                    self.pathPredicates = model
                }
                if dict.keys.contains("QueryPredicates") {
                    var tmp : [UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.QueryPredicates] = []
                    for v in dict["QueryPredicates"] as! [Any] {
                        var model = UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates.QueryPredicates()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.queryPredicates = tmp
                }
            }
        }
        public class RouteServices : Tea.TeaModel {
            public var groupName: String?

            public var name: String?

            public var namespace: String?

            public var percent: Int32?

            public var serviceId: Int64?

            public var serviceName: String?

            public var sourceType: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! Int32
                }
                if dict.keys.contains("ServiceId") {
                    self.serviceId = dict["ServiceId"] as! Int64
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class Timeout : Tea.TeaModel {
            public var status: String?

            public var timeUnit: String?

            public var unitNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeUnit") {
                    self.timeUnit = dict["TimeUnit"] as! String
                }
                if dict.keys.contains("UnitNum") {
                    self.unitNum = dict["UnitNum"] as! Int32
                }
            }
        }
        public var cors: UpdateGatewayRouteWafStatusResponseBody.Data.Cors?

        public var defaultServiceId: Int64?

        public var defaultServiceName: String?

        public var destinationType: String?

        public var directResponse: UpdateGatewayRouteWafStatusResponseBody.Data.DirectResponse?

        public var domainId: Int64?

        public var domainIdList: [Int64]?

        public var domainName: String?

        public var domainNameList: [String]?

        public var enableWaf: Bool?

        public var gatewayId: Int64?

        public var gatewayUniqueId: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var HTTPRewrite: UpdateGatewayRouteWafStatusResponseBody.Data.HTTPRewrite?

        public var headerOp: UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp?

        public var id: Int64?

        public var name: String?

        public var predicates: String?

        public var redirect: UpdateGatewayRouteWafStatusResponseBody.Data.Redirect?

        public var retry: UpdateGatewayRouteWafStatusResponseBody.Data.Retry?

        public var routeOrder: Int32?

        public var routePredicates: UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates?

        public var routeServices: [UpdateGatewayRouteWafStatusResponseBody.Data.RouteServices]?

        public var services: String?

        public var status: Int32?

        public var timeout: UpdateGatewayRouteWafStatusResponseBody.Data.Timeout?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cors?.validate()
            try self.directResponse?.validate()
            try self.HTTPRewrite?.validate()
            try self.headerOp?.validate()
            try self.redirect?.validate()
            try self.retry?.validate()
            try self.routePredicates?.validate()
            try self.timeout?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cors != nil {
                map["Cors"] = self.cors?.toMap()
            }
            if self.defaultServiceId != nil {
                map["DefaultServiceId"] = self.defaultServiceId!
            }
            if self.defaultServiceName != nil {
                map["DefaultServiceName"] = self.defaultServiceName!
            }
            if self.destinationType != nil {
                map["DestinationType"] = self.destinationType!
            }
            if self.directResponse != nil {
                map["DirectResponse"] = self.directResponse?.toMap()
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainIdList != nil {
                map["DomainIdList"] = self.domainIdList!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainNameList != nil {
                map["DomainNameList"] = self.domainNameList!
            }
            if self.enableWaf != nil {
                map["EnableWaf"] = self.enableWaf!
            }
            if self.gatewayId != nil {
                map["GatewayId"] = self.gatewayId!
            }
            if self.gatewayUniqueId != nil {
                map["GatewayUniqueId"] = self.gatewayUniqueId!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.HTTPRewrite != nil {
                map["HTTPRewrite"] = self.HTTPRewrite?.toMap()
            }
            if self.headerOp != nil {
                map["HeaderOp"] = self.headerOp?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.predicates != nil {
                map["Predicates"] = self.predicates!
            }
            if self.redirect != nil {
                map["Redirect"] = self.redirect?.toMap()
            }
            if self.retry != nil {
                map["Retry"] = self.retry?.toMap()
            }
            if self.routeOrder != nil {
                map["RouteOrder"] = self.routeOrder!
            }
            if self.routePredicates != nil {
                map["RoutePredicates"] = self.routePredicates?.toMap()
            }
            if self.routeServices != nil {
                var tmp : [Any] = []
                for k in self.routeServices! {
                    tmp.append(k.toMap())
                }
                map["RouteServices"] = tmp
            }
            if self.services != nil {
                map["Services"] = self.services!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cors") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.Cors()
                model.fromMap(dict["Cors"] as! [String: Any])
                self.cors = model
            }
            if dict.keys.contains("DefaultServiceId") {
                self.defaultServiceId = dict["DefaultServiceId"] as! Int64
            }
            if dict.keys.contains("DefaultServiceName") {
                self.defaultServiceName = dict["DefaultServiceName"] as! String
            }
            if dict.keys.contains("DestinationType") {
                self.destinationType = dict["DestinationType"] as! String
            }
            if dict.keys.contains("DirectResponse") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.DirectResponse()
                model.fromMap(dict["DirectResponse"] as! [String: Any])
                self.directResponse = model
            }
            if dict.keys.contains("DomainId") {
                self.domainId = dict["DomainId"] as! Int64
            }
            if dict.keys.contains("DomainIdList") {
                self.domainIdList = dict["DomainIdList"] as! [Int64]
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainNameList") {
                self.domainNameList = dict["DomainNameList"] as! [String]
            }
            if dict.keys.contains("EnableWaf") {
                self.enableWaf = dict["EnableWaf"] as! Bool
            }
            if dict.keys.contains("GatewayId") {
                self.gatewayId = dict["GatewayId"] as! Int64
            }
            if dict.keys.contains("GatewayUniqueId") {
                self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("HTTPRewrite") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.HTTPRewrite()
                model.fromMap(dict["HTTPRewrite"] as! [String: Any])
                self.HTTPRewrite = model
            }
            if dict.keys.contains("HeaderOp") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.HeaderOp()
                model.fromMap(dict["HeaderOp"] as! [String: Any])
                self.headerOp = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Predicates") {
                self.predicates = dict["Predicates"] as! String
            }
            if dict.keys.contains("Redirect") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.Redirect()
                model.fromMap(dict["Redirect"] as! [String: Any])
                self.redirect = model
            }
            if dict.keys.contains("Retry") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.Retry()
                model.fromMap(dict["Retry"] as! [String: Any])
                self.retry = model
            }
            if dict.keys.contains("RouteOrder") {
                self.routeOrder = dict["RouteOrder"] as! Int32
            }
            if dict.keys.contains("RoutePredicates") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.RoutePredicates()
                model.fromMap(dict["RoutePredicates"] as! [String: Any])
                self.routePredicates = model
            }
            if dict.keys.contains("RouteServices") {
                var tmp : [UpdateGatewayRouteWafStatusResponseBody.Data.RouteServices] = []
                for v in dict["RouteServices"] as! [Any] {
                    var model = UpdateGatewayRouteWafStatusResponseBody.Data.RouteServices()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.routeServices = tmp
            }
            if dict.keys.contains("Services") {
                self.services = dict["Services"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Timeout") {
                var model = UpdateGatewayRouteWafStatusResponseBody.Data.Timeout()
                model.fromMap(dict["Timeout"] as! [String: Any])
                self.timeout = model
            }
        }
    }
    public var code: Int32?

    public var data: UpdateGatewayRouteWafStatusResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = UpdateGatewayRouteWafStatusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayRouteWafStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayRouteWafStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayRouteWafStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayServiceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dnsServerList: [String]?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: String?

    public var ipList: [String]?

    public var name: String?

    public var servicePort: String?

    public var serviceProtocol: String?

    public var tlsSetting: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dnsServerList != nil {
            map["DnsServerList"] = self.dnsServerList!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ipList != nil {
            map["IpList"] = self.ipList!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.servicePort != nil {
            map["ServicePort"] = self.servicePort!
        }
        if self.serviceProtocol != nil {
            map["ServiceProtocol"] = self.serviceProtocol!
        }
        if self.tlsSetting != nil {
            map["TlsSetting"] = self.tlsSetting!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DnsServerList") {
            self.dnsServerList = dict["DnsServerList"] as! [String]
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("IpList") {
            self.ipList = dict["IpList"] as! [String]
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ServicePort") {
            self.servicePort = dict["ServicePort"] as! String
        }
        if dict.keys.contains("ServiceProtocol") {
            self.serviceProtocol = dict["ServiceProtocol"] as! String
        }
        if dict.keys.contains("TlsSetting") {
            self.tlsSetting = dict["TlsSetting"] as! String
        }
    }
}

public class UpdateGatewayServiceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dnsServerListShrink: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: String?

    public var ipListShrink: String?

    public var name: String?

    public var servicePort: String?

    public var serviceProtocol: String?

    public var tlsSetting: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dnsServerListShrink != nil {
            map["DnsServerList"] = self.dnsServerListShrink!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ipListShrink != nil {
            map["IpList"] = self.ipListShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.servicePort != nil {
            map["ServicePort"] = self.servicePort!
        }
        if self.serviceProtocol != nil {
            map["ServiceProtocol"] = self.serviceProtocol!
        }
        if self.tlsSetting != nil {
            map["TlsSetting"] = self.tlsSetting!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DnsServerList") {
            self.dnsServerListShrink = dict["DnsServerList"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("IpList") {
            self.ipListShrink = dict["IpList"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ServicePort") {
            self.servicePort = dict["ServicePort"] as! String
        }
        if dict.keys.contains("ServiceProtocol") {
            self.serviceProtocol = dict["ServiceProtocol"] as! String
        }
        if dict.keys.contains("TlsSetting") {
            self.tlsSetting = dict["TlsSetting"] as! String
        }
    }
}

public class UpdateGatewayServiceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayServiceCheckRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var check: Bool?

    public var expectedStatuses: [Int32]?

    public var gatewayUniqueId: String?

    public var healthyThreshold: Int32?

    public var httpHost: String?

    public var httpPath: String?

    public var interval: Int32?

    public var protocol_: String?

    public var serviceId: String?

    public var timeout: Int32?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.check != nil {
            map["Check"] = self.check!
        }
        if self.expectedStatuses != nil {
            map["ExpectedStatuses"] = self.expectedStatuses!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.httpHost != nil {
            map["HttpHost"] = self.httpHost!
        }
        if self.httpPath != nil {
            map["HttpPath"] = self.httpPath!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Check") {
            self.check = dict["Check"] as! Bool
        }
        if dict.keys.contains("ExpectedStatuses") {
            self.expectedStatuses = dict["ExpectedStatuses"] as! [Int32]
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("HttpHost") {
            self.httpHost = dict["HttpHost"] as! String
        }
        if dict.keys.contains("HttpPath") {
            self.httpPath = dict["HttpPath"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class UpdateGatewayServiceCheckShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var check: Bool?

    public var expectedStatusesShrink: String?

    public var gatewayUniqueId: String?

    public var healthyThreshold: Int32?

    public var httpHost: String?

    public var httpPath: String?

    public var interval: Int32?

    public var protocol_: String?

    public var serviceId: String?

    public var timeout: Int32?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.check != nil {
            map["Check"] = self.check!
        }
        if self.expectedStatusesShrink != nil {
            map["ExpectedStatuses"] = self.expectedStatusesShrink!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.httpHost != nil {
            map["HttpHost"] = self.httpHost!
        }
        if self.httpPath != nil {
            map["HttpPath"] = self.httpPath!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Check") {
            self.check = dict["Check"] as! Bool
        }
        if dict.keys.contains("ExpectedStatuses") {
            self.expectedStatusesShrink = dict["ExpectedStatuses"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("HttpHost") {
            self.httpHost = dict["HttpHost"] as! String
        }
        if dict.keys.contains("HttpPath") {
            self.httpPath = dict["HttpPath"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class UpdateGatewayServiceCheckResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayServiceCheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayServiceCheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayServiceCheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayServiceTrafficPolicyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayTrafficPolicy: TrafficPolicy?

    public var gatewayUniqueId: String?

    public var serviceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gatewayTrafficPolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayTrafficPolicy != nil {
            map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicy?.toMap()
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayTrafficPolicy") {
            var model = TrafficPolicy()
            model.fromMap(dict["GatewayTrafficPolicy"] as! [String: Any])
            self.gatewayTrafficPolicy = model
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! Int64
        }
    }
}

public class UpdateGatewayServiceTrafficPolicyShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayId: Int64?

    public var gatewayTrafficPolicyShrink: String?

    public var gatewayUniqueId: String?

    public var serviceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayTrafficPolicyShrink != nil {
            map["GatewayTrafficPolicy"] = self.gatewayTrafficPolicyShrink!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayTrafficPolicy") {
            self.gatewayTrafficPolicyShrink = dict["GatewayTrafficPolicy"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! Int64
        }
    }
}

public class UpdateGatewayServiceTrafficPolicyResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: GatewayService?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = GatewayService()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayServiceTrafficPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayServiceTrafficPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayServiceTrafficPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewayServiceVersionRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var serviceId: Int64?

    public var serviceVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceVersion != nil {
            map["ServiceVersion"] = self.serviceVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! Int64
        }
        if dict.keys.contains("ServiceVersion") {
            self.serviceVersion = dict["ServiceVersion"] as! String
        }
    }
}

public class UpdateGatewayServiceVersionResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewayServiceVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewayServiceVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewayServiceVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGatewaySpecRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var gatewayUniqueId: String?

    public var replica: Int32?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.replica != nil {
            map["Replica"] = self.replica!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Replica") {
            self.replica = dict["Replica"] as! Int32
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class UpdateGatewaySpecResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGatewaySpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGatewaySpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGatewaySpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateImageRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
    }
}

public class UpdateImageResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIsolationRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var limitApp: String?

    public var namespace: String?

    public var ruleId: Int64?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.limitApp != nil {
            map["LimitApp"] = self.limitApp!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("LimitApp") {
            self.limitApp = dict["LimitApp"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! Int64
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Double
        }
    }
}

public class UpdateIsolationRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var enable: Bool?

        public var id: Int64?

        public var limitApp: String?

        public var namespace: String?

        public var resource: String?

        public var threshold: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.limitApp != nil {
                map["LimitApp"] = self.limitApp!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("LimitApp") {
                self.limitApp = dict["LimitApp"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Resource") {
                self.resource = dict["Resource"] as! String
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Double
            }
        }
    }
    public var code: String?

    public var data: UpdateIsolationRuleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateIsolationRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateIsolationRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIsolationRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateIsolationRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLocalityRuleRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var namespace: String?

    public var region: String?

    public var rules: String?

    public var source: String?

    public var threshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.rules != nil {
            map["Rules"] = self.rules!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Rules") {
            self.rules = dict["Rules"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Double
        }
    }
}

public class UpdateLocalityRuleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class UpdateLocalityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLocalityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLocalityRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMessageQueueRouteRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var filterSide: String?

    public var namespace: String?

    public var region: String?

    public var tags: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.filterSide != nil {
            map["FilterSide"] = self.filterSide!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("FilterSide") {
            self.filterSide = dict["FilterSide"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! [String]
        }
    }
}

public class UpdateMessageQueueRouteShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appId: String?

    public var appName: String?

    public var enable: Bool?

    public var filterSide: String?

    public var namespace: String?

    public var region: String?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.filterSide != nil {
            map["FilterSide"] = self.filterSide!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("FilterSide") {
            self.filterSide = dict["FilterSide"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
    }
}

public class UpdateMessageQueueRouteResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateMessageQueueRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMessageQueueRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMessageQueueRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMigrationTaskRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterType: String?

    public var id: String?

    public var originInstanceAddress: String?

    public var originInstanceName: String?

    public var originInstanceNamespace: String?

    public var projectDesc: String?

    public var requestPars: String?

    public var syncType: String?

    public var targetClusterName: String?

    public var targetClusterUrl: String?

    public var targetInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.originInstanceAddress != nil {
            map["OriginInstanceAddress"] = self.originInstanceAddress!
        }
        if self.originInstanceName != nil {
            map["OriginInstanceName"] = self.originInstanceName!
        }
        if self.originInstanceNamespace != nil {
            map["OriginInstanceNamespace"] = self.originInstanceNamespace!
        }
        if self.projectDesc != nil {
            map["ProjectDesc"] = self.projectDesc!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.syncType != nil {
            map["SyncType"] = self.syncType!
        }
        if self.targetClusterName != nil {
            map["TargetClusterName"] = self.targetClusterName!
        }
        if self.targetClusterUrl != nil {
            map["TargetClusterUrl"] = self.targetClusterUrl!
        }
        if self.targetInstanceId != nil {
            map["TargetInstanceId"] = self.targetInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterType") {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("OriginInstanceAddress") {
            self.originInstanceAddress = dict["OriginInstanceAddress"] as! String
        }
        if dict.keys.contains("OriginInstanceName") {
            self.originInstanceName = dict["OriginInstanceName"] as! String
        }
        if dict.keys.contains("OriginInstanceNamespace") {
            self.originInstanceNamespace = dict["OriginInstanceNamespace"] as! String
        }
        if dict.keys.contains("ProjectDesc") {
            self.projectDesc = dict["ProjectDesc"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("SyncType") {
            self.syncType = dict["SyncType"] as! String
        }
        if dict.keys.contains("TargetClusterName") {
            self.targetClusterName = dict["TargetClusterName"] as! String
        }
        if dict.keys.contains("TargetClusterUrl") {
            self.targetClusterUrl = dict["TargetClusterUrl"] as! String
        }
        if dict.keys.contains("TargetInstanceId") {
            self.targetInstanceId = dict["TargetInstanceId"] as! String
        }
    }
}

public class UpdateMigrationTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterType: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: String?

        public var originInstanceAddress: String?

        public var originInstanceName: String?

        public var originInstanceNamespace: String?

        public var projectDesc: String?

        public var syncType: String?

        public var targetClusterName: String?

        public var targetClusterUrl: String?

        public var targetInstanceId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.originInstanceAddress != nil {
                map["OriginInstanceAddress"] = self.originInstanceAddress!
            }
            if self.originInstanceName != nil {
                map["OriginInstanceName"] = self.originInstanceName!
            }
            if self.originInstanceNamespace != nil {
                map["OriginInstanceNamespace"] = self.originInstanceNamespace!
            }
            if self.projectDesc != nil {
                map["ProjectDesc"] = self.projectDesc!
            }
            if self.syncType != nil {
                map["SyncType"] = self.syncType!
            }
            if self.targetClusterName != nil {
                map["TargetClusterName"] = self.targetClusterName!
            }
            if self.targetClusterUrl != nil {
                map["TargetClusterUrl"] = self.targetClusterUrl!
            }
            if self.targetInstanceId != nil {
                map["TargetInstanceId"] = self.targetInstanceId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterType") {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("OriginInstanceAddress") {
                self.originInstanceAddress = dict["OriginInstanceAddress"] as! String
            }
            if dict.keys.contains("OriginInstanceName") {
                self.originInstanceName = dict["OriginInstanceName"] as! String
            }
            if dict.keys.contains("OriginInstanceNamespace") {
                self.originInstanceNamespace = dict["OriginInstanceNamespace"] as! String
            }
            if dict.keys.contains("ProjectDesc") {
                self.projectDesc = dict["ProjectDesc"] as! String
            }
            if dict.keys.contains("SyncType") {
                self.syncType = dict["SyncType"] as! String
            }
            if dict.keys.contains("TargetClusterName") {
                self.targetClusterName = dict["TargetClusterName"] as! String
            }
            if dict.keys.contains("TargetClusterUrl") {
                self.targetClusterUrl = dict["TargetClusterUrl"] as! String
            }
            if dict.keys.contains("TargetInstanceId") {
                self.targetInstanceId = dict["TargetInstanceId"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var data: UpdateMigrationTaskResponseBody.Data?

    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = UpdateMigrationTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateMigrationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMigrationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMigrationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNacosClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var checkPort: Int32?

    public var clusterName: String?

    public var groupName: String?

    public var healthChecker: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var serviceName: String?

    public var useInstancePortForCheck: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.checkPort != nil {
            map["CheckPort"] = self.checkPort!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.healthChecker != nil {
            map["HealthChecker"] = self.healthChecker!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.useInstancePortForCheck != nil {
            map["UseInstancePortForCheck"] = self.useInstancePortForCheck!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CheckPort") {
            self.checkPort = dict["CheckPort"] as! Int32
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("HealthChecker") {
            self.healthChecker = dict["HealthChecker"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("UseInstancePortForCheck") {
            self.useInstancePortForCheck = dict["UseInstancePortForCheck"] as! Bool
        }
    }
}

public class UpdateNacosClusterResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNacosClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNacosClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNacosClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNacosConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var betaIps: String?

    public var content: String?

    public var dataId: String?

    public var desc: String?

    public var encryptedDataKey: String?

    public var group: String?

    public var instanceId: String?

    public var md5: String?

    public var namespaceId: String?

    public var tags: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.betaIps != nil {
            map["BetaIps"] = self.betaIps!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.encryptedDataKey != nil {
            map["EncryptedDataKey"] = self.encryptedDataKey!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.md5 != nil {
            map["Md5"] = self.md5!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BetaIps") {
            self.betaIps = dict["BetaIps"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("Desc") {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("EncryptedDataKey") {
            self.encryptedDataKey = dict["EncryptedDataKey"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Md5") {
            self.md5 = dict["Md5"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateNacosConfigResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNacosConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNacosConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNacosConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNacosGrayConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var appName: String?

    public var content: String?

    public var dataId: String?

    public var grayRule: String?

    public var grayRuleName: String?

    public var grayRulePriority: Int32?

    public var grayType: String?

    public var group: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var opType: String?

    public var regionId: String?

    public var requestPars: String?

    public var stopGray: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.dataId != nil {
            map["DataId"] = self.dataId!
        }
        if self.grayRule != nil {
            map["GrayRule"] = self.grayRule!
        }
        if self.grayRuleName != nil {
            map["GrayRuleName"] = self.grayRuleName!
        }
        if self.grayRulePriority != nil {
            map["GrayRulePriority"] = self.grayRulePriority!
        }
        if self.grayType != nil {
            map["GrayType"] = self.grayType!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.opType != nil {
            map["OpType"] = self.opType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.stopGray != nil {
            map["StopGray"] = self.stopGray!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("DataId") {
            self.dataId = dict["DataId"] as! String
        }
        if dict.keys.contains("GrayRule") {
            self.grayRule = dict["GrayRule"] as! String
        }
        if dict.keys.contains("GrayRuleName") {
            self.grayRuleName = dict["GrayRuleName"] as! String
        }
        if dict.keys.contains("GrayRulePriority") {
            self.grayRulePriority = dict["GrayRulePriority"] as! Int32
        }
        if dict.keys.contains("GrayType") {
            self.grayType = dict["GrayType"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("OpType") {
            self.opType = dict["OpType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("StopGray") {
            self.stopGray = dict["StopGray"] as! Bool
        }
    }
}

public class UpdateNacosGrayConfigResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateNacosGrayConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNacosGrayConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNacosGrayConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNacosInstanceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterName: String?

    public var enabled: Bool?

    public var ephemeral: Bool?

    public var groupName: String?

    public var instanceId: String?

    public var ip: String?

    public var metadata: String?

    public var namespaceId: String?

    public var port: Int32?

    public var serviceName: String?

    public var weight: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.ephemeral != nil {
            map["Ephemeral"] = self.ephemeral!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.metadata != nil {
            map["Metadata"] = self.metadata!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("Ephemeral") {
            self.ephemeral = dict["Ephemeral"] as! Bool
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Metadata") {
            self.metadata = dict["Metadata"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! String
        }
    }
}

public class UpdateNacosInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNacosInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNacosInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNacosInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNacosServiceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var groupName: String?

    public var instanceId: String?

    public var namespaceId: String?

    public var protectThreshold: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.protectThreshold != nil {
            map["ProtectThreshold"] = self.protectThreshold!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("ProtectThreshold") {
            self.protectThreshold = dict["ProtectThreshold"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class UpdateNacosServiceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNacosServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNacosServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNacosServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePluginConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var config: String?

    public var configLevel: Int32?

    public var enable: Bool?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var id: Int64?

    public var pluginId: Int64?

    public var resourceIdList: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.configLevel != nil {
            map["ConfigLevel"] = self.configLevel!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.resourceIdList != nil {
            map["ResourceIdList"] = self.resourceIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("ConfigLevel") {
            self.configLevel = dict["ConfigLevel"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! Int64
        }
        if dict.keys.contains("ResourceIdList") {
            self.resourceIdList = dict["ResourceIdList"] as! [Int64]
        }
    }
}

public class UpdatePluginConfigShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var config: String?

    public var configLevel: Int32?

    public var enable: Bool?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var id: Int64?

    public var pluginId: Int64?

    public var resourceIdListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.configLevel != nil {
            map["ConfigLevel"] = self.configLevel!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.resourceIdListShrink != nil {
            map["ResourceIdList"] = self.resourceIdListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("ConfigLevel") {
            self.configLevel = dict["ConfigLevel"] as! Int32
        }
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("GmtCreate") {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! Int64
        }
        if dict.keys.contains("ResourceIdList") {
            self.resourceIdListShrink = dict["ResourceIdList"] as! String
        }
    }
}

public class UpdatePluginConfigResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var dynamicMessage: String?

    public var errorCode: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdatePluginConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePluginConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePluginConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSSLCertRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var certIdentifier: String?

    public var domainId: Int64?

    public var gatewayUniqueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.certIdentifier != nil {
            map["CertIdentifier"] = self.certIdentifier!
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("CertIdentifier") {
            self.certIdentifier = dict["CertIdentifier"] as! String
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
    }
}

public class UpdateSSLCertResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateSSLCertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSSLCertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSSLCertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateServiceSourceRequest : Tea.TeaModel {
    public class IngressOptionsRequest : Tea.TeaModel {
        public var enableIngress: Bool?

        public var enableStatus: Bool?

        public var ingressClass: String?

        public var watchNamespace: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableIngress != nil {
                map["EnableIngress"] = self.enableIngress!
            }
            if self.enableStatus != nil {
                map["EnableStatus"] = self.enableStatus!
            }
            if self.ingressClass != nil {
                map["IngressClass"] = self.ingressClass!
            }
            if self.watchNamespace != nil {
                map["WatchNamespace"] = self.watchNamespace!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableIngress") {
                self.enableIngress = dict["EnableIngress"] as! Bool
            }
            if dict.keys.contains("EnableStatus") {
                self.enableStatus = dict["EnableStatus"] as! Bool
            }
            if dict.keys.contains("IngressClass") {
                self.ingressClass = dict["IngressClass"] as! String
            }
            if dict.keys.contains("WatchNamespace") {
                self.watchNamespace = dict["WatchNamespace"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var address: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var ingressOptionsRequest: UpdateServiceSourceRequest.IngressOptionsRequest?

    public var name: String?

    public var pathList: [String]?

    public var source: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ingressOptionsRequest?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ingressOptionsRequest != nil {
            map["IngressOptionsRequest"] = self.ingressOptionsRequest?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pathList != nil {
            map["PathList"] = self.pathList!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IngressOptionsRequest") {
            var model = UpdateServiceSourceRequest.IngressOptionsRequest()
            model.fromMap(dict["IngressOptionsRequest"] as! [String: Any])
            self.ingressOptionsRequest = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PathList") {
            self.pathList = dict["PathList"] as! [String]
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateServiceSourceShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var gatewayId: Int64?

    public var gatewayUniqueId: String?

    public var id: Int64?

    public var ingressOptionsRequestShrink: String?

    public var name: String?

    public var pathListShrink: String?

    public var source: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ingressOptionsRequestShrink != nil {
            map["IngressOptionsRequest"] = self.ingressOptionsRequestShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pathListShrink != nil {
            map["PathList"] = self.pathListShrink!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! Int64
        }
        if dict.keys.contains("GatewayUniqueId") {
            self.gatewayUniqueId = dict["GatewayUniqueId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IngressOptionsRequest") {
            self.ingressOptionsRequestShrink = dict["IngressOptionsRequest"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PathList") {
            self.pathListShrink = dict["PathList"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateServiceSourceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Int64?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateServiceSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateServiceSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateServiceSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateZnodeRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clusterId: String?

    public var data: String?

    public var path: String?

    public var requestPars: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
    }
}

public class UpdateZnodeResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateZnodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateZnodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateZnodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeClusterRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceId: String?

    public var requestPars: String?

    public var upgradeVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestPars != nil {
            map["RequestPars"] = self.requestPars!
        }
        if self.upgradeVersion != nil {
            map["UpgradeVersion"] = self.upgradeVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestPars") {
            self.requestPars = dict["RequestPars"] as! String
        }
        if dict.keys.contains("UpgradeVersion") {
            self.upgradeVersion = dict["UpgradeVersion"] as! String
        }
    }
}

public class UpgradeClusterResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var httpCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.httpCode != nil {
            map["HttpCode"] = self.httpCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("HttpCode") {
            self.httpCode = dict["HttpCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpgradeClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpgradeClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
