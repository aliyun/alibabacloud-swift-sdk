import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddCustomLineRequest : Tea.TeaModel {
    public class IpSegment : Tea.TeaModel {
        public var endIp: String?

        public var startIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endIp != nil {
                map["EndIp"] = self.endIp!
            }
            if self.startIp != nil {
                map["StartIp"] = self.startIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndIp") {
                self.endIp = dict["EndIp"] as! String
            }
            if dict.keys.contains("StartIp") {
                self.startIp = dict["StartIp"] as! String
            }
        }
    }
    public var domainName: String?

    public var ipSegment: [AddCustomLineRequest.IpSegment]?

    public var lang: String?

    public var lineName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ipSegment != nil {
            var tmp : [Any] = []
            for k in self.ipSegment! {
                tmp.append(k.toMap())
            }
            map["IpSegment"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lineName != nil {
            map["LineName"] = self.lineName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("IpSegment") {
            self.ipSegment = dict["IpSegment"] as! [AddCustomLineRequest.IpSegment]
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LineName") {
            self.lineName = dict["LineName"] as! String
        }
    }
}

public class AddCustomLineResponseBody : Tea.TeaModel {
    public var lineCode: String?

    public var lineId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lineCode != nil {
            map["LineCode"] = self.lineCode!
        }
        if self.lineId != nil {
            map["LineId"] = self.lineId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LineCode") {
            self.lineCode = dict["LineCode"] as! String
        }
        if dict.keys.contains("LineId") {
            self.lineId = dict["LineId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCustomLineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCustomLineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCustomLineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDnsCacheDomainRequest : Tea.TeaModel {
    public class SourceDnsServer : Tea.TeaModel {
        public var host: String?

        public var port: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
        }
    }
    public var cacheTtlMax: Int32?

    public var cacheTtlMin: Int32?

    public var domainName: String?

    public var instanceId: String?

    public var lang: String?

    public var remark: String?

    public var sourceDnsServer: [AddDnsCacheDomainRequest.SourceDnsServer]?

    public var sourceEdns: String?

    public var sourceProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cacheTtlMax != nil {
            map["CacheTtlMax"] = self.cacheTtlMax!
        }
        if self.cacheTtlMin != nil {
            map["CacheTtlMin"] = self.cacheTtlMin!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.sourceDnsServer != nil {
            var tmp : [Any] = []
            for k in self.sourceDnsServer! {
                tmp.append(k.toMap())
            }
            map["SourceDnsServer"] = tmp
        }
        if self.sourceEdns != nil {
            map["SourceEdns"] = self.sourceEdns!
        }
        if self.sourceProtocol != nil {
            map["SourceProtocol"] = self.sourceProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CacheTtlMax") {
            self.cacheTtlMax = dict["CacheTtlMax"] as! Int32
        }
        if dict.keys.contains("CacheTtlMin") {
            self.cacheTtlMin = dict["CacheTtlMin"] as! Int32
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SourceDnsServer") {
            self.sourceDnsServer = dict["SourceDnsServer"] as! [AddDnsCacheDomainRequest.SourceDnsServer]
        }
        if dict.keys.contains("SourceEdns") {
            self.sourceEdns = dict["SourceEdns"] as! String
        }
        if dict.keys.contains("SourceProtocol") {
            self.sourceProtocol = dict["SourceProtocol"] as! String
        }
    }
}

public class AddDnsCacheDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDnsCacheDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDnsCacheDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDnsCacheDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDnsGtmAccessStrategyRequest : Tea.TeaModel {
    public class DefaultAddrPool : Tea.TeaModel {
        public var id: String?

        public var lbaWeight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
        }
    }
    public class FailoverAddrPool : Tea.TeaModel {
        public var id: String?

        public var lbaWeight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
        }
    }
    public var defaultAddrPool: [AddDnsGtmAccessStrategyRequest.DefaultAddrPool]?

    public var defaultAddrPoolType: String?

    public var defaultLatencyOptimization: String?

    public var defaultLbaStrategy: String?

    public var defaultMaxReturnAddrNum: Int32?

    public var defaultMinAvailableAddrNum: Int32?

    public var failoverAddrPool: [AddDnsGtmAccessStrategyRequest.FailoverAddrPool]?

    public var failoverAddrPoolType: String?

    public var failoverLatencyOptimization: String?

    public var failoverLbaStrategy: String?

    public var failoverMaxReturnAddrNum: Int32?

    public var failoverMinAvailableAddrNum: Int32?

    public var instanceId: String?

    public var lang: String?

    public var lines: String?

    public var strategyMode: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultAddrPool != nil {
            var tmp : [Any] = []
            for k in self.defaultAddrPool! {
                tmp.append(k.toMap())
            }
            map["DefaultAddrPool"] = tmp
        }
        if self.defaultAddrPoolType != nil {
            map["DefaultAddrPoolType"] = self.defaultAddrPoolType!
        }
        if self.defaultLatencyOptimization != nil {
            map["DefaultLatencyOptimization"] = self.defaultLatencyOptimization!
        }
        if self.defaultLbaStrategy != nil {
            map["DefaultLbaStrategy"] = self.defaultLbaStrategy!
        }
        if self.defaultMaxReturnAddrNum != nil {
            map["DefaultMaxReturnAddrNum"] = self.defaultMaxReturnAddrNum!
        }
        if self.defaultMinAvailableAddrNum != nil {
            map["DefaultMinAvailableAddrNum"] = self.defaultMinAvailableAddrNum!
        }
        if self.failoverAddrPool != nil {
            var tmp : [Any] = []
            for k in self.failoverAddrPool! {
                tmp.append(k.toMap())
            }
            map["FailoverAddrPool"] = tmp
        }
        if self.failoverAddrPoolType != nil {
            map["FailoverAddrPoolType"] = self.failoverAddrPoolType!
        }
        if self.failoverLatencyOptimization != nil {
            map["FailoverLatencyOptimization"] = self.failoverLatencyOptimization!
        }
        if self.failoverLbaStrategy != nil {
            map["FailoverLbaStrategy"] = self.failoverLbaStrategy!
        }
        if self.failoverMaxReturnAddrNum != nil {
            map["FailoverMaxReturnAddrNum"] = self.failoverMaxReturnAddrNum!
        }
        if self.failoverMinAvailableAddrNum != nil {
            map["FailoverMinAvailableAddrNum"] = self.failoverMinAvailableAddrNum!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lines != nil {
            map["Lines"] = self.lines!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefaultAddrPool") {
            self.defaultAddrPool = dict["DefaultAddrPool"] as! [AddDnsGtmAccessStrategyRequest.DefaultAddrPool]
        }
        if dict.keys.contains("DefaultAddrPoolType") {
            self.defaultAddrPoolType = dict["DefaultAddrPoolType"] as! String
        }
        if dict.keys.contains("DefaultLatencyOptimization") {
            self.defaultLatencyOptimization = dict["DefaultLatencyOptimization"] as! String
        }
        if dict.keys.contains("DefaultLbaStrategy") {
            self.defaultLbaStrategy = dict["DefaultLbaStrategy"] as! String
        }
        if dict.keys.contains("DefaultMaxReturnAddrNum") {
            self.defaultMaxReturnAddrNum = dict["DefaultMaxReturnAddrNum"] as! Int32
        }
        if dict.keys.contains("DefaultMinAvailableAddrNum") {
            self.defaultMinAvailableAddrNum = dict["DefaultMinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("FailoverAddrPool") {
            self.failoverAddrPool = dict["FailoverAddrPool"] as! [AddDnsGtmAccessStrategyRequest.FailoverAddrPool]
        }
        if dict.keys.contains("FailoverAddrPoolType") {
            self.failoverAddrPoolType = dict["FailoverAddrPoolType"] as! String
        }
        if dict.keys.contains("FailoverLatencyOptimization") {
            self.failoverLatencyOptimization = dict["FailoverLatencyOptimization"] as! String
        }
        if dict.keys.contains("FailoverLbaStrategy") {
            self.failoverLbaStrategy = dict["FailoverLbaStrategy"] as! String
        }
        if dict.keys.contains("FailoverMaxReturnAddrNum") {
            self.failoverMaxReturnAddrNum = dict["FailoverMaxReturnAddrNum"] as! Int32
        }
        if dict.keys.contains("FailoverMinAvailableAddrNum") {
            self.failoverMinAvailableAddrNum = dict["FailoverMinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Lines") {
            self.lines = dict["Lines"] as! String
        }
        if dict.keys.contains("StrategyMode") {
            self.strategyMode = dict["StrategyMode"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class AddDnsGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class AddDnsGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDnsGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDnsGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDnsGtmAddressPoolRequest : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public var addr: String?

        public var attributeInfo: String?

        public var lbaWeight: Int32?

        public var mode: String?

        public var remark: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                map["Addr"] = self.addr!
            }
            if self.attributeInfo != nil {
                map["AttributeInfo"] = self.attributeInfo!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Addr") {
                self.addr = dict["Addr"] as! String
            }
            if dict.keys.contains("AttributeInfo") {
                self.attributeInfo = dict["AttributeInfo"] as! String
            }
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! String
            }
            if dict.keys.contains("Remark") {
                self.remark = dict["Remark"] as! String
            }
        }
    }
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var addr: [AddDnsGtmAddressPoolRequest.Addr]?

    public var evaluationCount: Int32?

    public var instanceId: String?

    public var interval: Int32?

    public var ispCityNode: [AddDnsGtmAddressPoolRequest.IspCityNode]?

    public var lang: String?

    public var lbaStrategy: String?

    public var monitorExtendInfo: String?

    public var monitorStatus: String?

    public var name: String?

    public var protocolType: String?

    public var timeout: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            var tmp : [Any] = []
            for k in self.addr! {
                tmp.append(k.toMap())
            }
            map["Addr"] = tmp
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.monitorStatus != nil {
            map["MonitorStatus"] = self.monitorStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addr") {
            self.addr = dict["Addr"] as! [AddDnsGtmAddressPoolRequest.Addr]
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNode") {
            self.ispCityNode = dict["IspCityNode"] as! [AddDnsGtmAddressPoolRequest.IspCityNode]
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LbaStrategy") {
            self.lbaStrategy = dict["LbaStrategy"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("MonitorStatus") {
            self.monitorStatus = dict["MonitorStatus"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddDnsGtmAddressPoolResponseBody : Tea.TeaModel {
    public var addrPoolId: String?

    public var monitorConfigId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDnsGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDnsGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDnsGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDnsGtmMonitorRequest : Tea.TeaModel {
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var addrPoolId: String?

    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNode: [AddDnsGtmMonitorRequest.IspCityNode]?

    public var lang: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNode") {
            self.ispCityNode = dict["IspCityNode"] as! [AddDnsGtmMonitorRequest.IspCityNode]
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class AddDnsGtmMonitorResponseBody : Tea.TeaModel {
    public var monitorConfigId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDnsGtmMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDnsGtmMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDnsGtmMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var lang: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class AddDomainResponseBody : Tea.TeaModel {
    public class DnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServer") {
                self.dnsServer = dict["DnsServer"] as! [String]
            }
        }
    }
    public var dnsServers: AddDomainResponseBody.DnsServers?

    public var domainId: String?

    public var domainName: String?

    public var groupId: String?

    public var groupName: String?

    public var punyCode: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dnsServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dnsServers != nil {
            map["DnsServers"] = self.dnsServers?.toMap()
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.punyCode != nil {
            map["PunyCode"] = self.punyCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DnsServers") {
            var model = AddDomainResponseBody.DnsServers()
            model.fromMap(dict["DnsServers"] as! [String: Any])
            self.dnsServers = model
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("PunyCode") {
            self.punyCode = dict["PunyCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDomainBackupRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var periodType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.periodType != nil {
            map["PeriodType"] = self.periodType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PeriodType") {
            self.periodType = dict["PeriodType"] as! String
        }
    }
}

public class AddDomainBackupResponseBody : Tea.TeaModel {
    public var domainName: String?

    public var periodType: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.periodType != nil {
            map["PeriodType"] = self.periodType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("PeriodType") {
            self.periodType = dict["PeriodType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDomainBackupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDomainBackupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDomainBackupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDomainGroupRequest : Tea.TeaModel {
    public var groupName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class AddDomainGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDomainGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDomainGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDomainGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDomainRecordRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var line: String?

    public var priority: Int64?

    public var RR: String?

    public var TTL: Int64?

    public var type: String?

    public var userClientIp: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.TTL != nil {
            map["TTL"] = self.TTL!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Line") {
            self.line = dict["Line"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int64
        }
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("TTL") {
            self.TTL = dict["TTL"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class AddDomainRecordResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDomainRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDomainRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDomainRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGtmAccessStrategyRequest : Tea.TeaModel {
    public var accessLines: String?

    public var defaultAddrPoolId: String?

    public var failoverAddrPoolId: String?

    public var instanceId: String?

    public var lang: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessLines != nil {
            map["AccessLines"] = self.accessLines!
        }
        if self.defaultAddrPoolId != nil {
            map["DefaultAddrPoolId"] = self.defaultAddrPoolId!
        }
        if self.failoverAddrPoolId != nil {
            map["FailoverAddrPoolId"] = self.failoverAddrPoolId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessLines") {
            self.accessLines = dict["AccessLines"] as! String
        }
        if dict.keys.contains("DefaultAddrPoolId") {
            self.defaultAddrPoolId = dict["DefaultAddrPoolId"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolId") {
            self.failoverAddrPoolId = dict["FailoverAddrPoolId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class AddGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class AddGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGtmAddressPoolRequest : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public var lbaWeight: Int32?

        public var mode: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var addr: [AddGtmAddressPoolRequest.Addr]?

    public var evaluationCount: Int32?

    public var instanceId: String?

    public var interval: Int32?

    public var ispCityNode: [AddGtmAddressPoolRequest.IspCityNode]?

    public var lang: String?

    public var minAvailableAddrNum: Int32?

    public var monitorExtendInfo: String?

    public var monitorStatus: String?

    public var name: String?

    public var protocolType: String?

    public var timeout: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            var tmp : [Any] = []
            for k in self.addr! {
                tmp.append(k.toMap())
            }
            map["Addr"] = tmp
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.minAvailableAddrNum != nil {
            map["MinAvailableAddrNum"] = self.minAvailableAddrNum!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.monitorStatus != nil {
            map["MonitorStatus"] = self.monitorStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addr") {
            self.addr = dict["Addr"] as! [AddGtmAddressPoolRequest.Addr]
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNode") {
            self.ispCityNode = dict["IspCityNode"] as! [AddGtmAddressPoolRequest.IspCityNode]
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MinAvailableAddrNum") {
            self.minAvailableAddrNum = dict["MinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("MonitorStatus") {
            self.monitorStatus = dict["MonitorStatus"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddGtmAddressPoolResponseBody : Tea.TeaModel {
    public var addrPoolId: String?

    public var monitorConfigId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGtmMonitorRequest : Tea.TeaModel {
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var addrPoolId: String?

    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNode: [AddGtmMonitorRequest.IspCityNode]?

    public var lang: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNode") {
            self.ispCityNode = dict["IspCityNode"] as! [AddGtmMonitorRequest.IspCityNode]
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class AddGtmMonitorResponseBody : Tea.TeaModel {
    public var monitorConfigId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddGtmMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGtmMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGtmMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGtmRecoveryPlanRequest : Tea.TeaModel {
    public var faultAddrPool: String?

    public var lang: String?

    public var name: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.faultAddrPool != nil {
            map["FaultAddrPool"] = self.faultAddrPool!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FaultAddrPool") {
            self.faultAddrPool = dict["FaultAddrPool"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class AddGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var recoveryPlanId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindInstanceDomainsRequest : Tea.TeaModel {
    public var domainNames: String?

    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class BindInstanceDomainsResponseBody : Tea.TeaModel {
    public var failedCount: Int32?

    public var requestId: String?

    public var successCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedCount") {
            self.failedCount = dict["FailedCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessCount") {
            self.successCount = dict["SuccessCount"] as! Int32
        }
    }
}

public class BindInstanceDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindInstanceDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindInstanceDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeDomainGroupRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class ChangeDomainGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeDomainGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeDomainGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeDomainGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeDomainOfDnsProductRequest : Tea.TeaModel {
    public var force: Bool?

    public var instanceId: String?

    public var lang: String?

    public var newDomain: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.newDomain != nil {
            map["NewDomain"] = self.newDomain!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NewDomain") {
            self.newDomain = dict["NewDomain"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class ChangeDomainOfDnsProductResponseBody : Tea.TeaModel {
    public var originalDomain: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.originalDomain != nil {
            map["OriginalDomain"] = self.originalDomain!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OriginalDomain") {
            self.originalDomain = dict["OriginalDomain"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeDomainOfDnsProductResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeDomainOfDnsProductResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeDomainOfDnsProductResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopyGtmConfigRequest : Tea.TeaModel {
    public var copyType: String?

    public var lang: String?

    public var sourceId: String?

    public var targetId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.copyType != nil {
            map["CopyType"] = self.copyType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceId != nil {
            map["SourceId"] = self.sourceId!
        }
        if self.targetId != nil {
            map["TargetId"] = self.targetId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CopyType") {
            self.copyType = dict["CopyType"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceId") {
            self.sourceId = dict["SourceId"] as! String
        }
        if dict.keys.contains("TargetId") {
            self.targetId = dict["TargetId"] as! String
        }
    }
}

public class CopyGtmConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CopyGtmConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyGtmConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CopyGtmConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePdnsAppKeyRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class CreatePdnsAppKeyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePdnsAppKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePdnsAppKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePdnsAppKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePdnsUdpIpSegmentRequest : Tea.TeaModel {
    public var ip: String?

    public var lang: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class CreatePdnsUdpIpSegmentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var validMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.validMessage != nil {
            map["ValidMessage"] = self.validMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ValidMessage") {
            self.validMessage = dict["ValidMessage"] as! String
        }
    }
}

public class CreatePdnsUdpIpSegmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePdnsUdpIpSegmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePdnsUdpIpSegmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomLinesRequest : Tea.TeaModel {
    public var lang: String?

    public var lineIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lineIds != nil {
            map["LineIds"] = self.lineIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LineIds") {
            self.lineIds = dict["LineIds"] as! String
        }
    }
}

public class DeleteCustomLinesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomLinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomLinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustomLinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDnsCacheDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DeleteDnsCacheDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDnsCacheDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDnsCacheDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDnsCacheDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDnsGtmAccessStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class DeleteDnsGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDnsGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDnsGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDnsGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDnsGtmAddressPoolRequest : Tea.TeaModel {
    public var addrPoolId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DeleteDnsGtmAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDnsGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDnsGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDnsGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DeleteDomainResponseBody : Tea.TeaModel {
    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDomainGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DeleteDomainGroupResponseBody : Tea.TeaModel {
    public var groupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDomainGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDomainGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDomainRecordRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DeleteDomainRecordResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDomainRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDomainRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGtmAccessStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class DeleteGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGtmAddressPoolRequest : Tea.TeaModel {
    public var addrPoolId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DeleteGtmAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
    }
}

public class DeleteGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSubDomainRecordsRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var RR: String?

    public var type: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DeleteSubDomainRecordsResponseBody : Tea.TeaModel {
    public var RR: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DeleteSubDomainRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSubDomainRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSubDomainRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBatchResultCountRequest : Tea.TeaModel {
    public var batchType: String?

    public var lang: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchType != nil {
            map["BatchType"] = self.batchType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchType") {
            self.batchType = dict["BatchType"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class DescribeBatchResultCountResponseBody : Tea.TeaModel {
    public var batchType: String?

    public var failedCount: Int32?

    public var reason: String?

    public var requestId: String?

    public var status: Int32?

    public var successCount: Int32?

    public var taskId: Int64?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchType != nil {
            map["BatchType"] = self.batchType!
        }
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchType") {
            self.batchType = dict["BatchType"] as! String
        }
        if dict.keys.contains("FailedCount") {
            self.failedCount = dict["FailedCount"] as! Int32
        }
        if dict.keys.contains("Reason") {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("SuccessCount") {
            self.successCount = dict["SuccessCount"] as! Int32
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeBatchResultCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBatchResultCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBatchResultCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBatchResultDetailRequest : Tea.TeaModel {
    public var batchType: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchType != nil {
            map["BatchType"] = self.batchType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchType") {
            self.batchType = dict["BatchType"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class DescribeBatchResultDetailResponseBody : Tea.TeaModel {
    public class BatchResultDetails : Tea.TeaModel {
        public class BatchResultDetail : Tea.TeaModel {
            public var batchType: String?

            public var domain: String?

            public var line: String?

            public var newRr: String?

            public var newValue: String?

            public var operateDateStr: String?

            public var priority: String?

            public var reason: String?

            public var recordId: String?

            public var remark: String?

            public var rr: String?

            public var rrStatus: String?

            public var status: Bool?

            public var ttl: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchType != nil {
                    map["BatchType"] = self.batchType!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.line != nil {
                    map["Line"] = self.line!
                }
                if self.newRr != nil {
                    map["NewRr"] = self.newRr!
                }
                if self.newValue != nil {
                    map["NewValue"] = self.newValue!
                }
                if self.operateDateStr != nil {
                    map["OperateDateStr"] = self.operateDateStr!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.rr != nil {
                    map["Rr"] = self.rr!
                }
                if self.rrStatus != nil {
                    map["RrStatus"] = self.rrStatus!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BatchType") {
                    self.batchType = dict["BatchType"] as! String
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("Line") {
                    self.line = dict["Line"] as! String
                }
                if dict.keys.contains("NewRr") {
                    self.newRr = dict["NewRr"] as! String
                }
                if dict.keys.contains("NewValue") {
                    self.newValue = dict["NewValue"] as! String
                }
                if dict.keys.contains("OperateDateStr") {
                    self.operateDateStr = dict["OperateDateStr"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! String
                }
                if dict.keys.contains("Reason") {
                    self.reason = dict["Reason"] as! String
                }
                if dict.keys.contains("RecordId") {
                    self.recordId = dict["RecordId"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("Rr") {
                    self.rr = dict["Rr"] as! String
                }
                if dict.keys.contains("RrStatus") {
                    self.rrStatus = dict["RrStatus"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Bool
                }
                if dict.keys.contains("Ttl") {
                    self.ttl = dict["Ttl"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var batchResultDetail: [DescribeBatchResultDetailResponseBody.BatchResultDetails.BatchResultDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchResultDetail != nil {
                var tmp : [Any] = []
                for k in self.batchResultDetail! {
                    tmp.append(k.toMap())
                }
                map["BatchResultDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BatchResultDetail") {
                self.batchResultDetail = dict["BatchResultDetail"] as! [DescribeBatchResultDetailResponseBody.BatchResultDetails.BatchResultDetail]
            }
        }
    }
    public var batchResultDetails: DescribeBatchResultDetailResponseBody.BatchResultDetails?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.batchResultDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchResultDetails != nil {
            map["BatchResultDetails"] = self.batchResultDetails?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchResultDetails") {
            var model = DescribeBatchResultDetailResponseBody.BatchResultDetails()
            model.fromMap(dict["BatchResultDetails"] as! [String: Any])
            self.batchResultDetails = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeBatchResultDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBatchResultDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBatchResultDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomLineRequest : Tea.TeaModel {
    public var lang: String?

    public var lineId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lineId != nil {
            map["LineId"] = self.lineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LineId") {
            self.lineId = dict["LineId"] as! Int64
        }
    }
}

public class DescribeCustomLineResponseBody : Tea.TeaModel {
    public class IpSegmentList : Tea.TeaModel {
        public var endIp: String?

        public var startIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endIp != nil {
                map["EndIp"] = self.endIp!
            }
            if self.startIp != nil {
                map["StartIp"] = self.startIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndIp") {
                self.endIp = dict["EndIp"] as! String
            }
            if dict.keys.contains("StartIp") {
                self.startIp = dict["StartIp"] as! String
            }
        }
    }
    public var code: String?

    public var domainName: String?

    public var id: Int64?

    public var ipSegmentList: [DescribeCustomLineResponseBody.IpSegmentList]?

    public var name: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ipSegmentList != nil {
            var tmp : [Any] = []
            for k in self.ipSegmentList! {
                tmp.append(k.toMap())
            }
            map["IpSegmentList"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IpSegmentList") {
            self.ipSegmentList = dict["IpSegmentList"] as! [DescribeCustomLineResponseBody.IpSegmentList]
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCustomLineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomLineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCustomLineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomLinesRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribeCustomLinesResponseBody : Tea.TeaModel {
    public class CustomLines : Tea.TeaModel {
        public var code: String?

        public var id: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var customLines: [DescribeCustomLinesResponseBody.CustomLines]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customLines != nil {
            var tmp : [Any] = []
            for k in self.customLines! {
                tmp.append(k.toMap())
            }
            map["CustomLines"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomLines") {
            self.customLines = dict["CustomLines"] as! [DescribeCustomLinesResponseBody.CustomLines]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeCustomLinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomLinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCustomLinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDNSSLBSubDomainsRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var rr: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.rr != nil {
            map["Rr"] = self.rr!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Rr") {
            self.rr = dict["Rr"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DescribeDNSSLBSubDomainsResponseBody : Tea.TeaModel {
    public class SlbSubDomains : Tea.TeaModel {
        public class SlbSubDomain : Tea.TeaModel {
            public class LineAlgorithms : Tea.TeaModel {
                public class LineAlgorithm : Tea.TeaModel {
                    public var line: String?

                    public var open_: Bool?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.line != nil {
                            map["Line"] = self.line!
                        }
                        if self.open_ != nil {
                            map["Open"] = self.open_!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Line") {
                            self.line = dict["Line"] as! String
                        }
                        if dict.keys.contains("Open") {
                            self.open_ = dict["Open"] as! Bool
                        }
                    }
                }
                public var lineAlgorithm: [DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms.LineAlgorithm]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lineAlgorithm != nil {
                        var tmp : [Any] = []
                        for k in self.lineAlgorithm! {
                            tmp.append(k.toMap())
                        }
                        map["LineAlgorithm"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LineAlgorithm") {
                        self.lineAlgorithm = dict["LineAlgorithm"] as! [DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms.LineAlgorithm]
                    }
                }
            }
            public var lineAlgorithms: DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms?

            public var open_: Bool?

            public var recordCount: Int64?

            public var subDomain: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.lineAlgorithms?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.lineAlgorithms != nil {
                    map["LineAlgorithms"] = self.lineAlgorithms?.toMap()
                }
                if self.open_ != nil {
                    map["Open"] = self.open_!
                }
                if self.recordCount != nil {
                    map["RecordCount"] = self.recordCount!
                }
                if self.subDomain != nil {
                    map["SubDomain"] = self.subDomain!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LineAlgorithms") {
                    var model = DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms()
                    model.fromMap(dict["LineAlgorithms"] as! [String: Any])
                    self.lineAlgorithms = model
                }
                if dict.keys.contains("Open") {
                    self.open_ = dict["Open"] as! Bool
                }
                if dict.keys.contains("RecordCount") {
                    self.recordCount = dict["RecordCount"] as! Int64
                }
                if dict.keys.contains("SubDomain") {
                    self.subDomain = dict["SubDomain"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var slbSubDomain: [DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbSubDomain != nil {
                var tmp : [Any] = []
                for k in self.slbSubDomain! {
                    tmp.append(k.toMap())
                }
                map["SlbSubDomain"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SlbSubDomain") {
                self.slbSubDomain = dict["SlbSubDomain"] as! [DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain]
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var slbSubDomains: DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.slbSubDomains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.slbSubDomains != nil {
            map["SlbSubDomains"] = self.slbSubDomains?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SlbSubDomains") {
            var model = DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains()
            model.fromMap(dict["SlbSubDomains"] as! [String: Any])
            self.slbSubDomains = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDNSSLBSubDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDNSSLBSubDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDNSSLBSubDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsCacheDomainsRequest : Tea.TeaModel {
    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribeDnsCacheDomainsResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class SourceDnsServers : Tea.TeaModel {
            public var host: String?

            public var port: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
            }
        }
        public var cacheTtlMax: Int32?

        public var cacheTtlMin: Int32?

        public var createTime: String?

        public var createTimestamp: Int64?

        public var domainId: String?

        public var domainName: String?

        public var expireTime: String?

        public var expireTimestamp: Int64?

        public var instanceId: String?

        public var remark: String?

        public var sourceDnsServers: [DescribeDnsCacheDomainsResponseBody.Domains.SourceDnsServers]?

        public var sourceEdns: String?

        public var sourceProtocol: String?

        public var updateTime: String?

        public var updateTimestamp: Int64?

        public var versionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cacheTtlMax != nil {
                map["CacheTtlMax"] = self.cacheTtlMax!
            }
            if self.cacheTtlMin != nil {
                map["CacheTtlMin"] = self.cacheTtlMin!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.expireTimestamp != nil {
                map["ExpireTimestamp"] = self.expireTimestamp!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.sourceDnsServers != nil {
                var tmp : [Any] = []
                for k in self.sourceDnsServers! {
                    tmp.append(k.toMap())
                }
                map["SourceDnsServers"] = tmp
            }
            if self.sourceEdns != nil {
                map["SourceEdns"] = self.sourceEdns!
            }
            if self.sourceProtocol != nil {
                map["SourceProtocol"] = self.sourceProtocol!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.updateTimestamp != nil {
                map["UpdateTimestamp"] = self.updateTimestamp!
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CacheTtlMax") {
                self.cacheTtlMax = dict["CacheTtlMax"] as! Int32
            }
            if dict.keys.contains("CacheTtlMin") {
                self.cacheTtlMin = dict["CacheTtlMin"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("DomainId") {
                self.domainId = dict["DomainId"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("ExpireTimestamp") {
                self.expireTimestamp = dict["ExpireTimestamp"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Remark") {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("SourceDnsServers") {
                self.sourceDnsServers = dict["SourceDnsServers"] as! [DescribeDnsCacheDomainsResponseBody.Domains.SourceDnsServers]
            }
            if dict.keys.contains("SourceEdns") {
                self.sourceEdns = dict["SourceEdns"] as! String
            }
            if dict.keys.contains("SourceProtocol") {
                self.sourceProtocol = dict["SourceProtocol"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
            if dict.keys.contains("UpdateTimestamp") {
                self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
            }
            if dict.keys.contains("VersionCode") {
                self.versionCode = dict["VersionCode"] as! String
            }
        }
    }
    public var domains: [DescribeDnsCacheDomainsResponseBody.Domains]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domains != nil {
            var tmp : [Any] = []
            for k in self.domains! {
                tmp.append(k.toMap())
            }
            map["Domains"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Domains") {
            self.domains = dict["Domains"] as! [DescribeDnsCacheDomainsResponseBody.Domains]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDnsCacheDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsCacheDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsCacheDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmAccessStrategiesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var strategyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StrategyMode") {
            self.strategyMode = dict["StrategyMode"] as! String
        }
    }
}

public class DescribeDnsGtmAccessStrategiesResponseBody : Tea.TeaModel {
    public class Strategies : Tea.TeaModel {
        public class Strategy : Tea.TeaModel {
            public class EffectiveAddrPools : Tea.TeaModel {
                public class EffectiveAddrPool : Tea.TeaModel {
                    public var addrCount: Int32?

                    public var id: String?

                    public var lbaWeight: Int32?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.addrCount != nil {
                            map["AddrCount"] = self.addrCount!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.lbaWeight != nil {
                            map["LbaWeight"] = self.lbaWeight!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AddrCount") {
                            self.addrCount = dict["AddrCount"] as! Int32
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("LbaWeight") {
                            self.lbaWeight = dict["LbaWeight"] as! Int32
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public var effectiveAddrPool: [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools.EffectiveAddrPool]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.effectiveAddrPool != nil {
                        var tmp : [Any] = []
                        for k in self.effectiveAddrPool! {
                            tmp.append(k.toMap())
                        }
                        map["EffectiveAddrPool"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EffectiveAddrPool") {
                        self.effectiveAddrPool = dict["EffectiveAddrPool"] as! [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools.EffectiveAddrPool]
                    }
                }
            }
            public class Lines : Tea.TeaModel {
                public class Line : Tea.TeaModel {
                    public var groupCode: String?

                    public var groupName: String?

                    public var lineCode: String?

                    public var lineName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.groupCode != nil {
                            map["GroupCode"] = self.groupCode!
                        }
                        if self.groupName != nil {
                            map["GroupName"] = self.groupName!
                        }
                        if self.lineCode != nil {
                            map["LineCode"] = self.lineCode!
                        }
                        if self.lineName != nil {
                            map["LineName"] = self.lineName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("GroupCode") {
                            self.groupCode = dict["GroupCode"] as! String
                        }
                        if dict.keys.contains("GroupName") {
                            self.groupName = dict["GroupName"] as! String
                        }
                        if dict.keys.contains("LineCode") {
                            self.lineCode = dict["LineCode"] as! String
                        }
                        if dict.keys.contains("LineName") {
                            self.lineName = dict["LineName"] as! String
                        }
                    }
                }
                public var line: [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.line != nil {
                        var tmp : [Any] = []
                        for k in self.line! {
                            tmp.append(k.toMap())
                        }
                        map["Line"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Line") {
                        self.line = dict["Line"] as! [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line]
                    }
                }
            }
            public var createTime: String?

            public var createTimestamp: Int64?

            public var effectiveAddrPoolGroupType: String?

            public var effectiveAddrPoolType: String?

            public var effectiveAddrPools: DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools?

            public var effectiveLbaStrategy: String?

            public var lines: DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines?

            public var strategyId: String?

            public var strategyName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.effectiveAddrPools?.validate()
                try self.lines?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.effectiveAddrPoolGroupType != nil {
                    map["EffectiveAddrPoolGroupType"] = self.effectiveAddrPoolGroupType!
                }
                if self.effectiveAddrPoolType != nil {
                    map["EffectiveAddrPoolType"] = self.effectiveAddrPoolType!
                }
                if self.effectiveAddrPools != nil {
                    map["EffectiveAddrPools"] = self.effectiveAddrPools?.toMap()
                }
                if self.effectiveLbaStrategy != nil {
                    map["EffectiveLbaStrategy"] = self.effectiveLbaStrategy!
                }
                if self.lines != nil {
                    map["Lines"] = self.lines?.toMap()
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.strategyName != nil {
                    map["StrategyName"] = self.strategyName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("EffectiveAddrPoolGroupType") {
                    self.effectiveAddrPoolGroupType = dict["EffectiveAddrPoolGroupType"] as! String
                }
                if dict.keys.contains("EffectiveAddrPoolType") {
                    self.effectiveAddrPoolType = dict["EffectiveAddrPoolType"] as! String
                }
                if dict.keys.contains("EffectiveAddrPools") {
                    var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools()
                    model.fromMap(dict["EffectiveAddrPools"] as! [String: Any])
                    self.effectiveAddrPools = model
                }
                if dict.keys.contains("EffectiveLbaStrategy") {
                    self.effectiveLbaStrategy = dict["EffectiveLbaStrategy"] as! String
                }
                if dict.keys.contains("Lines") {
                    var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines()
                    model.fromMap(dict["Lines"] as! [String: Any])
                    self.lines = model
                }
                if dict.keys.contains("StrategyId") {
                    self.strategyId = dict["StrategyId"] as! String
                }
                if dict.keys.contains("StrategyName") {
                    self.strategyName = dict["StrategyName"] as! String
                }
            }
        }
        public var strategy: [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.strategy != nil {
                var tmp : [Any] = []
                for k in self.strategy! {
                    tmp.append(k.toMap())
                }
                map["Strategy"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Strategy") {
                self.strategy = dict["Strategy"] as! [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var strategies: DescribeDnsGtmAccessStrategiesResponseBody.Strategies?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.strategies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategies != nil {
            map["Strategies"] = self.strategies?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Strategies") {
            var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies()
            model.fromMap(dict["Strategies"] as! [String: Any])
            self.strategies = model
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDnsGtmAccessStrategiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAccessStrategiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmAccessStrategiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmAccessStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class DescribeDnsGtmAccessStrategyResponseBody : Tea.TeaModel {
    public class DefaultAddrPools : Tea.TeaModel {
        public class DefaultAddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var lbaWeight: Int32?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.lbaWeight != nil {
                    map["LbaWeight"] = self.lbaWeight!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("LbaWeight") {
                    self.lbaWeight = dict["LbaWeight"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var defaultAddrPool: [DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools.DefaultAddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultAddrPool != nil {
                var tmp : [Any] = []
                for k in self.defaultAddrPool! {
                    tmp.append(k.toMap())
                }
                map["DefaultAddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultAddrPool") {
                self.defaultAddrPool = dict["DefaultAddrPool"] as! [DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools.DefaultAddrPool]
            }
        }
    }
    public class FailoverAddrPools : Tea.TeaModel {
        public class FailoverAddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var lbaWeight: Int32?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.lbaWeight != nil {
                    map["LbaWeight"] = self.lbaWeight!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("LbaWeight") {
                    self.lbaWeight = dict["LbaWeight"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var failoverAddrPool: [DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools.FailoverAddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failoverAddrPool != nil {
                var tmp : [Any] = []
                for k in self.failoverAddrPool! {
                    tmp.append(k.toMap())
                }
                map["FailoverAddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailoverAddrPool") {
                self.failoverAddrPool = dict["FailoverAddrPool"] as! [DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools.FailoverAddrPool]
            }
        }
    }
    public class Lines : Tea.TeaModel {
        public class Line : Tea.TeaModel {
            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupCode") {
                    self.groupCode = dict["GroupCode"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
            }
        }
        public var line: [DescribeDnsGtmAccessStrategyResponseBody.Lines.Line]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.line != nil {
                var tmp : [Any] = []
                for k in self.line! {
                    tmp.append(k.toMap())
                }
                map["Line"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Line") {
                self.line = dict["Line"] as! [DescribeDnsGtmAccessStrategyResponseBody.Lines.Line]
            }
        }
    }
    public var accessMode: String?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var defaultAddrPoolGroupStatus: String?

    public var defaultAddrPoolType: String?

    public var defaultAddrPools: DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools?

    public var defaultAvailableAddrNum: Int32?

    public var defaultLatencyOptimization: String?

    public var defaultLbaStrategy: String?

    public var defaultMaxReturnAddrNum: Int32?

    public var defaultMinAvailableAddrNum: Int32?

    public var effectiveAddrPoolGroupType: String?

    public var failoverAddrPoolGroupStatus: String?

    public var failoverAddrPoolType: String?

    public var failoverAddrPools: DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools?

    public var failoverAvailableAddrNum: Int32?

    public var failoverLatencyOptimization: String?

    public var failoverLbaStrategy: String?

    public var failoverMaxReturnAddrNum: Int32?

    public var failoverMinAvailableAddrNum: Int32?

    public var instanceId: String?

    public var lines: DescribeDnsGtmAccessStrategyResponseBody.Lines?

    public var requestId: String?

    public var strategyId: String?

    public var strategyMode: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.defaultAddrPools?.validate()
        try self.failoverAddrPools?.validate()
        try self.lines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.defaultAddrPoolGroupStatus != nil {
            map["DefaultAddrPoolGroupStatus"] = self.defaultAddrPoolGroupStatus!
        }
        if self.defaultAddrPoolType != nil {
            map["DefaultAddrPoolType"] = self.defaultAddrPoolType!
        }
        if self.defaultAddrPools != nil {
            map["DefaultAddrPools"] = self.defaultAddrPools?.toMap()
        }
        if self.defaultAvailableAddrNum != nil {
            map["DefaultAvailableAddrNum"] = self.defaultAvailableAddrNum!
        }
        if self.defaultLatencyOptimization != nil {
            map["DefaultLatencyOptimization"] = self.defaultLatencyOptimization!
        }
        if self.defaultLbaStrategy != nil {
            map["DefaultLbaStrategy"] = self.defaultLbaStrategy!
        }
        if self.defaultMaxReturnAddrNum != nil {
            map["DefaultMaxReturnAddrNum"] = self.defaultMaxReturnAddrNum!
        }
        if self.defaultMinAvailableAddrNum != nil {
            map["DefaultMinAvailableAddrNum"] = self.defaultMinAvailableAddrNum!
        }
        if self.effectiveAddrPoolGroupType != nil {
            map["EffectiveAddrPoolGroupType"] = self.effectiveAddrPoolGroupType!
        }
        if self.failoverAddrPoolGroupStatus != nil {
            map["FailoverAddrPoolGroupStatus"] = self.failoverAddrPoolGroupStatus!
        }
        if self.failoverAddrPoolType != nil {
            map["FailoverAddrPoolType"] = self.failoverAddrPoolType!
        }
        if self.failoverAddrPools != nil {
            map["FailoverAddrPools"] = self.failoverAddrPools?.toMap()
        }
        if self.failoverAvailableAddrNum != nil {
            map["FailoverAvailableAddrNum"] = self.failoverAvailableAddrNum!
        }
        if self.failoverLatencyOptimization != nil {
            map["FailoverLatencyOptimization"] = self.failoverLatencyOptimization!
        }
        if self.failoverLbaStrategy != nil {
            map["FailoverLbaStrategy"] = self.failoverLbaStrategy!
        }
        if self.failoverMaxReturnAddrNum != nil {
            map["FailoverMaxReturnAddrNum"] = self.failoverMaxReturnAddrNum!
        }
        if self.failoverMinAvailableAddrNum != nil {
            map["FailoverMinAvailableAddrNum"] = self.failoverMinAvailableAddrNum!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lines != nil {
            map["Lines"] = self.lines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessMode") {
            self.accessMode = dict["AccessMode"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("DefaultAddrPoolGroupStatus") {
            self.defaultAddrPoolGroupStatus = dict["DefaultAddrPoolGroupStatus"] as! String
        }
        if dict.keys.contains("DefaultAddrPoolType") {
            self.defaultAddrPoolType = dict["DefaultAddrPoolType"] as! String
        }
        if dict.keys.contains("DefaultAddrPools") {
            var model = DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools()
            model.fromMap(dict["DefaultAddrPools"] as! [String: Any])
            self.defaultAddrPools = model
        }
        if dict.keys.contains("DefaultAvailableAddrNum") {
            self.defaultAvailableAddrNum = dict["DefaultAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("DefaultLatencyOptimization") {
            self.defaultLatencyOptimization = dict["DefaultLatencyOptimization"] as! String
        }
        if dict.keys.contains("DefaultLbaStrategy") {
            self.defaultLbaStrategy = dict["DefaultLbaStrategy"] as! String
        }
        if dict.keys.contains("DefaultMaxReturnAddrNum") {
            self.defaultMaxReturnAddrNum = dict["DefaultMaxReturnAddrNum"] as! Int32
        }
        if dict.keys.contains("DefaultMinAvailableAddrNum") {
            self.defaultMinAvailableAddrNum = dict["DefaultMinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("EffectiveAddrPoolGroupType") {
            self.effectiveAddrPoolGroupType = dict["EffectiveAddrPoolGroupType"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolGroupStatus") {
            self.failoverAddrPoolGroupStatus = dict["FailoverAddrPoolGroupStatus"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolType") {
            self.failoverAddrPoolType = dict["FailoverAddrPoolType"] as! String
        }
        if dict.keys.contains("FailoverAddrPools") {
            var model = DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools()
            model.fromMap(dict["FailoverAddrPools"] as! [String: Any])
            self.failoverAddrPools = model
        }
        if dict.keys.contains("FailoverAvailableAddrNum") {
            self.failoverAvailableAddrNum = dict["FailoverAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("FailoverLatencyOptimization") {
            self.failoverLatencyOptimization = dict["FailoverLatencyOptimization"] as! String
        }
        if dict.keys.contains("FailoverLbaStrategy") {
            self.failoverLbaStrategy = dict["FailoverLbaStrategy"] as! String
        }
        if dict.keys.contains("FailoverMaxReturnAddrNum") {
            self.failoverMaxReturnAddrNum = dict["FailoverMaxReturnAddrNum"] as! Int32
        }
        if dict.keys.contains("FailoverMinAvailableAddrNum") {
            self.failoverMinAvailableAddrNum = dict["FailoverMinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lines") {
            var model = DescribeDnsGtmAccessStrategyResponseBody.Lines()
            model.fromMap(dict["Lines"] as! [String: Any])
            self.lines = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
        if dict.keys.contains("StrategyMode") {
            self.strategyMode = dict["StrategyMode"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class DescribeDnsGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmAccessStrategyAvailableConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var strategyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyMode") {
            self.strategyMode = dict["StrategyMode"] as! String
        }
    }
}

public class DescribeDnsGtmAccessStrategyAvailableConfigResponseBody : Tea.TeaModel {
    public class DomainAddrPools : Tea.TeaModel {
        public class DomainAddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var domainAddrPool: [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools.DomainAddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainAddrPool != nil {
                var tmp : [Any] = []
                for k in self.domainAddrPool! {
                    tmp.append(k.toMap())
                }
                map["DomainAddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainAddrPool") {
                self.domainAddrPool = dict["DomainAddrPool"] as! [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools.DomainAddrPool]
            }
        }
    }
    public class Ipv4AddrPools : Tea.TeaModel {
        public class Ipv4AddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var ipv4AddrPool: [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools.Ipv4AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4AddrPool != nil {
                var tmp : [Any] = []
                for k in self.ipv4AddrPool! {
                    tmp.append(k.toMap())
                }
                map["Ipv4AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv4AddrPool") {
                self.ipv4AddrPool = dict["Ipv4AddrPool"] as! [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools.Ipv4AddrPool]
            }
        }
    }
    public class Ipv6AddrPools : Tea.TeaModel {
        public class Ipv6AddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var ipv6AddrPool: [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools.Ipv6AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6AddrPool != nil {
                var tmp : [Any] = []
                for k in self.ipv6AddrPool! {
                    tmp.append(k.toMap())
                }
                map["Ipv6AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6AddrPool") {
                self.ipv6AddrPool = dict["Ipv6AddrPool"] as! [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools.Ipv6AddrPool]
            }
        }
    }
    public class Lines : Tea.TeaModel {
        public class Line : Tea.TeaModel {
            public var fatherCode: String?

            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FatherCode") {
                    self.fatherCode = dict["FatherCode"] as! String
                }
                if dict.keys.contains("GroupCode") {
                    self.groupCode = dict["GroupCode"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
            }
        }
        public var line: [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines.Line]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.line != nil {
                var tmp : [Any] = []
                for k in self.line! {
                    tmp.append(k.toMap())
                }
                map["Line"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Line") {
                self.line = dict["Line"] as! [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines.Line]
            }
        }
    }
    public class SelectedDomainLines : Tea.TeaModel {
        public var selectedDomainLine: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.selectedDomainLine != nil {
                map["SelectedDomainLine"] = self.selectedDomainLine!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SelectedDomainLine") {
                self.selectedDomainLine = dict["SelectedDomainLine"] as! [String]
            }
        }
    }
    public class SelectedIpv4Lines : Tea.TeaModel {
        public var selectedIpv4Line: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.selectedIpv4Line != nil {
                map["SelectedIpv4Line"] = self.selectedIpv4Line!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SelectedIpv4Line") {
                self.selectedIpv4Line = dict["SelectedIpv4Line"] as! [String]
            }
        }
    }
    public class SelectedIpv6Lines : Tea.TeaModel {
        public var selectedIpv6Line: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.selectedIpv6Line != nil {
                map["SelectedIpv6Line"] = self.selectedIpv6Line!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SelectedIpv6Line") {
                self.selectedIpv6Line = dict["SelectedIpv6Line"] as! [String]
            }
        }
    }
    public var domainAddrPools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools?

    public var ipv4AddrPools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools?

    public var ipv6AddrPools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools?

    public var lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines?

    public var requestId: String?

    public var selectedDomainLines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedDomainLines?

    public var selectedIpv4Lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedIpv4Lines?

    public var selectedIpv6Lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedIpv6Lines?

    public var suggestSetDefaultLine: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainAddrPools?.validate()
        try self.ipv4AddrPools?.validate()
        try self.ipv6AddrPools?.validate()
        try self.lines?.validate()
        try self.selectedDomainLines?.validate()
        try self.selectedIpv4Lines?.validate()
        try self.selectedIpv6Lines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainAddrPools != nil {
            map["DomainAddrPools"] = self.domainAddrPools?.toMap()
        }
        if self.ipv4AddrPools != nil {
            map["Ipv4AddrPools"] = self.ipv4AddrPools?.toMap()
        }
        if self.ipv6AddrPools != nil {
            map["Ipv6AddrPools"] = self.ipv6AddrPools?.toMap()
        }
        if self.lines != nil {
            map["Lines"] = self.lines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.selectedDomainLines != nil {
            map["SelectedDomainLines"] = self.selectedDomainLines?.toMap()
        }
        if self.selectedIpv4Lines != nil {
            map["SelectedIpv4Lines"] = self.selectedIpv4Lines?.toMap()
        }
        if self.selectedIpv6Lines != nil {
            map["SelectedIpv6Lines"] = self.selectedIpv6Lines?.toMap()
        }
        if self.suggestSetDefaultLine != nil {
            map["SuggestSetDefaultLine"] = self.suggestSetDefaultLine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainAddrPools") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools()
            model.fromMap(dict["DomainAddrPools"] as! [String: Any])
            self.domainAddrPools = model
        }
        if dict.keys.contains("Ipv4AddrPools") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools()
            model.fromMap(dict["Ipv4AddrPools"] as! [String: Any])
            self.ipv4AddrPools = model
        }
        if dict.keys.contains("Ipv6AddrPools") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools()
            model.fromMap(dict["Ipv6AddrPools"] as! [String: Any])
            self.ipv6AddrPools = model
        }
        if dict.keys.contains("Lines") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines()
            model.fromMap(dict["Lines"] as! [String: Any])
            self.lines = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SelectedDomainLines") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedDomainLines()
            model.fromMap(dict["SelectedDomainLines"] as! [String: Any])
            self.selectedDomainLines = model
        }
        if dict.keys.contains("SelectedIpv4Lines") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedIpv4Lines()
            model.fromMap(dict["SelectedIpv4Lines"] as! [String: Any])
            self.selectedIpv4Lines = model
        }
        if dict.keys.contains("SelectedIpv6Lines") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedIpv6Lines()
            model.fromMap(dict["SelectedIpv6Lines"] as! [String: Any])
            self.selectedIpv6Lines = model
        }
        if dict.keys.contains("SuggestSetDefaultLine") {
            self.suggestSetDefaultLine = dict["SuggestSetDefaultLine"] as! Bool
        }
    }
}

public class DescribeDnsGtmAccessStrategyAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmAddrAttributeInfoRequest : Tea.TeaModel {
    public var addrs: String?

    public var lang: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrs != nil {
            map["Addrs"] = self.addrs!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addrs") {
            self.addrs = dict["Addrs"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeDnsGtmAddrAttributeInfoResponseBody : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public class Addr : Tea.TeaModel {
            public class AttributeInfo : Tea.TeaModel {
                public var fatherCode: String?

                public var groupCode: String?

                public var groupName: String?

                public var lineCode: String?

                public var lineName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fatherCode != nil {
                        map["FatherCode"] = self.fatherCode!
                    }
                    if self.groupCode != nil {
                        map["GroupCode"] = self.groupCode!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.lineCode != nil {
                        map["LineCode"] = self.lineCode!
                    }
                    if self.lineName != nil {
                        map["LineName"] = self.lineName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FatherCode") {
                        self.fatherCode = dict["FatherCode"] as! String
                    }
                    if dict.keys.contains("GroupCode") {
                        self.groupCode = dict["GroupCode"] as! String
                    }
                    if dict.keys.contains("GroupName") {
                        self.groupName = dict["GroupName"] as! String
                    }
                    if dict.keys.contains("LineCode") {
                        self.lineCode = dict["LineCode"] as! String
                    }
                    if dict.keys.contains("LineName") {
                        self.lineName = dict["LineName"] as! String
                    }
                }
            }
            public var addr: String?

            public var attributeInfo: DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr.AttributeInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.attributeInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addr != nil {
                    map["Addr"] = self.addr!
                }
                if self.attributeInfo != nil {
                    map["AttributeInfo"] = self.attributeInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Addr") {
                    self.addr = dict["Addr"] as! String
                }
                if dict.keys.contains("AttributeInfo") {
                    var model = DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr.AttributeInfo()
                    model.fromMap(dict["AttributeInfo"] as! [String: Any])
                    self.attributeInfo = model
                }
            }
        }
        public var addr: [DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                var tmp : [Any] = []
                for k in self.addr! {
                    tmp.append(k.toMap())
                }
                map["Addr"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Addr") {
                self.addr = dict["Addr"] as! [DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr]
            }
        }
    }
    public var addr: DescribeDnsGtmAddrAttributeInfoResponseBody.Addr?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addr?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            map["Addr"] = self.addr?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addr") {
            var model = DescribeDnsGtmAddrAttributeInfoResponseBody.Addr()
            model.fromMap(dict["Addr"] as! [String: Any])
            self.addr = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDnsGtmAddrAttributeInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAddrAttributeInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmAddrAttributeInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmAddressPoolAvailableConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmAddressPoolAvailableConfigResponseBody : Tea.TeaModel {
    public class AttributeInfos : Tea.TeaModel {
        public class AttributeInfo : Tea.TeaModel {
            public var fatherCode: String?

            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FatherCode") {
                    self.fatherCode = dict["FatherCode"] as! String
                }
                if dict.keys.contains("GroupCode") {
                    self.groupCode = dict["GroupCode"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
            }
        }
        public var attributeInfo: [DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos.AttributeInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attributeInfo != nil {
                var tmp : [Any] = []
                for k in self.attributeInfo! {
                    tmp.append(k.toMap())
                }
                map["AttributeInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttributeInfo") {
                self.attributeInfo = dict["AttributeInfo"] as! [DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos.AttributeInfo]
            }
        }
    }
    public var attributeInfos: DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.attributeInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributeInfos != nil {
            map["AttributeInfos"] = self.attributeInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttributeInfos") {
            var model = DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos()
            model.fromMap(dict["AttributeInfos"] as! [String: Any])
            self.attributeInfos = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDnsGtmAddressPoolAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAddressPoolAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmAddressPoolAvailableConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmAvailableAlertGroupRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmAvailableAlertGroupResponseBody : Tea.TeaModel {
    public var availableAlertGroup: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAlertGroup != nil {
            map["AvailableAlertGroup"] = self.availableAlertGroup!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableAlertGroup") {
            self.availableAlertGroup = dict["AvailableAlertGroup"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDnsGtmAvailableAlertGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAvailableAlertGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmAvailableAlertGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmInstanceResponseBody : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public class AlertConfig : Tea.TeaModel {
            public class AlertConfig : Tea.TeaModel {
                public var dingtalkNotice: Bool?

                public var emailNotice: Bool?

                public var noticeType: String?

                public var smsNotice: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dingtalkNotice != nil {
                        map["DingtalkNotice"] = self.dingtalkNotice!
                    }
                    if self.emailNotice != nil {
                        map["EmailNotice"] = self.emailNotice!
                    }
                    if self.noticeType != nil {
                        map["NoticeType"] = self.noticeType!
                    }
                    if self.smsNotice != nil {
                        map["SmsNotice"] = self.smsNotice!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DingtalkNotice") {
                        self.dingtalkNotice = dict["DingtalkNotice"] as! Bool
                    }
                    if dict.keys.contains("EmailNotice") {
                        self.emailNotice = dict["EmailNotice"] as! Bool
                    }
                    if dict.keys.contains("NoticeType") {
                        self.noticeType = dict["NoticeType"] as! String
                    }
                    if dict.keys.contains("SmsNotice") {
                        self.smsNotice = dict["SmsNotice"] as! Bool
                    }
                }
            }
            public var alertConfig: [DescribeDnsGtmInstanceResponseBody.Config.AlertConfig.AlertConfig]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertConfig != nil {
                    var tmp : [Any] = []
                    for k in self.alertConfig! {
                        tmp.append(k.toMap())
                    }
                    map["AlertConfig"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertConfig") {
                    self.alertConfig = dict["AlertConfig"] as! [DescribeDnsGtmInstanceResponseBody.Config.AlertConfig.AlertConfig]
                }
            }
        }
        public var alertConfig: DescribeDnsGtmInstanceResponseBody.Config.AlertConfig?

        public var alertGroup: String?

        public var cnameType: String?

        public var instanceName: String?

        public var pubicZoneName: String?

        public var publicCnameMode: String?

        public var publicRr: String?

        public var publicUserDomainName: String?

        public var strategyMode: String?

        public var ttl: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.alertConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertConfig != nil {
                map["AlertConfig"] = self.alertConfig?.toMap()
            }
            if self.alertGroup != nil {
                map["AlertGroup"] = self.alertGroup!
            }
            if self.cnameType != nil {
                map["CnameType"] = self.cnameType!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.pubicZoneName != nil {
                map["PubicZoneName"] = self.pubicZoneName!
            }
            if self.publicCnameMode != nil {
                map["PublicCnameMode"] = self.publicCnameMode!
            }
            if self.publicRr != nil {
                map["PublicRr"] = self.publicRr!
            }
            if self.publicUserDomainName != nil {
                map["PublicUserDomainName"] = self.publicUserDomainName!
            }
            if self.strategyMode != nil {
                map["StrategyMode"] = self.strategyMode!
            }
            if self.ttl != nil {
                map["Ttl"] = self.ttl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertConfig") {
                var model = DescribeDnsGtmInstanceResponseBody.Config.AlertConfig()
                model.fromMap(dict["AlertConfig"] as! [String: Any])
                self.alertConfig = model
            }
            if dict.keys.contains("AlertGroup") {
                self.alertGroup = dict["AlertGroup"] as! String
            }
            if dict.keys.contains("CnameType") {
                self.cnameType = dict["CnameType"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("PubicZoneName") {
                self.pubicZoneName = dict["PubicZoneName"] as! String
            }
            if dict.keys.contains("PublicCnameMode") {
                self.publicCnameMode = dict["PublicCnameMode"] as! String
            }
            if dict.keys.contains("PublicRr") {
                self.publicRr = dict["PublicRr"] as! String
            }
            if dict.keys.contains("PublicUserDomainName") {
                self.publicUserDomainName = dict["PublicUserDomainName"] as! String
            }
            if dict.keys.contains("StrategyMode") {
                self.strategyMode = dict["StrategyMode"] as! String
            }
            if dict.keys.contains("Ttl") {
                self.ttl = dict["Ttl"] as! Int32
            }
        }
    }
    public class UsedQuota : Tea.TeaModel {
        public var dingtalkUsedCount: Int32?

        public var emailUsedCount: Int32?

        public var smsUsedCount: Int32?

        public var taskUsedCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingtalkUsedCount != nil {
                map["DingtalkUsedCount"] = self.dingtalkUsedCount!
            }
            if self.emailUsedCount != nil {
                map["EmailUsedCount"] = self.emailUsedCount!
            }
            if self.smsUsedCount != nil {
                map["SmsUsedCount"] = self.smsUsedCount!
            }
            if self.taskUsedCount != nil {
                map["TaskUsedCount"] = self.taskUsedCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DingtalkUsedCount") {
                self.dingtalkUsedCount = dict["DingtalkUsedCount"] as! Int32
            }
            if dict.keys.contains("EmailUsedCount") {
                self.emailUsedCount = dict["EmailUsedCount"] as! Int32
            }
            if dict.keys.contains("SmsUsedCount") {
                self.smsUsedCount = dict["SmsUsedCount"] as! Int32
            }
            if dict.keys.contains("TaskUsedCount") {
                self.taskUsedCount = dict["TaskUsedCount"] as! Int32
            }
        }
    }
    public var config: DescribeDnsGtmInstanceResponseBody.Config?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var expireTime: String?

    public var expireTimestamp: Int64?

    public var instanceId: String?

    public var paymentType: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var smsQuota: Int32?

    public var taskQuota: Int32?

    public var usedQuota: DescribeDnsGtmInstanceResponseBody.UsedQuota?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.config?.validate()
        try self.usedQuota?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.expireTimestamp != nil {
            map["ExpireTimestamp"] = self.expireTimestamp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.smsQuota != nil {
            map["SmsQuota"] = self.smsQuota!
        }
        if self.taskQuota != nil {
            map["TaskQuota"] = self.taskQuota!
        }
        if self.usedQuota != nil {
            map["UsedQuota"] = self.usedQuota?.toMap()
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            var model = DescribeDnsGtmInstanceResponseBody.Config()
            model.fromMap(dict["Config"] as! [String: Any])
            self.config = model
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("ExpireTime") {
            self.expireTime = dict["ExpireTime"] as! String
        }
        if dict.keys.contains("ExpireTimestamp") {
            self.expireTimestamp = dict["ExpireTimestamp"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SmsQuota") {
            self.smsQuota = dict["SmsQuota"] as! Int32
        }
        if dict.keys.contains("TaskQuota") {
            self.taskQuota = dict["TaskQuota"] as! Int32
        }
        if dict.keys.contains("UsedQuota") {
            var model = DescribeDnsGtmInstanceResponseBody.UsedQuota()
            model.fromMap(dict["UsedQuota"] as! [String: Any])
            self.usedQuota = model
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
    }
}

public class DescribeDnsGtmInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolRequest : Tea.TeaModel {
    public var addrPoolId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolResponseBody : Tea.TeaModel {
    public class Addrs : Tea.TeaModel {
        public class Addr : Tea.TeaModel {
            public var addr: String?

            public var alertStatus: String?

            public var attributeInfo: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var lbaWeight: Int32?

            public var mode: String?

            public var remark: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addr != nil {
                    map["Addr"] = self.addr!
                }
                if self.alertStatus != nil {
                    map["AlertStatus"] = self.alertStatus!
                }
                if self.attributeInfo != nil {
                    map["AttributeInfo"] = self.attributeInfo!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.lbaWeight != nil {
                    map["LbaWeight"] = self.lbaWeight!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Addr") {
                    self.addr = dict["Addr"] as! String
                }
                if dict.keys.contains("AlertStatus") {
                    self.alertStatus = dict["AlertStatus"] as! String
                }
                if dict.keys.contains("AttributeInfo") {
                    self.attributeInfo = dict["AttributeInfo"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("LbaWeight") {
                    self.lbaWeight = dict["LbaWeight"] as! Int32
                }
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var addr: [DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs.Addr]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                var tmp : [Any] = []
                for k in self.addr! {
                    tmp.append(k.toMap())
                }
                map["Addr"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Addr") {
                self.addr = dict["Addr"] as! [DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs.Addr]
            }
        }
    }
    public var addrCount: Int32?

    public var addrPoolId: String?

    public var addrs: DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var lbaStrategy: String?

    public var monitorConfigId: String?

    public var monitorStatus: String?

    public var name: String?

    public var requestId: String?

    public var type: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrCount != nil {
            map["AddrCount"] = self.addrCount!
        }
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.addrs != nil {
            map["Addrs"] = self.addrs?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorStatus != nil {
            map["MonitorStatus"] = self.monitorStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrCount") {
            self.addrCount = dict["AddrCount"] as! Int32
        }
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Addrs") {
            var model = DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs()
            model.fromMap(dict["Addrs"] as! [String: Any])
            self.addrs = model
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("LbaStrategy") {
            self.lbaStrategy = dict["LbaStrategy"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("MonitorStatus") {
            self.monitorStatus = dict["MonitorStatus"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmInstanceAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolsResponseBody : Tea.TeaModel {
    public class AddrPools : Tea.TeaModel {
        public class AddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var addrPoolId: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var lbaStrategy: String?

            public var monitorConfigId: String?

            public var monitorStatus: String?

            public var name: String?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.addrPoolId != nil {
                    map["AddrPoolId"] = self.addrPoolId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.lbaStrategy != nil {
                    map["LbaStrategy"] = self.lbaStrategy!
                }
                if self.monitorConfigId != nil {
                    map["MonitorConfigId"] = self.monitorConfigId!
                }
                if self.monitorStatus != nil {
                    map["MonitorStatus"] = self.monitorStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("AddrPoolId") {
                    self.addrPoolId = dict["AddrPoolId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("LbaStrategy") {
                    self.lbaStrategy = dict["LbaStrategy"] as! String
                }
                if dict.keys.contains("MonitorConfigId") {
                    self.monitorConfigId = dict["MonitorConfigId"] as! String
                }
                if dict.keys.contains("MonitorStatus") {
                    self.monitorStatus = dict["MonitorStatus"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var addrPool: [DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addrPool != nil {
                var tmp : [Any] = []
                for k in self.addrPool! {
                    tmp.append(k.toMap())
                }
                map["AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddrPool") {
                self.addrPool = dict["AddrPool"] as! [DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool]
            }
        }
    }
    public var addrPools: DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPools != nil {
            map["AddrPools"] = self.addrPools?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPools") {
            var model = DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools()
            model.fromMap(dict["AddrPools"] as! [String: Any])
            self.addrPools = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceAddressPoolsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmInstanceAddressPoolsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceStatusRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmInstanceStatusResponseBody : Tea.TeaModel {
    public var addrAvailableNum: Int32?

    public var addrNotAvailableNum: Int32?

    public var addrPoolGroupNotAvailableNum: Int32?

    public var requestId: String?

    public var strategyNotAvailableNum: Int32?

    public var switchToFailoverStrategyNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrAvailableNum != nil {
            map["AddrAvailableNum"] = self.addrAvailableNum!
        }
        if self.addrNotAvailableNum != nil {
            map["AddrNotAvailableNum"] = self.addrNotAvailableNum!
        }
        if self.addrPoolGroupNotAvailableNum != nil {
            map["AddrPoolGroupNotAvailableNum"] = self.addrPoolGroupNotAvailableNum!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyNotAvailableNum != nil {
            map["StrategyNotAvailableNum"] = self.strategyNotAvailableNum!
        }
        if self.switchToFailoverStrategyNum != nil {
            map["SwitchToFailoverStrategyNum"] = self.switchToFailoverStrategyNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrAvailableNum") {
            self.addrAvailableNum = dict["AddrAvailableNum"] as! Int32
        }
        if dict.keys.contains("AddrNotAvailableNum") {
            self.addrNotAvailableNum = dict["AddrNotAvailableNum"] as! Int32
        }
        if dict.keys.contains("AddrPoolGroupNotAvailableNum") {
            self.addrPoolGroupNotAvailableNum = dict["AddrPoolGroupNotAvailableNum"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StrategyNotAvailableNum") {
            self.strategyNotAvailableNum = dict["StrategyNotAvailableNum"] as! Int32
        }
        if dict.keys.contains("SwitchToFailoverStrategyNum") {
            self.switchToFailoverStrategyNum = dict["SwitchToFailoverStrategyNum"] as! Int32
        }
    }
}

public class DescribeDnsGtmInstanceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmInstanceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceSystemCnameRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmInstanceSystemCnameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var systemCname: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemCname != nil {
            map["SystemCname"] = self.systemCname!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemCname") {
            self.systemCname = dict["SystemCname"] as! String
        }
    }
}

public class DescribeDnsGtmInstanceSystemCnameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceSystemCnameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmInstanceSystemCnameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstancesRequest : Tea.TeaModel {
    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeDnsGtmInstancesResponseBody : Tea.TeaModel {
    public class GtmInstances : Tea.TeaModel {
        public class Config : Tea.TeaModel {
            public class AlertConfig : Tea.TeaModel {
                public var dingtalkNotice: String?

                public var emailNotice: String?

                public var noticeType: String?

                public var smsNotice: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dingtalkNotice != nil {
                        map["DingtalkNotice"] = self.dingtalkNotice!
                    }
                    if self.emailNotice != nil {
                        map["EmailNotice"] = self.emailNotice!
                    }
                    if self.noticeType != nil {
                        map["NoticeType"] = self.noticeType!
                    }
                    if self.smsNotice != nil {
                        map["SmsNotice"] = self.smsNotice!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DingtalkNotice") {
                        self.dingtalkNotice = dict["DingtalkNotice"] as! String
                    }
                    if dict.keys.contains("EmailNotice") {
                        self.emailNotice = dict["EmailNotice"] as! String
                    }
                    if dict.keys.contains("NoticeType") {
                        self.noticeType = dict["NoticeType"] as! String
                    }
                    if dict.keys.contains("SmsNotice") {
                        self.smsNotice = dict["SmsNotice"] as! String
                    }
                }
            }
            public var alertConfig: [DescribeDnsGtmInstancesResponseBody.GtmInstances.Config.AlertConfig]?

            public var alertGroup: String?

            public var cnameType: String?

            public var instanceName: String?

            public var publicCnameMode: String?

            public var publicRr: String?

            public var publicUserDomainName: String?

            public var publicZoneName: String?

            public var strategyMode: String?

            public var ttl: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertConfig != nil {
                    var tmp : [Any] = []
                    for k in self.alertConfig! {
                        tmp.append(k.toMap())
                    }
                    map["AlertConfig"] = tmp
                }
                if self.alertGroup != nil {
                    map["AlertGroup"] = self.alertGroup!
                }
                if self.cnameType != nil {
                    map["CnameType"] = self.cnameType!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.publicCnameMode != nil {
                    map["PublicCnameMode"] = self.publicCnameMode!
                }
                if self.publicRr != nil {
                    map["PublicRr"] = self.publicRr!
                }
                if self.publicUserDomainName != nil {
                    map["PublicUserDomainName"] = self.publicUserDomainName!
                }
                if self.publicZoneName != nil {
                    map["PublicZoneName"] = self.publicZoneName!
                }
                if self.strategyMode != nil {
                    map["StrategyMode"] = self.strategyMode!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertConfig") {
                    self.alertConfig = dict["AlertConfig"] as! [DescribeDnsGtmInstancesResponseBody.GtmInstances.Config.AlertConfig]
                }
                if dict.keys.contains("AlertGroup") {
                    self.alertGroup = dict["AlertGroup"] as! String
                }
                if dict.keys.contains("CnameType") {
                    self.cnameType = dict["CnameType"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("PublicCnameMode") {
                    self.publicCnameMode = dict["PublicCnameMode"] as! String
                }
                if dict.keys.contains("PublicRr") {
                    self.publicRr = dict["PublicRr"] as! String
                }
                if dict.keys.contains("PublicUserDomainName") {
                    self.publicUserDomainName = dict["PublicUserDomainName"] as! String
                }
                if dict.keys.contains("PublicZoneName") {
                    self.publicZoneName = dict["PublicZoneName"] as! String
                }
                if dict.keys.contains("StrategyMode") {
                    self.strategyMode = dict["StrategyMode"] as! String
                }
                if dict.keys.contains("Ttl") {
                    self.ttl = dict["Ttl"] as! Int32
                }
            }
        }
        public class UsedQuota : Tea.TeaModel {
            public var dingtalkUsedCount: Int32?

            public var emailUsedCount: Int32?

            public var smsUsedCount: Int32?

            public var taskUsedCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dingtalkUsedCount != nil {
                    map["DingtalkUsedCount"] = self.dingtalkUsedCount!
                }
                if self.emailUsedCount != nil {
                    map["EmailUsedCount"] = self.emailUsedCount!
                }
                if self.smsUsedCount != nil {
                    map["SmsUsedCount"] = self.smsUsedCount!
                }
                if self.taskUsedCount != nil {
                    map["TaskUsedCount"] = self.taskUsedCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DingtalkUsedCount") {
                    self.dingtalkUsedCount = dict["DingtalkUsedCount"] as! Int32
                }
                if dict.keys.contains("EmailUsedCount") {
                    self.emailUsedCount = dict["EmailUsedCount"] as! Int32
                }
                if dict.keys.contains("SmsUsedCount") {
                    self.smsUsedCount = dict["SmsUsedCount"] as! Int32
                }
                if dict.keys.contains("TaskUsedCount") {
                    self.taskUsedCount = dict["TaskUsedCount"] as! Int32
                }
            }
        }
        public var config: DescribeDnsGtmInstancesResponseBody.GtmInstances.Config?

        public var createTime: String?

        public var createTimestamp: Int64?

        public var expireTime: String?

        public var expireTimestamp: Int64?

        public var instanceId: String?

        public var paymentType: String?

        public var resourceGroupId: String?

        public var smsQuota: Int32?

        public var taskQuota: Int32?

        public var usedQuota: DescribeDnsGtmInstancesResponseBody.GtmInstances.UsedQuota?

        public var versionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.config?.validate()
            try self.usedQuota?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.expireTimestamp != nil {
                map["ExpireTimestamp"] = self.expireTimestamp!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.paymentType != nil {
                map["PaymentType"] = self.paymentType!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.smsQuota != nil {
                map["SmsQuota"] = self.smsQuota!
            }
            if self.taskQuota != nil {
                map["TaskQuota"] = self.taskQuota!
            }
            if self.usedQuota != nil {
                map["UsedQuota"] = self.usedQuota?.toMap()
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") {
                var model = DescribeDnsGtmInstancesResponseBody.GtmInstances.Config()
                model.fromMap(dict["Config"] as! [String: Any])
                self.config = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("ExpireTimestamp") {
                self.expireTimestamp = dict["ExpireTimestamp"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("PaymentType") {
                self.paymentType = dict["PaymentType"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("SmsQuota") {
                self.smsQuota = dict["SmsQuota"] as! Int32
            }
            if dict.keys.contains("TaskQuota") {
                self.taskQuota = dict["TaskQuota"] as! Int32
            }
            if dict.keys.contains("UsedQuota") {
                var model = DescribeDnsGtmInstancesResponseBody.GtmInstances.UsedQuota()
                model.fromMap(dict["UsedQuota"] as! [String: Any])
                self.usedQuota = model
            }
            if dict.keys.contains("VersionCode") {
                self.versionCode = dict["VersionCode"] as! String
            }
        }
    }
    public var gtmInstances: [DescribeDnsGtmInstancesResponseBody.GtmInstances]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gtmInstances != nil {
            var tmp : [Any] = []
            for k in self.gtmInstances! {
                tmp.append(k.toMap())
            }
            map["GtmInstances"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GtmInstances") {
            self.gtmInstances = dict["GtmInstances"] as! [DescribeDnsGtmInstancesResponseBody.GtmInstances]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDnsGtmInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmLogsRequest : Tea.TeaModel {
    public var endTimestamp: Int64?

    public var instanceId: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimestamp != nil {
            map["StartTimestamp"] = self.startTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTimestamp") {
            self.endTimestamp = dict["EndTimestamp"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTimestamp") {
            self.startTimestamp = dict["StartTimestamp"] as! Int64
        }
    }
}

public class DescribeDnsGtmLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public class Log : Tea.TeaModel {
            public var content: String?

            public var entityId: String?

            public var entityName: String?

            public var entityType: String?

            public var id: Int64?

            public var operAction: String?

            public var operTime: String?

            public var operTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.entityId != nil {
                    map["EntityId"] = self.entityId!
                }
                if self.entityName != nil {
                    map["EntityName"] = self.entityName!
                }
                if self.entityType != nil {
                    map["EntityType"] = self.entityType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.operAction != nil {
                    map["OperAction"] = self.operAction!
                }
                if self.operTime != nil {
                    map["OperTime"] = self.operTime!
                }
                if self.operTimestamp != nil {
                    map["OperTimestamp"] = self.operTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("EntityId") {
                    self.entityId = dict["EntityId"] as! String
                }
                if dict.keys.contains("EntityName") {
                    self.entityName = dict["EntityName"] as! String
                }
                if dict.keys.contains("EntityType") {
                    self.entityType = dict["EntityType"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("OperAction") {
                    self.operAction = dict["OperAction"] as! String
                }
                if dict.keys.contains("OperTime") {
                    self.operTime = dict["OperTime"] as! String
                }
                if dict.keys.contains("OperTimestamp") {
                    self.operTimestamp = dict["OperTimestamp"] as! Int64
                }
            }
        }
        public var log: [DescribeDnsGtmLogsResponseBody.Logs.Log]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.log != nil {
                var tmp : [Any] = []
                for k in self.log! {
                    tmp.append(k.toMap())
                }
                map["Log"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Log") {
                self.log = dict["Log"] as! [DescribeDnsGtmLogsResponseBody.Logs.Log]
            }
        }
    }
    public var logs: DescribeDnsGtmLogsResponseBody.Logs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            map["Logs"] = self.logs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logs") {
            var model = DescribeDnsGtmLogsResponseBody.Logs()
            model.fromMap(dict["Logs"] as! [String: Any])
            self.logs = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDnsGtmLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmMonitorAvailableConfigRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmMonitorAvailableConfigResponseBody : Tea.TeaModel {
    public class DomainIpv4IspCityNodes : Tea.TeaModel {
        public class DomainIpv4IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! [String]
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("DefaultSelected") {
                    self.defaultSelected = dict["DefaultSelected"] as! Bool
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") {
                    self.groupType = dict["GroupType"] as! String
                }
                if dict.keys.contains("Ips") {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode.Ips()
                    model.fromMap(dict["Ips"] as! [String: Any])
                    self.ips = model
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
            }
        }
        public var domainIpv4IspCityNode: [DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainIpv4IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.domainIpv4IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["DomainIpv4IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainIpv4IspCityNode") {
                self.domainIpv4IspCityNode = dict["DomainIpv4IspCityNode"] as! [DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode]
            }
        }
    }
    public class DomainIpv6IspCityNodes : Tea.TeaModel {
        public class DomainIpv6IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ip") {
                        self.ip = dict["ip"] as! [String]
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("DefaultSelected") {
                    self.defaultSelected = dict["DefaultSelected"] as! Bool
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") {
                    self.groupType = dict["GroupType"] as! String
                }
                if dict.keys.contains("Ips") {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode.Ips()
                    model.fromMap(dict["Ips"] as! [String: Any])
                    self.ips = model
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
            }
        }
        public var domainIpv6IspCityNode: [DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainIpv6IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.domainIpv6IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["DomainIpv6IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainIpv6IspCityNode") {
                self.domainIpv6IspCityNode = dict["DomainIpv6IspCityNode"] as! [DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode]
            }
        }
    }
    public class Ipv4IspCityNodes : Tea.TeaModel {
        public class Ipv4IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! [String]
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("DefaultSelected") {
                    self.defaultSelected = dict["DefaultSelected"] as! Bool
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") {
                    self.groupType = dict["GroupType"] as! String
                }
                if dict.keys.contains("Ips") {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode.Ips()
                    model.fromMap(dict["Ips"] as! [String: Any])
                    self.ips = model
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
            }
        }
        public var ipv4IspCityNode: [DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.ipv4IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["Ipv4IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv4IspCityNode") {
                self.ipv4IspCityNode = dict["Ipv4IspCityNode"] as! [DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode]
            }
        }
    }
    public class Ipv6IspCityNodes : Tea.TeaModel {
        public class Ipv6IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! [String]
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("DefaultSelected") {
                    self.defaultSelected = dict["DefaultSelected"] as! Bool
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") {
                    self.groupType = dict["GroupType"] as! String
                }
                if dict.keys.contains("Ips") {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode.Ips()
                    model.fromMap(dict["Ips"] as! [String: Any])
                    self.ips = model
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
            }
        }
        public var ipv6IspCityNode: [DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.ipv6IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["Ipv6IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6IspCityNode") {
                self.ipv6IspCityNode = dict["Ipv6IspCityNode"] as! [DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode]
            }
        }
    }
    public var domainIpv4IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes?

    public var domainIpv6IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes?

    public var ipv4IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes?

    public var ipv6IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainIpv4IspCityNodes?.validate()
        try self.domainIpv6IspCityNodes?.validate()
        try self.ipv4IspCityNodes?.validate()
        try self.ipv6IspCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainIpv4IspCityNodes != nil {
            map["DomainIpv4IspCityNodes"] = self.domainIpv4IspCityNodes?.toMap()
        }
        if self.domainIpv6IspCityNodes != nil {
            map["DomainIpv6IspCityNodes"] = self.domainIpv6IspCityNodes?.toMap()
        }
        if self.ipv4IspCityNodes != nil {
            map["Ipv4IspCityNodes"] = self.ipv4IspCityNodes?.toMap()
        }
        if self.ipv6IspCityNodes != nil {
            map["Ipv6IspCityNodes"] = self.ipv6IspCityNodes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainIpv4IspCityNodes") {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes()
            model.fromMap(dict["DomainIpv4IspCityNodes"] as! [String: Any])
            self.domainIpv4IspCityNodes = model
        }
        if dict.keys.contains("DomainIpv6IspCityNodes") {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes()
            model.fromMap(dict["DomainIpv6IspCityNodes"] as! [String: Any])
            self.domainIpv6IspCityNodes = model
        }
        if dict.keys.contains("Ipv4IspCityNodes") {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes()
            model.fromMap(dict["Ipv4IspCityNodes"] as! [String: Any])
            self.ipv4IspCityNodes = model
        }
        if dict.keys.contains("Ipv6IspCityNodes") {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes()
            model.fromMap(dict["Ipv6IspCityNodes"] as! [String: Any])
            self.ipv6IspCityNodes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDnsGtmMonitorAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmMonitorAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmMonitorConfigRequest : Tea.TeaModel {
    public var lang: String?

    public var monitorConfigId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
    }
}

public class DescribeDnsGtmMonitorConfigResponseBody : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public class IspCityNode : Tea.TeaModel {
            public var cityCode: String?

            public var cityName: String?

            public var countryCode: String?

            public var countryName: String?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.countryCode != nil {
                    map["CountryCode"] = self.countryCode!
                }
                if self.countryName != nil {
                    map["CountryName"] = self.countryName!
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("CountryCode") {
                    self.countryCode = dict["CountryCode"] as! String
                }
                if dict.keys.contains("CountryName") {
                    self.countryName = dict["CountryName"] as! String
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
            }
        }
        public var ispCityNode: [DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ispCityNode != nil {
                var tmp : [Any] = []
                for k in self.ispCityNode! {
                    tmp.append(k.toMap())
                }
                map["IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IspCityNode") {
                self.ispCityNode = dict["IspCityNode"] as! [DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode]
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNodes: DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes?

    public var monitorConfigId: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var requestId: String?

    public var timeout: Int32?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ispCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNodes != nil {
            map["IspCityNodes"] = self.ispCityNodes?.toMap()
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNodes") {
            var model = DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes()
            model.fromMap(dict["IspCityNodes"] as! [String: Any])
            self.ispCityNodes = model
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
    }
}

public class DescribeDnsGtmMonitorConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmMonitorConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmMonitorConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsProductInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DescribeDnsProductInstanceResponseBody : Tea.TeaModel {
    public class DnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServer") {
                self.dnsServer = dict["DnsServer"] as! [String]
            }
        }
    }
    public var bindCount: Int64?

    public var bindDomainCount: Int64?

    public var bindDomainUsedCount: Int64?

    public var bindUsedCount: Int64?

    public var DDosDefendFlow: Int64?

    public var DDosDefendQuery: Int64?

    public var dnsSLBCount: Int64?

    public var dnsSecurity: String?

    public var dnsServers: DescribeDnsProductInstanceResponseBody.DnsServers?

    public var domain: String?

    public var domainType: String?

    public var endTime: String?

    public var endTimestamp: Int64?

    public var gslb: Bool?

    public var ISPLines: String?

    public var ISPRegionLines: String?

    public var inBlackHole: Bool?

    public var inClean: Bool?

    public var instanceId: String?

    public var monitorFrequency: Int64?

    public var monitorNodeCount: Int64?

    public var monitorTaskCount: Int64?

    public var overseaDDosDefendFlow: Int64?

    public var overseaLine: String?

    public var paymentType: String?

    public var regionLines: Bool?

    public var requestId: String?

    public var searchEngineLines: String?

    public var startTime: String?

    public var startTimestamp: Int64?

    public var subDomainLevel: Int64?

    public var TTLMinValue: Int64?

    public var URLForwardCount: Int64?

    public var versionCode: String?

    public var versionName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dnsServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bindCount != nil {
            map["BindCount"] = self.bindCount!
        }
        if self.bindDomainCount != nil {
            map["BindDomainCount"] = self.bindDomainCount!
        }
        if self.bindDomainUsedCount != nil {
            map["BindDomainUsedCount"] = self.bindDomainUsedCount!
        }
        if self.bindUsedCount != nil {
            map["BindUsedCount"] = self.bindUsedCount!
        }
        if self.DDosDefendFlow != nil {
            map["DDosDefendFlow"] = self.DDosDefendFlow!
        }
        if self.DDosDefendQuery != nil {
            map["DDosDefendQuery"] = self.DDosDefendQuery!
        }
        if self.dnsSLBCount != nil {
            map["DnsSLBCount"] = self.dnsSLBCount!
        }
        if self.dnsSecurity != nil {
            map["DnsSecurity"] = self.dnsSecurity!
        }
        if self.dnsServers != nil {
            map["DnsServers"] = self.dnsServers?.toMap()
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.gslb != nil {
            map["Gslb"] = self.gslb!
        }
        if self.ISPLines != nil {
            map["ISPLines"] = self.ISPLines!
        }
        if self.ISPRegionLines != nil {
            map["ISPRegionLines"] = self.ISPRegionLines!
        }
        if self.inBlackHole != nil {
            map["InBlackHole"] = self.inBlackHole!
        }
        if self.inClean != nil {
            map["InClean"] = self.inClean!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.monitorFrequency != nil {
            map["MonitorFrequency"] = self.monitorFrequency!
        }
        if self.monitorNodeCount != nil {
            map["MonitorNodeCount"] = self.monitorNodeCount!
        }
        if self.monitorTaskCount != nil {
            map["MonitorTaskCount"] = self.monitorTaskCount!
        }
        if self.overseaDDosDefendFlow != nil {
            map["OverseaDDosDefendFlow"] = self.overseaDDosDefendFlow!
        }
        if self.overseaLine != nil {
            map["OverseaLine"] = self.overseaLine!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.regionLines != nil {
            map["RegionLines"] = self.regionLines!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchEngineLines != nil {
            map["SearchEngineLines"] = self.searchEngineLines!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.startTimestamp != nil {
            map["StartTimestamp"] = self.startTimestamp!
        }
        if self.subDomainLevel != nil {
            map["SubDomainLevel"] = self.subDomainLevel!
        }
        if self.TTLMinValue != nil {
            map["TTLMinValue"] = self.TTLMinValue!
        }
        if self.URLForwardCount != nil {
            map["URLForwardCount"] = self.URLForwardCount!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        if self.versionName != nil {
            map["VersionName"] = self.versionName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BindCount") {
            self.bindCount = dict["BindCount"] as! Int64
        }
        if dict.keys.contains("BindDomainCount") {
            self.bindDomainCount = dict["BindDomainCount"] as! Int64
        }
        if dict.keys.contains("BindDomainUsedCount") {
            self.bindDomainUsedCount = dict["BindDomainUsedCount"] as! Int64
        }
        if dict.keys.contains("BindUsedCount") {
            self.bindUsedCount = dict["BindUsedCount"] as! Int64
        }
        if dict.keys.contains("DDosDefendFlow") {
            self.DDosDefendFlow = dict["DDosDefendFlow"] as! Int64
        }
        if dict.keys.contains("DDosDefendQuery") {
            self.DDosDefendQuery = dict["DDosDefendQuery"] as! Int64
        }
        if dict.keys.contains("DnsSLBCount") {
            self.dnsSLBCount = dict["DnsSLBCount"] as! Int64
        }
        if dict.keys.contains("DnsSecurity") {
            self.dnsSecurity = dict["DnsSecurity"] as! String
        }
        if dict.keys.contains("DnsServers") {
            var model = DescribeDnsProductInstanceResponseBody.DnsServers()
            model.fromMap(dict["DnsServers"] as! [String: Any])
            self.dnsServers = model
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("DomainType") {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EndTimestamp") {
            self.endTimestamp = dict["EndTimestamp"] as! Int64
        }
        if dict.keys.contains("Gslb") {
            self.gslb = dict["Gslb"] as! Bool
        }
        if dict.keys.contains("ISPLines") {
            self.ISPLines = dict["ISPLines"] as! String
        }
        if dict.keys.contains("ISPRegionLines") {
            self.ISPRegionLines = dict["ISPRegionLines"] as! String
        }
        if dict.keys.contains("InBlackHole") {
            self.inBlackHole = dict["InBlackHole"] as! Bool
        }
        if dict.keys.contains("InClean") {
            self.inClean = dict["InClean"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MonitorFrequency") {
            self.monitorFrequency = dict["MonitorFrequency"] as! Int64
        }
        if dict.keys.contains("MonitorNodeCount") {
            self.monitorNodeCount = dict["MonitorNodeCount"] as! Int64
        }
        if dict.keys.contains("MonitorTaskCount") {
            self.monitorTaskCount = dict["MonitorTaskCount"] as! Int64
        }
        if dict.keys.contains("OverseaDDosDefendFlow") {
            self.overseaDDosDefendFlow = dict["OverseaDDosDefendFlow"] as! Int64
        }
        if dict.keys.contains("OverseaLine") {
            self.overseaLine = dict["OverseaLine"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("RegionLines") {
            self.regionLines = dict["RegionLines"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchEngineLines") {
            self.searchEngineLines = dict["SearchEngineLines"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StartTimestamp") {
            self.startTimestamp = dict["StartTimestamp"] as! Int64
        }
        if dict.keys.contains("SubDomainLevel") {
            self.subDomainLevel = dict["SubDomainLevel"] as! Int64
        }
        if dict.keys.contains("TTLMinValue") {
            self.TTLMinValue = dict["TTLMinValue"] as! Int64
        }
        if dict.keys.contains("URLForwardCount") {
            self.URLForwardCount = dict["URLForwardCount"] as! Int64
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
        if dict.keys.contains("VersionName") {
            self.versionName = dict["VersionName"] as! String
        }
    }
}

public class DescribeDnsProductInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsProductInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsProductInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsProductInstancesRequest : Tea.TeaModel {
    public var domainType: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var userClientIp: String?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainType") {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
    }
}

public class DescribeDnsProductInstancesResponseBody : Tea.TeaModel {
    public class DnsProducts : Tea.TeaModel {
        public class DnsProduct : Tea.TeaModel {
            public var bindCount: Int64?

            public var bindDomainCount: Int64?

            public var bindDomainUsedCount: Int64?

            public var bindUsedCount: Int64?

            public var DDosDefendFlow: Int64?

            public var DDosDefendQuery: Int64?

            public var dnsSLBCount: Int64?

            public var dnsSecurity: String?

            public var domain: String?

            public var endTime: String?

            public var endTimestamp: Int64?

            public var gslb: Bool?

            public var ISPLines: String?

            public var ISPRegionLines: String?

            public var inBlackHole: Bool?

            public var inClean: Bool?

            public var instanceId: String?

            public var monitorFrequency: Int64?

            public var monitorNodeCount: Int64?

            public var monitorTaskCount: Int64?

            public var overseaDDosDefendFlow: Int64?

            public var overseaLine: String?

            public var paymentType: String?

            public var regionLines: Bool?

            public var searchEngineLines: String?

            public var startTime: String?

            public var startTimestamp: Int64?

            public var subDomainLevel: Int64?

            public var TTLMinValue: Int64?

            public var URLForwardCount: Int64?

            public var versionCode: String?

            public var versionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindCount != nil {
                    map["BindCount"] = self.bindCount!
                }
                if self.bindDomainCount != nil {
                    map["BindDomainCount"] = self.bindDomainCount!
                }
                if self.bindDomainUsedCount != nil {
                    map["BindDomainUsedCount"] = self.bindDomainUsedCount!
                }
                if self.bindUsedCount != nil {
                    map["BindUsedCount"] = self.bindUsedCount!
                }
                if self.DDosDefendFlow != nil {
                    map["DDosDefendFlow"] = self.DDosDefendFlow!
                }
                if self.DDosDefendQuery != nil {
                    map["DDosDefendQuery"] = self.DDosDefendQuery!
                }
                if self.dnsSLBCount != nil {
                    map["DnsSLBCount"] = self.dnsSLBCount!
                }
                if self.dnsSecurity != nil {
                    map["DnsSecurity"] = self.dnsSecurity!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.endTimestamp != nil {
                    map["EndTimestamp"] = self.endTimestamp!
                }
                if self.gslb != nil {
                    map["Gslb"] = self.gslb!
                }
                if self.ISPLines != nil {
                    map["ISPLines"] = self.ISPLines!
                }
                if self.ISPRegionLines != nil {
                    map["ISPRegionLines"] = self.ISPRegionLines!
                }
                if self.inBlackHole != nil {
                    map["InBlackHole"] = self.inBlackHole!
                }
                if self.inClean != nil {
                    map["InClean"] = self.inClean!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.monitorFrequency != nil {
                    map["MonitorFrequency"] = self.monitorFrequency!
                }
                if self.monitorNodeCount != nil {
                    map["MonitorNodeCount"] = self.monitorNodeCount!
                }
                if self.monitorTaskCount != nil {
                    map["MonitorTaskCount"] = self.monitorTaskCount!
                }
                if self.overseaDDosDefendFlow != nil {
                    map["OverseaDDosDefendFlow"] = self.overseaDDosDefendFlow!
                }
                if self.overseaLine != nil {
                    map["OverseaLine"] = self.overseaLine!
                }
                if self.paymentType != nil {
                    map["PaymentType"] = self.paymentType!
                }
                if self.regionLines != nil {
                    map["RegionLines"] = self.regionLines!
                }
                if self.searchEngineLines != nil {
                    map["SearchEngineLines"] = self.searchEngineLines!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.startTimestamp != nil {
                    map["StartTimestamp"] = self.startTimestamp!
                }
                if self.subDomainLevel != nil {
                    map["SubDomainLevel"] = self.subDomainLevel!
                }
                if self.TTLMinValue != nil {
                    map["TTLMinValue"] = self.TTLMinValue!
                }
                if self.URLForwardCount != nil {
                    map["URLForwardCount"] = self.URLForwardCount!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                if self.versionName != nil {
                    map["VersionName"] = self.versionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BindCount") {
                    self.bindCount = dict["BindCount"] as! Int64
                }
                if dict.keys.contains("BindDomainCount") {
                    self.bindDomainCount = dict["BindDomainCount"] as! Int64
                }
                if dict.keys.contains("BindDomainUsedCount") {
                    self.bindDomainUsedCount = dict["BindDomainUsedCount"] as! Int64
                }
                if dict.keys.contains("BindUsedCount") {
                    self.bindUsedCount = dict["BindUsedCount"] as! Int64
                }
                if dict.keys.contains("DDosDefendFlow") {
                    self.DDosDefendFlow = dict["DDosDefendFlow"] as! Int64
                }
                if dict.keys.contains("DDosDefendQuery") {
                    self.DDosDefendQuery = dict["DDosDefendQuery"] as! Int64
                }
                if dict.keys.contains("DnsSLBCount") {
                    self.dnsSLBCount = dict["DnsSLBCount"] as! Int64
                }
                if dict.keys.contains("DnsSecurity") {
                    self.dnsSecurity = dict["DnsSecurity"] as! String
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("EndTimestamp") {
                    self.endTimestamp = dict["EndTimestamp"] as! Int64
                }
                if dict.keys.contains("Gslb") {
                    self.gslb = dict["Gslb"] as! Bool
                }
                if dict.keys.contains("ISPLines") {
                    self.ISPLines = dict["ISPLines"] as! String
                }
                if dict.keys.contains("ISPRegionLines") {
                    self.ISPRegionLines = dict["ISPRegionLines"] as! String
                }
                if dict.keys.contains("InBlackHole") {
                    self.inBlackHole = dict["InBlackHole"] as! Bool
                }
                if dict.keys.contains("InClean") {
                    self.inClean = dict["InClean"] as! Bool
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("MonitorFrequency") {
                    self.monitorFrequency = dict["MonitorFrequency"] as! Int64
                }
                if dict.keys.contains("MonitorNodeCount") {
                    self.monitorNodeCount = dict["MonitorNodeCount"] as! Int64
                }
                if dict.keys.contains("MonitorTaskCount") {
                    self.monitorTaskCount = dict["MonitorTaskCount"] as! Int64
                }
                if dict.keys.contains("OverseaDDosDefendFlow") {
                    self.overseaDDosDefendFlow = dict["OverseaDDosDefendFlow"] as! Int64
                }
                if dict.keys.contains("OverseaLine") {
                    self.overseaLine = dict["OverseaLine"] as! String
                }
                if dict.keys.contains("PaymentType") {
                    self.paymentType = dict["PaymentType"] as! String
                }
                if dict.keys.contains("RegionLines") {
                    self.regionLines = dict["RegionLines"] as! Bool
                }
                if dict.keys.contains("SearchEngineLines") {
                    self.searchEngineLines = dict["SearchEngineLines"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("StartTimestamp") {
                    self.startTimestamp = dict["StartTimestamp"] as! Int64
                }
                if dict.keys.contains("SubDomainLevel") {
                    self.subDomainLevel = dict["SubDomainLevel"] as! Int64
                }
                if dict.keys.contains("TTLMinValue") {
                    self.TTLMinValue = dict["TTLMinValue"] as! Int64
                }
                if dict.keys.contains("URLForwardCount") {
                    self.URLForwardCount = dict["URLForwardCount"] as! Int64
                }
                if dict.keys.contains("VersionCode") {
                    self.versionCode = dict["VersionCode"] as! String
                }
                if dict.keys.contains("VersionName") {
                    self.versionName = dict["VersionName"] as! String
                }
            }
        }
        public var dnsProduct: [DescribeDnsProductInstancesResponseBody.DnsProducts.DnsProduct]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsProduct != nil {
                var tmp : [Any] = []
                for k in self.dnsProduct! {
                    tmp.append(k.toMap())
                }
                map["DnsProduct"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsProduct") {
                self.dnsProduct = dict["DnsProduct"] as! [DescribeDnsProductInstancesResponseBody.DnsProducts.DnsProduct]
            }
        }
    }
    public var dnsProducts: DescribeDnsProductInstancesResponseBody.DnsProducts?

    public var domainType: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dnsProducts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dnsProducts != nil {
            map["DnsProducts"] = self.dnsProducts?.toMap()
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DnsProducts") {
            var model = DescribeDnsProductInstancesResponseBody.DnsProducts()
            model.fromMap(dict["DnsProducts"] as! [String: Any])
            self.dnsProducts = model
        }
        if dict.keys.contains("DomainType") {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDnsProductInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsProductInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsProductInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDohAccountStatisticsRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeDohAccountStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var timestamp: Int64?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var statistics: [DescribeDohAccountStatisticsResponseBody.Statistics]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            self.statistics = dict["Statistics"] as! [DescribeDohAccountStatisticsResponseBody.Statistics]
        }
    }
}

public class DescribeDohAccountStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohAccountStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDohAccountStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDohDomainStatisticsRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeDohDomainStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var timestamp: Int64?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var statistics: [DescribeDohDomainStatisticsResponseBody.Statistics]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            self.statistics = dict["Statistics"] as! [DescribeDohDomainStatisticsResponseBody.Statistics]
        }
    }
}

public class DescribeDohDomainStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohDomainStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDohDomainStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDohDomainStatisticsSummaryRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeDohDomainStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var domainName: String?

        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var ipCount: Int64?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("HttpCount") {
                self.httpCount = dict["HttpCount"] as! Int64
            }
            if dict.keys.contains("HttpsCount") {
                self.httpsCount = dict["HttpsCount"] as! Int64
            }
            if dict.keys.contains("IpCount") {
                self.ipCount = dict["IpCount"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: [DescribeDohDomainStatisticsSummaryResponseBody.Statistics]?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            self.statistics = dict["Statistics"] as! [DescribeDohDomainStatisticsSummaryResponseBody.Statistics]
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDohDomainStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohDomainStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDohDomainStatisticsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDohSubDomainStatisticsRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
    }
}

public class DescribeDohSubDomainStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var timestamp: Int64?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var statistics: [DescribeDohSubDomainStatisticsResponseBody.Statistics]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            self.statistics = dict["Statistics"] as! [DescribeDohSubDomainStatisticsResponseBody.Statistics]
        }
    }
}

public class DescribeDohSubDomainStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohSubDomainStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDohSubDomainStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDohSubDomainStatisticsSummaryRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startDate: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
    }
}

public class DescribeDohSubDomainStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var ipCount: Int64?

        public var subDomain: String?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HttpCount") {
                self.httpCount = dict["HttpCount"] as! Int64
            }
            if dict.keys.contains("HttpsCount") {
                self.httpsCount = dict["HttpsCount"] as! Int64
            }
            if dict.keys.contains("IpCount") {
                self.ipCount = dict["IpCount"] as! Int64
            }
            if dict.keys.contains("SubDomain") {
                self.subDomain = dict["SubDomain"] as! String
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: [DescribeDohSubDomainStatisticsSummaryResponseBody.Statistics]?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            self.statistics = dict["Statistics"] as! [DescribeDohSubDomainStatisticsSummaryResponseBody.Statistics]
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDohSubDomainStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohSubDomainStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDohSubDomainStatisticsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDohUserInfoRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeDohUserInfoResponseBody : Tea.TeaModel {
    public var domainCount: Int32?

    public var pdnsId: Int64?

    public var requestId: String?

    public var subDomainCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainCount != nil {
            map["DomainCount"] = self.domainCount!
        }
        if self.pdnsId != nil {
            map["PdnsId"] = self.pdnsId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subDomainCount != nil {
            map["SubDomainCount"] = self.subDomainCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainCount") {
            self.domainCount = dict["DomainCount"] as! Int32
        }
        if dict.keys.contains("PdnsId") {
            self.pdnsId = dict["PdnsId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubDomainCount") {
            self.subDomainCount = dict["SubDomainCount"] as! Int32
        }
    }
}

public class DescribeDohUserInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohUserInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDohUserInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainDnssecInfoRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDomainDnssecInfoResponseBody : Tea.TeaModel {
    public var algorithm: String?

    public var digest: String?

    public var digestType: String?

    public var domainName: String?

    public var dsRecord: String?

    public var flags: String?

    public var keyTag: String?

    public var publicKey: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithm != nil {
            map["Algorithm"] = self.algorithm!
        }
        if self.digest != nil {
            map["Digest"] = self.digest!
        }
        if self.digestType != nil {
            map["DigestType"] = self.digestType!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.dsRecord != nil {
            map["DsRecord"] = self.dsRecord!
        }
        if self.flags != nil {
            map["Flags"] = self.flags!
        }
        if self.keyTag != nil {
            map["KeyTag"] = self.keyTag!
        }
        if self.publicKey != nil {
            map["PublicKey"] = self.publicKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Algorithm") {
            self.algorithm = dict["Algorithm"] as! String
        }
        if dict.keys.contains("Digest") {
            self.digest = dict["Digest"] as! String
        }
        if dict.keys.contains("DigestType") {
            self.digestType = dict["DigestType"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DsRecord") {
            self.dsRecord = dict["DsRecord"] as! String
        }
        if dict.keys.contains("Flags") {
            self.flags = dict["Flags"] as! String
        }
        if dict.keys.contains("KeyTag") {
            self.keyTag = dict["KeyTag"] as! String
        }
        if dict.keys.contains("PublicKey") {
            self.publicKey = dict["PublicKey"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeDomainDnssecInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainDnssecInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainDnssecInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainGroupsRequest : Tea.TeaModel {
    public var keyWord: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribeDomainGroupsResponseBody : Tea.TeaModel {
    public class DomainGroups : Tea.TeaModel {
        public class DomainGroup : Tea.TeaModel {
            public var domainCount: Int64?

            public var groupId: String?

            public var groupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainCount != nil {
                    map["DomainCount"] = self.domainCount!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainCount") {
                    self.domainCount = dict["DomainCount"] as! Int64
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
            }
        }
        public var domainGroup: [DescribeDomainGroupsResponseBody.DomainGroups.DomainGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainGroup != nil {
                var tmp : [Any] = []
                for k in self.domainGroup! {
                    tmp.append(k.toMap())
                }
                map["DomainGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainGroup") {
                self.domainGroup = dict["DomainGroup"] as! [DescribeDomainGroupsResponseBody.DomainGroups.DomainGroup]
            }
        }
    }
    public var domainGroups: DescribeDomainGroupsResponseBody.DomainGroups?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainGroups != nil {
            map["DomainGroups"] = self.domainGroups?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainGroups") {
            var model = DescribeDomainGroupsResponseBody.DomainGroups()
            model.fromMap(dict["DomainGroups"] as! [String: Any])
            self.domainGroups = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDomainGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainInfoRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var needDetailAttributes: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.needDetailAttributes != nil {
            map["NeedDetailAttributes"] = self.needDetailAttributes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NeedDetailAttributes") {
            self.needDetailAttributes = dict["NeedDetailAttributes"] as! Bool
        }
    }
}

public class DescribeDomainInfoResponseBody : Tea.TeaModel {
    public class AvailableTtls : Tea.TeaModel {
        public var availableTtl: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableTtl != nil {
                map["AvailableTtl"] = self.availableTtl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableTtl") {
                self.availableTtl = dict["AvailableTtl"] as! [String]
            }
        }
    }
    public class DnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServer") {
                self.dnsServer = dict["DnsServer"] as! [String]
            }
        }
    }
    public class RecordLines : Tea.TeaModel {
        public class RecordLine : Tea.TeaModel {
            public var fatherCode: String?

            public var lineCode: String?

            public var lineDisplayName: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineDisplayName != nil {
                    map["LineDisplayName"] = self.lineDisplayName!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FatherCode") {
                    self.fatherCode = dict["FatherCode"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineDisplayName") {
                    self.lineDisplayName = dict["LineDisplayName"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
            }
        }
        public var recordLine: [DescribeDomainInfoResponseBody.RecordLines.RecordLine]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordLine != nil {
                var tmp : [Any] = []
                for k in self.recordLine! {
                    tmp.append(k.toMap())
                }
                map["RecordLine"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecordLine") {
                self.recordLine = dict["RecordLine"] as! [DescribeDomainInfoResponseBody.RecordLines.RecordLine]
            }
        }
    }
    public var aliDomain: Bool?

    public var availableTtls: DescribeDomainInfoResponseBody.AvailableTtls?

    public var createTime: String?

    public var dnsServers: DescribeDomainInfoResponseBody.DnsServers?

    public var domainId: String?

    public var domainName: String?

    public var groupId: String?

    public var groupName: String?

    public var inBlackHole: Bool?

    public var inClean: Bool?

    public var instanceId: String?

    public var lineType: String?

    public var minTtl: Int64?

    public var punyCode: String?

    public var recordLineTreeJson: String?

    public var recordLines: DescribeDomainInfoResponseBody.RecordLines?

    public var regionLines: Bool?

    public var remark: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var slaveDns: Bool?

    public var versionCode: String?

    public var versionName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.availableTtls?.validate()
        try self.dnsServers?.validate()
        try self.recordLines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliDomain != nil {
            map["AliDomain"] = self.aliDomain!
        }
        if self.availableTtls != nil {
            map["AvailableTtls"] = self.availableTtls?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.dnsServers != nil {
            map["DnsServers"] = self.dnsServers?.toMap()
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.inBlackHole != nil {
            map["InBlackHole"] = self.inBlackHole!
        }
        if self.inClean != nil {
            map["InClean"] = self.inClean!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lineType != nil {
            map["LineType"] = self.lineType!
        }
        if self.minTtl != nil {
            map["MinTtl"] = self.minTtl!
        }
        if self.punyCode != nil {
            map["PunyCode"] = self.punyCode!
        }
        if self.recordLineTreeJson != nil {
            map["RecordLineTreeJson"] = self.recordLineTreeJson!
        }
        if self.recordLines != nil {
            map["RecordLines"] = self.recordLines?.toMap()
        }
        if self.regionLines != nil {
            map["RegionLines"] = self.regionLines!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.slaveDns != nil {
            map["SlaveDns"] = self.slaveDns!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        if self.versionName != nil {
            map["VersionName"] = self.versionName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliDomain") {
            self.aliDomain = dict["AliDomain"] as! Bool
        }
        if dict.keys.contains("AvailableTtls") {
            var model = DescribeDomainInfoResponseBody.AvailableTtls()
            model.fromMap(dict["AvailableTtls"] as! [String: Any])
            self.availableTtls = model
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("DnsServers") {
            var model = DescribeDomainInfoResponseBody.DnsServers()
            model.fromMap(dict["DnsServers"] as! [String: Any])
            self.dnsServers = model
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InBlackHole") {
            self.inBlackHole = dict["InBlackHole"] as! Bool
        }
        if dict.keys.contains("InClean") {
            self.inClean = dict["InClean"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LineType") {
            self.lineType = dict["LineType"] as! String
        }
        if dict.keys.contains("MinTtl") {
            self.minTtl = dict["MinTtl"] as! Int64
        }
        if dict.keys.contains("PunyCode") {
            self.punyCode = dict["PunyCode"] as! String
        }
        if dict.keys.contains("RecordLineTreeJson") {
            self.recordLineTreeJson = dict["RecordLineTreeJson"] as! String
        }
        if dict.keys.contains("RecordLines") {
            var model = DescribeDomainInfoResponseBody.RecordLines()
            model.fromMap(dict["RecordLines"] as! [String: Any])
            self.recordLines = model
        }
        if dict.keys.contains("RegionLines") {
            self.regionLines = dict["RegionLines"] as! Bool
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SlaveDns") {
            self.slaveDns = dict["SlaveDns"] as! Bool
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
        if dict.keys.contains("VersionName") {
            self.versionName = dict["VersionName"] as! String
        }
    }
}

public class DescribeDomainInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainLogsRequest : Tea.TeaModel {
    public var groupId: String?

    public var keyWord: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var type: String?

    public var endDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.endDate != nil {
            map["endDate"] = self.endDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("endDate") {
            self.endDate = dict["endDate"] as! String
        }
    }
}

public class DescribeDomainLogsResponseBody : Tea.TeaModel {
    public class DomainLogs : Tea.TeaModel {
        public class DomainLog : Tea.TeaModel {
            public var action: String?

            public var actionTime: String?

            public var actionTimestamp: Int64?

            public var clientIp: String?

            public var domainName: String?

            public var message: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.actionTime != nil {
                    map["ActionTime"] = self.actionTime!
                }
                if self.actionTimestamp != nil {
                    map["ActionTimestamp"] = self.actionTimestamp!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ActionTime") {
                    self.actionTime = dict["ActionTime"] as! String
                }
                if dict.keys.contains("ActionTimestamp") {
                    self.actionTimestamp = dict["ActionTimestamp"] as! Int64
                }
                if dict.keys.contains("ClientIp") {
                    self.clientIp = dict["ClientIp"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var domainLog: [DescribeDomainLogsResponseBody.DomainLogs.DomainLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainLog != nil {
                var tmp : [Any] = []
                for k in self.domainLog! {
                    tmp.append(k.toMap())
                }
                map["DomainLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainLog") {
                self.domainLog = dict["DomainLog"] as! [DescribeDomainLogsResponseBody.DomainLogs.DomainLog]
            }
        }
    }
    public var domainLogs: DescribeDomainLogsResponseBody.DomainLogs?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainLogs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLogs != nil {
            map["DomainLogs"] = self.domainLogs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainLogs") {
            var model = DescribeDomainLogsResponseBody.DomainLogs()
            model.fromMap(dict["DomainLogs"] as! [String: Any])
            self.domainLogs = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDomainLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainNsRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDomainNsResponseBody : Tea.TeaModel {
    public class DnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServer") {
                self.dnsServer = dict["DnsServer"] as! [String]
            }
        }
    }
    public class ExpectDnsServers : Tea.TeaModel {
        public var expectDnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expectDnsServer != nil {
                map["ExpectDnsServer"] = self.expectDnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExpectDnsServer") {
                self.expectDnsServer = dict["ExpectDnsServer"] as! [String]
            }
        }
    }
    public var allAliDns: Bool?

    public var dnsServers: DescribeDomainNsResponseBody.DnsServers?

    public var expectDnsServers: DescribeDomainNsResponseBody.ExpectDnsServers?

    public var includeAliDns: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dnsServers?.validate()
        try self.expectDnsServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allAliDns != nil {
            map["AllAliDns"] = self.allAliDns!
        }
        if self.dnsServers != nil {
            map["DnsServers"] = self.dnsServers?.toMap()
        }
        if self.expectDnsServers != nil {
            map["ExpectDnsServers"] = self.expectDnsServers?.toMap()
        }
        if self.includeAliDns != nil {
            map["IncludeAliDns"] = self.includeAliDns!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllAliDns") {
            self.allAliDns = dict["AllAliDns"] as! Bool
        }
        if dict.keys.contains("DnsServers") {
            var model = DescribeDomainNsResponseBody.DnsServers()
            model.fromMap(dict["DnsServers"] as! [String: Any])
            self.dnsServers = model
        }
        if dict.keys.contains("ExpectDnsServers") {
            var model = DescribeDomainNsResponseBody.ExpectDnsServers()
            model.fromMap(dict["ExpectDnsServers"] as! [String: Any])
            self.expectDnsServers = model
        }
        if dict.keys.contains("IncludeAliDns") {
            self.includeAliDns = dict["IncludeAliDns"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDomainNsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainNsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainNsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainRecordInfoRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DescribeDomainRecordInfoResponseBody : Tea.TeaModel {
    public var domainId: String?

    public var domainName: String?

    public var groupId: String?

    public var groupName: String?

    public var line: String?

    public var locked: Bool?

    public var priority: Int64?

    public var punyCode: String?

    public var RR: String?

    public var recordId: String?

    public var requestId: String?

    public var status: String?

    public var TTL: Int64?

    public var type: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.locked != nil {
            map["Locked"] = self.locked!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.punyCode != nil {
            map["PunyCode"] = self.punyCode!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.TTL != nil {
            map["TTL"] = self.TTL!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Line") {
            self.line = dict["Line"] as! String
        }
        if dict.keys.contains("Locked") {
            self.locked = dict["Locked"] as! Bool
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int64
        }
        if dict.keys.contains("PunyCode") {
            self.punyCode = dict["PunyCode"] as! String
        }
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TTL") {
            self.TTL = dict["TTL"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class DescribeDomainRecordInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainRecordInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainRecordInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainRecordsRequest : Tea.TeaModel {
    public var direction: String?

    public var domainName: String?

    public var groupId: Int64?

    public var keyWord: String?

    public var lang: String?

    public var line: String?

    public var orderBy: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var RRKeyWord: String?

    public var searchMode: String?

    public var status: String?

    public var type: String?

    public var typeKeyWord: String?

    public var valueKeyWord: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.RRKeyWord != nil {
            map["RRKeyWord"] = self.RRKeyWord!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.typeKeyWord != nil {
            map["TypeKeyWord"] = self.typeKeyWord!
        }
        if self.valueKeyWord != nil {
            map["ValueKeyWord"] = self.valueKeyWord!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Line") {
            self.line = dict["Line"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RRKeyWord") {
            self.RRKeyWord = dict["RRKeyWord"] as! String
        }
        if dict.keys.contains("SearchMode") {
            self.searchMode = dict["SearchMode"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("TypeKeyWord") {
            self.typeKeyWord = dict["TypeKeyWord"] as! String
        }
        if dict.keys.contains("ValueKeyWord") {
            self.valueKeyWord = dict["ValueKeyWord"] as! String
        }
    }
}

public class DescribeDomainRecordsResponseBody : Tea.TeaModel {
    public class DomainRecords : Tea.TeaModel {
        public class Record : Tea.TeaModel {
            public var domainName: String?

            public var line: String?

            public var locked: Bool?

            public var priority: Int64?

            public var RR: String?

            public var recordId: String?

            public var remark: String?

            public var status: String?

            public var TTL: Int64?

            public var type: String?

            public var value: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.line != nil {
                    map["Line"] = self.line!
                }
                if self.locked != nil {
                    map["Locked"] = self.locked!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.RR != nil {
                    map["RR"] = self.RR!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.TTL != nil {
                    map["TTL"] = self.TTL!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Line") {
                    self.line = dict["Line"] as! String
                }
                if dict.keys.contains("Locked") {
                    self.locked = dict["Locked"] as! Bool
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int64
                }
                if dict.keys.contains("RR") {
                    self.RR = dict["RR"] as! String
                }
                if dict.keys.contains("RecordId") {
                    self.recordId = dict["RecordId"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TTL") {
                    self.TTL = dict["TTL"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var record: [DescribeDomainRecordsResponseBody.DomainRecords.Record]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.record != nil {
                var tmp : [Any] = []
                for k in self.record! {
                    tmp.append(k.toMap())
                }
                map["Record"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Record") {
                self.record = dict["Record"] as! [DescribeDomainRecordsResponseBody.DomainRecords.Record]
            }
        }
    }
    public var domainRecords: DescribeDomainRecordsResponseBody.DomainRecords?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainRecords?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainRecords != nil {
            map["DomainRecords"] = self.domainRecords?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainRecords") {
            var model = DescribeDomainRecordsResponseBody.DomainRecords()
            model.fromMap(dict["DomainRecords"] as! [String: Any])
            self.domainRecords = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDomainRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainStatisticsRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainType: String?

    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainType") {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeDomainStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public class Statistic : Tea.TeaModel {
            public var count: Int64?

            public var timestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
            }
        }
        public var statistic: [DescribeDomainStatisticsResponseBody.Statistics.Statistic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.statistic != nil {
                var tmp : [Any] = []
                for k in self.statistic! {
                    tmp.append(k.toMap())
                }
                map["Statistic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Statistic") {
                self.statistic = dict["Statistic"] as! [DescribeDomainStatisticsResponseBody.Statistics.Statistic]
            }
        }
    }
    public var requestId: String?

    public var statistics: DescribeDomainStatisticsResponseBody.Statistics?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var model = DescribeDomainStatisticsResponseBody.Statistics()
            model.fromMap(dict["Statistics"] as! [String: Any])
            self.statistics = model
        }
    }
}

public class DescribeDomainStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainStatisticsSummaryRequest : Tea.TeaModel {
    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var searchMode: String?

    public var startDate: String?

    public var threshold: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SearchMode") {
            self.searchMode = dict["SearchMode"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Int64
        }
    }
}

public class DescribeDomainStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public class Statistic : Tea.TeaModel {
            public var count: Int64?

            public var domainName: String?

            public var domainType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.domainType != nil {
                    map["DomainType"] = self.domainType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("DomainType") {
                    self.domainType = dict["DomainType"] as! String
                }
            }
        }
        public var statistic: [DescribeDomainStatisticsSummaryResponseBody.Statistics.Statistic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.statistic != nil {
                var tmp : [Any] = []
                for k in self.statistic! {
                    tmp.append(k.toMap())
                }
                map["Statistic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Statistic") {
                self.statistic = dict["Statistic"] as! [DescribeDomainStatisticsSummaryResponseBody.Statistics.Statistic]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: DescribeDomainStatisticsSummaryResponseBody.Statistics?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var model = DescribeDomainStatisticsSummaryResponseBody.Statistics()
            model.fromMap(dict["Statistics"] as! [String: Any])
            self.statistics = model
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDomainStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainStatisticsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainsRequest : Tea.TeaModel {
    public var groupId: String?

    public var keyWord: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceGroupId: String?

    public var searchMode: String?

    public var starmark: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.starmark != nil {
            map["Starmark"] = self.starmark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SearchMode") {
            self.searchMode = dict["SearchMode"] as! String
        }
        if dict.keys.contains("Starmark") {
            self.starmark = dict["Starmark"] as! Bool
        }
    }
}

public class DescribeDomainsResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class Domain : Tea.TeaModel {
            public class DnsServers : Tea.TeaModel {
                public var dnsServer: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dnsServer != nil {
                        map["DnsServer"] = self.dnsServer!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DnsServer") {
                        self.dnsServer = dict["DnsServer"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeDomainsResponseBody.Domains.Domain.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! [DescribeDomainsResponseBody.Domains.Domain.Tags.Tag]
                    }
                }
            }
            public var aliDomain: Bool?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var dnsServers: DescribeDomainsResponseBody.Domains.Domain.DnsServers?

            public var domainId: String?

            public var domainName: String?

            public var groupId: String?

            public var groupName: String?

            public var instanceEndTime: String?

            public var instanceExpired: Bool?

            public var instanceId: String?

            public var punyCode: String?

            public var recordCount: Int64?

            public var registrantEmail: String?

            public var remark: String?

            public var resourceGroupId: String?

            public var starmark: Bool?

            public var tags: DescribeDomainsResponseBody.Domains.Domain.Tags?

            public var versionCode: String?

            public var versionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dnsServers?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliDomain != nil {
                    map["AliDomain"] = self.aliDomain!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.dnsServers != nil {
                    map["DnsServers"] = self.dnsServers?.toMap()
                }
                if self.domainId != nil {
                    map["DomainId"] = self.domainId!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.instanceEndTime != nil {
                    map["InstanceEndTime"] = self.instanceEndTime!
                }
                if self.instanceExpired != nil {
                    map["InstanceExpired"] = self.instanceExpired!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.punyCode != nil {
                    map["PunyCode"] = self.punyCode!
                }
                if self.recordCount != nil {
                    map["RecordCount"] = self.recordCount!
                }
                if self.registrantEmail != nil {
                    map["RegistrantEmail"] = self.registrantEmail!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.starmark != nil {
                    map["Starmark"] = self.starmark!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                if self.versionName != nil {
                    map["VersionName"] = self.versionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliDomain") {
                    self.aliDomain = dict["AliDomain"] as! Bool
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("DnsServers") {
                    var model = DescribeDomainsResponseBody.Domains.Domain.DnsServers()
                    model.fromMap(dict["DnsServers"] as! [String: Any])
                    self.dnsServers = model
                }
                if dict.keys.contains("DomainId") {
                    self.domainId = dict["DomainId"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("InstanceEndTime") {
                    self.instanceEndTime = dict["InstanceEndTime"] as! String
                }
                if dict.keys.contains("InstanceExpired") {
                    self.instanceExpired = dict["InstanceExpired"] as! Bool
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PunyCode") {
                    self.punyCode = dict["PunyCode"] as! String
                }
                if dict.keys.contains("RecordCount") {
                    self.recordCount = dict["RecordCount"] as! Int64
                }
                if dict.keys.contains("RegistrantEmail") {
                    self.registrantEmail = dict["RegistrantEmail"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Starmark") {
                    self.starmark = dict["Starmark"] as! Bool
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeDomainsResponseBody.Domains.Domain.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VersionCode") {
                    self.versionCode = dict["VersionCode"] as! String
                }
                if dict.keys.contains("VersionName") {
                    self.versionName = dict["VersionName"] as! String
                }
            }
        }
        public var domain: [DescribeDomainsResponseBody.Domains.Domain]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domain != nil {
                var tmp : [Any] = []
                for k in self.domain! {
                    tmp.append(k.toMap())
                }
                map["Domain"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! [DescribeDomainsResponseBody.Domains.Domain]
            }
        }
    }
    public var domains: DescribeDomainsResponseBody.Domains?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domains != nil {
            map["Domains"] = self.domains?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Domains") {
            var model = DescribeDomainsResponseBody.Domains()
            model.fromMap(dict["Domains"] as! [String: Any])
            self.domains = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmAccessStrategiesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeGtmAccessStrategiesResponseBody : Tea.TeaModel {
    public class Strategies : Tea.TeaModel {
        public class Strategy : Tea.TeaModel {
            public class Lines : Tea.TeaModel {
                public class Line : Tea.TeaModel {
                    public var groupCode: String?

                    public var groupName: String?

                    public var lineCode: String?

                    public var lineName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.groupCode != nil {
                            map["GroupCode"] = self.groupCode!
                        }
                        if self.groupName != nil {
                            map["GroupName"] = self.groupName!
                        }
                        if self.lineCode != nil {
                            map["LineCode"] = self.lineCode!
                        }
                        if self.lineName != nil {
                            map["LineName"] = self.lineName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("GroupCode") {
                            self.groupCode = dict["GroupCode"] as! String
                        }
                        if dict.keys.contains("GroupName") {
                            self.groupName = dict["GroupName"] as! String
                        }
                        if dict.keys.contains("LineCode") {
                            self.lineCode = dict["LineCode"] as! String
                        }
                        if dict.keys.contains("LineName") {
                            self.lineName = dict["LineName"] as! String
                        }
                    }
                }
                public var line: [DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.line != nil {
                        var tmp : [Any] = []
                        for k in self.line! {
                            tmp.append(k.toMap())
                        }
                        map["Line"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Line") {
                        self.line = dict["Line"] as! [DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line]
                    }
                }
            }
            public var accessMode: String?

            public var accessStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var defaultAddrPoolId: String?

            public var defaultAddrPoolMonitorStatus: String?

            public var defaultAddrPoolName: String?

            public var defaultAddrPoolStatus: String?

            public var failoverAddrPoolId: String?

            public var failoverAddrPoolMonitorStatus: String?

            public var failoverAddrPoolName: String?

            public var failoverAddrPoolStatus: String?

            public var instanceId: String?

            public var lines: DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines?

            public var strategyId: String?

            public var strategyMode: String?

            public var strategyName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.lines?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessMode != nil {
                    map["AccessMode"] = self.accessMode!
                }
                if self.accessStatus != nil {
                    map["AccessStatus"] = self.accessStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.defaultAddrPoolId != nil {
                    map["DefaultAddrPoolId"] = self.defaultAddrPoolId!
                }
                if self.defaultAddrPoolMonitorStatus != nil {
                    map["DefaultAddrPoolMonitorStatus"] = self.defaultAddrPoolMonitorStatus!
                }
                if self.defaultAddrPoolName != nil {
                    map["DefaultAddrPoolName"] = self.defaultAddrPoolName!
                }
                if self.defaultAddrPoolStatus != nil {
                    map["DefaultAddrPoolStatus"] = self.defaultAddrPoolStatus!
                }
                if self.failoverAddrPoolId != nil {
                    map["FailoverAddrPoolId"] = self.failoverAddrPoolId!
                }
                if self.failoverAddrPoolMonitorStatus != nil {
                    map["FailoverAddrPoolMonitorStatus"] = self.failoverAddrPoolMonitorStatus!
                }
                if self.failoverAddrPoolName != nil {
                    map["FailoverAddrPoolName"] = self.failoverAddrPoolName!
                }
                if self.failoverAddrPoolStatus != nil {
                    map["FailoverAddrPoolStatus"] = self.failoverAddrPoolStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.lines != nil {
                    map["Lines"] = self.lines?.toMap()
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.strategyMode != nil {
                    map["StrategyMode"] = self.strategyMode!
                }
                if self.strategyName != nil {
                    map["StrategyName"] = self.strategyName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessMode") {
                    self.accessMode = dict["AccessMode"] as! String
                }
                if dict.keys.contains("AccessStatus") {
                    self.accessStatus = dict["AccessStatus"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("DefaultAddrPoolId") {
                    self.defaultAddrPoolId = dict["DefaultAddrPoolId"] as! String
                }
                if dict.keys.contains("DefaultAddrPoolMonitorStatus") {
                    self.defaultAddrPoolMonitorStatus = dict["DefaultAddrPoolMonitorStatus"] as! String
                }
                if dict.keys.contains("DefaultAddrPoolName") {
                    self.defaultAddrPoolName = dict["DefaultAddrPoolName"] as! String
                }
                if dict.keys.contains("DefaultAddrPoolStatus") {
                    self.defaultAddrPoolStatus = dict["DefaultAddrPoolStatus"] as! String
                }
                if dict.keys.contains("FailoverAddrPoolId") {
                    self.failoverAddrPoolId = dict["FailoverAddrPoolId"] as! String
                }
                if dict.keys.contains("FailoverAddrPoolMonitorStatus") {
                    self.failoverAddrPoolMonitorStatus = dict["FailoverAddrPoolMonitorStatus"] as! String
                }
                if dict.keys.contains("FailoverAddrPoolName") {
                    self.failoverAddrPoolName = dict["FailoverAddrPoolName"] as! String
                }
                if dict.keys.contains("FailoverAddrPoolStatus") {
                    self.failoverAddrPoolStatus = dict["FailoverAddrPoolStatus"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Lines") {
                    var model = DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines()
                    model.fromMap(dict["Lines"] as! [String: Any])
                    self.lines = model
                }
                if dict.keys.contains("StrategyId") {
                    self.strategyId = dict["StrategyId"] as! String
                }
                if dict.keys.contains("StrategyMode") {
                    self.strategyMode = dict["StrategyMode"] as! String
                }
                if dict.keys.contains("StrategyName") {
                    self.strategyName = dict["StrategyName"] as! String
                }
            }
        }
        public var strategy: [DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.strategy != nil {
                var tmp : [Any] = []
                for k in self.strategy! {
                    tmp.append(k.toMap())
                }
                map["Strategy"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Strategy") {
                self.strategy = dict["Strategy"] as! [DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var strategies: DescribeGtmAccessStrategiesResponseBody.Strategies?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.strategies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategies != nil {
            map["Strategies"] = self.strategies?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Strategies") {
            var model = DescribeGtmAccessStrategiesResponseBody.Strategies()
            model.fromMap(dict["Strategies"] as! [String: Any])
            self.strategies = model
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeGtmAccessStrategiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmAccessStrategiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmAccessStrategiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmAccessStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class DescribeGtmAccessStrategyResponseBody : Tea.TeaModel {
    public class Lines : Tea.TeaModel {
        public class Line : Tea.TeaModel {
            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupCode") {
                    self.groupCode = dict["GroupCode"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
            }
        }
        public var line: [DescribeGtmAccessStrategyResponseBody.Lines.Line]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.line != nil {
                var tmp : [Any] = []
                for k in self.line! {
                    tmp.append(k.toMap())
                }
                map["Line"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Line") {
                self.line = dict["Line"] as! [DescribeGtmAccessStrategyResponseBody.Lines.Line]
            }
        }
    }
    public var accessMode: String?

    public var accessStatus: String?

    public var defaultAddrPoolMonitorStatus: String?

    public var defaultAddrPoolName: String?

    public var defaultAddrPoolStatus: String?

    public var defultAddrPoolId: String?

    public var failoverAddrPoolId: String?

    public var failoverAddrPoolMonitorStatus: String?

    public var failoverAddrPoolName: String?

    public var failoverAddrPoolStatus: String?

    public var instanceId: String?

    public var lines: DescribeGtmAccessStrategyResponseBody.Lines?

    public var requestId: String?

    public var strategyId: String?

    public var strategyMode: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.accessStatus != nil {
            map["AccessStatus"] = self.accessStatus!
        }
        if self.defaultAddrPoolMonitorStatus != nil {
            map["DefaultAddrPoolMonitorStatus"] = self.defaultAddrPoolMonitorStatus!
        }
        if self.defaultAddrPoolName != nil {
            map["DefaultAddrPoolName"] = self.defaultAddrPoolName!
        }
        if self.defaultAddrPoolStatus != nil {
            map["DefaultAddrPoolStatus"] = self.defaultAddrPoolStatus!
        }
        if self.defultAddrPoolId != nil {
            map["DefultAddrPoolId"] = self.defultAddrPoolId!
        }
        if self.failoverAddrPoolId != nil {
            map["FailoverAddrPoolId"] = self.failoverAddrPoolId!
        }
        if self.failoverAddrPoolMonitorStatus != nil {
            map["FailoverAddrPoolMonitorStatus"] = self.failoverAddrPoolMonitorStatus!
        }
        if self.failoverAddrPoolName != nil {
            map["FailoverAddrPoolName"] = self.failoverAddrPoolName!
        }
        if self.failoverAddrPoolStatus != nil {
            map["FailoverAddrPoolStatus"] = self.failoverAddrPoolStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lines != nil {
            map["Lines"] = self.lines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessMode") {
            self.accessMode = dict["AccessMode"] as! String
        }
        if dict.keys.contains("AccessStatus") {
            self.accessStatus = dict["AccessStatus"] as! String
        }
        if dict.keys.contains("DefaultAddrPoolMonitorStatus") {
            self.defaultAddrPoolMonitorStatus = dict["DefaultAddrPoolMonitorStatus"] as! String
        }
        if dict.keys.contains("DefaultAddrPoolName") {
            self.defaultAddrPoolName = dict["DefaultAddrPoolName"] as! String
        }
        if dict.keys.contains("DefaultAddrPoolStatus") {
            self.defaultAddrPoolStatus = dict["DefaultAddrPoolStatus"] as! String
        }
        if dict.keys.contains("DefultAddrPoolId") {
            self.defultAddrPoolId = dict["DefultAddrPoolId"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolId") {
            self.failoverAddrPoolId = dict["FailoverAddrPoolId"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolMonitorStatus") {
            self.failoverAddrPoolMonitorStatus = dict["FailoverAddrPoolMonitorStatus"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolName") {
            self.failoverAddrPoolName = dict["FailoverAddrPoolName"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolStatus") {
            self.failoverAddrPoolStatus = dict["FailoverAddrPoolStatus"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lines") {
            var model = DescribeGtmAccessStrategyResponseBody.Lines()
            model.fromMap(dict["Lines"] as! [String: Any])
            self.lines = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
        if dict.keys.contains("StrategyMode") {
            self.strategyMode = dict["StrategyMode"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class DescribeGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmAccessStrategyAvailableConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmAccessStrategyAvailableConfigResponseBody : Tea.TeaModel {
    public class AddrPools : Tea.TeaModel {
        public class AddrPool : Tea.TeaModel {
            public var addrPoolId: String?

            public var addrPoolName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrPoolId != nil {
                    map["AddrPoolId"] = self.addrPoolId!
                }
                if self.addrPoolName != nil {
                    map["AddrPoolName"] = self.addrPoolName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrPoolId") {
                    self.addrPoolId = dict["AddrPoolId"] as! String
                }
                if dict.keys.contains("AddrPoolName") {
                    self.addrPoolName = dict["AddrPoolName"] as! String
                }
            }
        }
        public var addrPool: [DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools.AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addrPool != nil {
                var tmp : [Any] = []
                for k in self.addrPool! {
                    tmp.append(k.toMap())
                }
                map["AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddrPool") {
                self.addrPool = dict["AddrPool"] as! [DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools.AddrPool]
            }
        }
    }
    public class Lines : Tea.TeaModel {
        public class Line : Tea.TeaModel {
            public var fatherCode: String?

            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FatherCode") {
                    self.fatherCode = dict["FatherCode"] as! String
                }
                if dict.keys.contains("GroupCode") {
                    self.groupCode = dict["GroupCode"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var line: [DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines.Line]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.line != nil {
                var tmp : [Any] = []
                for k in self.line! {
                    tmp.append(k.toMap())
                }
                map["Line"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Line") {
                self.line = dict["Line"] as! [DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines.Line]
            }
        }
    }
    public var addrPools: DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools?

    public var lines: DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrPools?.validate()
        try self.lines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPools != nil {
            map["AddrPools"] = self.addrPools?.toMap()
        }
        if self.lines != nil {
            map["Lines"] = self.lines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPools") {
            var model = DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools()
            model.fromMap(dict["AddrPools"] as! [String: Any])
            self.addrPools = model
        }
        if dict.keys.contains("Lines") {
            var model = DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines()
            model.fromMap(dict["Lines"] as! [String: Any])
            self.lines = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGtmAccessStrategyAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmAccessStrategyAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmAccessStrategyAvailableConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmAvailableAlertGroupRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmAvailableAlertGroupResponseBody : Tea.TeaModel {
    public var availableAlertGroup: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAlertGroup != nil {
            map["AvailableAlertGroup"] = self.availableAlertGroup!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableAlertGroup") {
            self.availableAlertGroup = dict["AvailableAlertGroup"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGtmAvailableAlertGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmAvailableAlertGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmAvailableAlertGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var needDetailAttributes: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.needDetailAttributes != nil {
            map["NeedDetailAttributes"] = self.needDetailAttributes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NeedDetailAttributes") {
            self.needDetailAttributes = dict["NeedDetailAttributes"] as! Bool
        }
    }
}

public class DescribeGtmInstanceResponseBody : Tea.TeaModel {
    public var accessStrategyNum: Int32?

    public var addressPoolNum: Int32?

    public var alertGroup: String?

    public var cname: String?

    public var cnameMode: String?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var expireTime: String?

    public var expireTimestamp: Int64?

    public var instanceId: String?

    public var instanceName: String?

    public var lbaStrategy: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var ttl: Int32?

    public var userDomainName: String?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessStrategyNum != nil {
            map["AccessStrategyNum"] = self.accessStrategyNum!
        }
        if self.addressPoolNum != nil {
            map["AddressPoolNum"] = self.addressPoolNum!
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.cname != nil {
            map["Cname"] = self.cname!
        }
        if self.cnameMode != nil {
            map["CnameMode"] = self.cnameMode!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.expireTimestamp != nil {
            map["ExpireTimestamp"] = self.expireTimestamp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.userDomainName != nil {
            map["UserDomainName"] = self.userDomainName!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessStrategyNum") {
            self.accessStrategyNum = dict["AccessStrategyNum"] as! Int32
        }
        if dict.keys.contains("AddressPoolNum") {
            self.addressPoolNum = dict["AddressPoolNum"] as! Int32
        }
        if dict.keys.contains("AlertGroup") {
            self.alertGroup = dict["AlertGroup"] as! String
        }
        if dict.keys.contains("Cname") {
            self.cname = dict["Cname"] as! String
        }
        if dict.keys.contains("CnameMode") {
            self.cnameMode = dict["CnameMode"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("ExpireTime") {
            self.expireTime = dict["ExpireTime"] as! String
        }
        if dict.keys.contains("ExpireTimestamp") {
            self.expireTimestamp = dict["ExpireTimestamp"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("LbaStrategy") {
            self.lbaStrategy = dict["LbaStrategy"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Ttl") {
            self.ttl = dict["Ttl"] as! Int32
        }
        if dict.keys.contains("UserDomainName") {
            self.userDomainName = dict["UserDomainName"] as! String
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
    }
}

public class DescribeGtmInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmInstanceAddressPoolRequest : Tea.TeaModel {
    public var addrPoolId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmInstanceAddressPoolResponseBody : Tea.TeaModel {
    public class Addrs : Tea.TeaModel {
        public class Addr : Tea.TeaModel {
            public var addrId: Int64?

            public var alertStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var lbaWeight: Int32?

            public var mode: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrId != nil {
                    map["AddrId"] = self.addrId!
                }
                if self.alertStatus != nil {
                    map["AlertStatus"] = self.alertStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.lbaWeight != nil {
                    map["LbaWeight"] = self.lbaWeight!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrId") {
                    self.addrId = dict["AddrId"] as! Int64
                }
                if dict.keys.contains("AlertStatus") {
                    self.alertStatus = dict["AlertStatus"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("LbaWeight") {
                    self.lbaWeight = dict["LbaWeight"] as! Int32
                }
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var addr: [DescribeGtmInstanceAddressPoolResponseBody.Addrs.Addr]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                var tmp : [Any] = []
                for k in self.addr! {
                    tmp.append(k.toMap())
                }
                map["Addr"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Addr") {
                self.addr = dict["Addr"] as! [DescribeGtmInstanceAddressPoolResponseBody.Addrs.Addr]
            }
        }
    }
    public var addrCount: Int32?

    public var addrPoolId: String?

    public var addrs: DescribeGtmInstanceAddressPoolResponseBody.Addrs?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var minAvailableAddrNum: Int32?

    public var monitorConfigId: String?

    public var monitorStatus: String?

    public var name: String?

    public var requestId: String?

    public var status: String?

    public var type: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrCount != nil {
            map["AddrCount"] = self.addrCount!
        }
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.addrs != nil {
            map["Addrs"] = self.addrs?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.minAvailableAddrNum != nil {
            map["MinAvailableAddrNum"] = self.minAvailableAddrNum!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorStatus != nil {
            map["MonitorStatus"] = self.monitorStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrCount") {
            self.addrCount = dict["AddrCount"] as! Int32
        }
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Addrs") {
            var model = DescribeGtmInstanceAddressPoolResponseBody.Addrs()
            model.fromMap(dict["Addrs"] as! [String: Any])
            self.addrs = model
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("MinAvailableAddrNum") {
            self.minAvailableAddrNum = dict["MinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("MonitorStatus") {
            self.monitorStatus = dict["MonitorStatus"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
    }
}

public class DescribeGtmInstanceAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmInstanceAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmInstanceAddressPoolsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeGtmInstanceAddressPoolsResponseBody : Tea.TeaModel {
    public class AddrPools : Tea.TeaModel {
        public class AddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var addrPoolId: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var minAvailableAddrNum: Int32?

            public var monitorConfigId: String?

            public var monitorStatus: String?

            public var name: String?

            public var status: String?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.addrPoolId != nil {
                    map["AddrPoolId"] = self.addrPoolId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.minAvailableAddrNum != nil {
                    map["MinAvailableAddrNum"] = self.minAvailableAddrNum!
                }
                if self.monitorConfigId != nil {
                    map["MonitorConfigId"] = self.monitorConfigId!
                }
                if self.monitorStatus != nil {
                    map["MonitorStatus"] = self.monitorStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("AddrPoolId") {
                    self.addrPoolId = dict["AddrPoolId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("MinAvailableAddrNum") {
                    self.minAvailableAddrNum = dict["MinAvailableAddrNum"] as! Int32
                }
                if dict.keys.contains("MonitorConfigId") {
                    self.monitorConfigId = dict["MonitorConfigId"] as! String
                }
                if dict.keys.contains("MonitorStatus") {
                    self.monitorStatus = dict["MonitorStatus"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var addrPool: [DescribeGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addrPool != nil {
                var tmp : [Any] = []
                for k in self.addrPool! {
                    tmp.append(k.toMap())
                }
                map["AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddrPool") {
                self.addrPool = dict["AddrPool"] as! [DescribeGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool]
            }
        }
    }
    public var addrPools: DescribeGtmInstanceAddressPoolsResponseBody.AddrPools?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPools != nil {
            map["AddrPools"] = self.addrPools?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPools") {
            var model = DescribeGtmInstanceAddressPoolsResponseBody.AddrPools()
            model.fromMap(dict["AddrPools"] as! [String: Any])
            self.addrPools = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeGtmInstanceAddressPoolsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceAddressPoolsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmInstanceAddressPoolsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmInstanceStatusRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmInstanceStatusResponseBody : Tea.TeaModel {
    public var addrNotAvailableNum: Int32?

    public var addrPoolNotAvailableNum: Int32?

    public var requestId: String?

    public var status: String?

    public var statusReason: String?

    public var strategyNotAvailableNum: Int32?

    public var switchToFailoverStrategyNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrNotAvailableNum != nil {
            map["AddrNotAvailableNum"] = self.addrNotAvailableNum!
        }
        if self.addrPoolNotAvailableNum != nil {
            map["AddrPoolNotAvailableNum"] = self.addrPoolNotAvailableNum!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.statusReason != nil {
            map["StatusReason"] = self.statusReason!
        }
        if self.strategyNotAvailableNum != nil {
            map["StrategyNotAvailableNum"] = self.strategyNotAvailableNum!
        }
        if self.switchToFailoverStrategyNum != nil {
            map["SwitchToFailoverStrategyNum"] = self.switchToFailoverStrategyNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrNotAvailableNum") {
            self.addrNotAvailableNum = dict["AddrNotAvailableNum"] as! Int32
        }
        if dict.keys.contains("AddrPoolNotAvailableNum") {
            self.addrPoolNotAvailableNum = dict["AddrPoolNotAvailableNum"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StatusReason") {
            self.statusReason = dict["StatusReason"] as! String
        }
        if dict.keys.contains("StrategyNotAvailableNum") {
            self.strategyNotAvailableNum = dict["StrategyNotAvailableNum"] as! Int32
        }
        if dict.keys.contains("SwitchToFailoverStrategyNum") {
            self.switchToFailoverStrategyNum = dict["SwitchToFailoverStrategyNum"] as! Int32
        }
    }
}

public class DescribeGtmInstanceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmInstanceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmInstanceSystemCnameRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmInstanceSystemCnameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var systemCname: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemCname != nil {
            map["SystemCname"] = self.systemCname!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemCname") {
            self.systemCname = dict["SystemCname"] as! String
        }
    }
}

public class DescribeGtmInstanceSystemCnameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceSystemCnameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmInstanceSystemCnameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmInstancesRequest : Tea.TeaModel {
    public var keyword: String?

    public var lang: String?

    public var needDetailAttributes: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.needDetailAttributes != nil {
            map["NeedDetailAttributes"] = self.needDetailAttributes!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NeedDetailAttributes") {
            self.needDetailAttributes = dict["NeedDetailAttributes"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeGtmInstancesResponseBody : Tea.TeaModel {
    public class GtmInstances : Tea.TeaModel {
        public class GtmInstance : Tea.TeaModel {
            public var accessStrategyNum: Int32?

            public var addressPoolNum: Int32?

            public var alertGroup: String?

            public var cname: String?

            public var cnameMode: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var expireTime: String?

            public var expireTimestamp: Int64?

            public var instanceId: String?

            public var instanceName: String?

            public var lbaStrategy: String?

            public var resourceGroupId: String?

            public var ttl: Int32?

            public var userDomainName: String?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessStrategyNum != nil {
                    map["AccessStrategyNum"] = self.accessStrategyNum!
                }
                if self.addressPoolNum != nil {
                    map["AddressPoolNum"] = self.addressPoolNum!
                }
                if self.alertGroup != nil {
                    map["AlertGroup"] = self.alertGroup!
                }
                if self.cname != nil {
                    map["Cname"] = self.cname!
                }
                if self.cnameMode != nil {
                    map["CnameMode"] = self.cnameMode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.expireTimestamp != nil {
                    map["ExpireTimestamp"] = self.expireTimestamp!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.lbaStrategy != nil {
                    map["LbaStrategy"] = self.lbaStrategy!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.userDomainName != nil {
                    map["UserDomainName"] = self.userDomainName!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessStrategyNum") {
                    self.accessStrategyNum = dict["AccessStrategyNum"] as! Int32
                }
                if dict.keys.contains("AddressPoolNum") {
                    self.addressPoolNum = dict["AddressPoolNum"] as! Int32
                }
                if dict.keys.contains("AlertGroup") {
                    self.alertGroup = dict["AlertGroup"] as! String
                }
                if dict.keys.contains("Cname") {
                    self.cname = dict["Cname"] as! String
                }
                if dict.keys.contains("CnameMode") {
                    self.cnameMode = dict["CnameMode"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! String
                }
                if dict.keys.contains("ExpireTimestamp") {
                    self.expireTimestamp = dict["ExpireTimestamp"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("LbaStrategy") {
                    self.lbaStrategy = dict["LbaStrategy"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Ttl") {
                    self.ttl = dict["Ttl"] as! Int32
                }
                if dict.keys.contains("UserDomainName") {
                    self.userDomainName = dict["UserDomainName"] as! String
                }
                if dict.keys.contains("VersionCode") {
                    self.versionCode = dict["VersionCode"] as! String
                }
            }
        }
        public var gtmInstance: [DescribeGtmInstancesResponseBody.GtmInstances.GtmInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gtmInstance != nil {
                var tmp : [Any] = []
                for k in self.gtmInstance! {
                    tmp.append(k.toMap())
                }
                map["GtmInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GtmInstance") {
                self.gtmInstance = dict["GtmInstance"] as! [DescribeGtmInstancesResponseBody.GtmInstances.GtmInstance]
            }
        }
    }
    public var gtmInstances: DescribeGtmInstancesResponseBody.GtmInstances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gtmInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gtmInstances != nil {
            map["GtmInstances"] = self.gtmInstances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GtmInstances") {
            var model = DescribeGtmInstancesResponseBody.GtmInstances()
            model.fromMap(dict["GtmInstances"] as! [String: Any])
            self.gtmInstances = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeGtmInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmLogsRequest : Tea.TeaModel {
    public var endTimestamp: Int64?

    public var instanceId: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimestamp != nil {
            map["StartTimestamp"] = self.startTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTimestamp") {
            self.endTimestamp = dict["EndTimestamp"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTimestamp") {
            self.startTimestamp = dict["StartTimestamp"] as! Int64
        }
    }
}

public class DescribeGtmLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public class Log : Tea.TeaModel {
            public var content: String?

            public var entityId: String?

            public var entityName: String?

            public var entityType: String?

            public var id: Int64?

            public var operAction: String?

            public var operIp: String?

            public var operTime: String?

            public var operTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.entityId != nil {
                    map["EntityId"] = self.entityId!
                }
                if self.entityName != nil {
                    map["EntityName"] = self.entityName!
                }
                if self.entityType != nil {
                    map["EntityType"] = self.entityType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.operAction != nil {
                    map["OperAction"] = self.operAction!
                }
                if self.operIp != nil {
                    map["OperIp"] = self.operIp!
                }
                if self.operTime != nil {
                    map["OperTime"] = self.operTime!
                }
                if self.operTimestamp != nil {
                    map["OperTimestamp"] = self.operTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("EntityId") {
                    self.entityId = dict["EntityId"] as! String
                }
                if dict.keys.contains("EntityName") {
                    self.entityName = dict["EntityName"] as! String
                }
                if dict.keys.contains("EntityType") {
                    self.entityType = dict["EntityType"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("OperAction") {
                    self.operAction = dict["OperAction"] as! String
                }
                if dict.keys.contains("OperIp") {
                    self.operIp = dict["OperIp"] as! String
                }
                if dict.keys.contains("OperTime") {
                    self.operTime = dict["OperTime"] as! String
                }
                if dict.keys.contains("OperTimestamp") {
                    self.operTimestamp = dict["OperTimestamp"] as! Int64
                }
            }
        }
        public var log: [DescribeGtmLogsResponseBody.Logs.Log]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.log != nil {
                var tmp : [Any] = []
                for k in self.log! {
                    tmp.append(k.toMap())
                }
                map["Log"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Log") {
                self.log = dict["Log"] as! [DescribeGtmLogsResponseBody.Logs.Log]
            }
        }
    }
    public var logs: DescribeGtmLogsResponseBody.Logs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            map["Logs"] = self.logs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logs") {
            var model = DescribeGtmLogsResponseBody.Logs()
            model.fromMap(dict["Logs"] as! [String: Any])
            self.logs = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeGtmLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmMonitorAvailableConfigRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmMonitorAvailableConfigResponseBody : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public class IspCityNode : Tea.TeaModel {
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ispCode: String?

            public var ispName: String?

            public var mainland: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                if self.mainland != nil {
                    map["Mainland"] = self.mainland!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("DefaultSelected") {
                    self.defaultSelected = dict["DefaultSelected"] as! Bool
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") {
                    self.groupType = dict["GroupType"] as! String
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
                if dict.keys.contains("Mainland") {
                    self.mainland = dict["Mainland"] as! Bool
                }
            }
        }
        public var ispCityNode: [DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes.IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ispCityNode != nil {
                var tmp : [Any] = []
                for k in self.ispCityNode! {
                    tmp.append(k.toMap())
                }
                map["IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IspCityNode") {
                self.ispCityNode = dict["IspCityNode"] as! [DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes.IspCityNode]
            }
        }
    }
    public var ispCityNodes: DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ispCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ispCityNodes != nil {
            map["IspCityNodes"] = self.ispCityNodes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IspCityNodes") {
            var model = DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes()
            model.fromMap(dict["IspCityNodes"] as! [String: Any])
            self.ispCityNodes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGtmMonitorAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmMonitorAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmMonitorAvailableConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmMonitorConfigRequest : Tea.TeaModel {
    public var lang: String?

    public var monitorConfigId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
    }
}

public class DescribeGtmMonitorConfigResponseBody : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public class IspCityNode : Tea.TeaModel {
            public var cityCode: String?

            public var cityName: String?

            public var countryCode: String?

            public var countryName: String?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.countryCode != nil {
                    map["CountryCode"] = self.countryCode!
                }
                if self.countryName != nil {
                    map["CountryName"] = self.countryName!
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("CountryCode") {
                    self.countryCode = dict["CountryCode"] as! String
                }
                if dict.keys.contains("CountryName") {
                    self.countryName = dict["CountryName"] as! String
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
            }
        }
        public var ispCityNode: [DescribeGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ispCityNode != nil {
                var tmp : [Any] = []
                for k in self.ispCityNode! {
                    tmp.append(k.toMap())
                }
                map["IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IspCityNode") {
                self.ispCityNode = dict["IspCityNode"] as! [DescribeGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode]
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNodes: DescribeGtmMonitorConfigResponseBody.IspCityNodes?

    public var monitorConfigId: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var requestId: String?

    public var timeout: Int32?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ispCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNodes != nil {
            map["IspCityNodes"] = self.ispCityNodes?.toMap()
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNodes") {
            var model = DescribeGtmMonitorConfigResponseBody.IspCityNodes()
            model.fromMap(dict["IspCityNodes"] as! [String: Any])
            self.ispCityNodes = model
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
    }
}

public class DescribeGtmMonitorConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmMonitorConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmMonitorConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
    }
}

public class DescribeGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public class FaultAddrPools : Tea.TeaModel {
        public class FaultAddrPool : Tea.TeaModel {
            public class Addrs : Tea.TeaModel {
                public class Addr : Tea.TeaModel {
                    public var id: Int64?

                    public var mode: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.mode != nil {
                            map["Mode"] = self.mode!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! Int64
                        }
                        if dict.keys.contains("Mode") {
                            self.mode = dict["Mode"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var addr: [DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs.Addr]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.addr != nil {
                        var tmp : [Any] = []
                        for k in self.addr! {
                            tmp.append(k.toMap())
                        }
                        map["Addr"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Addr") {
                        self.addr = dict["Addr"] as! [DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs.Addr]
                    }
                }
            }
            public var addrPoolId: String?

            public var addrPoolName: String?

            public var addrs: DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addrs?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrPoolId != nil {
                    map["AddrPoolId"] = self.addrPoolId!
                }
                if self.addrPoolName != nil {
                    map["AddrPoolName"] = self.addrPoolName!
                }
                if self.addrs != nil {
                    map["Addrs"] = self.addrs?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrPoolId") {
                    self.addrPoolId = dict["AddrPoolId"] as! String
                }
                if dict.keys.contains("AddrPoolName") {
                    self.addrPoolName = dict["AddrPoolName"] as! String
                }
                if dict.keys.contains("Addrs") {
                    var model = DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs()
                    model.fromMap(dict["Addrs"] as! [String: Any])
                    self.addrs = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var faultAddrPool: [DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.faultAddrPool != nil {
                var tmp : [Any] = []
                for k in self.faultAddrPool! {
                    tmp.append(k.toMap())
                }
                map["FaultAddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FaultAddrPool") {
                self.faultAddrPool = dict["FaultAddrPool"] as! [DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool]
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var faultAddrPoolNum: Int32?

    public var faultAddrPools: DescribeGtmRecoveryPlanResponseBody.FaultAddrPools?

    public var lastExecuteTime: String?

    public var lastExecuteTimestamp: Int64?

    public var lastRollbackTime: String?

    public var lastRollbackTimestamp: Int64?

    public var name: String?

    public var recoveryPlanId: Int64?

    public var remark: String?

    public var requestId: String?

    public var status: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.faultAddrPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.faultAddrPoolNum != nil {
            map["FaultAddrPoolNum"] = self.faultAddrPoolNum!
        }
        if self.faultAddrPools != nil {
            map["FaultAddrPools"] = self.faultAddrPools?.toMap()
        }
        if self.lastExecuteTime != nil {
            map["LastExecuteTime"] = self.lastExecuteTime!
        }
        if self.lastExecuteTimestamp != nil {
            map["LastExecuteTimestamp"] = self.lastExecuteTimestamp!
        }
        if self.lastRollbackTime != nil {
            map["LastRollbackTime"] = self.lastRollbackTime!
        }
        if self.lastRollbackTimestamp != nil {
            map["LastRollbackTimestamp"] = self.lastRollbackTimestamp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("FaultAddrPoolNum") {
            self.faultAddrPoolNum = dict["FaultAddrPoolNum"] as! Int32
        }
        if dict.keys.contains("FaultAddrPools") {
            var model = DescribeGtmRecoveryPlanResponseBody.FaultAddrPools()
            model.fromMap(dict["FaultAddrPools"] as! [String: Any])
            self.faultAddrPools = model
        }
        if dict.keys.contains("LastExecuteTime") {
            self.lastExecuteTime = dict["LastExecuteTime"] as! String
        }
        if dict.keys.contains("LastExecuteTimestamp") {
            self.lastExecuteTimestamp = dict["LastExecuteTimestamp"] as! Int64
        }
        if dict.keys.contains("LastRollbackTime") {
            self.lastRollbackTime = dict["LastRollbackTime"] as! String
        }
        if dict.keys.contains("LastRollbackTimestamp") {
            self.lastRollbackTimestamp = dict["LastRollbackTimestamp"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
    }
}

public class DescribeGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmRecoveryPlanAvailableConfigRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmRecoveryPlanAvailableConfigResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public class AddrPools : Tea.TeaModel {
                public class AddrPool : Tea.TeaModel {
                    public var addrPoolId: String?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.addrPoolId != nil {
                            map["AddrPoolId"] = self.addrPoolId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AddrPoolId") {
                            self.addrPoolId = dict["AddrPoolId"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public var addrPool: [DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools.AddrPool]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.addrPool != nil {
                        var tmp : [Any] = []
                        for k in self.addrPool! {
                            tmp.append(k.toMap())
                        }
                        map["AddrPool"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AddrPool") {
                        self.addrPool = dict["AddrPool"] as! [DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools.AddrPool]
                    }
                }
            }
            public var addrPools: DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools?

            public var instanceId: String?

            public var instanceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addrPools?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrPools != nil {
                    map["AddrPools"] = self.addrPools?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrPools") {
                    var model = DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools()
                    model.fromMap(dict["AddrPools"] as! [String: Any])
                    self.addrPools = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
            }
        }
        public var instance: [DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instance") {
                self.instance = dict["Instance"] as! [DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance]
            }
        }
    }
    public var instances: DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var model = DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances()
            model.fromMap(dict["Instances"] as! [String: Any])
            self.instances = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGtmRecoveryPlanAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmRecoveryPlanAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmRecoveryPlanAvailableConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmRecoveryPlansRequest : Tea.TeaModel {
    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeGtmRecoveryPlansResponseBody : Tea.TeaModel {
    public class RecoveryPlans : Tea.TeaModel {
        public class RecoveryPlan : Tea.TeaModel {
            public var createTime: String?

            public var createTimestamp: Int64?

            public var faultAddrPoolNum: Int32?

            public var lastExecuteTime: String?

            public var lastExecuteTimestamp: Int64?

            public var lastRollbackTime: String?

            public var lastRollbackTimestamp: Int64?

            public var name: String?

            public var recoveryPlanId: Int64?

            public var remark: String?

            public var status: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.faultAddrPoolNum != nil {
                    map["FaultAddrPoolNum"] = self.faultAddrPoolNum!
                }
                if self.lastExecuteTime != nil {
                    map["LastExecuteTime"] = self.lastExecuteTime!
                }
                if self.lastExecuteTimestamp != nil {
                    map["LastExecuteTimestamp"] = self.lastExecuteTimestamp!
                }
                if self.lastRollbackTime != nil {
                    map["LastRollbackTime"] = self.lastRollbackTime!
                }
                if self.lastRollbackTimestamp != nil {
                    map["LastRollbackTimestamp"] = self.lastRollbackTimestamp!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.recoveryPlanId != nil {
                    map["RecoveryPlanId"] = self.recoveryPlanId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("FaultAddrPoolNum") {
                    self.faultAddrPoolNum = dict["FaultAddrPoolNum"] as! Int32
                }
                if dict.keys.contains("LastExecuteTime") {
                    self.lastExecuteTime = dict["LastExecuteTime"] as! String
                }
                if dict.keys.contains("LastExecuteTimestamp") {
                    self.lastExecuteTimestamp = dict["LastExecuteTimestamp"] as! Int64
                }
                if dict.keys.contains("LastRollbackTime") {
                    self.lastRollbackTime = dict["LastRollbackTime"] as! String
                }
                if dict.keys.contains("LastRollbackTimestamp") {
                    self.lastRollbackTimestamp = dict["LastRollbackTimestamp"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RecoveryPlanId") {
                    self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var recoveryPlan: [DescribeGtmRecoveryPlansResponseBody.RecoveryPlans.RecoveryPlan]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recoveryPlan != nil {
                var tmp : [Any] = []
                for k in self.recoveryPlan! {
                    tmp.append(k.toMap())
                }
                map["RecoveryPlan"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecoveryPlan") {
                self.recoveryPlan = dict["RecoveryPlan"] as! [DescribeGtmRecoveryPlansResponseBody.RecoveryPlans.RecoveryPlan]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var recoveryPlans: DescribeGtmRecoveryPlansResponseBody.RecoveryPlans?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recoveryPlans?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recoveryPlans != nil {
            map["RecoveryPlans"] = self.recoveryPlans?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecoveryPlans") {
            var model = DescribeGtmRecoveryPlansResponseBody.RecoveryPlans()
            model.fromMap(dict["RecoveryPlans"] as! [String: Any])
            self.recoveryPlans = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeGtmRecoveryPlansResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmRecoveryPlansResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmRecoveryPlansResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceDomainsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribeInstanceDomainsResponseBody : Tea.TeaModel {
    public class InstanceDomains : Tea.TeaModel {
        public var createTime: String?

        public var createTimestamp: Int64?

        public var domainName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
        }
    }
    public var instanceDomains: [DescribeInstanceDomainsResponseBody.InstanceDomains]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceDomains != nil {
            var tmp : [Any] = []
            for k in self.instanceDomains! {
                tmp.append(k.toMap())
            }
            map["InstanceDomains"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceDomains") {
            self.instanceDomains = dict["InstanceDomains"] as! [DescribeInstanceDomainsResponseBody.InstanceDomains]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeInstanceDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIspFlushCacheInstancesRequest : Tea.TeaModel {
    public var direction: String?

    public var isp: String?

    public var keyword: String?

    public var lang: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeIspFlushCacheInstancesResponseBody : Tea.TeaModel {
    public class IspFlushCacheInstances : Tea.TeaModel {
        public class QuotaInfo : Tea.TeaModel {
            public var instanceQuota: Int32?

            public var instanceQuotaUsed: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceQuota != nil {
                    map["InstanceQuota"] = self.instanceQuota!
                }
                if self.instanceQuotaUsed != nil {
                    map["InstanceQuotaUsed"] = self.instanceQuotaUsed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceQuota") {
                    self.instanceQuota = dict["InstanceQuota"] as! Int32
                }
                if dict.keys.contains("InstanceQuotaUsed") {
                    self.instanceQuotaUsed = dict["InstanceQuotaUsed"] as! Int32
                }
            }
        }
        public var expireTime: String?

        public var expireTimestamp: Int64?

        public var instanceId: String?

        public var instanceName: String?

        public var isp: String?

        public var quotaInfo: DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances.QuotaInfo?

        public var status: String?

        public var versionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.quotaInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.expireTimestamp != nil {
                map["ExpireTimestamp"] = self.expireTimestamp!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.isp != nil {
                map["Isp"] = self.isp!
            }
            if self.quotaInfo != nil {
                map["QuotaInfo"] = self.quotaInfo?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("ExpireTimestamp") {
                self.expireTimestamp = dict["ExpireTimestamp"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("Isp") {
                self.isp = dict["Isp"] as! String
            }
            if dict.keys.contains("QuotaInfo") {
                var model = DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances.QuotaInfo()
                model.fromMap(dict["QuotaInfo"] as! [String: Any])
                self.quotaInfo = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("VersionCode") {
                self.versionCode = dict["VersionCode"] as! String
            }
        }
    }
    public var ispFlushCacheInstances: [DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ispFlushCacheInstances != nil {
            var tmp : [Any] = []
            for k in self.ispFlushCacheInstances! {
                tmp.append(k.toMap())
            }
            map["IspFlushCacheInstances"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IspFlushCacheInstances") {
            self.ispFlushCacheInstances = dict["IspFlushCacheInstances"] as! [DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeIspFlushCacheInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIspFlushCacheInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIspFlushCacheInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIspFlushCacheRemainQuotaRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeIspFlushCacheRemainQuotaResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var telecomRemainQuota: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.telecomRemainQuota != nil {
            map["TelecomRemainQuota"] = self.telecomRemainQuota!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TelecomRemainQuota") {
            self.telecomRemainQuota = dict["TelecomRemainQuota"] as! Int32
        }
    }
}

public class DescribeIspFlushCacheRemainQuotaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIspFlushCacheRemainQuotaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIspFlushCacheRemainQuotaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIspFlushCacheTaskRequest : Tea.TeaModel {
    public var lang: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeIspFlushCacheTaskResponseBody : Tea.TeaModel {
    public class FlushCacheResults : Tea.TeaModel {
        public class DnsNodes : Tea.TeaModel {
            public class Answers : Tea.TeaModel {
                public var name: String?

                public var record: String?

                public var ttl: Int64?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.record != nil {
                        map["Record"] = self.record!
                    }
                    if self.ttl != nil {
                        map["Ttl"] = self.ttl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Record") {
                        self.record = dict["Record"] as! String
                    }
                    if dict.keys.contains("Ttl") {
                        self.ttl = dict["Ttl"] as! Int64
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var answers: [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes.Answers]?

            public var nodeIp: String?

            public var spName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answers != nil {
                    var tmp : [Any] = []
                    for k in self.answers! {
                        tmp.append(k.toMap())
                    }
                    map["Answers"] = tmp
                }
                if self.nodeIp != nil {
                    map["NodeIp"] = self.nodeIp!
                }
                if self.spName != nil {
                    map["SpName"] = self.spName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Answers") {
                    self.answers = dict["Answers"] as! [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes.Answers]
                }
                if dict.keys.contains("NodeIp") {
                    self.nodeIp = dict["NodeIp"] as! String
                }
                if dict.keys.contains("SpName") {
                    self.spName = dict["SpName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var dnsNodes: [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes]?

        public var province: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsNodes != nil {
                var tmp : [Any] = []
                for k in self.dnsNodes! {
                    tmp.append(k.toMap())
                }
                map["DnsNodes"] = tmp
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsNodes") {
                self.dnsNodes = dict["DnsNodes"] as! [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes]
            }
            if dict.keys.contains("Province") {
                self.province = dict["Province"] as! String
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var domainName: String?

    public var flushCacheResults: [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults]?

    public var instanceId: String?

    public var instanceName: String?

    public var isp: String?

    public var requestId: String?

    public var taskId: String?

    public var taskStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.flushCacheResults != nil {
            var tmp : [Any] = []
            for k in self.flushCacheResults! {
                tmp.append(k.toMap())
            }
            map["FlushCacheResults"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("FlushCacheResults") {
            self.flushCacheResults = dict["FlushCacheResults"] as! [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskStatus") {
            self.taskStatus = dict["TaskStatus"] as! String
        }
    }
}

public class DescribeIspFlushCacheTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIspFlushCacheTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIspFlushCacheTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIspFlushCacheTasksRequest : Tea.TeaModel {
    public var direction: String?

    public var domainName: String?

    public var instanceId: String?

    public var isp: String?

    public var lang: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeIspFlushCacheTasksResponseBody : Tea.TeaModel {
    public class IspFlushCacheTasks : Tea.TeaModel {
        public var createTime: String?

        public var createTimestamp: Int64?

        public var domainName: String?

        public var instanceId: String?

        public var instanceName: String?

        public var isp: String?

        public var taskId: String?

        public var taskStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.isp != nil {
                map["Isp"] = self.isp!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("Isp") {
                self.isp = dict["Isp"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskStatus") {
                self.taskStatus = dict["TaskStatus"] as! String
            }
        }
    }
    public var ispFlushCacheTasks: [DescribeIspFlushCacheTasksResponseBody.IspFlushCacheTasks]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ispFlushCacheTasks != nil {
            var tmp : [Any] = []
            for k in self.ispFlushCacheTasks! {
                tmp.append(k.toMap())
            }
            map["IspFlushCacheTasks"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IspFlushCacheTasks") {
            self.ispFlushCacheTasks = dict["IspFlushCacheTasks"] as! [DescribeIspFlushCacheTasksResponseBody.IspFlushCacheTasks]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeIspFlushCacheTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIspFlushCacheTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIspFlushCacheTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsAccountSummaryRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribePdnsAccountSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var domainCount: Int64?

        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var subDomainCount: Int64?

        public var threatCount: Int64?

        public var totalCount: Int64?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainCount != nil {
                map["DomainCount"] = self.domainCount!
            }
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.subDomainCount != nil {
                map["SubDomainCount"] = self.subDomainCount!
            }
            if self.threatCount != nil {
                map["ThreatCount"] = self.threatCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainCount") {
                self.domainCount = dict["DomainCount"] as! Int64
            }
            if dict.keys.contains("HttpCount") {
                self.httpCount = dict["HttpCount"] as! Int64
            }
            if dict.keys.contains("HttpsCount") {
                self.httpsCount = dict["HttpsCount"] as! Int64
            }
            if dict.keys.contains("SubDomainCount") {
                self.subDomainCount = dict["SubDomainCount"] as! Int64
            }
            if dict.keys.contains("ThreatCount") {
                self.threatCount = dict["ThreatCount"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var data: DescribePdnsAccountSummaryResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribePdnsAccountSummaryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePdnsAccountSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsAccountSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsAccountSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsAppKeyRequest : Tea.TeaModel {
    public var appKeyId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKeyId != nil {
            map["AppKeyId"] = self.appKeyId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppKeyId") {
            self.appKeyId = dict["AppKeyId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribePdnsAppKeyResponseBody : Tea.TeaModel {
    public class AppKey : Tea.TeaModel {
        public var appKeyId: String?

        public var appKeySecret: String?

        public var createDate: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appKeyId != nil {
                map["AppKeyId"] = self.appKeyId!
            }
            if self.appKeySecret != nil {
                map["AppKeySecret"] = self.appKeySecret!
            }
            if self.createDate != nil {
                map["CreateDate"] = self.createDate!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppKeyId") {
                self.appKeyId = dict["AppKeyId"] as! String
            }
            if dict.keys.contains("AppKeySecret") {
                self.appKeySecret = dict["AppKeySecret"] as! String
            }
            if dict.keys.contains("CreateDate") {
                self.createDate = dict["CreateDate"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var appKey: DescribePdnsAppKeyResponseBody.AppKey?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appKey?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKey != nil {
            map["AppKey"] = self.appKey?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppKey") {
            var model = DescribePdnsAppKeyResponseBody.AppKey()
            model.fromMap(dict["AppKey"] as! [String: Any])
            self.appKey = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePdnsAppKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsAppKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsAppKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsAppKeysRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribePdnsAppKeysResponseBody : Tea.TeaModel {
    public class AppKeys : Tea.TeaModel {
        public var appKeyId: String?

        public var createDate: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appKeyId != nil {
                map["AppKeyId"] = self.appKeyId!
            }
            if self.createDate != nil {
                map["CreateDate"] = self.createDate!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppKeyId") {
                self.appKeyId = dict["AppKeyId"] as! String
            }
            if dict.keys.contains("CreateDate") {
                self.createDate = dict["CreateDate"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var appKeys: [DescribePdnsAppKeysResponseBody.AppKeys]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKeys != nil {
            var tmp : [Any] = []
            for k in self.appKeys! {
                tmp.append(k.toMap())
            }
            map["AppKeys"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppKeys") {
            self.appKeys = dict["AppKeys"] as! [DescribePdnsAppKeysResponseBody.AppKeys]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePdnsAppKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsAppKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsAppKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsOperateLogsRequest : Tea.TeaModel {
    public var actionType: String?

    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["ActionType"] = self.actionType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionType") {
            self.actionType = dict["ActionType"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribePdnsOperateLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public var action: String?

        public var operateTime: String?

        public var type: String?

        public var content: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.operateTime != nil {
                map["OperateTime"] = self.operateTime!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.content != nil {
                map["content"] = self.content!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("OperateTime") {
                self.operateTime = dict["OperateTime"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
        }
    }
    public var logs: [DescribePdnsOperateLogsResponseBody.Logs]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            var tmp : [Any] = []
            for k in self.logs! {
                tmp.append(k.toMap())
            }
            map["Logs"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logs") {
            self.logs = dict["Logs"] as! [DescribePdnsOperateLogsResponseBody.Logs]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePdnsOperateLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsOperateLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsOperateLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsRequestStatisticRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
    }
}

public class DescribePdnsRequestStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dohTotalCount: Int64?

        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var ipCount: Int64?

        public var timestamp: Int64?

        public var totalCount: Int64?

        public var udpTotalCount: Int64?

        public var v4Count: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6Count: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dohTotalCount != nil {
                map["DohTotalCount"] = self.dohTotalCount!
            }
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.udpTotalCount != nil {
                map["UdpTotalCount"] = self.udpTotalCount!
            }
            if self.v4Count != nil {
                map["V4Count"] = self.v4Count!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6Count != nil {
                map["V6Count"] = self.v6Count!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DohTotalCount") {
                self.dohTotalCount = dict["DohTotalCount"] as! Int64
            }
            if dict.keys.contains("HttpCount") {
                self.httpCount = dict["HttpCount"] as! Int64
            }
            if dict.keys.contains("HttpsCount") {
                self.httpsCount = dict["HttpsCount"] as! Int64
            }
            if dict.keys.contains("IpCount") {
                self.ipCount = dict["IpCount"] as! Int64
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("UdpTotalCount") {
                self.udpTotalCount = dict["UdpTotalCount"] as! Int64
            }
            if dict.keys.contains("V4Count") {
                self.v4Count = dict["V4Count"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6Count") {
                self.v6Count = dict["V6Count"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var data: [DescribePdnsRequestStatisticResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribePdnsRequestStatisticResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePdnsRequestStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsRequestStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsRequestStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsRequestStatisticsRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var subDomain: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribePdnsRequestStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ThreatInfo : Tea.TeaModel {
            public var threatLevel: String?

            public var threatType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.threatLevel != nil {
                    map["ThreatLevel"] = self.threatLevel!
                }
                if self.threatType != nil {
                    map["ThreatType"] = self.threatType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ThreatLevel") {
                    self.threatLevel = dict["ThreatLevel"] as! String
                }
                if dict.keys.contains("ThreatType") {
                    self.threatType = dict["ThreatType"] as! String
                }
            }
        }
        public var dohTotalCount: Int64?

        public var domainName: String?

        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var ipCount: Int64?

        public var maxThreatLevel: String?

        public var subDomain: String?

        public var threatCount: Int64?

        public var threatInfo: [DescribePdnsRequestStatisticsResponseBody.Data.ThreatInfo]?

        public var totalCount: Int64?

        public var udpTotalCount: Int64?

        public var v4Count: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6Count: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dohTotalCount != nil {
                map["DohTotalCount"] = self.dohTotalCount!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.maxThreatLevel != nil {
                map["MaxThreatLevel"] = self.maxThreatLevel!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            if self.threatCount != nil {
                map["ThreatCount"] = self.threatCount!
            }
            if self.threatInfo != nil {
                var tmp : [Any] = []
                for k in self.threatInfo! {
                    tmp.append(k.toMap())
                }
                map["ThreatInfo"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.udpTotalCount != nil {
                map["UdpTotalCount"] = self.udpTotalCount!
            }
            if self.v4Count != nil {
                map["V4Count"] = self.v4Count!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6Count != nil {
                map["V6Count"] = self.v6Count!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DohTotalCount") {
                self.dohTotalCount = dict["DohTotalCount"] as! Int64
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("HttpCount") {
                self.httpCount = dict["HttpCount"] as! Int64
            }
            if dict.keys.contains("HttpsCount") {
                self.httpsCount = dict["HttpsCount"] as! Int64
            }
            if dict.keys.contains("IpCount") {
                self.ipCount = dict["IpCount"] as! Int64
            }
            if dict.keys.contains("MaxThreatLevel") {
                self.maxThreatLevel = dict["MaxThreatLevel"] as! String
            }
            if dict.keys.contains("SubDomain") {
                self.subDomain = dict["SubDomain"] as! String
            }
            if dict.keys.contains("ThreatCount") {
                self.threatCount = dict["ThreatCount"] as! Int64
            }
            if dict.keys.contains("ThreatInfo") {
                self.threatInfo = dict["ThreatInfo"] as! [DescribePdnsRequestStatisticsResponseBody.Data.ThreatInfo]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("UdpTotalCount") {
                self.udpTotalCount = dict["UdpTotalCount"] as! Int64
            }
            if dict.keys.contains("V4Count") {
                self.v4Count = dict["V4Count"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6Count") {
                self.v6Count = dict["V6Count"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var data: [DescribePdnsRequestStatisticsResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribePdnsRequestStatisticsResponseBody.Data]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePdnsRequestStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsRequestStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsRequestStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsThreatLogsRequest : Tea.TeaModel {
    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var threatLevel: String?

    public var threatSourceIp: String?

    public var threatType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threatLevel != nil {
            map["ThreatLevel"] = self.threatLevel!
        }
        if self.threatSourceIp != nil {
            map["ThreatSourceIp"] = self.threatSourceIp!
        }
        if self.threatType != nil {
            map["ThreatType"] = self.threatType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("ThreatLevel") {
            self.threatLevel = dict["ThreatLevel"] as! String
        }
        if dict.keys.contains("ThreatSourceIp") {
            self.threatSourceIp = dict["ThreatSourceIp"] as! String
        }
        if dict.keys.contains("ThreatType") {
            self.threatType = dict["ThreatType"] as! String
        }
    }
}

public class DescribePdnsThreatLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public var sourceIp: String?

        public var subDomain: String?

        public var threatLevel: String?

        public var threatTime: String?

        public var threatType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceIp != nil {
                map["SourceIp"] = self.sourceIp!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            if self.threatLevel != nil {
                map["ThreatLevel"] = self.threatLevel!
            }
            if self.threatTime != nil {
                map["ThreatTime"] = self.threatTime!
            }
            if self.threatType != nil {
                map["ThreatType"] = self.threatType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SourceIp") {
                self.sourceIp = dict["SourceIp"] as! String
            }
            if dict.keys.contains("SubDomain") {
                self.subDomain = dict["SubDomain"] as! String
            }
            if dict.keys.contains("ThreatLevel") {
                self.threatLevel = dict["ThreatLevel"] as! String
            }
            if dict.keys.contains("ThreatTime") {
                self.threatTime = dict["ThreatTime"] as! String
            }
            if dict.keys.contains("ThreatType") {
                self.threatType = dict["ThreatType"] as! String
            }
        }
    }
    public var logs: [DescribePdnsThreatLogsResponseBody.Logs]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            var tmp : [Any] = []
            for k in self.logs! {
                tmp.append(k.toMap())
            }
            map["Logs"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logs") {
            self.logs = dict["Logs"] as! [DescribePdnsThreatLogsResponseBody.Logs]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePdnsThreatLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsThreatLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsThreatLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsThreatStatisticRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public var threatSourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threatSourceIp != nil {
            map["ThreatSourceIp"] = self.threatSourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("ThreatSourceIp") {
            self.threatSourceIp = dict["ThreatSourceIp"] as! String
        }
    }
}

public class DescribePdnsThreatStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dohTotalCount: Int64?

        public var threatLevel: String?

        public var threatType: String?

        public var timestamp: Int64?

        public var totalCount: Int64?

        public var udpTotalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dohTotalCount != nil {
                map["DohTotalCount"] = self.dohTotalCount!
            }
            if self.threatLevel != nil {
                map["ThreatLevel"] = self.threatLevel!
            }
            if self.threatType != nil {
                map["ThreatType"] = self.threatType!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.udpTotalCount != nil {
                map["UdpTotalCount"] = self.udpTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DohTotalCount") {
                self.dohTotalCount = dict["DohTotalCount"] as! Int64
            }
            if dict.keys.contains("ThreatLevel") {
                self.threatLevel = dict["ThreatLevel"] as! String
            }
            if dict.keys.contains("ThreatType") {
                self.threatType = dict["ThreatType"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("UdpTotalCount") {
                self.udpTotalCount = dict["UdpTotalCount"] as! Int64
            }
        }
    }
    public var data: [DescribePdnsThreatStatisticResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribePdnsThreatStatisticResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePdnsThreatStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsThreatStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsThreatStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsThreatStatisticsRequest : Tea.TeaModel {
    public var direction: String?

    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var orderBy: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var subDomain: String?

    public var threatLevel: String?

    public var threatSourceIp: String?

    public var threatType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.threatLevel != nil {
            map["ThreatLevel"] = self.threatLevel!
        }
        if self.threatSourceIp != nil {
            map["ThreatSourceIp"] = self.threatSourceIp!
        }
        if self.threatType != nil {
            map["ThreatType"] = self.threatType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
        if dict.keys.contains("ThreatLevel") {
            self.threatLevel = dict["ThreatLevel"] as! String
        }
        if dict.keys.contains("ThreatSourceIp") {
            self.threatSourceIp = dict["ThreatSourceIp"] as! String
        }
        if dict.keys.contains("ThreatType") {
            self.threatType = dict["ThreatType"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribePdnsThreatStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dohTotalCount: Int64?

        public var domainCount: Int64?

        public var domainName: String?

        public var latestThreatTime: Int64?

        public var maxThreatLevel: String?

        public var sourceIp: String?

        public var subDomain: String?

        public var threatLevel: String?

        public var threatType: String?

        public var totalCount: Int64?

        public var udpTotalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dohTotalCount != nil {
                map["DohTotalCount"] = self.dohTotalCount!
            }
            if self.domainCount != nil {
                map["DomainCount"] = self.domainCount!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.latestThreatTime != nil {
                map["LatestThreatTime"] = self.latestThreatTime!
            }
            if self.maxThreatLevel != nil {
                map["MaxThreatLevel"] = self.maxThreatLevel!
            }
            if self.sourceIp != nil {
                map["SourceIp"] = self.sourceIp!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            if self.threatLevel != nil {
                map["ThreatLevel"] = self.threatLevel!
            }
            if self.threatType != nil {
                map["ThreatType"] = self.threatType!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.udpTotalCount != nil {
                map["UdpTotalCount"] = self.udpTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DohTotalCount") {
                self.dohTotalCount = dict["DohTotalCount"] as! Int64
            }
            if dict.keys.contains("DomainCount") {
                self.domainCount = dict["DomainCount"] as! Int64
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("LatestThreatTime") {
                self.latestThreatTime = dict["LatestThreatTime"] as! Int64
            }
            if dict.keys.contains("MaxThreatLevel") {
                self.maxThreatLevel = dict["MaxThreatLevel"] as! String
            }
            if dict.keys.contains("SourceIp") {
                self.sourceIp = dict["SourceIp"] as! String
            }
            if dict.keys.contains("SubDomain") {
                self.subDomain = dict["SubDomain"] as! String
            }
            if dict.keys.contains("ThreatLevel") {
                self.threatLevel = dict["ThreatLevel"] as! String
            }
            if dict.keys.contains("ThreatType") {
                self.threatType = dict["ThreatType"] as! String
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("UdpTotalCount") {
                self.udpTotalCount = dict["UdpTotalCount"] as! Int64
            }
        }
    }
    public var data: [DescribePdnsThreatStatisticsResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribePdnsThreatStatisticsResponseBody.Data]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePdnsThreatStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsThreatStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsThreatStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsUdpIpSegmentsRequest : Tea.TeaModel {
    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribePdnsUdpIpSegmentsResponseBody : Tea.TeaModel {
    public class IpSegments : Tea.TeaModel {
        public var createDate: String?

        public var ip: String?

        public var mask: Int64?

        public var name: String?

        public var state: String?

        public var updateDate: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createDate != nil {
                map["CreateDate"] = self.createDate!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.mask != nil {
                map["Mask"] = self.mask!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.updateDate != nil {
                map["UpdateDate"] = self.updateDate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateDate") {
                self.createDate = dict["CreateDate"] as! String
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Mask") {
                self.mask = dict["Mask"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("UpdateDate") {
                self.updateDate = dict["UpdateDate"] as! String
            }
        }
    }
    public var ipSegments: [DescribePdnsUdpIpSegmentsResponseBody.IpSegments]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipSegments != nil {
            var tmp : [Any] = []
            for k in self.ipSegments! {
                tmp.append(k.toMap())
            }
            map["IpSegments"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpSegments") {
            self.ipSegments = dict["IpSegments"] as! [DescribePdnsUdpIpSegmentsResponseBody.IpSegments]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePdnsUdpIpSegmentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsUdpIpSegmentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsUdpIpSegmentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsUserInfoRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribePdnsUserInfoResponseBody : Tea.TeaModel {
    public class UserInfo : Tea.TeaModel {
        public var availableService: String?

        public var pdnsId: Int64?

        public var serviceType: String?

        public var state: String?

        public var stoppedService: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableService != nil {
                map["AvailableService"] = self.availableService!
            }
            if self.pdnsId != nil {
                map["PdnsId"] = self.pdnsId!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.stoppedService != nil {
                map["StoppedService"] = self.stoppedService!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableService") {
                self.availableService = dict["AvailableService"] as! String
            }
            if dict.keys.contains("PdnsId") {
                self.pdnsId = dict["PdnsId"] as! Int64
            }
            if dict.keys.contains("ServiceType") {
                self.serviceType = dict["ServiceType"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("StoppedService") {
                self.stoppedService = dict["StoppedService"] as! String
            }
        }
    }
    public var requestId: String?

    public var userInfo: DescribePdnsUserInfoResponseBody.UserInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userInfo != nil {
            map["UserInfo"] = self.userInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserInfo") {
            var model = DescribePdnsUserInfoResponseBody.UserInfo()
            model.fromMap(dict["UserInfo"] as! [String: Any])
            self.userInfo = model
        }
    }
}

public class DescribePdnsUserInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsUserInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsUserInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecordLogsRequest : Tea.TeaModel {
    public var domainName: String?

    public var keyWord: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var userClientIp: String?

    public var endDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.endDate != nil {
            map["endDate"] = self.endDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
        if dict.keys.contains("endDate") {
            self.endDate = dict["endDate"] as! String
        }
    }
}

public class DescribeRecordLogsResponseBody : Tea.TeaModel {
    public class RecordLogs : Tea.TeaModel {
        public class RecordLog : Tea.TeaModel {
            public var action: String?

            public var actionTime: String?

            public var actionTimestamp: Int64?

            public var clientIp: String?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.actionTime != nil {
                    map["ActionTime"] = self.actionTime!
                }
                if self.actionTimestamp != nil {
                    map["ActionTimestamp"] = self.actionTimestamp!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ActionTime") {
                    self.actionTime = dict["ActionTime"] as! String
                }
                if dict.keys.contains("ActionTimestamp") {
                    self.actionTimestamp = dict["ActionTimestamp"] as! Int64
                }
                if dict.keys.contains("ClientIp") {
                    self.clientIp = dict["ClientIp"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public var recordLog: [DescribeRecordLogsResponseBody.RecordLogs.RecordLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordLog != nil {
                var tmp : [Any] = []
                for k in self.recordLog! {
                    tmp.append(k.toMap())
                }
                map["RecordLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecordLog") {
                self.recordLog = dict["RecordLog"] as! [DescribeRecordLogsResponseBody.RecordLogs.RecordLog]
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var recordLogs: DescribeRecordLogsResponseBody.RecordLogs?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordLogs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordLogs != nil {
            map["RecordLogs"] = self.recordLogs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RecordLogs") {
            var model = DescribeRecordLogsResponseBody.RecordLogs()
            model.fromMap(dict["RecordLogs"] as! [String: Any])
            self.recordLogs = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeRecordLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecordLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecordLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecordStatisticsRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainType: String?

    public var endDate: String?

    public var lang: String?

    public var rr: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.rr != nil {
            map["Rr"] = self.rr!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainType") {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Rr") {
            self.rr = dict["Rr"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeRecordStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public class Statistic : Tea.TeaModel {
            public var count: Int64?

            public var timestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
            }
        }
        public var statistic: [DescribeRecordStatisticsResponseBody.Statistics.Statistic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.statistic != nil {
                var tmp : [Any] = []
                for k in self.statistic! {
                    tmp.append(k.toMap())
                }
                map["Statistic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Statistic") {
                self.statistic = dict["Statistic"] as! [DescribeRecordStatisticsResponseBody.Statistics.Statistic]
            }
        }
    }
    public var requestId: String?

    public var statistics: DescribeRecordStatisticsResponseBody.Statistics?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var model = DescribeRecordStatisticsResponseBody.Statistics()
            model.fromMap(dict["Statistics"] as! [String: Any])
            self.statistics = model
        }
    }
}

public class DescribeRecordStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecordStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecordStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecordStatisticsSummaryRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainType: String?

    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var searchMode: String?

    public var startDate: String?

    public var threshold: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainType") {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SearchMode") {
            self.searchMode = dict["SearchMode"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Int64
        }
    }
}

public class DescribeRecordStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public class Statistic : Tea.TeaModel {
            public var count: Int64?

            public var subDomain: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.subDomain != nil {
                    map["SubDomain"] = self.subDomain!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("SubDomain") {
                    self.subDomain = dict["SubDomain"] as! String
                }
            }
        }
        public var statistic: [DescribeRecordStatisticsSummaryResponseBody.Statistics.Statistic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.statistic != nil {
                var tmp : [Any] = []
                for k in self.statistic! {
                    tmp.append(k.toMap())
                }
                map["Statistic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Statistic") {
                self.statistic = dict["Statistic"] as! [DescribeRecordStatisticsSummaryResponseBody.Statistics.Statistic]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: DescribeRecordStatisticsSummaryResponseBody.Statistics?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var model = DescribeRecordStatisticsSummaryResponseBody.Statistics()
            model.fromMap(dict["Statistics"] as! [String: Any])
            self.statistics = model
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeRecordStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecordStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecordStatisticsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSubDomainRecordsRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var line: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var subDomain: String?

    public var type: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Line") {
            self.line = dict["Line"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DescribeSubDomainRecordsResponseBody : Tea.TeaModel {
    public class DomainRecords : Tea.TeaModel {
        public class Record : Tea.TeaModel {
            public var domainName: String?

            public var line: String?

            public var locked: Bool?

            public var priority: Int64?

            public var RR: String?

            public var recordId: String?

            public var status: String?

            public var TTL: Int64?

            public var type: String?

            public var value: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.line != nil {
                    map["Line"] = self.line!
                }
                if self.locked != nil {
                    map["Locked"] = self.locked!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.RR != nil {
                    map["RR"] = self.RR!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.TTL != nil {
                    map["TTL"] = self.TTL!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Line") {
                    self.line = dict["Line"] as! String
                }
                if dict.keys.contains("Locked") {
                    self.locked = dict["Locked"] as! Bool
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int64
                }
                if dict.keys.contains("RR") {
                    self.RR = dict["RR"] as! String
                }
                if dict.keys.contains("RecordId") {
                    self.recordId = dict["RecordId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TTL") {
                    self.TTL = dict["TTL"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var record: [DescribeSubDomainRecordsResponseBody.DomainRecords.Record]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.record != nil {
                var tmp : [Any] = []
                for k in self.record! {
                    tmp.append(k.toMap())
                }
                map["Record"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Record") {
                self.record = dict["Record"] as! [DescribeSubDomainRecordsResponseBody.DomainRecords.Record]
            }
        }
    }
    public var domainRecords: DescribeSubDomainRecordsResponseBody.DomainRecords?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainRecords?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainRecords != nil {
            map["DomainRecords"] = self.domainRecords?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainRecords") {
            var model = DescribeSubDomainRecordsResponseBody.DomainRecords()
            model.fromMap(dict["DomainRecords"] as! [String: Any])
            self.domainRecords = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeSubDomainRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSubDomainRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSubDomainRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSupportLinesRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DescribeSupportLinesResponseBody : Tea.TeaModel {
    public class RecordLines : Tea.TeaModel {
        public class RecordLine : Tea.TeaModel {
            public var fatherCode: String?

            public var lineCode: String?

            public var lineDisplayName: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineDisplayName != nil {
                    map["LineDisplayName"] = self.lineDisplayName!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FatherCode") {
                    self.fatherCode = dict["FatherCode"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineDisplayName") {
                    self.lineDisplayName = dict["LineDisplayName"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
            }
        }
        public var recordLine: [DescribeSupportLinesResponseBody.RecordLines.RecordLine]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordLine != nil {
                var tmp : [Any] = []
                for k in self.recordLine! {
                    tmp.append(k.toMap())
                }
                map["RecordLine"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecordLine") {
                self.recordLine = dict["RecordLine"] as! [DescribeSupportLinesResponseBody.RecordLines.RecordLine]
            }
        }
    }
    public var recordLines: DescribeSupportLinesResponseBody.RecordLines?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordLines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordLines != nil {
            map["RecordLines"] = self.recordLines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordLines") {
            var model = DescribeSupportLinesResponseBody.RecordLines()
            model.fromMap(dict["RecordLines"] as! [String: Any])
            self.recordLines = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSupportLinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSupportLinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSupportLinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagsRequest : Tea.TeaModel {
    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeTagsResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var values: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.values != nil {
                map["Values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Values") {
                self.values = dict["Values"] as! [String]
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var tags: [DescribeTagsResponseBody.Tags]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! [DescribeTagsResponseBody.Tags]
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTransferDomainsRequest : Tea.TeaModel {
    public var domainName: String?

    public var fromUserId: Int64?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var targetUserId: Int64?

    public var transferType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.fromUserId != nil {
            map["FromUserId"] = self.fromUserId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        if self.transferType != nil {
            map["TransferType"] = self.transferType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("FromUserId") {
            self.fromUserId = dict["FromUserId"] as! Int64
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("TargetUserId") {
            self.targetUserId = dict["TargetUserId"] as! Int64
        }
        if dict.keys.contains("TransferType") {
            self.transferType = dict["TransferType"] as! String
        }
    }
}

public class DescribeTransferDomainsResponseBody : Tea.TeaModel {
    public class DomainTransfers : Tea.TeaModel {
        public class DomainTransfer : Tea.TeaModel {
            public var createTime: String?

            public var createTimestamp: Int64?

            public var domainName: String?

            public var fromUserId: Int64?

            public var id: Int64?

            public var targetUserId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.fromUserId != nil {
                    map["FromUserId"] = self.fromUserId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.targetUserId != nil {
                    map["TargetUserId"] = self.targetUserId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("FromUserId") {
                    self.fromUserId = dict["FromUserId"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("TargetUserId") {
                    self.targetUserId = dict["TargetUserId"] as! Int64
                }
            }
        }
        public var domainTransfer: [DescribeTransferDomainsResponseBody.DomainTransfers.DomainTransfer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainTransfer != nil {
                var tmp : [Any] = []
                for k in self.domainTransfer! {
                    tmp.append(k.toMap())
                }
                map["DomainTransfer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainTransfer") {
                self.domainTransfer = dict["DomainTransfer"] as! [DescribeTransferDomainsResponseBody.DomainTransfers.DomainTransfer]
            }
        }
    }
    public var domainTransfers: DescribeTransferDomainsResponseBody.DomainTransfers?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainTransfers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainTransfers != nil {
            map["DomainTransfers"] = self.domainTransfers?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainTransfers") {
            var model = DescribeTransferDomainsResponseBody.DomainTransfers()
            model.fromMap(dict["DomainTransfers"] as! [String: Any])
            self.domainTransfers = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeTransferDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTransferDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTransferDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
    }
}

public class ExecuteGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExecuteGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExecuteGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMainDomainNameRequest : Tea.TeaModel {
    public var inputString: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputString != nil {
            map["InputString"] = self.inputString!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputString") {
            self.inputString = dict["InputString"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class GetMainDomainNameResponseBody : Tea.TeaModel {
    public var domainLevel: Int64?

    public var domainName: String?

    public var RR: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLevel != nil {
            map["DomainLevel"] = self.domainLevel!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainLevel") {
            self.domainLevel = dict["DomainLevel"] as! Int64
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMainDomainNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMainDomainNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMainDomainNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTxtRecordForVerifyRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetTxtRecordForVerifyResponseBody : Tea.TeaModel {
    public var domainName: String?

    public var RR: String?

    public var requestId: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class GetTxtRecordForVerifyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTxtRecordForVerifyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTxtRecordForVerifyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var lang: String?

    public var nextToken: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [ListTagResourcesRequest.Tag]
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("TagKey") {
                self.tagKey = dict["TagKey"] as! String
            }
            if dict.keys.contains("TagValue") {
                self.tagValue = dict["TagValue"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: [ListTagResourcesResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            self.tagResources = dict["TagResources"] as! [ListTagResourcesResponseBody.TagResources]
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyHichinaDomainDNSRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class ModifyHichinaDomainDNSResponseBody : Tea.TeaModel {
    public class NewDnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServer") {
                self.dnsServer = dict["DnsServer"] as! [String]
            }
        }
    }
    public class OriginalDnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServer") {
                self.dnsServer = dict["DnsServer"] as! [String]
            }
        }
    }
    public var newDnsServers: ModifyHichinaDomainDNSResponseBody.NewDnsServers?

    public var originalDnsServers: ModifyHichinaDomainDNSResponseBody.OriginalDnsServers?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.newDnsServers?.validate()
        try self.originalDnsServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newDnsServers != nil {
            map["NewDnsServers"] = self.newDnsServers?.toMap()
        }
        if self.originalDnsServers != nil {
            map["OriginalDnsServers"] = self.originalDnsServers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NewDnsServers") {
            var model = ModifyHichinaDomainDNSResponseBody.NewDnsServers()
            model.fromMap(dict["NewDnsServers"] as! [String: Any])
            self.newDnsServers = model
        }
        if dict.keys.contains("OriginalDnsServers") {
            var model = ModifyHichinaDomainDNSResponseBody.OriginalDnsServers()
            model.fromMap(dict["OriginalDnsServers"] as! [String: Any])
            self.originalDnsServers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyHichinaDomainDNSResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHichinaDomainDNSResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyHichinaDomainDNSResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveDomainResourceGroupRequest : Tea.TeaModel {
    public var lang: String?

    public var newResourceGroupId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NewResourceGroupId") {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class MoveDomainResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MoveDomainResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveDomainResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveDomainResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveGtmResourceGroupRequest : Tea.TeaModel {
    public var lang: String?

    public var newResourceGroupId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NewResourceGroupId") {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class MoveGtmResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MoveGtmResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveGtmResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveGtmResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateBatchDomainRequest : Tea.TeaModel {
    public class DomainRecordInfo : Tea.TeaModel {
        public var domain: String?

        public var line: String?

        public var newRr: String?

        public var newType: String?

        public var newValue: String?

        public var priority: Int32?

        public var rr: String?

        public var ttl: Int32?

        public var type: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.line != nil {
                map["Line"] = self.line!
            }
            if self.newRr != nil {
                map["NewRr"] = self.newRr!
            }
            if self.newType != nil {
                map["NewType"] = self.newType!
            }
            if self.newValue != nil {
                map["NewValue"] = self.newValue!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.rr != nil {
                map["Rr"] = self.rr!
            }
            if self.ttl != nil {
                map["Ttl"] = self.ttl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Line") {
                self.line = dict["Line"] as! String
            }
            if dict.keys.contains("NewRr") {
                self.newRr = dict["NewRr"] as! String
            }
            if dict.keys.contains("NewType") {
                self.newType = dict["NewType"] as! String
            }
            if dict.keys.contains("NewValue") {
                self.newValue = dict["NewValue"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Rr") {
                self.rr = dict["Rr"] as! String
            }
            if dict.keys.contains("Ttl") {
                self.ttl = dict["Ttl"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var domainRecordInfo: [OperateBatchDomainRequest.DomainRecordInfo]?

    public var lang: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainRecordInfo != nil {
            var tmp : [Any] = []
            for k in self.domainRecordInfo! {
                tmp.append(k.toMap())
            }
            map["DomainRecordInfo"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainRecordInfo") {
            self.domainRecordInfo = dict["DomainRecordInfo"] as! [OperateBatchDomainRequest.DomainRecordInfo]
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class OperateBatchDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class OperateBatchDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateBatchDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OperateBatchDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PausePdnsServiceRequest : Tea.TeaModel {
    public var lang: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ServiceType") {
            self.serviceType = dict["ServiceType"] as! String
        }
    }
}

public class PausePdnsServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PausePdnsServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PausePdnsServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PausePdnsServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PreviewGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
    }
}

public class PreviewGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public class Previews : Tea.TeaModel {
        public class Preview : Tea.TeaModel {
            public class SwitchInfos : Tea.TeaModel {
                public class SwitchInfo : Tea.TeaModel {
                    public var content: String?

                    public var strategyName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.strategyName != nil {
                            map["StrategyName"] = self.strategyName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("StrategyName") {
                            self.strategyName = dict["StrategyName"] as! String
                        }
                    }
                }
                public var switchInfo: [PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos.SwitchInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.switchInfo != nil {
                        var tmp : [Any] = []
                        for k in self.switchInfo! {
                            tmp.append(k.toMap())
                        }
                        map["SwitchInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SwitchInfo") {
                        self.switchInfo = dict["SwitchInfo"] as! [PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos.SwitchInfo]
                    }
                }
            }
            public var instanceId: String?

            public var name: String?

            public var switchInfos: PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos?

            public var userDomainName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.switchInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.switchInfos != nil {
                    map["SwitchInfos"] = self.switchInfos?.toMap()
                }
                if self.userDomainName != nil {
                    map["UserDomainName"] = self.userDomainName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SwitchInfos") {
                    var model = PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos()
                    model.fromMap(dict["SwitchInfos"] as! [String: Any])
                    self.switchInfos = model
                }
                if dict.keys.contains("UserDomainName") {
                    self.userDomainName = dict["UserDomainName"] as! String
                }
            }
        }
        public var preview: [PreviewGtmRecoveryPlanResponseBody.Previews.Preview]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preview != nil {
                var tmp : [Any] = []
                for k in self.preview! {
                    tmp.append(k.toMap())
                }
                map["Preview"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Preview") {
                self.preview = dict["Preview"] as! [PreviewGtmRecoveryPlanResponseBody.Previews.Preview]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var previews: PreviewGtmRecoveryPlanResponseBody.Previews?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.previews?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.previews != nil {
            map["Previews"] = self.previews?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Previews") {
            var model = PreviewGtmRecoveryPlanResponseBody.Previews()
            model.fromMap(dict["Previews"] as! [String: Any])
            self.previews = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class PreviewGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PreviewGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PreviewGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePdnsAppKeyRequest : Tea.TeaModel {
    public var appKeyId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKeyId != nil {
            map["AppKeyId"] = self.appKeyId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppKeyId") {
            self.appKeyId = dict["AppKeyId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class RemovePdnsAppKeyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePdnsAppKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePdnsAppKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemovePdnsAppKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePdnsUdpIpSegmentRequest : Tea.TeaModel {
    public var ip: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class RemovePdnsUdpIpSegmentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePdnsUdpIpSegmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePdnsUdpIpSegmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemovePdnsUdpIpSegmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumePdnsServiceRequest : Tea.TeaModel {
    public var lang: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ServiceType") {
            self.serviceType = dict["ServiceType"] as! String
        }
    }
}

public class ResumePdnsServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResumePdnsServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumePdnsServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumePdnsServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetrieveDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class RetrieveDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RetrieveDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetrieveDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RetrieveDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RollbackGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
    }
}

public class RollbackGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RollbackGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RollbackGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDNSSLBStatusRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var line: String?

    public var open_: Bool?

    public var subDomain: String?

    public var type: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.open_ != nil {
            map["Open"] = self.open_!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Line") {
            self.line = dict["Line"] as! String
        }
        if dict.keys.contains("Open") {
            self.open_ = dict["Open"] as! Bool
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class SetDNSSLBStatusResponseBody : Tea.TeaModel {
    public var open_: Bool?

    public var recordCount: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.open_ != nil {
            map["Open"] = self.open_!
        }
        if self.recordCount != nil {
            map["RecordCount"] = self.recordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Open") {
            self.open_ = dict["Open"] as! Bool
        }
        if dict.keys.contains("RecordCount") {
            self.recordCount = dict["RecordCount"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDNSSLBStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDNSSLBStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDNSSLBStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDnsGtmAccessModeRequest : Tea.TeaModel {
    public var accessMode: String?

    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessMode") {
            self.accessMode = dict["AccessMode"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class SetDnsGtmAccessModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDnsGtmAccessModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDnsGtmAccessModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDnsGtmAccessModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDnsGtmMonitorStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var monitorConfigId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class SetDnsGtmMonitorStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDnsGtmMonitorStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDnsGtmMonitorStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDnsGtmMonitorStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDomainDnssecStatusRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class SetDomainDnssecStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDomainDnssecStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDomainDnssecStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDomainDnssecStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDomainRecordStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var status: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class SetDomainRecordStatusResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class SetDomainRecordStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDomainRecordStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDomainRecordStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetGtmAccessModeRequest : Tea.TeaModel {
    public var accessMode: String?

    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessMode") {
            self.accessMode = dict["AccessMode"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class SetGtmAccessModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetGtmAccessModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetGtmAccessModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetGtmAccessModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetGtmMonitorStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var monitorConfigId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class SetGtmMonitorStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetGtmMonitorStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetGtmMonitorStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetGtmMonitorStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitIspFlushCacheTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public var domainName: String?

    public var isp: [String]?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! [String]
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class SubmitIspFlushCacheTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitIspFlushCacheTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitIspFlushCacheTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitIspFlushCacheTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchDnsGtmInstanceStrategyModeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var strategyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyMode") {
            self.strategyMode = dict["StrategyMode"] as! String
        }
    }
}

public class SwitchDnsGtmInstanceStrategyModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SwitchDnsGtmInstanceStrategyModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchDnsGtmInstanceStrategyModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SwitchDnsGtmInstanceStrategyModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var lang: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [TagResourcesRequest.Tag]
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TransferDomainRequest : Tea.TeaModel {
    public var domainNames: String?

    public var lang: String?

    public var remark: String?

    public var targetUserId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("TargetUserId") {
            self.targetUserId = dict["TargetUserId"] as! Int64
        }
    }
}

public class TransferDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class TransferDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransferDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TransferDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindInstanceDomainsRequest : Tea.TeaModel {
    public var domainNames: String?

    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class UnbindInstanceDomainsResponseBody : Tea.TeaModel {
    public var failedCount: Int32?

    public var requestId: String?

    public var successCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedCount") {
            self.failedCount = dict["FailedCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessCount") {
            self.successCount = dict["SuccessCount"] as! Int32
        }
    }
}

public class UnbindInstanceDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindInstanceDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnbindInstanceDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var lang: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAppKeyStateRequest : Tea.TeaModel {
    public var appKeyId: String?

    public var lang: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKeyId != nil {
            map["AppKeyId"] = self.appKeyId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppKeyId") {
            self.appKeyId = dict["AppKeyId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class UpdateAppKeyStateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAppKeyStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAppKeyStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAppKeyStateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCustomLineRequest : Tea.TeaModel {
    public class IpSegment : Tea.TeaModel {
        public var endIp: String?

        public var startIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endIp != nil {
                map["EndIp"] = self.endIp!
            }
            if self.startIp != nil {
                map["StartIp"] = self.startIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndIp") {
                self.endIp = dict["EndIp"] as! String
            }
            if dict.keys.contains("StartIp") {
                self.startIp = dict["StartIp"] as! String
            }
        }
    }
    public var ipSegment: [UpdateCustomLineRequest.IpSegment]?

    public var lang: String?

    public var lineId: Int64?

    public var lineName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipSegment != nil {
            var tmp : [Any] = []
            for k in self.ipSegment! {
                tmp.append(k.toMap())
            }
            map["IpSegment"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lineId != nil {
            map["LineId"] = self.lineId!
        }
        if self.lineName != nil {
            map["LineName"] = self.lineName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpSegment") {
            self.ipSegment = dict["IpSegment"] as! [UpdateCustomLineRequest.IpSegment]
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LineId") {
            self.lineId = dict["LineId"] as! Int64
        }
        if dict.keys.contains("LineName") {
            self.lineName = dict["LineName"] as! String
        }
    }
}

public class UpdateCustomLineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCustomLineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomLineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCustomLineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDNSSLBWeightRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var userClientIp: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class UpdateDNSSLBWeightResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class UpdateDNSSLBWeightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDNSSLBWeightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDNSSLBWeightResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDnsCacheDomainRequest : Tea.TeaModel {
    public class SourceDnsServer : Tea.TeaModel {
        public var host: String?

        public var port: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
        }
    }
    public var cacheTtlMax: Int32?

    public var cacheTtlMin: Int32?

    public var domainName: String?

    public var instanceId: String?

    public var lang: String?

    public var sourceDnsServer: [UpdateDnsCacheDomainRequest.SourceDnsServer]?

    public var sourceEdns: String?

    public var sourceProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cacheTtlMax != nil {
            map["CacheTtlMax"] = self.cacheTtlMax!
        }
        if self.cacheTtlMin != nil {
            map["CacheTtlMin"] = self.cacheTtlMin!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceDnsServer != nil {
            var tmp : [Any] = []
            for k in self.sourceDnsServer! {
                tmp.append(k.toMap())
            }
            map["SourceDnsServer"] = tmp
        }
        if self.sourceEdns != nil {
            map["SourceEdns"] = self.sourceEdns!
        }
        if self.sourceProtocol != nil {
            map["SourceProtocol"] = self.sourceProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CacheTtlMax") {
            self.cacheTtlMax = dict["CacheTtlMax"] as! Int32
        }
        if dict.keys.contains("CacheTtlMin") {
            self.cacheTtlMin = dict["CacheTtlMin"] as! Int32
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceDnsServer") {
            self.sourceDnsServer = dict["SourceDnsServer"] as! [UpdateDnsCacheDomainRequest.SourceDnsServer]
        }
        if dict.keys.contains("SourceEdns") {
            self.sourceEdns = dict["SourceEdns"] as! String
        }
        if dict.keys.contains("SourceProtocol") {
            self.sourceProtocol = dict["SourceProtocol"] as! String
        }
    }
}

public class UpdateDnsCacheDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDnsCacheDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsCacheDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDnsCacheDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDnsCacheDomainRemarkRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class UpdateDnsCacheDomainRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDnsCacheDomainRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsCacheDomainRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDnsCacheDomainRemarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDnsGtmAccessStrategyRequest : Tea.TeaModel {
    public class DefaultAddrPool : Tea.TeaModel {
        public var id: String?

        public var lbaWeight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
        }
    }
    public class FailoverAddrPool : Tea.TeaModel {
        public var id: String?

        public var lbaWeight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
        }
    }
    public var accessMode: String?

    public var defaultAddrPool: [UpdateDnsGtmAccessStrategyRequest.DefaultAddrPool]?

    public var defaultAddrPoolType: String?

    public var defaultLatencyOptimization: String?

    public var defaultLbaStrategy: String?

    public var defaultMaxReturnAddrNum: Int32?

    public var defaultMinAvailableAddrNum: Int32?

    public var failoverAddrPool: [UpdateDnsGtmAccessStrategyRequest.FailoverAddrPool]?

    public var failoverAddrPoolType: String?

    public var failoverLatencyOptimization: String?

    public var failoverLbaStrategy: String?

    public var failoverMaxReturnAddrNum: Int32?

    public var failoverMinAvailableAddrNum: Int32?

    public var lang: String?

    public var lines: String?

    public var strategyId: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.defaultAddrPool != nil {
            var tmp : [Any] = []
            for k in self.defaultAddrPool! {
                tmp.append(k.toMap())
            }
            map["DefaultAddrPool"] = tmp
        }
        if self.defaultAddrPoolType != nil {
            map["DefaultAddrPoolType"] = self.defaultAddrPoolType!
        }
        if self.defaultLatencyOptimization != nil {
            map["DefaultLatencyOptimization"] = self.defaultLatencyOptimization!
        }
        if self.defaultLbaStrategy != nil {
            map["DefaultLbaStrategy"] = self.defaultLbaStrategy!
        }
        if self.defaultMaxReturnAddrNum != nil {
            map["DefaultMaxReturnAddrNum"] = self.defaultMaxReturnAddrNum!
        }
        if self.defaultMinAvailableAddrNum != nil {
            map["DefaultMinAvailableAddrNum"] = self.defaultMinAvailableAddrNum!
        }
        if self.failoverAddrPool != nil {
            var tmp : [Any] = []
            for k in self.failoverAddrPool! {
                tmp.append(k.toMap())
            }
            map["FailoverAddrPool"] = tmp
        }
        if self.failoverAddrPoolType != nil {
            map["FailoverAddrPoolType"] = self.failoverAddrPoolType!
        }
        if self.failoverLatencyOptimization != nil {
            map["FailoverLatencyOptimization"] = self.failoverLatencyOptimization!
        }
        if self.failoverLbaStrategy != nil {
            map["FailoverLbaStrategy"] = self.failoverLbaStrategy!
        }
        if self.failoverMaxReturnAddrNum != nil {
            map["FailoverMaxReturnAddrNum"] = self.failoverMaxReturnAddrNum!
        }
        if self.failoverMinAvailableAddrNum != nil {
            map["FailoverMinAvailableAddrNum"] = self.failoverMinAvailableAddrNum!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lines != nil {
            map["Lines"] = self.lines!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessMode") {
            self.accessMode = dict["AccessMode"] as! String
        }
        if dict.keys.contains("DefaultAddrPool") {
            self.defaultAddrPool = dict["DefaultAddrPool"] as! [UpdateDnsGtmAccessStrategyRequest.DefaultAddrPool]
        }
        if dict.keys.contains("DefaultAddrPoolType") {
            self.defaultAddrPoolType = dict["DefaultAddrPoolType"] as! String
        }
        if dict.keys.contains("DefaultLatencyOptimization") {
            self.defaultLatencyOptimization = dict["DefaultLatencyOptimization"] as! String
        }
        if dict.keys.contains("DefaultLbaStrategy") {
            self.defaultLbaStrategy = dict["DefaultLbaStrategy"] as! String
        }
        if dict.keys.contains("DefaultMaxReturnAddrNum") {
            self.defaultMaxReturnAddrNum = dict["DefaultMaxReturnAddrNum"] as! Int32
        }
        if dict.keys.contains("DefaultMinAvailableAddrNum") {
            self.defaultMinAvailableAddrNum = dict["DefaultMinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("FailoverAddrPool") {
            self.failoverAddrPool = dict["FailoverAddrPool"] as! [UpdateDnsGtmAccessStrategyRequest.FailoverAddrPool]
        }
        if dict.keys.contains("FailoverAddrPoolType") {
            self.failoverAddrPoolType = dict["FailoverAddrPoolType"] as! String
        }
        if dict.keys.contains("FailoverLatencyOptimization") {
            self.failoverLatencyOptimization = dict["FailoverLatencyOptimization"] as! String
        }
        if dict.keys.contains("FailoverLbaStrategy") {
            self.failoverLbaStrategy = dict["FailoverLbaStrategy"] as! String
        }
        if dict.keys.contains("FailoverMaxReturnAddrNum") {
            self.failoverMaxReturnAddrNum = dict["FailoverMaxReturnAddrNum"] as! Int32
        }
        if dict.keys.contains("FailoverMinAvailableAddrNum") {
            self.failoverMinAvailableAddrNum = dict["FailoverMinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Lines") {
            self.lines = dict["Lines"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class UpdateDnsGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class UpdateDnsGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDnsGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDnsGtmAddressPoolRequest : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public var addr: String?

        public var attributeInfo: String?

        public var lbaWeight: Int32?

        public var mode: String?

        public var remark: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                map["Addr"] = self.addr!
            }
            if self.attributeInfo != nil {
                map["AttributeInfo"] = self.attributeInfo!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Addr") {
                self.addr = dict["Addr"] as! String
            }
            if dict.keys.contains("AttributeInfo") {
                self.attributeInfo = dict["AttributeInfo"] as! String
            }
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! String
            }
            if dict.keys.contains("Remark") {
                self.remark = dict["Remark"] as! String
            }
        }
    }
    public var addr: [UpdateDnsGtmAddressPoolRequest.Addr]?

    public var addrPoolId: String?

    public var lang: String?

    public var lbaStrategy: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            var tmp : [Any] = []
            for k in self.addr! {
                tmp.append(k.toMap())
            }
            map["Addr"] = tmp
        }
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addr") {
            self.addr = dict["Addr"] as! [UpdateDnsGtmAddressPoolRequest.Addr]
        }
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LbaStrategy") {
            self.lbaStrategy = dict["LbaStrategy"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class UpdateDnsGtmAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDnsGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDnsGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDnsGtmInstanceGlobalConfigRequest : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public var dingtalkNotice: Bool?

        public var emailNotice: Bool?

        public var noticeType: String?

        public var smsNotice: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingtalkNotice != nil {
                map["DingtalkNotice"] = self.dingtalkNotice!
            }
            if self.emailNotice != nil {
                map["EmailNotice"] = self.emailNotice!
            }
            if self.noticeType != nil {
                map["NoticeType"] = self.noticeType!
            }
            if self.smsNotice != nil {
                map["SmsNotice"] = self.smsNotice!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DingtalkNotice") {
                self.dingtalkNotice = dict["DingtalkNotice"] as! Bool
            }
            if dict.keys.contains("EmailNotice") {
                self.emailNotice = dict["EmailNotice"] as! Bool
            }
            if dict.keys.contains("NoticeType") {
                self.noticeType = dict["NoticeType"] as! String
            }
            if dict.keys.contains("SmsNotice") {
                self.smsNotice = dict["SmsNotice"] as! Bool
            }
        }
    }
    public var alertConfig: [UpdateDnsGtmInstanceGlobalConfigRequest.AlertConfig]?

    public var alertGroup: String?

    public var cnameType: String?

    public var forceUpdate: Bool?

    public var instanceId: String?

    public var instanceName: String?

    public var lang: String?

    public var publicCnameMode: String?

    public var publicRr: String?

    public var publicUserDomainName: String?

    public var publicZoneName: String?

    public var ttl: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConfig != nil {
            var tmp : [Any] = []
            for k in self.alertConfig! {
                tmp.append(k.toMap())
            }
            map["AlertConfig"] = tmp
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.cnameType != nil {
            map["CnameType"] = self.cnameType!
        }
        if self.forceUpdate != nil {
            map["ForceUpdate"] = self.forceUpdate!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.publicCnameMode != nil {
            map["PublicCnameMode"] = self.publicCnameMode!
        }
        if self.publicRr != nil {
            map["PublicRr"] = self.publicRr!
        }
        if self.publicUserDomainName != nil {
            map["PublicUserDomainName"] = self.publicUserDomainName!
        }
        if self.publicZoneName != nil {
            map["PublicZoneName"] = self.publicZoneName!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertConfig") {
            self.alertConfig = dict["AlertConfig"] as! [UpdateDnsGtmInstanceGlobalConfigRequest.AlertConfig]
        }
        if dict.keys.contains("AlertGroup") {
            self.alertGroup = dict["AlertGroup"] as! String
        }
        if dict.keys.contains("CnameType") {
            self.cnameType = dict["CnameType"] as! String
        }
        if dict.keys.contains("ForceUpdate") {
            self.forceUpdate = dict["ForceUpdate"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PublicCnameMode") {
            self.publicCnameMode = dict["PublicCnameMode"] as! String
        }
        if dict.keys.contains("PublicRr") {
            self.publicRr = dict["PublicRr"] as! String
        }
        if dict.keys.contains("PublicUserDomainName") {
            self.publicUserDomainName = dict["PublicUserDomainName"] as! String
        }
        if dict.keys.contains("PublicZoneName") {
            self.publicZoneName = dict["PublicZoneName"] as! String
        }
        if dict.keys.contains("Ttl") {
            self.ttl = dict["Ttl"] as! Int32
        }
    }
}

public class UpdateDnsGtmInstanceGlobalConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDnsGtmInstanceGlobalConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsGtmInstanceGlobalConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDnsGtmInstanceGlobalConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDnsGtmMonitorRequest : Tea.TeaModel {
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNode: [UpdateDnsGtmMonitorRequest.IspCityNode]?

    public var lang: String?

    public var monitorConfigId: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNode") {
            self.ispCityNode = dict["IspCityNode"] as! [UpdateDnsGtmMonitorRequest.IspCityNode]
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpdateDnsGtmMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDnsGtmMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsGtmMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDnsGtmMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDomainGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class UpdateDomainGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDomainGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDomainGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDomainRecordRequest : Tea.TeaModel {
    public var lang: String?

    public var line: String?

    public var priority: Int64?

    public var RR: String?

    public var recordId: String?

    public var TTL: Int64?

    public var type: String?

    public var userClientIp: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.TTL != nil {
            map["TTL"] = self.TTL!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Line") {
            self.line = dict["Line"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int64
        }
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("TTL") {
            self.TTL = dict["TTL"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class UpdateDomainRecordResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDomainRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDomainRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDomainRecordRemarkRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var remark: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class UpdateDomainRecordRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDomainRecordRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainRecordRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDomainRecordRemarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDomainRemarkRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class UpdateDomainRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDomainRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDomainRemarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGtmAccessStrategyRequest : Tea.TeaModel {
    public var accessLines: String?

    public var defaultAddrPoolId: String?

    public var failoverAddrPoolId: String?

    public var lang: String?

    public var strategyId: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessLines != nil {
            map["AccessLines"] = self.accessLines!
        }
        if self.defaultAddrPoolId != nil {
            map["DefaultAddrPoolId"] = self.defaultAddrPoolId!
        }
        if self.failoverAddrPoolId != nil {
            map["FailoverAddrPoolId"] = self.failoverAddrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessLines") {
            self.accessLines = dict["AccessLines"] as! String
        }
        if dict.keys.contains("DefaultAddrPoolId") {
            self.defaultAddrPoolId = dict["DefaultAddrPoolId"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolId") {
            self.failoverAddrPoolId = dict["FailoverAddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class UpdateGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGtmAddressPoolRequest : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public var lbaWeight: Int32?

        public var mode: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var addr: [UpdateGtmAddressPoolRequest.Addr]?

    public var addrPoolId: String?

    public var lang: String?

    public var minAvailableAddrNum: Int32?

    public var name: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            var tmp : [Any] = []
            for k in self.addr! {
                tmp.append(k.toMap())
            }
            map["Addr"] = tmp
        }
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.minAvailableAddrNum != nil {
            map["MinAvailableAddrNum"] = self.minAvailableAddrNum!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addr") {
            self.addr = dict["Addr"] as! [UpdateGtmAddressPoolRequest.Addr]
        }
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MinAvailableAddrNum") {
            self.minAvailableAddrNum = dict["MinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateGtmAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGtmInstanceGlobalConfigRequest : Tea.TeaModel {
    public var alertGroup: String?

    public var cnameCustomDomainName: String?

    public var cnameMode: String?

    public var instanceId: String?

    public var instanceName: String?

    public var lang: String?

    public var lbaStrategy: String?

    public var ttl: Int32?

    public var userDomainName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.cnameCustomDomainName != nil {
            map["CnameCustomDomainName"] = self.cnameCustomDomainName!
        }
        if self.cnameMode != nil {
            map["CnameMode"] = self.cnameMode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.userDomainName != nil {
            map["UserDomainName"] = self.userDomainName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertGroup") {
            self.alertGroup = dict["AlertGroup"] as! String
        }
        if dict.keys.contains("CnameCustomDomainName") {
            self.cnameCustomDomainName = dict["CnameCustomDomainName"] as! String
        }
        if dict.keys.contains("CnameMode") {
            self.cnameMode = dict["CnameMode"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LbaStrategy") {
            self.lbaStrategy = dict["LbaStrategy"] as! String
        }
        if dict.keys.contains("Ttl") {
            self.ttl = dict["Ttl"] as! Int32
        }
        if dict.keys.contains("UserDomainName") {
            self.userDomainName = dict["UserDomainName"] as! String
        }
    }
}

public class UpdateGtmInstanceGlobalConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGtmInstanceGlobalConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmInstanceGlobalConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGtmInstanceGlobalConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGtmMonitorRequest : Tea.TeaModel {
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNode: [UpdateGtmMonitorRequest.IspCityNode]?

    public var lang: String?

    public var monitorConfigId: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNode") {
            self.ispCityNode = dict["IspCityNode"] as! [UpdateGtmMonitorRequest.IspCityNode]
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpdateGtmMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGtmMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGtmMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGtmRecoveryPlanRequest : Tea.TeaModel {
    public var faultAddrPool: String?

    public var lang: String?

    public var name: String?

    public var recoveryPlanId: Int64?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.faultAddrPool != nil {
            map["FaultAddrPool"] = self.faultAddrPool!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FaultAddrPool") {
            self.faultAddrPool = dict["FaultAddrPool"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class UpdateGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIspFlushCacheInstanceConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class UpdateIspFlushCacheInstanceConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateIspFlushCacheInstanceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIspFlushCacheInstanceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateIspFlushCacheInstanceConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ValidateDnsGtmCnameRrCanUseRequest : Tea.TeaModel {
    public var cnameMode: String?

    public var cnameRr: String?

    public var cnameType: String?

    public var cnameZone: String?

    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cnameMode != nil {
            map["CnameMode"] = self.cnameMode!
        }
        if self.cnameRr != nil {
            map["CnameRr"] = self.cnameRr!
        }
        if self.cnameType != nil {
            map["CnameType"] = self.cnameType!
        }
        if self.cnameZone != nil {
            map["CnameZone"] = self.cnameZone!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CnameMode") {
            self.cnameMode = dict["CnameMode"] as! String
        }
        if dict.keys.contains("CnameRr") {
            self.cnameRr = dict["CnameRr"] as! String
        }
        if dict.keys.contains("CnameType") {
            self.cnameType = dict["CnameType"] as! String
        }
        if dict.keys.contains("CnameZone") {
            self.cnameZone = dict["CnameZone"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class ValidateDnsGtmCnameRrCanUseResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ValidateDnsGtmCnameRrCanUseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateDnsGtmCnameRrCanUseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ValidateDnsGtmCnameRrCanUseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ValidatePdnsUdpIpSegmentRequest : Tea.TeaModel {
    public var ip: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class ValidatePdnsUdpIpSegmentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ValidatePdnsUdpIpSegmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidatePdnsUdpIpSegmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ValidatePdnsUdpIpSegmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
