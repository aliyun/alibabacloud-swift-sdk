import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddCustomLineRequest : Tea.TeaModel {
    public class IpSegment : Tea.TeaModel {
        public var endIp: String?

        public var startIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endIp != nil {
                map["EndIp"] = self.endIp!
            }
            if self.startIp != nil {
                map["StartIp"] = self.startIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EndIp"] as? String {
                self.endIp = value
            }
            if let value = dict["StartIp"] as? String {
                self.startIp = value
            }
        }
    }
    public var domainName: String?

    public var ipSegment: [AddCustomLineRequest.IpSegment]?

    public var lang: String?

    public var lineName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ipSegment != nil {
            var tmp : [Any] = []
            for k in self.ipSegment! {
                tmp.append(k.toMap())
            }
            map["IpSegment"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lineName != nil {
            map["LineName"] = self.lineName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["IpSegment"] as? [Any?] {
            var tmp : [AddCustomLineRequest.IpSegment] = []
            for v in value {
                if v != nil {
                    var model = AddCustomLineRequest.IpSegment()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ipSegment = tmp
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["LineName"] as? String {
            self.lineName = value
        }
    }
}

public class AddCustomLineResponseBody : Tea.TeaModel {
    public var lineCode: String?

    public var lineId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lineCode != nil {
            map["LineCode"] = self.lineCode!
        }
        if self.lineId != nil {
            map["LineId"] = self.lineId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LineCode"] as? String {
            self.lineCode = value
        }
        if let value = dict["LineId"] as? Int64 {
            self.lineId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddCustomLineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCustomLineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddCustomLineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddDnsCacheDomainRequest : Tea.TeaModel {
    public class SourceDnsServer : Tea.TeaModel {
        public var host: String?

        public var port: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Host"] as? String {
                self.host = value
            }
            if let value = dict["Port"] as? String {
                self.port = value
            }
        }
    }
    public var cacheTtlMax: Int32?

    public var cacheTtlMin: Int32?

    public var domainName: String?

    public var instanceId: String?

    public var lang: String?

    public var remark: String?

    public var sourceDnsServer: [AddDnsCacheDomainRequest.SourceDnsServer]?

    public var sourceEdns: String?

    public var sourceProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cacheTtlMax != nil {
            map["CacheTtlMax"] = self.cacheTtlMax!
        }
        if self.cacheTtlMin != nil {
            map["CacheTtlMin"] = self.cacheTtlMin!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.sourceDnsServer != nil {
            var tmp : [Any] = []
            for k in self.sourceDnsServer! {
                tmp.append(k.toMap())
            }
            map["SourceDnsServer"] = tmp
        }
        if self.sourceEdns != nil {
            map["SourceEdns"] = self.sourceEdns!
        }
        if self.sourceProtocol != nil {
            map["SourceProtocol"] = self.sourceProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CacheTtlMax"] as? Int32 {
            self.cacheTtlMax = value
        }
        if let value = dict["CacheTtlMin"] as? Int32 {
            self.cacheTtlMin = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["SourceDnsServer"] as? [Any?] {
            var tmp : [AddDnsCacheDomainRequest.SourceDnsServer] = []
            for v in value {
                if v != nil {
                    var model = AddDnsCacheDomainRequest.SourceDnsServer()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.sourceDnsServer = tmp
        }
        if let value = dict["SourceEdns"] as? String {
            self.sourceEdns = value
        }
        if let value = dict["SourceProtocol"] as? String {
            self.sourceProtocol = value
        }
    }
}

public class AddDnsCacheDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddDnsCacheDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDnsCacheDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddDnsCacheDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddDnsGtmAccessStrategyRequest : Tea.TeaModel {
    public class DefaultAddrPool : Tea.TeaModel {
        public var id: String?

        public var lbaWeight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["LbaWeight"] as? Int32 {
                self.lbaWeight = value
            }
        }
    }
    public class FailoverAddrPool : Tea.TeaModel {
        public var id: String?

        public var lbaWeight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["LbaWeight"] as? Int32 {
                self.lbaWeight = value
            }
        }
    }
    public var defaultAddrPool: [AddDnsGtmAccessStrategyRequest.DefaultAddrPool]?

    public var defaultAddrPoolType: String?

    public var defaultLatencyOptimization: String?

    public var defaultLbaStrategy: String?

    public var defaultMaxReturnAddrNum: Int32?

    public var defaultMinAvailableAddrNum: Int32?

    public var failoverAddrPool: [AddDnsGtmAccessStrategyRequest.FailoverAddrPool]?

    public var failoverAddrPoolType: String?

    public var failoverLatencyOptimization: String?

    public var failoverLbaStrategy: String?

    public var failoverMaxReturnAddrNum: Int32?

    public var failoverMinAvailableAddrNum: Int32?

    public var instanceId: String?

    public var lang: String?

    public var lines: String?

    public var strategyMode: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultAddrPool != nil {
            var tmp : [Any] = []
            for k in self.defaultAddrPool! {
                tmp.append(k.toMap())
            }
            map["DefaultAddrPool"] = tmp
        }
        if self.defaultAddrPoolType != nil {
            map["DefaultAddrPoolType"] = self.defaultAddrPoolType!
        }
        if self.defaultLatencyOptimization != nil {
            map["DefaultLatencyOptimization"] = self.defaultLatencyOptimization!
        }
        if self.defaultLbaStrategy != nil {
            map["DefaultLbaStrategy"] = self.defaultLbaStrategy!
        }
        if self.defaultMaxReturnAddrNum != nil {
            map["DefaultMaxReturnAddrNum"] = self.defaultMaxReturnAddrNum!
        }
        if self.defaultMinAvailableAddrNum != nil {
            map["DefaultMinAvailableAddrNum"] = self.defaultMinAvailableAddrNum!
        }
        if self.failoverAddrPool != nil {
            var tmp : [Any] = []
            for k in self.failoverAddrPool! {
                tmp.append(k.toMap())
            }
            map["FailoverAddrPool"] = tmp
        }
        if self.failoverAddrPoolType != nil {
            map["FailoverAddrPoolType"] = self.failoverAddrPoolType!
        }
        if self.failoverLatencyOptimization != nil {
            map["FailoverLatencyOptimization"] = self.failoverLatencyOptimization!
        }
        if self.failoverLbaStrategy != nil {
            map["FailoverLbaStrategy"] = self.failoverLbaStrategy!
        }
        if self.failoverMaxReturnAddrNum != nil {
            map["FailoverMaxReturnAddrNum"] = self.failoverMaxReturnAddrNum!
        }
        if self.failoverMinAvailableAddrNum != nil {
            map["FailoverMinAvailableAddrNum"] = self.failoverMinAvailableAddrNum!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lines != nil {
            map["Lines"] = self.lines!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DefaultAddrPool"] as? [Any?] {
            var tmp : [AddDnsGtmAccessStrategyRequest.DefaultAddrPool] = []
            for v in value {
                if v != nil {
                    var model = AddDnsGtmAccessStrategyRequest.DefaultAddrPool()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.defaultAddrPool = tmp
        }
        if let value = dict["DefaultAddrPoolType"] as? String {
            self.defaultAddrPoolType = value
        }
        if let value = dict["DefaultLatencyOptimization"] as? String {
            self.defaultLatencyOptimization = value
        }
        if let value = dict["DefaultLbaStrategy"] as? String {
            self.defaultLbaStrategy = value
        }
        if let value = dict["DefaultMaxReturnAddrNum"] as? Int32 {
            self.defaultMaxReturnAddrNum = value
        }
        if let value = dict["DefaultMinAvailableAddrNum"] as? Int32 {
            self.defaultMinAvailableAddrNum = value
        }
        if let value = dict["FailoverAddrPool"] as? [Any?] {
            var tmp : [AddDnsGtmAccessStrategyRequest.FailoverAddrPool] = []
            for v in value {
                if v != nil {
                    var model = AddDnsGtmAccessStrategyRequest.FailoverAddrPool()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.failoverAddrPool = tmp
        }
        if let value = dict["FailoverAddrPoolType"] as? String {
            self.failoverAddrPoolType = value
        }
        if let value = dict["FailoverLatencyOptimization"] as? String {
            self.failoverLatencyOptimization = value
        }
        if let value = dict["FailoverLbaStrategy"] as? String {
            self.failoverLbaStrategy = value
        }
        if let value = dict["FailoverMaxReturnAddrNum"] as? Int32 {
            self.failoverMaxReturnAddrNum = value
        }
        if let value = dict["FailoverMinAvailableAddrNum"] as? Int32 {
            self.failoverMinAvailableAddrNum = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Lines"] as? String {
            self.lines = value
        }
        if let value = dict["StrategyMode"] as? String {
            self.strategyMode = value
        }
        if let value = dict["StrategyName"] as? String {
            self.strategyName = value
        }
    }
}

public class AddDnsGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StrategyId"] as? String {
            self.strategyId = value
        }
    }
}

public class AddDnsGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDnsGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddDnsGtmAccessStrategyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddDnsGtmAddressPoolRequest : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public var addr: String?

        public var attributeInfo: String?

        public var lbaWeight: Int32?

        public var mode: String?

        public var remark: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                map["Addr"] = self.addr!
            }
            if self.attributeInfo != nil {
                map["AttributeInfo"] = self.attributeInfo!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Addr"] as? String {
                self.addr = value
            }
            if let value = dict["AttributeInfo"] as? String {
                self.attributeInfo = value
            }
            if let value = dict["LbaWeight"] as? Int32 {
                self.lbaWeight = value
            }
            if let value = dict["Mode"] as? String {
                self.mode = value
            }
            if let value = dict["Remark"] as? String {
                self.remark = value
            }
        }
    }
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CityCode"] as? String {
                self.cityCode = value
            }
            if let value = dict["IspCode"] as? String {
                self.ispCode = value
            }
        }
    }
    public var addr: [AddDnsGtmAddressPoolRequest.Addr]?

    public var evaluationCount: Int32?

    public var instanceId: String?

    public var interval: Int32?

    public var ispCityNode: [AddDnsGtmAddressPoolRequest.IspCityNode]?

    public var lang: String?

    public var lbaStrategy: String?

    public var monitorExtendInfo: String?

    public var monitorStatus: String?

    public var name: String?

    public var protocolType: String?

    public var timeout: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            var tmp : [Any] = []
            for k in self.addr! {
                tmp.append(k.toMap())
            }
            map["Addr"] = tmp
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.monitorStatus != nil {
            map["MonitorStatus"] = self.monitorStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Addr"] as? [Any?] {
            var tmp : [AddDnsGtmAddressPoolRequest.Addr] = []
            for v in value {
                if v != nil {
                    var model = AddDnsGtmAddressPoolRequest.Addr()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.addr = tmp
        }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["IspCityNode"] as? [Any?] {
            var tmp : [AddDnsGtmAddressPoolRequest.IspCityNode] = []
            for v in value {
                if v != nil {
                    var model = AddDnsGtmAddressPoolRequest.IspCityNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ispCityNode = tmp
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["LbaStrategy"] as? String {
            self.lbaStrategy = value
        }
        if let value = dict["MonitorExtendInfo"] as? String {
            self.monitorExtendInfo = value
        }
        if let value = dict["MonitorStatus"] as? String {
            self.monitorStatus = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProtocolType"] as? String {
            self.protocolType = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class AddDnsGtmAddressPoolResponseBody : Tea.TeaModel {
    public var addrPoolId: String?

    public var monitorConfigId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrPoolId"] as? String {
            self.addrPoolId = value
        }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddDnsGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDnsGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddDnsGtmAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddDnsGtmMonitorRequest : Tea.TeaModel {
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CityCode"] as? String {
                self.cityCode = value
            }
            if let value = dict["IspCode"] as? String {
                self.ispCode = value
            }
        }
    }
    public var addrPoolId: String?

    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNode: [AddDnsGtmMonitorRequest.IspCityNode]?

    public var lang: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrPoolId"] as? String {
            self.addrPoolId = value
        }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["IspCityNode"] as? [Any?] {
            var tmp : [AddDnsGtmMonitorRequest.IspCityNode] = []
            for v in value {
                if v != nil {
                    var model = AddDnsGtmMonitorRequest.IspCityNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ispCityNode = tmp
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["MonitorExtendInfo"] as? String {
            self.monitorExtendInfo = value
        }
        if let value = dict["ProtocolType"] as? String {
            self.protocolType = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class AddDnsGtmMonitorResponseBody : Tea.TeaModel {
    public var monitorConfigId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddDnsGtmMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDnsGtmMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddDnsGtmMonitorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var lang: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class AddDomainResponseBody : Tea.TeaModel {
    public class DnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DnsServer"] as? [String] {
                self.dnsServer = value
            }
        }
    }
    public var dnsServers: AddDomainResponseBody.DnsServers?

    public var domainId: String?

    public var domainName: String?

    public var groupId: String?

    public var groupName: String?

    public var punyCode: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dnsServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dnsServers != nil {
            map["DnsServers"] = self.dnsServers?.toMap()
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.punyCode != nil {
            map["PunyCode"] = self.punyCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DnsServers"] as? [String: Any?] {
            var model = AddDomainResponseBody.DnsServers()
            model.fromMap(value)
            self.dnsServers = model
        }
        if let value = dict["DomainId"] as? String {
            self.domainId = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["PunyCode"] as? String {
            self.punyCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddDomainBackupRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var periodType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.periodType != nil {
            map["PeriodType"] = self.periodType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PeriodType"] as? String {
            self.periodType = value
        }
    }
}

public class AddDomainBackupResponseBody : Tea.TeaModel {
    public var domainName: String?

    public var periodType: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.periodType != nil {
            map["PeriodType"] = self.periodType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["PeriodType"] as? String {
            self.periodType = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddDomainBackupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDomainBackupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddDomainBackupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddDomainGroupRequest : Tea.TeaModel {
    public var groupName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class AddDomainGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddDomainGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDomainGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddDomainGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddDomainRecordRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var line: String?

    public var priority: Int64?

    public var RR: String?

    public var TTL: Int64?

    public var type: String?

    public var userClientIp: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.TTL != nil {
            map["TTL"] = self.TTL!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Line"] as? String {
            self.line = value
        }
        if let value = dict["Priority"] as? Int64 {
            self.priority = value
        }
        if let value = dict["RR"] as? String {
            self.RR = value
        }
        if let value = dict["TTL"] as? Int64 {
            self.TTL = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
        if let value = dict["Value"] as? String {
            self.value = value
        }
    }
}

public class AddDomainRecordResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddDomainRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDomainRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddDomainRecordResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddGtmAccessStrategyRequest : Tea.TeaModel {
    public var accessLines: String?

    public var defaultAddrPoolId: String?

    public var failoverAddrPoolId: String?

    public var instanceId: String?

    public var lang: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessLines != nil {
            map["AccessLines"] = self.accessLines!
        }
        if self.defaultAddrPoolId != nil {
            map["DefaultAddrPoolId"] = self.defaultAddrPoolId!
        }
        if self.failoverAddrPoolId != nil {
            map["FailoverAddrPoolId"] = self.failoverAddrPoolId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessLines"] as? String {
            self.accessLines = value
        }
        if let value = dict["DefaultAddrPoolId"] as? String {
            self.defaultAddrPoolId = value
        }
        if let value = dict["FailoverAddrPoolId"] as? String {
            self.failoverAddrPoolId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StrategyName"] as? String {
            self.strategyName = value
        }
    }
}

public class AddGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StrategyId"] as? String {
            self.strategyId = value
        }
    }
}

public class AddGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddGtmAccessStrategyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddGtmAddressPoolRequest : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public var lbaWeight: Int32?

        public var mode: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LbaWeight"] as? Int32 {
                self.lbaWeight = value
            }
            if let value = dict["Mode"] as? String {
                self.mode = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CityCode"] as? String {
                self.cityCode = value
            }
            if let value = dict["IspCode"] as? String {
                self.ispCode = value
            }
        }
    }
    public var addr: [AddGtmAddressPoolRequest.Addr]?

    public var evaluationCount: Int32?

    public var instanceId: String?

    public var interval: Int32?

    public var ispCityNode: [AddGtmAddressPoolRequest.IspCityNode]?

    public var lang: String?

    public var minAvailableAddrNum: Int32?

    public var monitorExtendInfo: String?

    public var monitorStatus: String?

    public var name: String?

    public var protocolType: String?

    public var timeout: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            var tmp : [Any] = []
            for k in self.addr! {
                tmp.append(k.toMap())
            }
            map["Addr"] = tmp
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.minAvailableAddrNum != nil {
            map["MinAvailableAddrNum"] = self.minAvailableAddrNum!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.monitorStatus != nil {
            map["MonitorStatus"] = self.monitorStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Addr"] as? [Any?] {
            var tmp : [AddGtmAddressPoolRequest.Addr] = []
            for v in value {
                if v != nil {
                    var model = AddGtmAddressPoolRequest.Addr()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.addr = tmp
        }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["IspCityNode"] as? [Any?] {
            var tmp : [AddGtmAddressPoolRequest.IspCityNode] = []
            for v in value {
                if v != nil {
                    var model = AddGtmAddressPoolRequest.IspCityNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ispCityNode = tmp
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["MinAvailableAddrNum"] as? Int32 {
            self.minAvailableAddrNum = value
        }
        if let value = dict["MonitorExtendInfo"] as? String {
            self.monitorExtendInfo = value
        }
        if let value = dict["MonitorStatus"] as? String {
            self.monitorStatus = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProtocolType"] as? String {
            self.protocolType = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class AddGtmAddressPoolResponseBody : Tea.TeaModel {
    public var addrPoolId: String?

    public var monitorConfigId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrPoolId"] as? String {
            self.addrPoolId = value
        }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddGtmAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddGtmMonitorRequest : Tea.TeaModel {
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CityCode"] as? String {
                self.cityCode = value
            }
            if let value = dict["IspCode"] as? String {
                self.ispCode = value
            }
        }
    }
    public var addrPoolId: String?

    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNode: [AddGtmMonitorRequest.IspCityNode]?

    public var lang: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrPoolId"] as? String {
            self.addrPoolId = value
        }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["IspCityNode"] as? [Any?] {
            var tmp : [AddGtmMonitorRequest.IspCityNode] = []
            for v in value {
                if v != nil {
                    var model = AddGtmMonitorRequest.IspCityNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ispCityNode = tmp
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["MonitorExtendInfo"] as? String {
            self.monitorExtendInfo = value
        }
        if let value = dict["ProtocolType"] as? String {
            self.protocolType = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class AddGtmMonitorResponseBody : Tea.TeaModel {
    public var monitorConfigId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddGtmMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGtmMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddGtmMonitorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddGtmRecoveryPlanRequest : Tea.TeaModel {
    public var faultAddrPool: String?

    public var lang: String?

    public var name: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.faultAddrPool != nil {
            map["FaultAddrPool"] = self.faultAddrPool!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FaultAddrPool"] as? String {
            self.faultAddrPool = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class AddGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var recoveryPlanId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecoveryPlanId"] as? String {
            self.recoveryPlanId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddGtmRecoveryPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddRecursionRecordRequest : Tea.TeaModel {
    public var clientToken: String?

    public var priority: Int32?

    public var requestSource: String?

    public var rr: String?

    public var ttl: Int32?

    public var type: String?

    public var userClientIp: String?

    public var value: String?

    public var weight: Int32?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.requestSource != nil {
            map["RequestSource"] = self.requestSource!
        }
        if self.rr != nil {
            map["Rr"] = self.rr!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["RequestSource"] as? String {
            self.requestSource = value
        }
        if let value = dict["Rr"] as? String {
            self.rr = value
        }
        if let value = dict["Ttl"] as? Int32 {
            self.ttl = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
        if let value = dict["Value"] as? String {
            self.value = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class AddRecursionRecordResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class AddRecursionRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddRecursionRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddRecursionRecordResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddRecursionZoneRequest : Tea.TeaModel {
    public var clientToken: String?

    public var proxyPattern: String?

    public var zoneName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.proxyPattern != nil {
            map["ProxyPattern"] = self.proxyPattern!
        }
        if self.zoneName != nil {
            map["ZoneName"] = self.zoneName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ProxyPattern"] as? String {
            self.proxyPattern = value
        }
        if let value = dict["ZoneName"] as? String {
            self.zoneName = value
        }
    }
}

public class AddRecursionZoneResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class AddRecursionZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddRecursionZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddRecursionZoneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddRspDomainServerHoldStatusForGatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var domainName: String?

    public var statusMsg: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.statusMsg != nil {
            map["StatusMsg"] = self.statusMsg!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["StatusMsg"] as? String {
            self.statusMsg = value
        }
    }
}

public class AddRspDomainServerHoldStatusForGatewayResponseBody : Tea.TeaModel {
    public class AccessDeniedDetail : Tea.TeaModel {
        public var authAction: String?

        public var authPrincipalDisplayName: String?

        public var authPrincipalOwnerId: String?

        public var authPrincipalType: String?

        public var encodedDiagnosticMessage: String?

        public var noPermissionType: String?

        public var policyType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authAction != nil {
                map["AuthAction"] = self.authAction!
            }
            if self.authPrincipalDisplayName != nil {
                map["AuthPrincipalDisplayName"] = self.authPrincipalDisplayName!
            }
            if self.authPrincipalOwnerId != nil {
                map["AuthPrincipalOwnerId"] = self.authPrincipalOwnerId!
            }
            if self.authPrincipalType != nil {
                map["AuthPrincipalType"] = self.authPrincipalType!
            }
            if self.encodedDiagnosticMessage != nil {
                map["EncodedDiagnosticMessage"] = self.encodedDiagnosticMessage!
            }
            if self.noPermissionType != nil {
                map["NoPermissionType"] = self.noPermissionType!
            }
            if self.policyType != nil {
                map["PolicyType"] = self.policyType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AuthAction"] as? String {
                self.authAction = value
            }
            if let value = dict["AuthPrincipalDisplayName"] as? String {
                self.authPrincipalDisplayName = value
            }
            if let value = dict["AuthPrincipalOwnerId"] as? String {
                self.authPrincipalOwnerId = value
            }
            if let value = dict["AuthPrincipalType"] as? String {
                self.authPrincipalType = value
            }
            if let value = dict["EncodedDiagnosticMessage"] as? String {
                self.encodedDiagnosticMessage = value
            }
            if let value = dict["NoPermissionType"] as? String {
                self.noPermissionType = value
            }
            if let value = dict["PolicyType"] as? String {
                self.policyType = value
            }
        }
    }
    public class Data : Tea.TeaModel {
        public var domainName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
        }
    }
    public var accessDeniedDetail: AddRspDomainServerHoldStatusForGatewayResponseBody.AccessDeniedDetail?

    public var data: AddRspDomainServerHoldStatusForGatewayResponseBody.Data?

    public var recoverableError: Bool?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accessDeniedDetail?.validate()
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail?.toMap()
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.recoverableError != nil {
            map["RecoverableError"] = self.recoverableError!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? [String: Any?] {
            var model = AddRspDomainServerHoldStatusForGatewayResponseBody.AccessDeniedDetail()
            model.fromMap(value)
            self.accessDeniedDetail = model
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = AddRspDomainServerHoldStatusForGatewayResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RecoverableError"] as? Bool {
            self.recoverableError = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class AddRspDomainServerHoldStatusForGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddRspDomainServerHoldStatusForGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddRspDomainServerHoldStatusForGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BindInstanceDomainsRequest : Tea.TeaModel {
    public var domainNames: String?

    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainNames"] as? String {
            self.domainNames = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class BindInstanceDomainsResponseBody : Tea.TeaModel {
    public var failedCount: Int32?

    public var requestId: String?

    public var successCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FailedCount"] as? Int32 {
            self.failedCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessCount"] as? Int32 {
            self.successCount = value
        }
    }
}

public class BindInstanceDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindInstanceDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BindInstanceDomainsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ChangeDomainGroupRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class ChangeDomainGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ChangeDomainGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeDomainGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ChangeDomainGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ChangeDomainOfDnsProductRequest : Tea.TeaModel {
    public var force: Bool?

    public var instanceId: String?

    public var lang: String?

    public var newDomain: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.newDomain != nil {
            map["NewDomain"] = self.newDomain!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["NewDomain"] as? String {
            self.newDomain = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
    }
}

public class ChangeDomainOfDnsProductResponseBody : Tea.TeaModel {
    public var originalDomain: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.originalDomain != nil {
            map["OriginalDomain"] = self.originalDomain!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OriginalDomain"] as? String {
            self.originalDomain = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ChangeDomainOfDnsProductResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeDomainOfDnsProductResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ChangeDomainOfDnsProductResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CopyGtmConfigRequest : Tea.TeaModel {
    public var copyType: String?

    public var lang: String?

    public var sourceId: String?

    public var targetId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.copyType != nil {
            map["CopyType"] = self.copyType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceId != nil {
            map["SourceId"] = self.sourceId!
        }
        if self.targetId != nil {
            map["TargetId"] = self.targetId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CopyType"] as? String {
            self.copyType = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["SourceId"] as? String {
            self.sourceId = value
        }
        if let value = dict["TargetId"] as? String {
            self.targetId = value
        }
    }
}

public class CopyGtmConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CopyGtmConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyGtmConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CopyGtmConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCloudGtmAddressRequest : Tea.TeaModel {
    public class HealthTasks : Tea.TeaModel {
        public var port: Int32?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Port"] as? Int32 {
                self.port = value
            }
            if let value = dict["TemplateId"] as? String {
                self.templateId = value
            }
        }
    }
    public var acceptLanguage: String?

    public var address: String?

    public var attributeInfo: String?

    public var availableMode: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var healthJudgement: String?

    public var healthTasks: [CreateCloudGtmAddressRequest.HealthTasks]?

    public var manualAvailableStatus: String?

    public var name: String?

    public var remark: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.attributeInfo != nil {
            map["AttributeInfo"] = self.attributeInfo!
        }
        if self.availableMode != nil {
            map["AvailableMode"] = self.availableMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.healthTasks != nil {
            var tmp : [Any] = []
            for k in self.healthTasks! {
                tmp.append(k.toMap())
            }
            map["HealthTasks"] = tmp
        }
        if self.manualAvailableStatus != nil {
            map["ManualAvailableStatus"] = self.manualAvailableStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["Address"] as? String {
            self.address = value
        }
        if let value = dict["AttributeInfo"] as? String {
            self.attributeInfo = value
        }
        if let value = dict["AvailableMode"] as? String {
            self.availableMode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["HealthJudgement"] as? String {
            self.healthJudgement = value
        }
        if let value = dict["HealthTasks"] as? [Any?] {
            var tmp : [CreateCloudGtmAddressRequest.HealthTasks] = []
            for v in value {
                if v != nil {
                    var model = CreateCloudGtmAddressRequest.HealthTasks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.healthTasks = tmp
        }
        if let value = dict["ManualAvailableStatus"] as? String {
            self.manualAvailableStatus = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class CreateCloudGtmAddressShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var attributeInfo: String?

    public var availableMode: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var healthJudgement: String?

    public var healthTasksShrink: String?

    public var manualAvailableStatus: String?

    public var name: String?

    public var remark: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.attributeInfo != nil {
            map["AttributeInfo"] = self.attributeInfo!
        }
        if self.availableMode != nil {
            map["AvailableMode"] = self.availableMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.healthTasksShrink != nil {
            map["HealthTasks"] = self.healthTasksShrink!
        }
        if self.manualAvailableStatus != nil {
            map["ManualAvailableStatus"] = self.manualAvailableStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["Address"] as? String {
            self.address = value
        }
        if let value = dict["AttributeInfo"] as? String {
            self.attributeInfo = value
        }
        if let value = dict["AvailableMode"] as? String {
            self.availableMode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["HealthJudgement"] as? String {
            self.healthJudgement = value
        }
        if let value = dict["HealthTasks"] as? String {
            self.healthTasksShrink = value
        }
        if let value = dict["ManualAvailableStatus"] as? String {
            self.manualAvailableStatus = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class CreateCloudGtmAddressResponseBody : Tea.TeaModel {
    public var addressId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressId"] as? String {
            self.addressId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateCloudGtmAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudGtmAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCloudGtmAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCloudGtmAddressPoolRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolName: String?

    public var addressPoolType: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var healthJudgement: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolName != nil {
            map["AddressPoolName"] = self.addressPoolName!
        }
        if self.addressPoolType != nil {
            map["AddressPoolType"] = self.addressPoolType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPoolName"] as? String {
            self.addressPoolName = value
        }
        if let value = dict["AddressPoolType"] as? String {
            self.addressPoolType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["HealthJudgement"] as? String {
            self.healthJudgement = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class CreateCloudGtmAddressPoolResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateCloudGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCloudGtmAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCloudGtmInstanceConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var chargeType: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var instanceId: String?

    public var remark: String?

    public var scheduleHostname: String?

    public var scheduleRrType: String?

    public var scheduleZoneMode: String?

    public var scheduleZoneName: String?

    public var ttl: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.scheduleHostname != nil {
            map["ScheduleHostname"] = self.scheduleHostname!
        }
        if self.scheduleRrType != nil {
            map["ScheduleRrType"] = self.scheduleRrType!
        }
        if self.scheduleZoneMode != nil {
            map["ScheduleZoneMode"] = self.scheduleZoneMode!
        }
        if self.scheduleZoneName != nil {
            map["ScheduleZoneName"] = self.scheduleZoneName!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ChargeType"] as? String {
            self.chargeType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["ScheduleHostname"] as? String {
            self.scheduleHostname = value
        }
        if let value = dict["ScheduleRrType"] as? String {
            self.scheduleRrType = value
        }
        if let value = dict["ScheduleZoneMode"] as? String {
            self.scheduleZoneMode = value
        }
        if let value = dict["ScheduleZoneName"] as? String {
            self.scheduleZoneName = value
        }
        if let value = dict["Ttl"] as? Int32 {
            self.ttl = value
        }
    }
}

public class CreateCloudGtmInstanceConfigResponseBody : Tea.TeaModel {
    public var configId: Bool?

    public var instanceId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigId"] as? Bool {
            self.configId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateCloudGtmInstanceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudGtmInstanceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCloudGtmInstanceConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCloudGtmMonitorTemplateRequest : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CityCode"] as? String {
                self.cityCode = value
            }
            if let value = dict["IspCode"] as? String {
                self.ispCode = value
            }
        }
    }
    public var acceptLanguage: String?

    public var clientToken: String?

    public var evaluationCount: Int32?

    public var extendInfo: String?

    public var failureRate: Int32?

    public var interval: Int32?

    public var ipVersion: String?

    public var ispCityNodes: [CreateCloudGtmMonitorTemplateRequest.IspCityNodes]?

    public var name: String?

    public var protocol_: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.failureRate != nil {
            map["FailureRate"] = self.failureRate!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ispCityNodes != nil {
            var tmp : [Any] = []
            for k in self.ispCityNodes! {
                tmp.append(k.toMap())
            }
            map["IspCityNodes"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["ExtendInfo"] as? String {
            self.extendInfo = value
        }
        if let value = dict["FailureRate"] as? Int32 {
            self.failureRate = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["IspCityNodes"] as? [Any?] {
            var tmp : [CreateCloudGtmMonitorTemplateRequest.IspCityNodes] = []
            for v in value {
                if v != nil {
                    var model = CreateCloudGtmMonitorTemplateRequest.IspCityNodes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ispCityNodes = tmp
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class CreateCloudGtmMonitorTemplateShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var evaluationCount: Int32?

    public var extendInfo: String?

    public var failureRate: Int32?

    public var interval: Int32?

    public var ipVersion: String?

    public var ispCityNodesShrink: String?

    public var name: String?

    public var protocol_: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.failureRate != nil {
            map["FailureRate"] = self.failureRate!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ispCityNodesShrink != nil {
            map["IspCityNodes"] = self.ispCityNodesShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["ExtendInfo"] as? String {
            self.extendInfo = value
        }
        if let value = dict["FailureRate"] as? Int32 {
            self.failureRate = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["IspCityNodes"] as? String {
            self.ispCityNodesShrink = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class CreateCloudGtmMonitorTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
    }
}

public class CreateCloudGtmMonitorTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudGtmMonitorTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCloudGtmMonitorTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePdnsAppKeyRequest : Tea.TeaModel {
    public var lang: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class CreatePdnsAppKeyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreatePdnsAppKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePdnsAppKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePdnsAppKeyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePdnsUdpIpSegmentRequest : Tea.TeaModel {
    public var ip: String?

    public var ipToken: String?

    public var lang: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.ipToken != nil {
            map["IpToken"] = self.ipToken!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ip"] as? String {
            self.ip = value
        }
        if let value = dict["IpToken"] as? String {
            self.ipToken = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class CreatePdnsUdpIpSegmentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var validMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.validMessage != nil {
            map["ValidMessage"] = self.validMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ValidMessage"] as? String {
            self.validMessage = value
        }
    }
}

public class CreatePdnsUdpIpSegmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePdnsUdpIpSegmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePdnsUdpIpSegmentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCloudGtmAddressRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressId"] as? String {
            self.addressId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class DeleteCloudGtmAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteCloudGtmAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCloudGtmAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCloudGtmAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCloudGtmAddressPoolRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class DeleteCloudGtmAddressPoolResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteCloudGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCloudGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCloudGtmAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCloudGtmInstanceConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DeleteCloudGtmInstanceConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteCloudGtmInstanceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCloudGtmInstanceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCloudGtmInstanceConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCloudGtmMonitorTemplateRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
    }
}

public class DeleteCloudGtmMonitorTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteCloudGtmMonitorTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCloudGtmMonitorTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCloudGtmMonitorTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCustomLinesRequest : Tea.TeaModel {
    public var lang: String?

    public var lineIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lineIds != nil {
            map["LineIds"] = self.lineIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["LineIds"] as? String {
            self.lineIds = value
        }
    }
}

public class DeleteCustomLinesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCustomLinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomLinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCustomLinesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDnsCacheDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DeleteDnsCacheDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDnsCacheDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDnsCacheDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDnsCacheDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDnsGtmAccessStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StrategyId"] as? String {
            self.strategyId = value
        }
    }
}

public class DeleteDnsGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDnsGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDnsGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDnsGtmAccessStrategyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDnsGtmAddressPoolRequest : Tea.TeaModel {
    public var addrPoolId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrPoolId"] as? String {
            self.addrPoolId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DeleteDnsGtmAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDnsGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDnsGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDnsGtmAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DeleteDomainResponseBody : Tea.TeaModel {
    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDomainGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DeleteDomainGroupResponseBody : Tea.TeaModel {
    public var groupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDomainGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDomainGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDomainRecordRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
    }
}

public class DeleteDomainRecordResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDomainRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDomainRecordResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteGtmAccessStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StrategyId"] as? String {
            self.strategyId = value
        }
    }
}

public class DeleteGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteGtmAccessStrategyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteGtmAddressPoolRequest : Tea.TeaModel {
    public var addrPoolId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrPoolId"] as? String {
            self.addrPoolId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DeleteGtmAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteGtmAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["RecoveryPlanId"] as? Int64 {
            self.recoveryPlanId = value
        }
    }
}

public class DeleteGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteGtmRecoveryPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRecursionRecordRequest : Tea.TeaModel {
    public var clientToken: String?

    public var recordId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
    }
}

public class DeleteRecursionRecordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRecursionRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRecursionRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRecursionRecordResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRecursionZoneRequest : Tea.TeaModel {
    public var clientToken: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DeleteRecursionZoneResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRecursionZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRecursionZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRecursionZoneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSubDomainRecordsRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var RR: String?

    public var type: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["RR"] as? String {
            self.RR = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
    }
}

public class DeleteSubDomainRecordsResponseBody : Tea.TeaModel {
    public var RR: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RR"] as? String {
            self.RR = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DeleteSubDomainRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSubDomainRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSubDomainRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBatchResultCountRequest : Tea.TeaModel {
    public var batchType: String?

    public var lang: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchType != nil {
            map["BatchType"] = self.batchType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BatchType"] as? String {
            self.batchType = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
    }
}

public class DescribeBatchResultCountResponseBody : Tea.TeaModel {
    public var batchType: String?

    public var failedCount: Int32?

    public var reason: String?

    public var requestId: String?

    public var status: Int32?

    public var successCount: Int32?

    public var taskId: Int64?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchType != nil {
            map["BatchType"] = self.batchType!
        }
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BatchType"] as? String {
            self.batchType = value
        }
        if let value = dict["FailedCount"] as? Int32 {
            self.failedCount = value
        }
        if let value = dict["Reason"] as? String {
            self.reason = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
        if let value = dict["SuccessCount"] as? Int32 {
            self.successCount = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeBatchResultCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBatchResultCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBatchResultCountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBatchResultDetailRequest : Tea.TeaModel {
    public var batchType: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchType != nil {
            map["BatchType"] = self.batchType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BatchType"] as? String {
            self.batchType = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
    }
}

public class DescribeBatchResultDetailResponseBody : Tea.TeaModel {
    public class BatchResultDetails : Tea.TeaModel {
        public class BatchResultDetail : Tea.TeaModel {
            public var batchType: String?

            public var domain: String?

            public var line: String?

            public var newRr: String?

            public var newValue: String?

            public var operateDateStr: String?

            public var priority: String?

            public var reason: String?

            public var recordId: String?

            public var remark: String?

            public var rr: String?

            public var rrStatus: String?

            public var status: Bool?

            public var ttl: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchType != nil {
                    map["BatchType"] = self.batchType!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.line != nil {
                    map["Line"] = self.line!
                }
                if self.newRr != nil {
                    map["NewRr"] = self.newRr!
                }
                if self.newValue != nil {
                    map["NewValue"] = self.newValue!
                }
                if self.operateDateStr != nil {
                    map["OperateDateStr"] = self.operateDateStr!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.rr != nil {
                    map["Rr"] = self.rr!
                }
                if self.rrStatus != nil {
                    map["RrStatus"] = self.rrStatus!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BatchType"] as? String {
                    self.batchType = value
                }
                if let value = dict["Domain"] as? String {
                    self.domain = value
                }
                if let value = dict["Line"] as? String {
                    self.line = value
                }
                if let value = dict["NewRr"] as? String {
                    self.newRr = value
                }
                if let value = dict["NewValue"] as? String {
                    self.newValue = value
                }
                if let value = dict["OperateDateStr"] as? String {
                    self.operateDateStr = value
                }
                if let value = dict["Priority"] as? String {
                    self.priority = value
                }
                if let value = dict["Reason"] as? String {
                    self.reason = value
                }
                if let value = dict["RecordId"] as? String {
                    self.recordId = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["Rr"] as? String {
                    self.rr = value
                }
                if let value = dict["RrStatus"] as? String {
                    self.rrStatus = value
                }
                if let value = dict["Status"] as? Bool {
                    self.status = value
                }
                if let value = dict["Ttl"] as? String {
                    self.ttl = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var batchResultDetail: [DescribeBatchResultDetailResponseBody.BatchResultDetails.BatchResultDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchResultDetail != nil {
                var tmp : [Any] = []
                for k in self.batchResultDetail! {
                    tmp.append(k.toMap())
                }
                map["BatchResultDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BatchResultDetail"] as? [Any?] {
                var tmp : [DescribeBatchResultDetailResponseBody.BatchResultDetails.BatchResultDetail] = []
                for v in value {
                    if v != nil {
                        var model = DescribeBatchResultDetailResponseBody.BatchResultDetails.BatchResultDetail()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.batchResultDetail = tmp
            }
        }
    }
    public var batchResultDetails: DescribeBatchResultDetailResponseBody.BatchResultDetails?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.batchResultDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchResultDetails != nil {
            map["BatchResultDetails"] = self.batchResultDetails?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BatchResultDetails"] as? [String: Any?] {
            var model = DescribeBatchResultDetailResponseBody.BatchResultDetails()
            model.fromMap(value)
            self.batchResultDetails = model
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeBatchResultDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBatchResultDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBatchResultDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudGtmAddressRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressId"] as? String {
            self.addressId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class DescribeCloudGtmAddressResponseBody : Tea.TeaModel {
    public class HealthTasks : Tea.TeaModel {
        public class HealthTask : Tea.TeaModel {
            public var monitorStatus: String?

            public var port: Int32?

            public var templateId: String?

            public var templateName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.monitorStatus != nil {
                    map["MonitorStatus"] = self.monitorStatus!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MonitorStatus"] as? String {
                    self.monitorStatus = value
                }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["TemplateId"] as? String {
                    self.templateId = value
                }
                if let value = dict["TemplateName"] as? String {
                    self.templateName = value
                }
            }
        }
        public var healthTask: [DescribeCloudGtmAddressResponseBody.HealthTasks.HealthTask]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.healthTask != nil {
                var tmp : [Any] = []
                for k in self.healthTask! {
                    tmp.append(k.toMap())
                }
                map["HealthTask"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HealthTask"] as? [Any?] {
                var tmp : [DescribeCloudGtmAddressResponseBody.HealthTasks.HealthTask] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCloudGtmAddressResponseBody.HealthTasks.HealthTask()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.healthTask = tmp
            }
        }
    }
    public var address: String?

    public var addressId: String?

    public var attributeInfo: String?

    public var availableMode: String?

    public var availableStatus: String?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var enableStatus: String?

    public var healthJudgement: String?

    public var healthStatus: String?

    public var healthTasks: DescribeCloudGtmAddressResponseBody.HealthTasks?

    public var manualAvailableStatus: String?

    public var name: String?

    public var remark: String?

    public var requestId: String?

    public var type: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.healthTasks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.attributeInfo != nil {
            map["AttributeInfo"] = self.attributeInfo!
        }
        if self.availableMode != nil {
            map["AvailableMode"] = self.availableMode!
        }
        if self.availableStatus != nil {
            map["AvailableStatus"] = self.availableStatus!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.healthTasks != nil {
            map["HealthTasks"] = self.healthTasks?.toMap()
        }
        if self.manualAvailableStatus != nil {
            map["ManualAvailableStatus"] = self.manualAvailableStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Address"] as? String {
            self.address = value
        }
        if let value = dict["AddressId"] as? String {
            self.addressId = value
        }
        if let value = dict["AttributeInfo"] as? String {
            self.attributeInfo = value
        }
        if let value = dict["AvailableMode"] as? String {
            self.availableMode = value
        }
        if let value = dict["AvailableStatus"] as? String {
            self.availableStatus = value
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["HealthJudgement"] as? String {
            self.healthJudgement = value
        }
        if let value = dict["HealthStatus"] as? String {
            self.healthStatus = value
        }
        if let value = dict["HealthTasks"] as? [String: Any?] {
            var model = DescribeCloudGtmAddressResponseBody.HealthTasks()
            model.fromMap(value)
            self.healthTasks = model
        }
        if let value = dict["ManualAvailableStatus"] as? String {
            self.manualAvailableStatus = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
        if let value = dict["UpdateTimestamp"] as? Int64 {
            self.updateTimestamp = value
        }
    }
}

public class DescribeCloudGtmAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudGtmAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudGtmAddressPoolRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class DescribeCloudGtmAddressPoolResponseBody : Tea.TeaModel {
    public class Addresses : Tea.TeaModel {
        public class Address : Tea.TeaModel {
            public class HealthTasks : Tea.TeaModel {
                public class HealthTask : Tea.TeaModel {
                    public var port: Int32?

                    public var templateId: String?

                    public var templateName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        if self.templateName != nil {
                            map["TemplateName"] = self.templateName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Port"] as? Int32 {
                            self.port = value
                        }
                        if let value = dict["TemplateId"] as? String {
                            self.templateId = value
                        }
                        if let value = dict["TemplateName"] as? String {
                            self.templateName = value
                        }
                    }
                }
                public var healthTask: [DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.HealthTasks.HealthTask]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.healthTask != nil {
                        var tmp : [Any] = []
                        for k in self.healthTask! {
                            tmp.append(k.toMap())
                        }
                        map["HealthTask"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["HealthTask"] as? [Any?] {
                        var tmp : [DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.HealthTasks.HealthTask] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.HealthTasks.HealthTask()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.healthTask = tmp
                    }
                }
            }
            public class RequestSource : Tea.TeaModel {
                public var requestSource: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.requestSource != nil {
                        map["RequestSource"] = self.requestSource!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RequestSource"] as? [String] {
                        self.requestSource = value
                    }
                }
            }
            public var address: String?

            public var addressId: String?

            public var attributeInfo: String?

            public var availableMode: String?

            public var availableStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var healthTasks: DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.HealthTasks?

            public var manualAvailableStatus: String?

            public var name: String?

            public var remark: String?

            public var requestSource: DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.RequestSource?

            public var seqNonPreemptiveSchedule: Bool?

            public var serialNumber: Int32?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var weightValue: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.healthTasks?.validate()
                try self.requestSource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.addressId != nil {
                    map["AddressId"] = self.addressId!
                }
                if self.attributeInfo != nil {
                    map["AttributeInfo"] = self.attributeInfo!
                }
                if self.availableMode != nil {
                    map["AvailableMode"] = self.availableMode!
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.healthTasks != nil {
                    map["HealthTasks"] = self.healthTasks?.toMap()
                }
                if self.manualAvailableStatus != nil {
                    map["ManualAvailableStatus"] = self.manualAvailableStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.requestSource != nil {
                    map["RequestSource"] = self.requestSource?.toMap()
                }
                if self.seqNonPreemptiveSchedule != nil {
                    map["SeqNonPreemptiveSchedule"] = self.seqNonPreemptiveSchedule!
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.weightValue != nil {
                    map["WeightValue"] = self.weightValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Address"] as? String {
                    self.address = value
                }
                if let value = dict["AddressId"] as? String {
                    self.addressId = value
                }
                if let value = dict["AttributeInfo"] as? String {
                    self.attributeInfo = value
                }
                if let value = dict["AvailableMode"] as? String {
                    self.availableMode = value
                }
                if let value = dict["AvailableStatus"] as? String {
                    self.availableStatus = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["EnableStatus"] as? String {
                    self.enableStatus = value
                }
                if let value = dict["HealthJudgement"] as? String {
                    self.healthJudgement = value
                }
                if let value = dict["HealthStatus"] as? String {
                    self.healthStatus = value
                }
                if let value = dict["HealthTasks"] as? [String: Any?] {
                    var model = DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.HealthTasks()
                    model.fromMap(value)
                    self.healthTasks = model
                }
                if let value = dict["ManualAvailableStatus"] as? String {
                    self.manualAvailableStatus = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["RequestSource"] as? [String: Any?] {
                    var model = DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.RequestSource()
                    model.fromMap(value)
                    self.requestSource = model
                }
                if let value = dict["SeqNonPreemptiveSchedule"] as? Bool {
                    self.seqNonPreemptiveSchedule = value
                }
                if let value = dict["SerialNumber"] as? Int32 {
                    self.serialNumber = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
                if let value = dict["WeightValue"] as? Int32 {
                    self.weightValue = value
                }
            }
        }
        public var address: [DescribeCloudGtmAddressPoolResponseBody.Addresses.Address]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                var tmp : [Any] = []
                for k in self.address! {
                    tmp.append(k.toMap())
                }
                map["Address"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Address"] as? [Any?] {
                var tmp : [DescribeCloudGtmAddressPoolResponseBody.Addresses.Address] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCloudGtmAddressPoolResponseBody.Addresses.Address()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.address = tmp
            }
        }
    }
    public var addressLbStrategy: String?

    public var addressPoolId: String?

    public var addressPoolName: String?

    public var addressPoolType: String?

    public var addresses: DescribeCloudGtmAddressPoolResponseBody.Addresses?

    public var availableStatus: String?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var enableStatus: String?

    public var healthJudgement: String?

    public var healthStatus: String?

    public var remark: String?

    public var requestId: String?

    public var sequenceLbStrategyMode: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressLbStrategy != nil {
            map["AddressLbStrategy"] = self.addressLbStrategy!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.addressPoolName != nil {
            map["AddressPoolName"] = self.addressPoolName!
        }
        if self.addressPoolType != nil {
            map["AddressPoolType"] = self.addressPoolType!
        }
        if self.addresses != nil {
            map["Addresses"] = self.addresses?.toMap()
        }
        if self.availableStatus != nil {
            map["AvailableStatus"] = self.availableStatus!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sequenceLbStrategyMode != nil {
            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressLbStrategy"] as? String {
            self.addressLbStrategy = value
        }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["AddressPoolName"] as? String {
            self.addressPoolName = value
        }
        if let value = dict["AddressPoolType"] as? String {
            self.addressPoolType = value
        }
        if let value = dict["Addresses"] as? [String: Any?] {
            var model = DescribeCloudGtmAddressPoolResponseBody.Addresses()
            model.fromMap(value)
            self.addresses = model
        }
        if let value = dict["AvailableStatus"] as? String {
            self.availableStatus = value
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["HealthJudgement"] as? String {
            self.healthJudgement = value
        }
        if let value = dict["HealthStatus"] as? String {
            self.healthStatus = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SequenceLbStrategyMode"] as? String {
            self.sequenceLbStrategyMode = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
        if let value = dict["UpdateTimestamp"] as? Int64 {
            self.updateTimestamp = value
        }
    }
}

public class DescribeCloudGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudGtmAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudGtmAddressPoolReferenceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class DescribeCloudGtmAddressPoolReferenceResponseBody : Tea.TeaModel {
    public class InstanceConfigs : Tea.TeaModel {
        public class InstanceConfig : Tea.TeaModel {
            public var addressPoolLbStrategy: String?

            public var availableStatus: String?

            public var configId: String?

            public var enableStatus: String?

            public var healthStatus: String?

            public var instanceId: String?

            public var instanceName: String?

            public var remark: String?

            public var scheduleDomainName: String?

            public var scheduleHostname: String?

            public var scheduleRrType: String?

            public var scheduleZoneName: String?

            public var sequenceLbStrategyMode: String?

            public var ttl: Int32?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressPoolLbStrategy != nil {
                    map["AddressPoolLbStrategy"] = self.addressPoolLbStrategy!
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.configId != nil {
                    map["ConfigId"] = self.configId!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.scheduleDomainName != nil {
                    map["ScheduleDomainName"] = self.scheduleDomainName!
                }
                if self.scheduleHostname != nil {
                    map["ScheduleHostname"] = self.scheduleHostname!
                }
                if self.scheduleRrType != nil {
                    map["ScheduleRrType"] = self.scheduleRrType!
                }
                if self.scheduleZoneName != nil {
                    map["ScheduleZoneName"] = self.scheduleZoneName!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddressPoolLbStrategy"] as? String {
                    self.addressPoolLbStrategy = value
                }
                if let value = dict["AvailableStatus"] as? String {
                    self.availableStatus = value
                }
                if let value = dict["ConfigId"] as? String {
                    self.configId = value
                }
                if let value = dict["EnableStatus"] as? String {
                    self.enableStatus = value
                }
                if let value = dict["HealthStatus"] as? String {
                    self.healthStatus = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["ScheduleDomainName"] as? String {
                    self.scheduleDomainName = value
                }
                if let value = dict["ScheduleHostname"] as? String {
                    self.scheduleHostname = value
                }
                if let value = dict["ScheduleRrType"] as? String {
                    self.scheduleRrType = value
                }
                if let value = dict["ScheduleZoneName"] as? String {
                    self.scheduleZoneName = value
                }
                if let value = dict["SequenceLbStrategyMode"] as? String {
                    self.sequenceLbStrategyMode = value
                }
                if let value = dict["Ttl"] as? Int32 {
                    self.ttl = value
                }
                if let value = dict["VersionCode"] as? String {
                    self.versionCode = value
                }
            }
        }
        public var instanceConfig: [DescribeCloudGtmAddressPoolReferenceResponseBody.InstanceConfigs.InstanceConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceConfig != nil {
                var tmp : [Any] = []
                for k in self.instanceConfig! {
                    tmp.append(k.toMap())
                }
                map["InstanceConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceConfig"] as? [Any?] {
                var tmp : [DescribeCloudGtmAddressPoolReferenceResponseBody.InstanceConfigs.InstanceConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCloudGtmAddressPoolReferenceResponseBody.InstanceConfigs.InstanceConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceConfig = tmp
            }
        }
    }
    public var addressPoolId: String?

    public var addressPoolName: String?

    public var instanceConfigs: DescribeCloudGtmAddressPoolReferenceResponseBody.InstanceConfigs?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.addressPoolName != nil {
            map["AddressPoolName"] = self.addressPoolName!
        }
        if self.instanceConfigs != nil {
            map["InstanceConfigs"] = self.instanceConfigs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["AddressPoolName"] as? String {
            self.addressPoolName = value
        }
        if let value = dict["InstanceConfigs"] as? [String: Any?] {
            var model = DescribeCloudGtmAddressPoolReferenceResponseBody.InstanceConfigs()
            model.fromMap(value)
            self.instanceConfigs = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeCloudGtmAddressPoolReferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmAddressPoolReferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudGtmAddressPoolReferenceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudGtmAddressReferenceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressId"] as? String {
            self.addressId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class DescribeCloudGtmAddressReferenceResponseBody : Tea.TeaModel {
    public class AddressPools : Tea.TeaModel {
        public class AddressPool : Tea.TeaModel {
            public class InstanceConfigs : Tea.TeaModel {
                public class InstanceConfig : Tea.TeaModel {
                    public var addressPoolLbStrategy: String?

                    public var availableStatus: String?

                    public var configId: String?

                    public var enableStatus: String?

                    public var healthStatus: String?

                    public var instanceId: String?

                    public var instanceName: String?

                    public var remark: String?

                    public var scheduleDomainName: String?

                    public var scheduleHostname: String?

                    public var scheduleRrType: String?

                    public var scheduleZoneName: String?

                    public var sequenceLbStrategyMode: String?

                    public var ttl: Int32?

                    public var versionCode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.addressPoolLbStrategy != nil {
                            map["AddressPoolLbStrategy"] = self.addressPoolLbStrategy!
                        }
                        if self.availableStatus != nil {
                            map["AvailableStatus"] = self.availableStatus!
                        }
                        if self.configId != nil {
                            map["ConfigId"] = self.configId!
                        }
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.healthStatus != nil {
                            map["HealthStatus"] = self.healthStatus!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.instanceName != nil {
                            map["InstanceName"] = self.instanceName!
                        }
                        if self.remark != nil {
                            map["Remark"] = self.remark!
                        }
                        if self.scheduleDomainName != nil {
                            map["ScheduleDomainName"] = self.scheduleDomainName!
                        }
                        if self.scheduleHostname != nil {
                            map["ScheduleHostname"] = self.scheduleHostname!
                        }
                        if self.scheduleRrType != nil {
                            map["ScheduleRrType"] = self.scheduleRrType!
                        }
                        if self.scheduleZoneName != nil {
                            map["ScheduleZoneName"] = self.scheduleZoneName!
                        }
                        if self.sequenceLbStrategyMode != nil {
                            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                        }
                        if self.ttl != nil {
                            map["Ttl"] = self.ttl!
                        }
                        if self.versionCode != nil {
                            map["VersionCode"] = self.versionCode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AddressPoolLbStrategy"] as? String {
                            self.addressPoolLbStrategy = value
                        }
                        if let value = dict["AvailableStatus"] as? String {
                            self.availableStatus = value
                        }
                        if let value = dict["ConfigId"] as? String {
                            self.configId = value
                        }
                        if let value = dict["EnableStatus"] as? String {
                            self.enableStatus = value
                        }
                        if let value = dict["HealthStatus"] as? String {
                            self.healthStatus = value
                        }
                        if let value = dict["InstanceId"] as? String {
                            self.instanceId = value
                        }
                        if let value = dict["InstanceName"] as? String {
                            self.instanceName = value
                        }
                        if let value = dict["Remark"] as? String {
                            self.remark = value
                        }
                        if let value = dict["ScheduleDomainName"] as? String {
                            self.scheduleDomainName = value
                        }
                        if let value = dict["ScheduleHostname"] as? String {
                            self.scheduleHostname = value
                        }
                        if let value = dict["ScheduleRrType"] as? String {
                            self.scheduleRrType = value
                        }
                        if let value = dict["ScheduleZoneName"] as? String {
                            self.scheduleZoneName = value
                        }
                        if let value = dict["SequenceLbStrategyMode"] as? String {
                            self.sequenceLbStrategyMode = value
                        }
                        if let value = dict["Ttl"] as? Int32 {
                            self.ttl = value
                        }
                        if let value = dict["VersionCode"] as? String {
                            self.versionCode = value
                        }
                    }
                }
                public var instanceConfig: [DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool.InstanceConfigs.InstanceConfig]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceConfig != nil {
                        var tmp : [Any] = []
                        for k in self.instanceConfig! {
                            tmp.append(k.toMap())
                        }
                        map["InstanceConfig"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InstanceConfig"] as? [Any?] {
                        var tmp : [DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool.InstanceConfigs.InstanceConfig] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool.InstanceConfigs.InstanceConfig()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.instanceConfig = tmp
                    }
                }
            }
            public var addressLbStrategy: String?

            public var addressPoolId: String?

            public var addressPoolName: String?

            public var addressPoolType: String?

            public var availableStatus: String?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var instanceConfigs: DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool.InstanceConfigs?

            public var remark: String?

            public var sequenceLbStrategyMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.instanceConfigs?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressLbStrategy != nil {
                    map["AddressLbStrategy"] = self.addressLbStrategy!
                }
                if self.addressPoolId != nil {
                    map["AddressPoolId"] = self.addressPoolId!
                }
                if self.addressPoolName != nil {
                    map["AddressPoolName"] = self.addressPoolName!
                }
                if self.addressPoolType != nil {
                    map["AddressPoolType"] = self.addressPoolType!
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.instanceConfigs != nil {
                    map["InstanceConfigs"] = self.instanceConfigs?.toMap()
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddressLbStrategy"] as? String {
                    self.addressLbStrategy = value
                }
                if let value = dict["AddressPoolId"] as? String {
                    self.addressPoolId = value
                }
                if let value = dict["AddressPoolName"] as? String {
                    self.addressPoolName = value
                }
                if let value = dict["AddressPoolType"] as? String {
                    self.addressPoolType = value
                }
                if let value = dict["AvailableStatus"] as? String {
                    self.availableStatus = value
                }
                if let value = dict["EnableStatus"] as? String {
                    self.enableStatus = value
                }
                if let value = dict["HealthJudgement"] as? String {
                    self.healthJudgement = value
                }
                if let value = dict["HealthStatus"] as? String {
                    self.healthStatus = value
                }
                if let value = dict["InstanceConfigs"] as? [String: Any?] {
                    var model = DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool.InstanceConfigs()
                    model.fromMap(value)
                    self.instanceConfigs = model
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["SequenceLbStrategyMode"] as? String {
                    self.sequenceLbStrategyMode = value
                }
            }
        }
        public var addressPool: [DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressPool != nil {
                var tmp : [Any] = []
                for k in self.addressPool! {
                    tmp.append(k.toMap())
                }
                map["AddressPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AddressPool"] as? [Any?] {
                var tmp : [DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.addressPool = tmp
            }
        }
    }
    public var address: String?

    public var addressId: String?

    public var addressPools: DescribeCloudGtmAddressReferenceResponseBody.AddressPools?

    public var name: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addressPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.addressPools != nil {
            map["AddressPools"] = self.addressPools?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Address"] as? String {
            self.address = value
        }
        if let value = dict["AddressId"] as? String {
            self.addressId = value
        }
        if let value = dict["AddressPools"] as? [String: Any?] {
            var model = DescribeCloudGtmAddressReferenceResponseBody.AddressPools()
            model.fromMap(value)
            self.addressPools = model
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeCloudGtmAddressReferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmAddressReferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudGtmAddressReferenceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudGtmGlobalAlertRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class DescribeCloudGtmGlobalAlertResponseBody : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public class AlertConfig : Tea.TeaModel {
            public var dingtalkNotice: Bool?

            public var emailNotice: Bool?

            public var noticeType: String?

            public var smsNotice: Bool?

            public var threshold: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dingtalkNotice != nil {
                    map["DingtalkNotice"] = self.dingtalkNotice!
                }
                if self.emailNotice != nil {
                    map["EmailNotice"] = self.emailNotice!
                }
                if self.noticeType != nil {
                    map["NoticeType"] = self.noticeType!
                }
                if self.smsNotice != nil {
                    map["SmsNotice"] = self.smsNotice!
                }
                if self.threshold != nil {
                    map["Threshold"] = self.threshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DingtalkNotice"] as? Bool {
                    self.dingtalkNotice = value
                }
                if let value = dict["EmailNotice"] as? Bool {
                    self.emailNotice = value
                }
                if let value = dict["NoticeType"] as? String {
                    self.noticeType = value
                }
                if let value = dict["SmsNotice"] as? Bool {
                    self.smsNotice = value
                }
                if let value = dict["Threshold"] as? Int32 {
                    self.threshold = value
                }
            }
        }
        public var alertConfig: [DescribeCloudGtmGlobalAlertResponseBody.AlertConfig.AlertConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertConfig != nil {
                var tmp : [Any] = []
                for k in self.alertConfig! {
                    tmp.append(k.toMap())
                }
                map["AlertConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlertConfig"] as? [Any?] {
                var tmp : [DescribeCloudGtmGlobalAlertResponseBody.AlertConfig.AlertConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCloudGtmGlobalAlertResponseBody.AlertConfig.AlertConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.alertConfig = tmp
            }
        }
    }
    public class AlertGroup : Tea.TeaModel {
        public var alertGroup: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertGroup != nil {
                map["AlertGroup"] = self.alertGroup!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlertGroup"] as? [String] {
                self.alertGroup = value
            }
        }
    }
    public var alertConfig: DescribeCloudGtmGlobalAlertResponseBody.AlertConfig?

    public var alertGroup: DescribeCloudGtmGlobalAlertResponseBody.AlertGroup?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertConfig?.validate()
        try self.alertGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConfig != nil {
            map["AlertConfig"] = self.alertConfig?.toMap()
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertConfig"] as? [String: Any?] {
            var model = DescribeCloudGtmGlobalAlertResponseBody.AlertConfig()
            model.fromMap(value)
            self.alertConfig = model
        }
        if let value = dict["AlertGroup"] as? [String: Any?] {
            var model = DescribeCloudGtmGlobalAlertResponseBody.AlertGroup()
            model.fromMap(value)
            self.alertGroup = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeCloudGtmGlobalAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmGlobalAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudGtmGlobalAlertResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudGtmInstanceConfigAlertRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DescribeCloudGtmInstanceConfigAlertResponseBody : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public class AlertConfig : Tea.TeaModel {
            public var dingtalkNotice: Bool?

            public var emailNotice: Bool?

            public var noticeType: String?

            public var smsNotice: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dingtalkNotice != nil {
                    map["DingtalkNotice"] = self.dingtalkNotice!
                }
                if self.emailNotice != nil {
                    map["EmailNotice"] = self.emailNotice!
                }
                if self.noticeType != nil {
                    map["NoticeType"] = self.noticeType!
                }
                if self.smsNotice != nil {
                    map["SmsNotice"] = self.smsNotice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DingtalkNotice"] as? Bool {
                    self.dingtalkNotice = value
                }
                if let value = dict["EmailNotice"] as? Bool {
                    self.emailNotice = value
                }
                if let value = dict["NoticeType"] as? String {
                    self.noticeType = value
                }
                if let value = dict["SmsNotice"] as? Bool {
                    self.smsNotice = value
                }
            }
        }
        public var alertConfig: [DescribeCloudGtmInstanceConfigAlertResponseBody.AlertConfig.AlertConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertConfig != nil {
                var tmp : [Any] = []
                for k in self.alertConfig! {
                    tmp.append(k.toMap())
                }
                map["AlertConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlertConfig"] as? [Any?] {
                var tmp : [DescribeCloudGtmInstanceConfigAlertResponseBody.AlertConfig.AlertConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCloudGtmInstanceConfigAlertResponseBody.AlertConfig.AlertConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.alertConfig = tmp
            }
        }
    }
    public class AlertGroup : Tea.TeaModel {
        public var alertGroup: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertGroup != nil {
                map["AlertGroup"] = self.alertGroup!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlertGroup"] as? [String] {
                self.alertGroup = value
            }
        }
    }
    public var alertConfig: DescribeCloudGtmInstanceConfigAlertResponseBody.AlertConfig?

    public var alertGroup: DescribeCloudGtmInstanceConfigAlertResponseBody.AlertGroup?

    public var alertMode: String?

    public var configId: String?

    public var instanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertConfig?.validate()
        try self.alertGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConfig != nil {
            map["AlertConfig"] = self.alertConfig?.toMap()
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup?.toMap()
        }
        if self.alertMode != nil {
            map["AlertMode"] = self.alertMode!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertConfig"] as? [String: Any?] {
            var model = DescribeCloudGtmInstanceConfigAlertResponseBody.AlertConfig()
            model.fromMap(value)
            self.alertConfig = model
        }
        if let value = dict["AlertGroup"] as? [String: Any?] {
            var model = DescribeCloudGtmInstanceConfigAlertResponseBody.AlertGroup()
            model.fromMap(value)
            self.alertGroup = model
        }
        if let value = dict["AlertMode"] as? String {
            self.alertMode = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeCloudGtmInstanceConfigAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmInstanceConfigAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudGtmInstanceConfigAlertResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudGtmInstanceConfigFullInfoRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DescribeCloudGtmInstanceConfigFullInfoResponseBody : Tea.TeaModel {
    public class AddressPools : Tea.TeaModel {
        public class AddressPool : Tea.TeaModel {
            public class Addresses : Tea.TeaModel {
                public class Address : Tea.TeaModel {
                    public class RequestSource : Tea.TeaModel {
                        public var requestSource: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.requestSource != nil {
                                map["RequestSource"] = self.requestSource!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["RequestSource"] as? [String] {
                                self.requestSource = value
                            }
                        }
                    }
                    public var address: String?

                    public var addressId: String?

                    public var attributeInfo: String?

                    public var availableMode: String?

                    public var availableStatus: String?

                    public var createTime: String?

                    public var createTimestamp: Int64?

                    public var enableStatus: String?

                    public var healthJudgement: String?

                    public var healthStatus: String?

                    public var manualAvailableStatus: String?

                    public var name: String?

                    public var remark: String?

                    public var requestSource: DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses.Address.RequestSource?

                    public var seqNonPreemptiveSchedule: Bool?

                    public var serialNumber: Int32?

                    public var type: String?

                    public var updateTime: String?

                    public var updateTimestamp: Int64?

                    public var weightValue: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.requestSource?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.addressId != nil {
                            map["AddressId"] = self.addressId!
                        }
                        if self.attributeInfo != nil {
                            map["AttributeInfo"] = self.attributeInfo!
                        }
                        if self.availableMode != nil {
                            map["AvailableMode"] = self.availableMode!
                        }
                        if self.availableStatus != nil {
                            map["AvailableStatus"] = self.availableStatus!
                        }
                        if self.createTime != nil {
                            map["CreateTime"] = self.createTime!
                        }
                        if self.createTimestamp != nil {
                            map["CreateTimestamp"] = self.createTimestamp!
                        }
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.healthJudgement != nil {
                            map["HealthJudgement"] = self.healthJudgement!
                        }
                        if self.healthStatus != nil {
                            map["HealthStatus"] = self.healthStatus!
                        }
                        if self.manualAvailableStatus != nil {
                            map["ManualAvailableStatus"] = self.manualAvailableStatus!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.remark != nil {
                            map["Remark"] = self.remark!
                        }
                        if self.requestSource != nil {
                            map["RequestSource"] = self.requestSource?.toMap()
                        }
                        if self.seqNonPreemptiveSchedule != nil {
                            map["SeqNonPreemptiveSchedule"] = self.seqNonPreemptiveSchedule!
                        }
                        if self.serialNumber != nil {
                            map["SerialNumber"] = self.serialNumber!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        if self.updateTimestamp != nil {
                            map["UpdateTimestamp"] = self.updateTimestamp!
                        }
                        if self.weightValue != nil {
                            map["WeightValue"] = self.weightValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Address"] as? String {
                            self.address = value
                        }
                        if let value = dict["AddressId"] as? String {
                            self.addressId = value
                        }
                        if let value = dict["AttributeInfo"] as? String {
                            self.attributeInfo = value
                        }
                        if let value = dict["AvailableMode"] as? String {
                            self.availableMode = value
                        }
                        if let value = dict["AvailableStatus"] as? String {
                            self.availableStatus = value
                        }
                        if let value = dict["CreateTime"] as? String {
                            self.createTime = value
                        }
                        if let value = dict["CreateTimestamp"] as? Int64 {
                            self.createTimestamp = value
                        }
                        if let value = dict["EnableStatus"] as? String {
                            self.enableStatus = value
                        }
                        if let value = dict["HealthJudgement"] as? String {
                            self.healthJudgement = value
                        }
                        if let value = dict["HealthStatus"] as? String {
                            self.healthStatus = value
                        }
                        if let value = dict["ManualAvailableStatus"] as? String {
                            self.manualAvailableStatus = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Remark"] as? String {
                            self.remark = value
                        }
                        if let value = dict["RequestSource"] as? [String: Any?] {
                            var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses.Address.RequestSource()
                            model.fromMap(value)
                            self.requestSource = model
                        }
                        if let value = dict["SeqNonPreemptiveSchedule"] as? Bool {
                            self.seqNonPreemptiveSchedule = value
                        }
                        if let value = dict["SerialNumber"] as? Int32 {
                            self.serialNumber = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                        if let value = dict["UpdateTime"] as? String {
                            self.updateTime = value
                        }
                        if let value = dict["UpdateTimestamp"] as? Int64 {
                            self.updateTimestamp = value
                        }
                        if let value = dict["WeightValue"] as? Int32 {
                            self.weightValue = value
                        }
                    }
                }
                public var address: [DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses.Address]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.address != nil {
                        var tmp : [Any] = []
                        for k in self.address! {
                            tmp.append(k.toMap())
                        }
                        map["Address"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Address"] as? [Any?] {
                        var tmp : [DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses.Address] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses.Address()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.address = tmp
                    }
                }
            }
            public class RequestSource : Tea.TeaModel {
                public var requestSource: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.requestSource != nil {
                        map["RequestSource"] = self.requestSource!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RequestSource"] as? [String] {
                        self.requestSource = value
                    }
                }
            }
            public var addressLbStrategy: String?

            public var addressPoolId: String?

            public var addressPoolName: String?

            public var addressPoolType: String?

            public var addresses: DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses?

            public var availableStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var requestSource: DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.RequestSource?

            public var seqNonPreemptiveSchedule: Bool?

            public var sequenceLbStrategyMode: String?

            public var serialNumber: Int32?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var weightValue: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addresses?.validate()
                try self.requestSource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressLbStrategy != nil {
                    map["AddressLbStrategy"] = self.addressLbStrategy!
                }
                if self.addressPoolId != nil {
                    map["AddressPoolId"] = self.addressPoolId!
                }
                if self.addressPoolName != nil {
                    map["AddressPoolName"] = self.addressPoolName!
                }
                if self.addressPoolType != nil {
                    map["AddressPoolType"] = self.addressPoolType!
                }
                if self.addresses != nil {
                    map["Addresses"] = self.addresses?.toMap()
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.requestSource != nil {
                    map["RequestSource"] = self.requestSource?.toMap()
                }
                if self.seqNonPreemptiveSchedule != nil {
                    map["SeqNonPreemptiveSchedule"] = self.seqNonPreemptiveSchedule!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.weightValue != nil {
                    map["WeightValue"] = self.weightValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddressLbStrategy"] as? String {
                    self.addressLbStrategy = value
                }
                if let value = dict["AddressPoolId"] as? String {
                    self.addressPoolId = value
                }
                if let value = dict["AddressPoolName"] as? String {
                    self.addressPoolName = value
                }
                if let value = dict["AddressPoolType"] as? String {
                    self.addressPoolType = value
                }
                if let value = dict["Addresses"] as? [String: Any?] {
                    var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses()
                    model.fromMap(value)
                    self.addresses = model
                }
                if let value = dict["AvailableStatus"] as? String {
                    self.availableStatus = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["EnableStatus"] as? String {
                    self.enableStatus = value
                }
                if let value = dict["HealthJudgement"] as? String {
                    self.healthJudgement = value
                }
                if let value = dict["HealthStatus"] as? String {
                    self.healthStatus = value
                }
                if let value = dict["RequestSource"] as? [String: Any?] {
                    var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.RequestSource()
                    model.fromMap(value)
                    self.requestSource = model
                }
                if let value = dict["SeqNonPreemptiveSchedule"] as? Bool {
                    self.seqNonPreemptiveSchedule = value
                }
                if let value = dict["SequenceLbStrategyMode"] as? String {
                    self.sequenceLbStrategyMode = value
                }
                if let value = dict["SerialNumber"] as? Int32 {
                    self.serialNumber = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
                if let value = dict["WeightValue"] as? Int32 {
                    self.weightValue = value
                }
            }
        }
        public var addressPool: [DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressPool != nil {
                var tmp : [Any] = []
                for k in self.addressPool! {
                    tmp.append(k.toMap())
                }
                map["AddressPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AddressPool"] as? [Any?] {
                var tmp : [DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.addressPool = tmp
            }
        }
    }
    public var addressPoolLbStrategy: String?

    public var addressPools: DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools?

    public var alertConfig: String?

    public var alertGroup: String?

    public var availableStatus: String?

    public var commodityCode: String?

    public var configId: String?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var enableStatus: String?

    public var healthStatus: String?

    public var instanceId: String?

    public var instanceName: String?

    public var remark: String?

    public var requestId: String?

    public var scheduleDomainName: String?

    public var scheduleHostname: String?

    public var scheduleRrType: String?

    public var scheduleZoneMode: String?

    public var scheduleZoneName: String?

    public var sequenceLbStrategyMode: String?

    public var ttl: Int32?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addressPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolLbStrategy != nil {
            map["AddressPoolLbStrategy"] = self.addressPoolLbStrategy!
        }
        if self.addressPools != nil {
            map["AddressPools"] = self.addressPools?.toMap()
        }
        if self.alertConfig != nil {
            map["AlertConfig"] = self.alertConfig!
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.availableStatus != nil {
            map["AvailableStatus"] = self.availableStatus!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduleDomainName != nil {
            map["ScheduleDomainName"] = self.scheduleDomainName!
        }
        if self.scheduleHostname != nil {
            map["ScheduleHostname"] = self.scheduleHostname!
        }
        if self.scheduleRrType != nil {
            map["ScheduleRrType"] = self.scheduleRrType!
        }
        if self.scheduleZoneMode != nil {
            map["ScheduleZoneMode"] = self.scheduleZoneMode!
        }
        if self.scheduleZoneName != nil {
            map["ScheduleZoneName"] = self.scheduleZoneName!
        }
        if self.sequenceLbStrategyMode != nil {
            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressPoolLbStrategy"] as? String {
            self.addressPoolLbStrategy = value
        }
        if let value = dict["AddressPools"] as? [String: Any?] {
            var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools()
            model.fromMap(value)
            self.addressPools = model
        }
        if let value = dict["AlertConfig"] as? String {
            self.alertConfig = value
        }
        if let value = dict["AlertGroup"] as? String {
            self.alertGroup = value
        }
        if let value = dict["AvailableStatus"] as? String {
            self.availableStatus = value
        }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["HealthStatus"] as? String {
            self.healthStatus = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ScheduleDomainName"] as? String {
            self.scheduleDomainName = value
        }
        if let value = dict["ScheduleHostname"] as? String {
            self.scheduleHostname = value
        }
        if let value = dict["ScheduleRrType"] as? String {
            self.scheduleRrType = value
        }
        if let value = dict["ScheduleZoneMode"] as? String {
            self.scheduleZoneMode = value
        }
        if let value = dict["ScheduleZoneName"] as? String {
            self.scheduleZoneName = value
        }
        if let value = dict["SequenceLbStrategyMode"] as? String {
            self.sequenceLbStrategyMode = value
        }
        if let value = dict["Ttl"] as? Int32 {
            self.ttl = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
        if let value = dict["UpdateTimestamp"] as? Int64 {
            self.updateTimestamp = value
        }
        if let value = dict["VersionCode"] as? String {
            self.versionCode = value
        }
    }
}

public class DescribeCloudGtmInstanceConfigFullInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmInstanceConfigFullInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudGtmMonitorTemplateRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
    }
}

public class DescribeCloudGtmMonitorTemplateResponseBody : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public class IspCityNode : Tea.TeaModel {
            public var cityCode: String?

            public var cityName: String?

            public var countryCode: String?

            public var countryName: String?

            public var groupName: String?

            public var groupType: String?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.countryCode != nil {
                    map["CountryCode"] = self.countryCode!
                }
                if self.countryName != nil {
                    map["CountryName"] = self.countryName!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CityCode"] as? String {
                    self.cityCode = value
                }
                if let value = dict["CityName"] as? String {
                    self.cityName = value
                }
                if let value = dict["CountryCode"] as? String {
                    self.countryCode = value
                }
                if let value = dict["CountryName"] as? String {
                    self.countryName = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["GroupType"] as? String {
                    self.groupType = value
                }
                if let value = dict["IspCode"] as? String {
                    self.ispCode = value
                }
                if let value = dict["IspName"] as? String {
                    self.ispName = value
                }
            }
        }
        public var ispCityNode: [DescribeCloudGtmMonitorTemplateResponseBody.IspCityNodes.IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ispCityNode != nil {
                var tmp : [Any] = []
                for k in self.ispCityNode! {
                    tmp.append(k.toMap())
                }
                map["IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IspCityNode"] as? [Any?] {
                var tmp : [DescribeCloudGtmMonitorTemplateResponseBody.IspCityNodes.IspCityNode] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCloudGtmMonitorTemplateResponseBody.IspCityNodes.IspCityNode()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ispCityNode = tmp
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var evaluationCount: Int32?

    public var extendInfo: String?

    public var failureRate: Int32?

    public var interval: Int32?

    public var ipVersion: String?

    public var ispCityNodes: DescribeCloudGtmMonitorTemplateResponseBody.IspCityNodes?

    public var name: String?

    public var protocol_: String?

    public var remark: String?

    public var requestId: String?

    public var templateId: String?

    public var timeout: Int32?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ispCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.failureRate != nil {
            map["FailureRate"] = self.failureRate!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ispCityNodes != nil {
            map["IspCityNodes"] = self.ispCityNodes?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["ExtendInfo"] as? String {
            self.extendInfo = value
        }
        if let value = dict["FailureRate"] as? Int32 {
            self.failureRate = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["IspCityNodes"] as? [String: Any?] {
            var model = DescribeCloudGtmMonitorTemplateResponseBody.IspCityNodes()
            model.fromMap(value)
            self.ispCityNodes = model
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
        if let value = dict["UpdateTimestamp"] as? Int64 {
            self.updateTimestamp = value
        }
    }
}

public class DescribeCloudGtmMonitorTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmMonitorTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudGtmMonitorTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudGtmSummaryRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
    }
}

public class DescribeCloudGtmSummaryResponseBody : Tea.TeaModel {
    public var instanceTotalCount: Int32?

    public var monitorTaskTotalCount: Int32?

    public var monitorTaskTotalQuota: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTotalCount != nil {
            map["InstanceTotalCount"] = self.instanceTotalCount!
        }
        if self.monitorTaskTotalCount != nil {
            map["MonitorTaskTotalCount"] = self.monitorTaskTotalCount!
        }
        if self.monitorTaskTotalQuota != nil {
            map["MonitorTaskTotalQuota"] = self.monitorTaskTotalQuota!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceTotalCount"] as? Int32 {
            self.instanceTotalCount = value
        }
        if let value = dict["MonitorTaskTotalCount"] as? Int32 {
            self.monitorTaskTotalCount = value
        }
        if let value = dict["MonitorTaskTotalQuota"] as? Int32 {
            self.monitorTaskTotalQuota = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeCloudGtmSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudGtmSummaryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudGtmSystemLinesResponseBody : Tea.TeaModel {
    public class SystemLines : Tea.TeaModel {
        public class SystemLine : Tea.TeaModel {
            public var code: String?

            public var displayName: String?

            public var isAvailable: Bool?

            public var name: String?

            public var parentCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.isAvailable != nil {
                    map["IsAvailable"] = self.isAvailable!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parentCode != nil {
                    map["ParentCode"] = self.parentCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["DisplayName"] as? String {
                    self.displayName = value
                }
                if let value = dict["IsAvailable"] as? Bool {
                    self.isAvailable = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ParentCode"] as? String {
                    self.parentCode = value
                }
            }
        }
        public var systemLine: [DescribeCloudGtmSystemLinesResponseBody.SystemLines.SystemLine]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemLine != nil {
                var tmp : [Any] = []
                for k in self.systemLine! {
                    tmp.append(k.toMap())
                }
                map["SystemLine"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SystemLine"] as? [Any?] {
                var tmp : [DescribeCloudGtmSystemLinesResponseBody.SystemLines.SystemLine] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCloudGtmSystemLinesResponseBody.SystemLines.SystemLine()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.systemLine = tmp
            }
        }
    }
    public var requestId: String?

    public var systemLines: DescribeCloudGtmSystemLinesResponseBody.SystemLines?

    public var systemLinesTree: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemLines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemLines != nil {
            map["SystemLines"] = self.systemLines?.toMap()
        }
        if self.systemLinesTree != nil {
            map["SystemLinesTree"] = self.systemLinesTree!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SystemLines"] as? [String: Any?] {
            var model = DescribeCloudGtmSystemLinesResponseBody.SystemLines()
            model.fromMap(value)
            self.systemLines = model
        }
        if let value = dict["SystemLinesTree"] as? String {
            self.systemLinesTree = value
        }
    }
}

public class DescribeCloudGtmSystemLinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmSystemLinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudGtmSystemLinesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCustomLineRequest : Tea.TeaModel {
    public var lang: String?

    public var lineId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lineId != nil {
            map["LineId"] = self.lineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["LineId"] as? Int64 {
            self.lineId = value
        }
    }
}

public class DescribeCustomLineResponseBody : Tea.TeaModel {
    public class IpSegmentList : Tea.TeaModel {
        public var endIp: String?

        public var startIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endIp != nil {
                map["EndIp"] = self.endIp!
            }
            if self.startIp != nil {
                map["StartIp"] = self.startIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EndIp"] as? String {
                self.endIp = value
            }
            if let value = dict["StartIp"] as? String {
                self.startIp = value
            }
        }
    }
    public var code: String?

    public var domainName: String?

    public var id: Int64?

    public var ipSegmentList: [DescribeCustomLineResponseBody.IpSegmentList]?

    public var name: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ipSegmentList != nil {
            var tmp : [Any] = []
            for k in self.ipSegmentList! {
                tmp.append(k.toMap())
            }
            map["IpSegmentList"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["IpSegmentList"] as? [Any?] {
            var tmp : [DescribeCustomLineResponseBody.IpSegmentList] = []
            for v in value {
                if v != nil {
                    var model = DescribeCustomLineResponseBody.IpSegmentList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ipSegmentList = tmp
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeCustomLineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomLineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCustomLineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCustomLinesRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class DescribeCustomLinesResponseBody : Tea.TeaModel {
    public class CustomLines : Tea.TeaModel {
        public class IpSegmentList : Tea.TeaModel {
            public var endIp: String?

            public var startIp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endIp != nil {
                    map["EndIp"] = self.endIp!
                }
                if self.startIp != nil {
                    map["StartIp"] = self.startIp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EndIp"] as? String {
                    self.endIp = value
                }
                if let value = dict["StartIp"] as? String {
                    self.startIp = value
                }
            }
        }
        public var code: String?

        public var id: Int64?

        public var ipSegmentList: [DescribeCustomLinesResponseBody.CustomLines.IpSegmentList]?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ipSegmentList != nil {
                var tmp : [Any] = []
                for k in self.ipSegmentList! {
                    tmp.append(k.toMap())
                }
                map["IpSegmentList"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Code"] as? String {
                self.code = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["IpSegmentList"] as? [Any?] {
                var tmp : [DescribeCustomLinesResponseBody.CustomLines.IpSegmentList] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCustomLinesResponseBody.CustomLines.IpSegmentList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipSegmentList = tmp
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
        }
    }
    public var customLines: [DescribeCustomLinesResponseBody.CustomLines]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customLines != nil {
            var tmp : [Any] = []
            for k in self.customLines! {
                tmp.append(k.toMap())
            }
            map["CustomLines"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CustomLines"] as? [Any?] {
            var tmp : [DescribeCustomLinesResponseBody.CustomLines] = []
            for v in value {
                if v != nil {
                    var model = DescribeCustomLinesResponseBody.CustomLines()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.customLines = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeCustomLinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomLinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCustomLinesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDNSSLBSubDomainsRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var rr: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.rr != nil {
            map["Rr"] = self.rr!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["Rr"] as? String {
            self.rr = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
    }
}

public class DescribeDNSSLBSubDomainsResponseBody : Tea.TeaModel {
    public class SlbSubDomains : Tea.TeaModel {
        public class SlbSubDomain : Tea.TeaModel {
            public class LineAlgorithms : Tea.TeaModel {
                public class LineAlgorithm : Tea.TeaModel {
                    public var line: String?

                    public var open_: Bool?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.line != nil {
                            map["Line"] = self.line!
                        }
                        if self.open_ != nil {
                            map["Open"] = self.open_!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Line"] as? String {
                            self.line = value
                        }
                        if let value = dict["Open"] as? Bool {
                            self.open_ = value
                        }
                    }
                }
                public var lineAlgorithm: [DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms.LineAlgorithm]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lineAlgorithm != nil {
                        var tmp : [Any] = []
                        for k in self.lineAlgorithm! {
                            tmp.append(k.toMap())
                        }
                        map["LineAlgorithm"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LineAlgorithm"] as? [Any?] {
                        var tmp : [DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms.LineAlgorithm] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms.LineAlgorithm()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.lineAlgorithm = tmp
                    }
                }
            }
            public var lineAlgorithms: DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms?

            public var open_: Bool?

            public var recordCount: Int64?

            public var subDomain: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.lineAlgorithms?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.lineAlgorithms != nil {
                    map["LineAlgorithms"] = self.lineAlgorithms?.toMap()
                }
                if self.open_ != nil {
                    map["Open"] = self.open_!
                }
                if self.recordCount != nil {
                    map["RecordCount"] = self.recordCount!
                }
                if self.subDomain != nil {
                    map["SubDomain"] = self.subDomain!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LineAlgorithms"] as? [String: Any?] {
                    var model = DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms()
                    model.fromMap(value)
                    self.lineAlgorithms = model
                }
                if let value = dict["Open"] as? Bool {
                    self.open_ = value
                }
                if let value = dict["RecordCount"] as? Int64 {
                    self.recordCount = value
                }
                if let value = dict["SubDomain"] as? String {
                    self.subDomain = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var slbSubDomain: [DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbSubDomain != nil {
                var tmp : [Any] = []
                for k in self.slbSubDomain! {
                    tmp.append(k.toMap())
                }
                map["SlbSubDomain"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SlbSubDomain"] as? [Any?] {
                var tmp : [DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.slbSubDomain = tmp
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var slbSubDomains: DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.slbSubDomains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.slbSubDomains != nil {
            map["SlbSubDomains"] = self.slbSubDomains?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SlbSubDomains"] as? [String: Any?] {
            var model = DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains()
            model.fromMap(value)
            self.slbSubDomains = model
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeDNSSLBSubDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDNSSLBSubDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDNSSLBSubDomainsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsCacheDomainsRequest : Tea.TeaModel {
    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class DescribeDnsCacheDomainsResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class SourceDnsServers : Tea.TeaModel {
            public var host: String?

            public var port: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Host"] as? String {
                    self.host = value
                }
                if let value = dict["Port"] as? String {
                    self.port = value
                }
            }
        }
        public var cacheTtlMax: Int32?

        public var cacheTtlMin: Int32?

        public var createTime: String?

        public var createTimestamp: Int64?

        public var domainId: String?

        public var domainName: String?

        public var expireTime: String?

        public var expireTimestamp: Int64?

        public var instanceId: String?

        public var remark: String?

        public var sourceDnsServers: [DescribeDnsCacheDomainsResponseBody.Domains.SourceDnsServers]?

        public var sourceEdns: String?

        public var sourceProtocol: String?

        public var updateTime: String?

        public var updateTimestamp: Int64?

        public var versionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cacheTtlMax != nil {
                map["CacheTtlMax"] = self.cacheTtlMax!
            }
            if self.cacheTtlMin != nil {
                map["CacheTtlMin"] = self.cacheTtlMin!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.expireTimestamp != nil {
                map["ExpireTimestamp"] = self.expireTimestamp!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.sourceDnsServers != nil {
                var tmp : [Any] = []
                for k in self.sourceDnsServers! {
                    tmp.append(k.toMap())
                }
                map["SourceDnsServers"] = tmp
            }
            if self.sourceEdns != nil {
                map["SourceEdns"] = self.sourceEdns!
            }
            if self.sourceProtocol != nil {
                map["SourceProtocol"] = self.sourceProtocol!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.updateTimestamp != nil {
                map["UpdateTimestamp"] = self.updateTimestamp!
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CacheTtlMax"] as? Int32 {
                self.cacheTtlMax = value
            }
            if let value = dict["CacheTtlMin"] as? Int32 {
                self.cacheTtlMin = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["CreateTimestamp"] as? Int64 {
                self.createTimestamp = value
            }
            if let value = dict["DomainId"] as? String {
                self.domainId = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["ExpireTime"] as? String {
                self.expireTime = value
            }
            if let value = dict["ExpireTimestamp"] as? Int64 {
                self.expireTimestamp = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["Remark"] as? String {
                self.remark = value
            }
            if let value = dict["SourceDnsServers"] as? [Any?] {
                var tmp : [DescribeDnsCacheDomainsResponseBody.Domains.SourceDnsServers] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsCacheDomainsResponseBody.Domains.SourceDnsServers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sourceDnsServers = tmp
            }
            if let value = dict["SourceEdns"] as? String {
                self.sourceEdns = value
            }
            if let value = dict["SourceProtocol"] as? String {
                self.sourceProtocol = value
            }
            if let value = dict["UpdateTime"] as? String {
                self.updateTime = value
            }
            if let value = dict["UpdateTimestamp"] as? Int64 {
                self.updateTimestamp = value
            }
            if let value = dict["VersionCode"] as? String {
                self.versionCode = value
            }
        }
    }
    public var domains: [DescribeDnsCacheDomainsResponseBody.Domains]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domains != nil {
            var tmp : [Any] = []
            for k in self.domains! {
                tmp.append(k.toMap())
            }
            map["Domains"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Domains"] as? [Any?] {
            var tmp : [DescribeDnsCacheDomainsResponseBody.Domains] = []
            for v in value {
                if v != nil {
                    var model = DescribeDnsCacheDomainsResponseBody.Domains()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.domains = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeDnsCacheDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsCacheDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsCacheDomainsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmAccessStrategiesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var strategyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StrategyMode"] as? String {
            self.strategyMode = value
        }
    }
}

public class DescribeDnsGtmAccessStrategiesResponseBody : Tea.TeaModel {
    public class Strategies : Tea.TeaModel {
        public class Strategy : Tea.TeaModel {
            public class EffectiveAddrPools : Tea.TeaModel {
                public class EffectiveAddrPool : Tea.TeaModel {
                    public var addrCount: Int32?

                    public var id: String?

                    public var lbaWeight: Int32?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.addrCount != nil {
                            map["AddrCount"] = self.addrCount!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.lbaWeight != nil {
                            map["LbaWeight"] = self.lbaWeight!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AddrCount"] as? Int32 {
                            self.addrCount = value
                        }
                        if let value = dict["Id"] as? String {
                            self.id = value
                        }
                        if let value = dict["LbaWeight"] as? Int32 {
                            self.lbaWeight = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                    }
                }
                public var effectiveAddrPool: [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools.EffectiveAddrPool]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.effectiveAddrPool != nil {
                        var tmp : [Any] = []
                        for k in self.effectiveAddrPool! {
                            tmp.append(k.toMap())
                        }
                        map["EffectiveAddrPool"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EffectiveAddrPool"] as? [Any?] {
                        var tmp : [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools.EffectiveAddrPool] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools.EffectiveAddrPool()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.effectiveAddrPool = tmp
                    }
                }
            }
            public class Lines : Tea.TeaModel {
                public class Line : Tea.TeaModel {
                    public var groupCode: String?

                    public var groupName: String?

                    public var lineCode: String?

                    public var lineName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.groupCode != nil {
                            map["GroupCode"] = self.groupCode!
                        }
                        if self.groupName != nil {
                            map["GroupName"] = self.groupName!
                        }
                        if self.lineCode != nil {
                            map["LineCode"] = self.lineCode!
                        }
                        if self.lineName != nil {
                            map["LineName"] = self.lineName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["GroupCode"] as? String {
                            self.groupCode = value
                        }
                        if let value = dict["GroupName"] as? String {
                            self.groupName = value
                        }
                        if let value = dict["LineCode"] as? String {
                            self.lineCode = value
                        }
                        if let value = dict["LineName"] as? String {
                            self.lineName = value
                        }
                    }
                }
                public var line: [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.line != nil {
                        var tmp : [Any] = []
                        for k in self.line! {
                            tmp.append(k.toMap())
                        }
                        map["Line"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Line"] as? [Any?] {
                        var tmp : [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.line = tmp
                    }
                }
            }
            public var createTime: String?

            public var createTimestamp: Int64?

            public var effectiveAddrPoolGroupType: String?

            public var effectiveAddrPoolType: String?

            public var effectiveAddrPools: DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools?

            public var effectiveLbaStrategy: String?

            public var lines: DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines?

            public var strategyId: String?

            public var strategyName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.effectiveAddrPools?.validate()
                try self.lines?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.effectiveAddrPoolGroupType != nil {
                    map["EffectiveAddrPoolGroupType"] = self.effectiveAddrPoolGroupType!
                }
                if self.effectiveAddrPoolType != nil {
                    map["EffectiveAddrPoolType"] = self.effectiveAddrPoolType!
                }
                if self.effectiveAddrPools != nil {
                    map["EffectiveAddrPools"] = self.effectiveAddrPools?.toMap()
                }
                if self.effectiveLbaStrategy != nil {
                    map["EffectiveLbaStrategy"] = self.effectiveLbaStrategy!
                }
                if self.lines != nil {
                    map["Lines"] = self.lines?.toMap()
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.strategyName != nil {
                    map["StrategyName"] = self.strategyName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["EffectiveAddrPoolGroupType"] as? String {
                    self.effectiveAddrPoolGroupType = value
                }
                if let value = dict["EffectiveAddrPoolType"] as? String {
                    self.effectiveAddrPoolType = value
                }
                if let value = dict["EffectiveAddrPools"] as? [String: Any?] {
                    var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools()
                    model.fromMap(value)
                    self.effectiveAddrPools = model
                }
                if let value = dict["EffectiveLbaStrategy"] as? String {
                    self.effectiveLbaStrategy = value
                }
                if let value = dict["Lines"] as? [String: Any?] {
                    var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines()
                    model.fromMap(value)
                    self.lines = model
                }
                if let value = dict["StrategyId"] as? String {
                    self.strategyId = value
                }
                if let value = dict["StrategyName"] as? String {
                    self.strategyName = value
                }
            }
        }
        public var strategy: [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.strategy != nil {
                var tmp : [Any] = []
                for k in self.strategy! {
                    tmp.append(k.toMap())
                }
                map["Strategy"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Strategy"] as? [Any?] {
                var tmp : [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.strategy = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var strategies: DescribeDnsGtmAccessStrategiesResponseBody.Strategies?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.strategies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategies != nil {
            map["Strategies"] = self.strategies?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Strategies"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies()
            model.fromMap(value)
            self.strategies = model
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeDnsGtmAccessStrategiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAccessStrategiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategiesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmAccessStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StrategyId"] as? String {
            self.strategyId = value
        }
    }
}

public class DescribeDnsGtmAccessStrategyResponseBody : Tea.TeaModel {
    public class DefaultAddrPools : Tea.TeaModel {
        public class DefaultAddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var lbaWeight: Int32?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.lbaWeight != nil {
                    map["LbaWeight"] = self.lbaWeight!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddrCount"] as? Int32 {
                    self.addrCount = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["LbaWeight"] as? Int32 {
                    self.lbaWeight = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var defaultAddrPool: [DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools.DefaultAddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultAddrPool != nil {
                var tmp : [Any] = []
                for k in self.defaultAddrPool! {
                    tmp.append(k.toMap())
                }
                map["DefaultAddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DefaultAddrPool"] as? [Any?] {
                var tmp : [DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools.DefaultAddrPool] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools.DefaultAddrPool()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.defaultAddrPool = tmp
            }
        }
    }
    public class FailoverAddrPools : Tea.TeaModel {
        public class FailoverAddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var lbaWeight: Int32?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.lbaWeight != nil {
                    map["LbaWeight"] = self.lbaWeight!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddrCount"] as? Int32 {
                    self.addrCount = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["LbaWeight"] as? Int32 {
                    self.lbaWeight = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var failoverAddrPool: [DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools.FailoverAddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failoverAddrPool != nil {
                var tmp : [Any] = []
                for k in self.failoverAddrPool! {
                    tmp.append(k.toMap())
                }
                map["FailoverAddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FailoverAddrPool"] as? [Any?] {
                var tmp : [DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools.FailoverAddrPool] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools.FailoverAddrPool()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.failoverAddrPool = tmp
            }
        }
    }
    public class Lines : Tea.TeaModel {
        public class Line : Tea.TeaModel {
            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["GroupCode"] as? String {
                    self.groupCode = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["LineCode"] as? String {
                    self.lineCode = value
                }
                if let value = dict["LineName"] as? String {
                    self.lineName = value
                }
            }
        }
        public var line: [DescribeDnsGtmAccessStrategyResponseBody.Lines.Line]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.line != nil {
                var tmp : [Any] = []
                for k in self.line! {
                    tmp.append(k.toMap())
                }
                map["Line"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Line"] as? [Any?] {
                var tmp : [DescribeDnsGtmAccessStrategyResponseBody.Lines.Line] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmAccessStrategyResponseBody.Lines.Line()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.line = tmp
            }
        }
    }
    public var accessMode: String?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var defaultAddrPoolGroupStatus: String?

    public var defaultAddrPoolType: String?

    public var defaultAddrPools: DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools?

    public var defaultAvailableAddrNum: Int32?

    public var defaultLatencyOptimization: String?

    public var defaultLbaStrategy: String?

    public var defaultMaxReturnAddrNum: Int32?

    public var defaultMinAvailableAddrNum: Int32?

    public var effectiveAddrPoolGroupType: String?

    public var failoverAddrPoolGroupStatus: String?

    public var failoverAddrPoolType: String?

    public var failoverAddrPools: DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools?

    public var failoverAvailableAddrNum: Int32?

    public var failoverLatencyOptimization: String?

    public var failoverLbaStrategy: String?

    public var failoverMaxReturnAddrNum: Int32?

    public var failoverMinAvailableAddrNum: Int32?

    public var instanceId: String?

    public var lines: DescribeDnsGtmAccessStrategyResponseBody.Lines?

    public var requestId: String?

    public var strategyId: String?

    public var strategyMode: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.defaultAddrPools?.validate()
        try self.failoverAddrPools?.validate()
        try self.lines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.defaultAddrPoolGroupStatus != nil {
            map["DefaultAddrPoolGroupStatus"] = self.defaultAddrPoolGroupStatus!
        }
        if self.defaultAddrPoolType != nil {
            map["DefaultAddrPoolType"] = self.defaultAddrPoolType!
        }
        if self.defaultAddrPools != nil {
            map["DefaultAddrPools"] = self.defaultAddrPools?.toMap()
        }
        if self.defaultAvailableAddrNum != nil {
            map["DefaultAvailableAddrNum"] = self.defaultAvailableAddrNum!
        }
        if self.defaultLatencyOptimization != nil {
            map["DefaultLatencyOptimization"] = self.defaultLatencyOptimization!
        }
        if self.defaultLbaStrategy != nil {
            map["DefaultLbaStrategy"] = self.defaultLbaStrategy!
        }
        if self.defaultMaxReturnAddrNum != nil {
            map["DefaultMaxReturnAddrNum"] = self.defaultMaxReturnAddrNum!
        }
        if self.defaultMinAvailableAddrNum != nil {
            map["DefaultMinAvailableAddrNum"] = self.defaultMinAvailableAddrNum!
        }
        if self.effectiveAddrPoolGroupType != nil {
            map["EffectiveAddrPoolGroupType"] = self.effectiveAddrPoolGroupType!
        }
        if self.failoverAddrPoolGroupStatus != nil {
            map["FailoverAddrPoolGroupStatus"] = self.failoverAddrPoolGroupStatus!
        }
        if self.failoverAddrPoolType != nil {
            map["FailoverAddrPoolType"] = self.failoverAddrPoolType!
        }
        if self.failoverAddrPools != nil {
            map["FailoverAddrPools"] = self.failoverAddrPools?.toMap()
        }
        if self.failoverAvailableAddrNum != nil {
            map["FailoverAvailableAddrNum"] = self.failoverAvailableAddrNum!
        }
        if self.failoverLatencyOptimization != nil {
            map["FailoverLatencyOptimization"] = self.failoverLatencyOptimization!
        }
        if self.failoverLbaStrategy != nil {
            map["FailoverLbaStrategy"] = self.failoverLbaStrategy!
        }
        if self.failoverMaxReturnAddrNum != nil {
            map["FailoverMaxReturnAddrNum"] = self.failoverMaxReturnAddrNum!
        }
        if self.failoverMinAvailableAddrNum != nil {
            map["FailoverMinAvailableAddrNum"] = self.failoverMinAvailableAddrNum!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lines != nil {
            map["Lines"] = self.lines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessMode"] as? String {
            self.accessMode = value
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["DefaultAddrPoolGroupStatus"] as? String {
            self.defaultAddrPoolGroupStatus = value
        }
        if let value = dict["DefaultAddrPoolType"] as? String {
            self.defaultAddrPoolType = value
        }
        if let value = dict["DefaultAddrPools"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools()
            model.fromMap(value)
            self.defaultAddrPools = model
        }
        if let value = dict["DefaultAvailableAddrNum"] as? Int32 {
            self.defaultAvailableAddrNum = value
        }
        if let value = dict["DefaultLatencyOptimization"] as? String {
            self.defaultLatencyOptimization = value
        }
        if let value = dict["DefaultLbaStrategy"] as? String {
            self.defaultLbaStrategy = value
        }
        if let value = dict["DefaultMaxReturnAddrNum"] as? Int32 {
            self.defaultMaxReturnAddrNum = value
        }
        if let value = dict["DefaultMinAvailableAddrNum"] as? Int32 {
            self.defaultMinAvailableAddrNum = value
        }
        if let value = dict["EffectiveAddrPoolGroupType"] as? String {
            self.effectiveAddrPoolGroupType = value
        }
        if let value = dict["FailoverAddrPoolGroupStatus"] as? String {
            self.failoverAddrPoolGroupStatus = value
        }
        if let value = dict["FailoverAddrPoolType"] as? String {
            self.failoverAddrPoolType = value
        }
        if let value = dict["FailoverAddrPools"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools()
            model.fromMap(value)
            self.failoverAddrPools = model
        }
        if let value = dict["FailoverAvailableAddrNum"] as? Int32 {
            self.failoverAvailableAddrNum = value
        }
        if let value = dict["FailoverLatencyOptimization"] as? String {
            self.failoverLatencyOptimization = value
        }
        if let value = dict["FailoverLbaStrategy"] as? String {
            self.failoverLbaStrategy = value
        }
        if let value = dict["FailoverMaxReturnAddrNum"] as? Int32 {
            self.failoverMaxReturnAddrNum = value
        }
        if let value = dict["FailoverMinAvailableAddrNum"] as? Int32 {
            self.failoverMinAvailableAddrNum = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lines"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategyResponseBody.Lines()
            model.fromMap(value)
            self.lines = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StrategyId"] as? String {
            self.strategyId = value
        }
        if let value = dict["StrategyMode"] as? String {
            self.strategyMode = value
        }
        if let value = dict["StrategyName"] as? String {
            self.strategyName = value
        }
    }
}

public class DescribeDnsGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmAccessStrategyAvailableConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var strategyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StrategyMode"] as? String {
            self.strategyMode = value
        }
    }
}

public class DescribeDnsGtmAccessStrategyAvailableConfigResponseBody : Tea.TeaModel {
    public class DomainAddrPools : Tea.TeaModel {
        public class DomainAddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddrCount"] as? Int32 {
                    self.addrCount = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var domainAddrPool: [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools.DomainAddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainAddrPool != nil {
                var tmp : [Any] = []
                for k in self.domainAddrPool! {
                    tmp.append(k.toMap())
                }
                map["DomainAddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainAddrPool"] as? [Any?] {
                var tmp : [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools.DomainAddrPool] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools.DomainAddrPool()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainAddrPool = tmp
            }
        }
    }
    public class Ipv4AddrPools : Tea.TeaModel {
        public class Ipv4AddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddrCount"] as? Int32 {
                    self.addrCount = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var ipv4AddrPool: [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools.Ipv4AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4AddrPool != nil {
                var tmp : [Any] = []
                for k in self.ipv4AddrPool! {
                    tmp.append(k.toMap())
                }
                map["Ipv4AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv4AddrPool"] as? [Any?] {
                var tmp : [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools.Ipv4AddrPool] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools.Ipv4AddrPool()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv4AddrPool = tmp
            }
        }
    }
    public class Ipv6AddrPools : Tea.TeaModel {
        public class Ipv6AddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddrCount"] as? Int32 {
                    self.addrCount = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var ipv6AddrPool: [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools.Ipv6AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6AddrPool != nil {
                var tmp : [Any] = []
                for k in self.ipv6AddrPool! {
                    tmp.append(k.toMap())
                }
                map["Ipv6AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6AddrPool"] as? [Any?] {
                var tmp : [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools.Ipv6AddrPool] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools.Ipv6AddrPool()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv6AddrPool = tmp
            }
        }
    }
    public class Lines : Tea.TeaModel {
        public class Line : Tea.TeaModel {
            public var fatherCode: String?

            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FatherCode"] as? String {
                    self.fatherCode = value
                }
                if let value = dict["GroupCode"] as? String {
                    self.groupCode = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["LineCode"] as? String {
                    self.lineCode = value
                }
                if let value = dict["LineName"] as? String {
                    self.lineName = value
                }
            }
        }
        public var line: [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines.Line]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.line != nil {
                var tmp : [Any] = []
                for k in self.line! {
                    tmp.append(k.toMap())
                }
                map["Line"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Line"] as? [Any?] {
                var tmp : [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines.Line] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines.Line()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.line = tmp
            }
        }
    }
    public class SelectedDomainLines : Tea.TeaModel {
        public var selectedDomainLine: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.selectedDomainLine != nil {
                map["SelectedDomainLine"] = self.selectedDomainLine!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SelectedDomainLine"] as? [String] {
                self.selectedDomainLine = value
            }
        }
    }
    public class SelectedIpv4Lines : Tea.TeaModel {
        public var selectedIpv4Line: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.selectedIpv4Line != nil {
                map["SelectedIpv4Line"] = self.selectedIpv4Line!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SelectedIpv4Line"] as? [String] {
                self.selectedIpv4Line = value
            }
        }
    }
    public class SelectedIpv6Lines : Tea.TeaModel {
        public var selectedIpv6Line: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.selectedIpv6Line != nil {
                map["SelectedIpv6Line"] = self.selectedIpv6Line!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SelectedIpv6Line"] as? [String] {
                self.selectedIpv6Line = value
            }
        }
    }
    public var domainAddrPools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools?

    public var ipv4AddrPools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools?

    public var ipv6AddrPools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools?

    public var lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines?

    public var requestId: String?

    public var selectedDomainLines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedDomainLines?

    public var selectedIpv4Lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedIpv4Lines?

    public var selectedIpv6Lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedIpv6Lines?

    public var suggestSetDefaultLine: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainAddrPools?.validate()
        try self.ipv4AddrPools?.validate()
        try self.ipv6AddrPools?.validate()
        try self.lines?.validate()
        try self.selectedDomainLines?.validate()
        try self.selectedIpv4Lines?.validate()
        try self.selectedIpv6Lines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainAddrPools != nil {
            map["DomainAddrPools"] = self.domainAddrPools?.toMap()
        }
        if self.ipv4AddrPools != nil {
            map["Ipv4AddrPools"] = self.ipv4AddrPools?.toMap()
        }
        if self.ipv6AddrPools != nil {
            map["Ipv6AddrPools"] = self.ipv6AddrPools?.toMap()
        }
        if self.lines != nil {
            map["Lines"] = self.lines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.selectedDomainLines != nil {
            map["SelectedDomainLines"] = self.selectedDomainLines?.toMap()
        }
        if self.selectedIpv4Lines != nil {
            map["SelectedIpv4Lines"] = self.selectedIpv4Lines?.toMap()
        }
        if self.selectedIpv6Lines != nil {
            map["SelectedIpv6Lines"] = self.selectedIpv6Lines?.toMap()
        }
        if self.suggestSetDefaultLine != nil {
            map["SuggestSetDefaultLine"] = self.suggestSetDefaultLine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainAddrPools"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools()
            model.fromMap(value)
            self.domainAddrPools = model
        }
        if let value = dict["Ipv4AddrPools"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools()
            model.fromMap(value)
            self.ipv4AddrPools = model
        }
        if let value = dict["Ipv6AddrPools"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools()
            model.fromMap(value)
            self.ipv6AddrPools = model
        }
        if let value = dict["Lines"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines()
            model.fromMap(value)
            self.lines = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SelectedDomainLines"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedDomainLines()
            model.fromMap(value)
            self.selectedDomainLines = model
        }
        if let value = dict["SelectedIpv4Lines"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedIpv4Lines()
            model.fromMap(value)
            self.selectedIpv4Lines = model
        }
        if let value = dict["SelectedIpv6Lines"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedIpv6Lines()
            model.fromMap(value)
            self.selectedIpv6Lines = model
        }
        if let value = dict["SuggestSetDefaultLine"] as? Bool {
            self.suggestSetDefaultLine = value
        }
    }
}

public class DescribeDnsGtmAccessStrategyAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmAddrAttributeInfoRequest : Tea.TeaModel {
    public var addrs: String?

    public var lang: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrs != nil {
            map["Addrs"] = self.addrs!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Addrs"] as? String {
            self.addrs = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeDnsGtmAddrAttributeInfoResponseBody : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public class Addr : Tea.TeaModel {
            public class AttributeInfo : Tea.TeaModel {
                public var fatherCode: String?

                public var groupCode: String?

                public var groupName: String?

                public var lineCode: String?

                public var lineName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fatherCode != nil {
                        map["FatherCode"] = self.fatherCode!
                    }
                    if self.groupCode != nil {
                        map["GroupCode"] = self.groupCode!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.lineCode != nil {
                        map["LineCode"] = self.lineCode!
                    }
                    if self.lineName != nil {
                        map["LineName"] = self.lineName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FatherCode"] as? String {
                        self.fatherCode = value
                    }
                    if let value = dict["GroupCode"] as? String {
                        self.groupCode = value
                    }
                    if let value = dict["GroupName"] as? String {
                        self.groupName = value
                    }
                    if let value = dict["LineCode"] as? String {
                        self.lineCode = value
                    }
                    if let value = dict["LineName"] as? String {
                        self.lineName = value
                    }
                }
            }
            public var addr: String?

            public var attributeInfo: DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr.AttributeInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.attributeInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addr != nil {
                    map["Addr"] = self.addr!
                }
                if self.attributeInfo != nil {
                    map["AttributeInfo"] = self.attributeInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Addr"] as? String {
                    self.addr = value
                }
                if let value = dict["AttributeInfo"] as? [String: Any?] {
                    var model = DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr.AttributeInfo()
                    model.fromMap(value)
                    self.attributeInfo = model
                }
            }
        }
        public var addr: [DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                var tmp : [Any] = []
                for k in self.addr! {
                    tmp.append(k.toMap())
                }
                map["Addr"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Addr"] as? [Any?] {
                var tmp : [DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.addr = tmp
            }
        }
    }
    public var addr: DescribeDnsGtmAddrAttributeInfoResponseBody.Addr?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addr?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            map["Addr"] = self.addr?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Addr"] as? [String: Any?] {
            var model = DescribeDnsGtmAddrAttributeInfoResponseBody.Addr()
            model.fromMap(value)
            self.addr = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDnsGtmAddrAttributeInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAddrAttributeInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmAddrAttributeInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmAddressPoolAvailableConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeDnsGtmAddressPoolAvailableConfigResponseBody : Tea.TeaModel {
    public class AttributeInfos : Tea.TeaModel {
        public class AttributeInfo : Tea.TeaModel {
            public var fatherCode: String?

            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FatherCode"] as? String {
                    self.fatherCode = value
                }
                if let value = dict["GroupCode"] as? String {
                    self.groupCode = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["LineCode"] as? String {
                    self.lineCode = value
                }
                if let value = dict["LineName"] as? String {
                    self.lineName = value
                }
            }
        }
        public var attributeInfo: [DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos.AttributeInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attributeInfo != nil {
                var tmp : [Any] = []
                for k in self.attributeInfo! {
                    tmp.append(k.toMap())
                }
                map["AttributeInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AttributeInfo"] as? [Any?] {
                var tmp : [DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos.AttributeInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos.AttributeInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.attributeInfo = tmp
            }
        }
    }
    public var attributeInfos: DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.attributeInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributeInfos != nil {
            map["AttributeInfos"] = self.attributeInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AttributeInfos"] as? [String: Any?] {
            var model = DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos()
            model.fromMap(value)
            self.attributeInfos = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDnsGtmAddressPoolAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAddressPoolAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmAddressPoolAvailableConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmAvailableAlertGroupRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeDnsGtmAvailableAlertGroupResponseBody : Tea.TeaModel {
    public var availableAlertGroup: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAlertGroup != nil {
            map["AvailableAlertGroup"] = self.availableAlertGroup!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AvailableAlertGroup"] as? String {
            self.availableAlertGroup = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDnsGtmAvailableAlertGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAvailableAlertGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmAvailableAlertGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeDnsGtmInstanceResponseBody : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public class AlertConfig : Tea.TeaModel {
            public class AlertConfig : Tea.TeaModel {
                public var dingtalkNotice: Bool?

                public var emailNotice: Bool?

                public var noticeType: String?

                public var smsNotice: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dingtalkNotice != nil {
                        map["DingtalkNotice"] = self.dingtalkNotice!
                    }
                    if self.emailNotice != nil {
                        map["EmailNotice"] = self.emailNotice!
                    }
                    if self.noticeType != nil {
                        map["NoticeType"] = self.noticeType!
                    }
                    if self.smsNotice != nil {
                        map["SmsNotice"] = self.smsNotice!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DingtalkNotice"] as? Bool {
                        self.dingtalkNotice = value
                    }
                    if let value = dict["EmailNotice"] as? Bool {
                        self.emailNotice = value
                    }
                    if let value = dict["NoticeType"] as? String {
                        self.noticeType = value
                    }
                    if let value = dict["SmsNotice"] as? Bool {
                        self.smsNotice = value
                    }
                }
            }
            public var alertConfig: [DescribeDnsGtmInstanceResponseBody.Config.AlertConfig.AlertConfig]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertConfig != nil {
                    var tmp : [Any] = []
                    for k in self.alertConfig! {
                        tmp.append(k.toMap())
                    }
                    map["AlertConfig"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AlertConfig"] as? [Any?] {
                    var tmp : [DescribeDnsGtmInstanceResponseBody.Config.AlertConfig.AlertConfig] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeDnsGtmInstanceResponseBody.Config.AlertConfig.AlertConfig()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.alertConfig = tmp
                }
            }
        }
        public var alertConfig: DescribeDnsGtmInstanceResponseBody.Config.AlertConfig?

        public var alertGroup: String?

        public var cnameType: String?

        public var instanceName: String?

        public var pubicZoneName: String?

        public var publicCnameMode: String?

        public var publicRr: String?

        public var publicUserDomainName: String?

        public var strategyMode: String?

        public var ttl: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.alertConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertConfig != nil {
                map["AlertConfig"] = self.alertConfig?.toMap()
            }
            if self.alertGroup != nil {
                map["AlertGroup"] = self.alertGroup!
            }
            if self.cnameType != nil {
                map["CnameType"] = self.cnameType!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.pubicZoneName != nil {
                map["PubicZoneName"] = self.pubicZoneName!
            }
            if self.publicCnameMode != nil {
                map["PublicCnameMode"] = self.publicCnameMode!
            }
            if self.publicRr != nil {
                map["PublicRr"] = self.publicRr!
            }
            if self.publicUserDomainName != nil {
                map["PublicUserDomainName"] = self.publicUserDomainName!
            }
            if self.strategyMode != nil {
                map["StrategyMode"] = self.strategyMode!
            }
            if self.ttl != nil {
                map["Ttl"] = self.ttl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlertConfig"] as? [String: Any?] {
                var model = DescribeDnsGtmInstanceResponseBody.Config.AlertConfig()
                model.fromMap(value)
                self.alertConfig = model
            }
            if let value = dict["AlertGroup"] as? String {
                self.alertGroup = value
            }
            if let value = dict["CnameType"] as? String {
                self.cnameType = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["PubicZoneName"] as? String {
                self.pubicZoneName = value
            }
            if let value = dict["PublicCnameMode"] as? String {
                self.publicCnameMode = value
            }
            if let value = dict["PublicRr"] as? String {
                self.publicRr = value
            }
            if let value = dict["PublicUserDomainName"] as? String {
                self.publicUserDomainName = value
            }
            if let value = dict["StrategyMode"] as? String {
                self.strategyMode = value
            }
            if let value = dict["Ttl"] as? Int32 {
                self.ttl = value
            }
        }
    }
    public class UsedQuota : Tea.TeaModel {
        public var dingtalkUsedCount: Int32?

        public var emailUsedCount: Int32?

        public var smsUsedCount: Int32?

        public var taskUsedCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingtalkUsedCount != nil {
                map["DingtalkUsedCount"] = self.dingtalkUsedCount!
            }
            if self.emailUsedCount != nil {
                map["EmailUsedCount"] = self.emailUsedCount!
            }
            if self.smsUsedCount != nil {
                map["SmsUsedCount"] = self.smsUsedCount!
            }
            if self.taskUsedCount != nil {
                map["TaskUsedCount"] = self.taskUsedCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DingtalkUsedCount"] as? Int32 {
                self.dingtalkUsedCount = value
            }
            if let value = dict["EmailUsedCount"] as? Int32 {
                self.emailUsedCount = value
            }
            if let value = dict["SmsUsedCount"] as? Int32 {
                self.smsUsedCount = value
            }
            if let value = dict["TaskUsedCount"] as? Int32 {
                self.taskUsedCount = value
            }
        }
    }
    public var config: DescribeDnsGtmInstanceResponseBody.Config?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var expireTime: String?

    public var expireTimestamp: Int64?

    public var instanceId: String?

    public var paymentType: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var smsQuota: Int32?

    public var taskQuota: Int32?

    public var usedQuota: DescribeDnsGtmInstanceResponseBody.UsedQuota?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.config?.validate()
        try self.usedQuota?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.expireTimestamp != nil {
            map["ExpireTimestamp"] = self.expireTimestamp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.smsQuota != nil {
            map["SmsQuota"] = self.smsQuota!
        }
        if self.taskQuota != nil {
            map["TaskQuota"] = self.taskQuota!
        }
        if self.usedQuota != nil {
            map["UsedQuota"] = self.usedQuota?.toMap()
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Config"] as? [String: Any?] {
            var model = DescribeDnsGtmInstanceResponseBody.Config()
            model.fromMap(value)
            self.config = model
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["ExpireTime"] as? String {
            self.expireTime = value
        }
        if let value = dict["ExpireTimestamp"] as? Int64 {
            self.expireTimestamp = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PaymentType"] as? String {
            self.paymentType = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SmsQuota"] as? Int32 {
            self.smsQuota = value
        }
        if let value = dict["TaskQuota"] as? Int32 {
            self.taskQuota = value
        }
        if let value = dict["UsedQuota"] as? [String: Any?] {
            var model = DescribeDnsGtmInstanceResponseBody.UsedQuota()
            model.fromMap(value)
            self.usedQuota = model
        }
        if let value = dict["VersionCode"] as? String {
            self.versionCode = value
        }
    }
}

public class DescribeDnsGtmInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolRequest : Tea.TeaModel {
    public var addrPoolId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrPoolId"] as? String {
            self.addrPoolId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolResponseBody : Tea.TeaModel {
    public class Addrs : Tea.TeaModel {
        public class Addr : Tea.TeaModel {
            public var addr: String?

            public var alertStatus: String?

            public var attributeInfo: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var lbaWeight: Int32?

            public var mode: String?

            public var remark: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addr != nil {
                    map["Addr"] = self.addr!
                }
                if self.alertStatus != nil {
                    map["AlertStatus"] = self.alertStatus!
                }
                if self.attributeInfo != nil {
                    map["AttributeInfo"] = self.attributeInfo!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.lbaWeight != nil {
                    map["LbaWeight"] = self.lbaWeight!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Addr"] as? String {
                    self.addr = value
                }
                if let value = dict["AlertStatus"] as? String {
                    self.alertStatus = value
                }
                if let value = dict["AttributeInfo"] as? String {
                    self.attributeInfo = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["LbaWeight"] as? Int32 {
                    self.lbaWeight = value
                }
                if let value = dict["Mode"] as? String {
                    self.mode = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
            }
        }
        public var addr: [DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs.Addr]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                var tmp : [Any] = []
                for k in self.addr! {
                    tmp.append(k.toMap())
                }
                map["Addr"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Addr"] as? [Any?] {
                var tmp : [DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs.Addr] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs.Addr()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.addr = tmp
            }
        }
    }
    public var addrCount: Int32?

    public var addrPoolId: String?

    public var addrs: DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var lbaStrategy: String?

    public var monitorConfigId: String?

    public var monitorStatus: String?

    public var name: String?

    public var requestId: String?

    public var type: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrCount != nil {
            map["AddrCount"] = self.addrCount!
        }
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.addrs != nil {
            map["Addrs"] = self.addrs?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorStatus != nil {
            map["MonitorStatus"] = self.monitorStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrCount"] as? Int32 {
            self.addrCount = value
        }
        if let value = dict["AddrPoolId"] as? String {
            self.addrPoolId = value
        }
        if let value = dict["Addrs"] as? [String: Any?] {
            var model = DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs()
            model.fromMap(value)
            self.addrs = model
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["LbaStrategy"] as? String {
            self.lbaStrategy = value
        }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
        if let value = dict["MonitorStatus"] as? String {
            self.monitorStatus = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
        if let value = dict["UpdateTimestamp"] as? Int64 {
            self.updateTimestamp = value
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmInstanceAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolsResponseBody : Tea.TeaModel {
    public class AddrPools : Tea.TeaModel {
        public class AddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var addrPoolId: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var lbaStrategy: String?

            public var monitorConfigId: String?

            public var monitorStatus: String?

            public var name: String?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.addrPoolId != nil {
                    map["AddrPoolId"] = self.addrPoolId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.lbaStrategy != nil {
                    map["LbaStrategy"] = self.lbaStrategy!
                }
                if self.monitorConfigId != nil {
                    map["MonitorConfigId"] = self.monitorConfigId!
                }
                if self.monitorStatus != nil {
                    map["MonitorStatus"] = self.monitorStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddrCount"] as? Int32 {
                    self.addrCount = value
                }
                if let value = dict["AddrPoolId"] as? String {
                    self.addrPoolId = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["LbaStrategy"] as? String {
                    self.lbaStrategy = value
                }
                if let value = dict["MonitorConfigId"] as? String {
                    self.monitorConfigId = value
                }
                if let value = dict["MonitorStatus"] as? String {
                    self.monitorStatus = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
            }
        }
        public var addrPool: [DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addrPool != nil {
                var tmp : [Any] = []
                for k in self.addrPool! {
                    tmp.append(k.toMap())
                }
                map["AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AddrPool"] as? [Any?] {
                var tmp : [DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.addrPool = tmp
            }
        }
    }
    public var addrPools: DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPools != nil {
            map["AddrPools"] = self.addrPools?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrPools"] as? [String: Any?] {
            var model = DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools()
            model.fromMap(value)
            self.addrPools = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceAddressPoolsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmInstanceAddressPoolsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceStatusRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeDnsGtmInstanceStatusResponseBody : Tea.TeaModel {
    public var addrAvailableNum: Int32?

    public var addrNotAvailableNum: Int32?

    public var addrPoolGroupNotAvailableNum: Int32?

    public var requestId: String?

    public var strategyNotAvailableNum: Int32?

    public var switchToFailoverStrategyNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrAvailableNum != nil {
            map["AddrAvailableNum"] = self.addrAvailableNum!
        }
        if self.addrNotAvailableNum != nil {
            map["AddrNotAvailableNum"] = self.addrNotAvailableNum!
        }
        if self.addrPoolGroupNotAvailableNum != nil {
            map["AddrPoolGroupNotAvailableNum"] = self.addrPoolGroupNotAvailableNum!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyNotAvailableNum != nil {
            map["StrategyNotAvailableNum"] = self.strategyNotAvailableNum!
        }
        if self.switchToFailoverStrategyNum != nil {
            map["SwitchToFailoverStrategyNum"] = self.switchToFailoverStrategyNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrAvailableNum"] as? Int32 {
            self.addrAvailableNum = value
        }
        if let value = dict["AddrNotAvailableNum"] as? Int32 {
            self.addrNotAvailableNum = value
        }
        if let value = dict["AddrPoolGroupNotAvailableNum"] as? Int32 {
            self.addrPoolGroupNotAvailableNum = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StrategyNotAvailableNum"] as? Int32 {
            self.strategyNotAvailableNum = value
        }
        if let value = dict["SwitchToFailoverStrategyNum"] as? Int32 {
            self.switchToFailoverStrategyNum = value
        }
    }
}

public class DescribeDnsGtmInstanceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmInstanceStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceSystemCnameRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeDnsGtmInstanceSystemCnameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var systemCname: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemCname != nil {
            map["SystemCname"] = self.systemCname!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SystemCname"] as? String {
            self.systemCname = value
        }
    }
}

public class DescribeDnsGtmInstanceSystemCnameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceSystemCnameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmInstanceSystemCnameResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstancesRequest : Tea.TeaModel {
    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class DescribeDnsGtmInstancesResponseBody : Tea.TeaModel {
    public class GtmInstances : Tea.TeaModel {
        public class Config : Tea.TeaModel {
            public class AlertConfig : Tea.TeaModel {
                public var dingtalkNotice: String?

                public var emailNotice: String?

                public var noticeType: String?

                public var smsNotice: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dingtalkNotice != nil {
                        map["DingtalkNotice"] = self.dingtalkNotice!
                    }
                    if self.emailNotice != nil {
                        map["EmailNotice"] = self.emailNotice!
                    }
                    if self.noticeType != nil {
                        map["NoticeType"] = self.noticeType!
                    }
                    if self.smsNotice != nil {
                        map["SmsNotice"] = self.smsNotice!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DingtalkNotice"] as? String {
                        self.dingtalkNotice = value
                    }
                    if let value = dict["EmailNotice"] as? String {
                        self.emailNotice = value
                    }
                    if let value = dict["NoticeType"] as? String {
                        self.noticeType = value
                    }
                    if let value = dict["SmsNotice"] as? String {
                        self.smsNotice = value
                    }
                }
            }
            public var alertConfig: [DescribeDnsGtmInstancesResponseBody.GtmInstances.Config.AlertConfig]?

            public var alertGroup: String?

            public var cnameType: String?

            public var instanceName: String?

            public var publicCnameMode: String?

            public var publicRr: String?

            public var publicUserDomainName: String?

            public var publicZoneName: String?

            public var strategyMode: String?

            public var ttl: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertConfig != nil {
                    var tmp : [Any] = []
                    for k in self.alertConfig! {
                        tmp.append(k.toMap())
                    }
                    map["AlertConfig"] = tmp
                }
                if self.alertGroup != nil {
                    map["AlertGroup"] = self.alertGroup!
                }
                if self.cnameType != nil {
                    map["CnameType"] = self.cnameType!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.publicCnameMode != nil {
                    map["PublicCnameMode"] = self.publicCnameMode!
                }
                if self.publicRr != nil {
                    map["PublicRr"] = self.publicRr!
                }
                if self.publicUserDomainName != nil {
                    map["PublicUserDomainName"] = self.publicUserDomainName!
                }
                if self.publicZoneName != nil {
                    map["PublicZoneName"] = self.publicZoneName!
                }
                if self.strategyMode != nil {
                    map["StrategyMode"] = self.strategyMode!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AlertConfig"] as? [Any?] {
                    var tmp : [DescribeDnsGtmInstancesResponseBody.GtmInstances.Config.AlertConfig] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeDnsGtmInstancesResponseBody.GtmInstances.Config.AlertConfig()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.alertConfig = tmp
                }
                if let value = dict["AlertGroup"] as? String {
                    self.alertGroup = value
                }
                if let value = dict["CnameType"] as? String {
                    self.cnameType = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["PublicCnameMode"] as? String {
                    self.publicCnameMode = value
                }
                if let value = dict["PublicRr"] as? String {
                    self.publicRr = value
                }
                if let value = dict["PublicUserDomainName"] as? String {
                    self.publicUserDomainName = value
                }
                if let value = dict["PublicZoneName"] as? String {
                    self.publicZoneName = value
                }
                if let value = dict["StrategyMode"] as? String {
                    self.strategyMode = value
                }
                if let value = dict["Ttl"] as? Int32 {
                    self.ttl = value
                }
            }
        }
        public class UsedQuota : Tea.TeaModel {
            public var dingtalkUsedCount: Int32?

            public var emailUsedCount: Int32?

            public var smsUsedCount: Int32?

            public var taskUsedCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dingtalkUsedCount != nil {
                    map["DingtalkUsedCount"] = self.dingtalkUsedCount!
                }
                if self.emailUsedCount != nil {
                    map["EmailUsedCount"] = self.emailUsedCount!
                }
                if self.smsUsedCount != nil {
                    map["SmsUsedCount"] = self.smsUsedCount!
                }
                if self.taskUsedCount != nil {
                    map["TaskUsedCount"] = self.taskUsedCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DingtalkUsedCount"] as? Int32 {
                    self.dingtalkUsedCount = value
                }
                if let value = dict["EmailUsedCount"] as? Int32 {
                    self.emailUsedCount = value
                }
                if let value = dict["SmsUsedCount"] as? Int32 {
                    self.smsUsedCount = value
                }
                if let value = dict["TaskUsedCount"] as? Int32 {
                    self.taskUsedCount = value
                }
            }
        }
        public var config: DescribeDnsGtmInstancesResponseBody.GtmInstances.Config?

        public var createTime: String?

        public var createTimestamp: Int64?

        public var expireTime: String?

        public var expireTimestamp: Int64?

        public var instanceId: String?

        public var paymentType: String?

        public var resourceGroupId: String?

        public var smsQuota: Int32?

        public var taskQuota: Int32?

        public var usedQuota: DescribeDnsGtmInstancesResponseBody.GtmInstances.UsedQuota?

        public var versionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.config?.validate()
            try self.usedQuota?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.expireTimestamp != nil {
                map["ExpireTimestamp"] = self.expireTimestamp!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.paymentType != nil {
                map["PaymentType"] = self.paymentType!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.smsQuota != nil {
                map["SmsQuota"] = self.smsQuota!
            }
            if self.taskQuota != nil {
                map["TaskQuota"] = self.taskQuota!
            }
            if self.usedQuota != nil {
                map["UsedQuota"] = self.usedQuota?.toMap()
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Config"] as? [String: Any?] {
                var model = DescribeDnsGtmInstancesResponseBody.GtmInstances.Config()
                model.fromMap(value)
                self.config = model
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["CreateTimestamp"] as? Int64 {
                self.createTimestamp = value
            }
            if let value = dict["ExpireTime"] as? String {
                self.expireTime = value
            }
            if let value = dict["ExpireTimestamp"] as? Int64 {
                self.expireTimestamp = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["PaymentType"] as? String {
                self.paymentType = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["SmsQuota"] as? Int32 {
                self.smsQuota = value
            }
            if let value = dict["TaskQuota"] as? Int32 {
                self.taskQuota = value
            }
            if let value = dict["UsedQuota"] as? [String: Any?] {
                var model = DescribeDnsGtmInstancesResponseBody.GtmInstances.UsedQuota()
                model.fromMap(value)
                self.usedQuota = model
            }
            if let value = dict["VersionCode"] as? String {
                self.versionCode = value
            }
        }
    }
    public var gtmInstances: [DescribeDnsGtmInstancesResponseBody.GtmInstances]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gtmInstances != nil {
            var tmp : [Any] = []
            for k in self.gtmInstances! {
                tmp.append(k.toMap())
            }
            map["GtmInstances"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GtmInstances"] as? [Any?] {
            var tmp : [DescribeDnsGtmInstancesResponseBody.GtmInstances] = []
            for v in value {
                if v != nil {
                    var model = DescribeDnsGtmInstancesResponseBody.GtmInstances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.gtmInstances = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeDnsGtmInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmLogsRequest : Tea.TeaModel {
    public var endTimestamp: Int64?

    public var instanceId: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimestamp != nil {
            map["StartTimestamp"] = self.startTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTimestamp"] as? Int64 {
            self.endTimestamp = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartTimestamp"] as? Int64 {
            self.startTimestamp = value
        }
    }
}

public class DescribeDnsGtmLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public class Log : Tea.TeaModel {
            public var content: String?

            public var entityId: String?

            public var entityName: String?

            public var entityType: String?

            public var id: Int64?

            public var operAction: String?

            public var operTime: String?

            public var operTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.entityId != nil {
                    map["EntityId"] = self.entityId!
                }
                if self.entityName != nil {
                    map["EntityName"] = self.entityName!
                }
                if self.entityType != nil {
                    map["EntityType"] = self.entityType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.operAction != nil {
                    map["OperAction"] = self.operAction!
                }
                if self.operTime != nil {
                    map["OperTime"] = self.operTime!
                }
                if self.operTimestamp != nil {
                    map["OperTimestamp"] = self.operTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["EntityId"] as? String {
                    self.entityId = value
                }
                if let value = dict["EntityName"] as? String {
                    self.entityName = value
                }
                if let value = dict["EntityType"] as? String {
                    self.entityType = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["OperAction"] as? String {
                    self.operAction = value
                }
                if let value = dict["OperTime"] as? String {
                    self.operTime = value
                }
                if let value = dict["OperTimestamp"] as? Int64 {
                    self.operTimestamp = value
                }
            }
        }
        public var log: [DescribeDnsGtmLogsResponseBody.Logs.Log]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.log != nil {
                var tmp : [Any] = []
                for k in self.log! {
                    tmp.append(k.toMap())
                }
                map["Log"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Log"] as? [Any?] {
                var tmp : [DescribeDnsGtmLogsResponseBody.Logs.Log] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmLogsResponseBody.Logs.Log()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.log = tmp
            }
        }
    }
    public var logs: DescribeDnsGtmLogsResponseBody.Logs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            map["Logs"] = self.logs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Logs"] as? [String: Any?] {
            var model = DescribeDnsGtmLogsResponseBody.Logs()
            model.fromMap(value)
            self.logs = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeDnsGtmLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmMonitorAvailableConfigRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeDnsGtmMonitorAvailableConfigResponseBody : Tea.TeaModel {
    public class DomainIpv4IspCityNodes : Tea.TeaModel {
        public class DomainIpv4IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Ip"] as? [String] {
                        self.ip = value
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CityCode"] as? String {
                    self.cityCode = value
                }
                if let value = dict["CityName"] as? String {
                    self.cityName = value
                }
                if let value = dict["DefaultSelected"] as? Bool {
                    self.defaultSelected = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["GroupType"] as? String {
                    self.groupType = value
                }
                if let value = dict["Ips"] as? [String: Any?] {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode.Ips()
                    model.fromMap(value)
                    self.ips = model
                }
                if let value = dict["IspCode"] as? String {
                    self.ispCode = value
                }
                if let value = dict["IspName"] as? String {
                    self.ispName = value
                }
            }
        }
        public var domainIpv4IspCityNode: [DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainIpv4IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.domainIpv4IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["DomainIpv4IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainIpv4IspCityNode"] as? [Any?] {
                var tmp : [DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainIpv4IspCityNode = tmp
            }
        }
    }
    public class DomainIpv6IspCityNodes : Tea.TeaModel {
        public class DomainIpv6IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ip"] as? [String] {
                        self.ip = value
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CityCode"] as? String {
                    self.cityCode = value
                }
                if let value = dict["CityName"] as? String {
                    self.cityName = value
                }
                if let value = dict["DefaultSelected"] as? Bool {
                    self.defaultSelected = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["GroupType"] as? String {
                    self.groupType = value
                }
                if let value = dict["Ips"] as? [String: Any?] {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode.Ips()
                    model.fromMap(value)
                    self.ips = model
                }
                if let value = dict["IspCode"] as? String {
                    self.ispCode = value
                }
                if let value = dict["IspName"] as? String {
                    self.ispName = value
                }
            }
        }
        public var domainIpv6IspCityNode: [DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainIpv6IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.domainIpv6IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["DomainIpv6IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainIpv6IspCityNode"] as? [Any?] {
                var tmp : [DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainIpv6IspCityNode = tmp
            }
        }
    }
    public class Ipv4IspCityNodes : Tea.TeaModel {
        public class Ipv4IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Ip"] as? [String] {
                        self.ip = value
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CityCode"] as? String {
                    self.cityCode = value
                }
                if let value = dict["CityName"] as? String {
                    self.cityName = value
                }
                if let value = dict["DefaultSelected"] as? Bool {
                    self.defaultSelected = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["GroupType"] as? String {
                    self.groupType = value
                }
                if let value = dict["Ips"] as? [String: Any?] {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode.Ips()
                    model.fromMap(value)
                    self.ips = model
                }
                if let value = dict["IspCode"] as? String {
                    self.ispCode = value
                }
                if let value = dict["IspName"] as? String {
                    self.ispName = value
                }
            }
        }
        public var ipv4IspCityNode: [DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.ipv4IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["Ipv4IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv4IspCityNode"] as? [Any?] {
                var tmp : [DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv4IspCityNode = tmp
            }
        }
    }
    public class Ipv6IspCityNodes : Tea.TeaModel {
        public class Ipv6IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Ip"] as? [String] {
                        self.ip = value
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CityCode"] as? String {
                    self.cityCode = value
                }
                if let value = dict["CityName"] as? String {
                    self.cityName = value
                }
                if let value = dict["DefaultSelected"] as? Bool {
                    self.defaultSelected = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["GroupType"] as? String {
                    self.groupType = value
                }
                if let value = dict["Ips"] as? [String: Any?] {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode.Ips()
                    model.fromMap(value)
                    self.ips = model
                }
                if let value = dict["IspCode"] as? String {
                    self.ispCode = value
                }
                if let value = dict["IspName"] as? String {
                    self.ispName = value
                }
            }
        }
        public var ipv6IspCityNode: [DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.ipv6IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["Ipv6IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6IspCityNode"] as? [Any?] {
                var tmp : [DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv6IspCityNode = tmp
            }
        }
    }
    public var domainIpv4IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes?

    public var domainIpv6IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes?

    public var ipv4IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes?

    public var ipv6IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainIpv4IspCityNodes?.validate()
        try self.domainIpv6IspCityNodes?.validate()
        try self.ipv4IspCityNodes?.validate()
        try self.ipv6IspCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainIpv4IspCityNodes != nil {
            map["DomainIpv4IspCityNodes"] = self.domainIpv4IspCityNodes?.toMap()
        }
        if self.domainIpv6IspCityNodes != nil {
            map["DomainIpv6IspCityNodes"] = self.domainIpv6IspCityNodes?.toMap()
        }
        if self.ipv4IspCityNodes != nil {
            map["Ipv4IspCityNodes"] = self.ipv4IspCityNodes?.toMap()
        }
        if self.ipv6IspCityNodes != nil {
            map["Ipv6IspCityNodes"] = self.ipv6IspCityNodes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainIpv4IspCityNodes"] as? [String: Any?] {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes()
            model.fromMap(value)
            self.domainIpv4IspCityNodes = model
        }
        if let value = dict["DomainIpv6IspCityNodes"] as? [String: Any?] {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes()
            model.fromMap(value)
            self.domainIpv6IspCityNodes = model
        }
        if let value = dict["Ipv4IspCityNodes"] as? [String: Any?] {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes()
            model.fromMap(value)
            self.ipv4IspCityNodes = model
        }
        if let value = dict["Ipv6IspCityNodes"] as? [String: Any?] {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes()
            model.fromMap(value)
            self.ipv6IspCityNodes = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDnsGtmMonitorAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmMonitorAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsGtmMonitorConfigRequest : Tea.TeaModel {
    public var lang: String?

    public var monitorConfigId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
    }
}

public class DescribeDnsGtmMonitorConfigResponseBody : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public class IspCityNode : Tea.TeaModel {
            public var cityCode: String?

            public var cityName: String?

            public var countryCode: String?

            public var countryName: String?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.countryCode != nil {
                    map["CountryCode"] = self.countryCode!
                }
                if self.countryName != nil {
                    map["CountryName"] = self.countryName!
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CityCode"] as? String {
                    self.cityCode = value
                }
                if let value = dict["CityName"] as? String {
                    self.cityName = value
                }
                if let value = dict["CountryCode"] as? String {
                    self.countryCode = value
                }
                if let value = dict["CountryName"] as? String {
                    self.countryName = value
                }
                if let value = dict["IspCode"] as? String {
                    self.ispCode = value
                }
                if let value = dict["IspName"] as? String {
                    self.ispName = value
                }
            }
        }
        public var ispCityNode: [DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ispCityNode != nil {
                var tmp : [Any] = []
                for k in self.ispCityNode! {
                    tmp.append(k.toMap())
                }
                map["IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IspCityNode"] as? [Any?] {
                var tmp : [DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ispCityNode = tmp
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNodes: DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes?

    public var monitorConfigId: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var requestId: String?

    public var timeout: Int32?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ispCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNodes != nil {
            map["IspCityNodes"] = self.ispCityNodes?.toMap()
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["IspCityNodes"] as? [String: Any?] {
            var model = DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes()
            model.fromMap(value)
            self.ispCityNodes = model
        }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
        if let value = dict["MonitorExtendInfo"] as? String {
            self.monitorExtendInfo = value
        }
        if let value = dict["ProtocolType"] as? String {
            self.protocolType = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
        if let value = dict["UpdateTimestamp"] as? Int64 {
            self.updateTimestamp = value
        }
    }
}

public class DescribeDnsGtmMonitorConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmMonitorConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsGtmMonitorConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsProductInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
    }
}

public class DescribeDnsProductInstanceResponseBody : Tea.TeaModel {
    public class DnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DnsServer"] as? [String] {
                self.dnsServer = value
            }
        }
    }
    public var autoRenewal: Bool?

    public var bindCount: Int64?

    public var bindDomainCount: Int64?

    public var bindDomainUsedCount: Int64?

    public var bindUsedCount: Int64?

    public var DDosDefendFlow: Int64?

    public var DDosDefendQuery: Int64?

    public var dnsSLBCount: Int64?

    public var dnsSecurity: String?

    public var dnsServers: DescribeDnsProductInstanceResponseBody.DnsServers?

    public var domain: String?

    public var domainType: String?

    public var endTime: String?

    public var endTimestamp: Int64?

    public var gslb: Bool?

    public var ISPLines: String?

    public var ISPRegionLines: String?

    public var inBlackHole: Bool?

    public var inClean: Bool?

    public var instanceId: String?

    public var monitorFrequency: Int64?

    public var monitorNodeCount: Int64?

    public var monitorTaskCount: Int64?

    public var overseaDDosDefendFlow: Int64?

    public var overseaLine: String?

    public var paymentType: String?

    public var regionLines: Bool?

    public var requestId: String?

    public var searchEngineLines: String?

    public var startTime: String?

    public var startTimestamp: Int64?

    public var subDomainLevel: Int64?

    public var TTLMinValue: Int64?

    public var URLForwardCount: Int64?

    public var versionCode: String?

    public var versionName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dnsServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenewal != nil {
            map["AutoRenewal"] = self.autoRenewal!
        }
        if self.bindCount != nil {
            map["BindCount"] = self.bindCount!
        }
        if self.bindDomainCount != nil {
            map["BindDomainCount"] = self.bindDomainCount!
        }
        if self.bindDomainUsedCount != nil {
            map["BindDomainUsedCount"] = self.bindDomainUsedCount!
        }
        if self.bindUsedCount != nil {
            map["BindUsedCount"] = self.bindUsedCount!
        }
        if self.DDosDefendFlow != nil {
            map["DDosDefendFlow"] = self.DDosDefendFlow!
        }
        if self.DDosDefendQuery != nil {
            map["DDosDefendQuery"] = self.DDosDefendQuery!
        }
        if self.dnsSLBCount != nil {
            map["DnsSLBCount"] = self.dnsSLBCount!
        }
        if self.dnsSecurity != nil {
            map["DnsSecurity"] = self.dnsSecurity!
        }
        if self.dnsServers != nil {
            map["DnsServers"] = self.dnsServers?.toMap()
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.gslb != nil {
            map["Gslb"] = self.gslb!
        }
        if self.ISPLines != nil {
            map["ISPLines"] = self.ISPLines!
        }
        if self.ISPRegionLines != nil {
            map["ISPRegionLines"] = self.ISPRegionLines!
        }
        if self.inBlackHole != nil {
            map["InBlackHole"] = self.inBlackHole!
        }
        if self.inClean != nil {
            map["InClean"] = self.inClean!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.monitorFrequency != nil {
            map["MonitorFrequency"] = self.monitorFrequency!
        }
        if self.monitorNodeCount != nil {
            map["MonitorNodeCount"] = self.monitorNodeCount!
        }
        if self.monitorTaskCount != nil {
            map["MonitorTaskCount"] = self.monitorTaskCount!
        }
        if self.overseaDDosDefendFlow != nil {
            map["OverseaDDosDefendFlow"] = self.overseaDDosDefendFlow!
        }
        if self.overseaLine != nil {
            map["OverseaLine"] = self.overseaLine!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.regionLines != nil {
            map["RegionLines"] = self.regionLines!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchEngineLines != nil {
            map["SearchEngineLines"] = self.searchEngineLines!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.startTimestamp != nil {
            map["StartTimestamp"] = self.startTimestamp!
        }
        if self.subDomainLevel != nil {
            map["SubDomainLevel"] = self.subDomainLevel!
        }
        if self.TTLMinValue != nil {
            map["TTLMinValue"] = self.TTLMinValue!
        }
        if self.URLForwardCount != nil {
            map["URLForwardCount"] = self.URLForwardCount!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        if self.versionName != nil {
            map["VersionName"] = self.versionName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoRenewal"] as? Bool {
            self.autoRenewal = value
        }
        if let value = dict["BindCount"] as? Int64 {
            self.bindCount = value
        }
        if let value = dict["BindDomainCount"] as? Int64 {
            self.bindDomainCount = value
        }
        if let value = dict["BindDomainUsedCount"] as? Int64 {
            self.bindDomainUsedCount = value
        }
        if let value = dict["BindUsedCount"] as? Int64 {
            self.bindUsedCount = value
        }
        if let value = dict["DDosDefendFlow"] as? Int64 {
            self.DDosDefendFlow = value
        }
        if let value = dict["DDosDefendQuery"] as? Int64 {
            self.DDosDefendQuery = value
        }
        if let value = dict["DnsSLBCount"] as? Int64 {
            self.dnsSLBCount = value
        }
        if let value = dict["DnsSecurity"] as? String {
            self.dnsSecurity = value
        }
        if let value = dict["DnsServers"] as? [String: Any?] {
            var model = DescribeDnsProductInstanceResponseBody.DnsServers()
            model.fromMap(value)
            self.dnsServers = model
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["DomainType"] as? String {
            self.domainType = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["EndTimestamp"] as? Int64 {
            self.endTimestamp = value
        }
        if let value = dict["Gslb"] as? Bool {
            self.gslb = value
        }
        if let value = dict["ISPLines"] as? String {
            self.ISPLines = value
        }
        if let value = dict["ISPRegionLines"] as? String {
            self.ISPRegionLines = value
        }
        if let value = dict["InBlackHole"] as? Bool {
            self.inBlackHole = value
        }
        if let value = dict["InClean"] as? Bool {
            self.inClean = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["MonitorFrequency"] as? Int64 {
            self.monitorFrequency = value
        }
        if let value = dict["MonitorNodeCount"] as? Int64 {
            self.monitorNodeCount = value
        }
        if let value = dict["MonitorTaskCount"] as? Int64 {
            self.monitorTaskCount = value
        }
        if let value = dict["OverseaDDosDefendFlow"] as? Int64 {
            self.overseaDDosDefendFlow = value
        }
        if let value = dict["OverseaLine"] as? String {
            self.overseaLine = value
        }
        if let value = dict["PaymentType"] as? String {
            self.paymentType = value
        }
        if let value = dict["RegionLines"] as? Bool {
            self.regionLines = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SearchEngineLines"] as? String {
            self.searchEngineLines = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StartTimestamp"] as? Int64 {
            self.startTimestamp = value
        }
        if let value = dict["SubDomainLevel"] as? Int64 {
            self.subDomainLevel = value
        }
        if let value = dict["TTLMinValue"] as? Int64 {
            self.TTLMinValue = value
        }
        if let value = dict["URLForwardCount"] as? Int64 {
            self.URLForwardCount = value
        }
        if let value = dict["VersionCode"] as? String {
            self.versionCode = value
        }
        if let value = dict["VersionName"] as? String {
            self.versionName = value
        }
    }
}

public class DescribeDnsProductInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsProductInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsProductInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDnsProductInstancesRequest : Tea.TeaModel {
    public var direction: String?

    public var domainType: String?

    public var lang: String?

    public var orderBy: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var userClientIp: String?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["DomainType"] as? String {
            self.domainType = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
        if let value = dict["VersionCode"] as? String {
            self.versionCode = value
        }
    }
}

public class DescribeDnsProductInstancesResponseBody : Tea.TeaModel {
    public class DnsProducts : Tea.TeaModel {
        public class DnsProduct : Tea.TeaModel {
            public var autoRenewal: Bool?

            public var bindCount: Int64?

            public var bindDomainCount: Int64?

            public var bindDomainUsedCount: Int64?

            public var bindUsedCount: Int64?

            public var DDosDefendFlow: Int64?

            public var DDosDefendQuery: Int64?

            public var dnsSLBCount: Int64?

            public var dnsSecurity: String?

            public var domain: String?

            public var endTime: String?

            public var endTimestamp: Int64?

            public var gslb: Bool?

            public var ISPLines: String?

            public var ISPRegionLines: String?

            public var inBlackHole: Bool?

            public var inClean: Bool?

            public var instanceId: String?

            public var monitorFrequency: Int64?

            public var monitorNodeCount: Int64?

            public var monitorTaskCount: Int64?

            public var overseaDDosDefendFlow: Int64?

            public var overseaLine: String?

            public var paymentType: String?

            public var regionLines: Bool?

            public var searchEngineLines: String?

            public var startTime: String?

            public var startTimestamp: Int64?

            public var subDomainLevel: Int64?

            public var TTLMinValue: Int64?

            public var URLForwardCount: Int64?

            public var versionCode: String?

            public var versionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoRenewal != nil {
                    map["AutoRenewal"] = self.autoRenewal!
                }
                if self.bindCount != nil {
                    map["BindCount"] = self.bindCount!
                }
                if self.bindDomainCount != nil {
                    map["BindDomainCount"] = self.bindDomainCount!
                }
                if self.bindDomainUsedCount != nil {
                    map["BindDomainUsedCount"] = self.bindDomainUsedCount!
                }
                if self.bindUsedCount != nil {
                    map["BindUsedCount"] = self.bindUsedCount!
                }
                if self.DDosDefendFlow != nil {
                    map["DDosDefendFlow"] = self.DDosDefendFlow!
                }
                if self.DDosDefendQuery != nil {
                    map["DDosDefendQuery"] = self.DDosDefendQuery!
                }
                if self.dnsSLBCount != nil {
                    map["DnsSLBCount"] = self.dnsSLBCount!
                }
                if self.dnsSecurity != nil {
                    map["DnsSecurity"] = self.dnsSecurity!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.endTimestamp != nil {
                    map["EndTimestamp"] = self.endTimestamp!
                }
                if self.gslb != nil {
                    map["Gslb"] = self.gslb!
                }
                if self.ISPLines != nil {
                    map["ISPLines"] = self.ISPLines!
                }
                if self.ISPRegionLines != nil {
                    map["ISPRegionLines"] = self.ISPRegionLines!
                }
                if self.inBlackHole != nil {
                    map["InBlackHole"] = self.inBlackHole!
                }
                if self.inClean != nil {
                    map["InClean"] = self.inClean!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.monitorFrequency != nil {
                    map["MonitorFrequency"] = self.monitorFrequency!
                }
                if self.monitorNodeCount != nil {
                    map["MonitorNodeCount"] = self.monitorNodeCount!
                }
                if self.monitorTaskCount != nil {
                    map["MonitorTaskCount"] = self.monitorTaskCount!
                }
                if self.overseaDDosDefendFlow != nil {
                    map["OverseaDDosDefendFlow"] = self.overseaDDosDefendFlow!
                }
                if self.overseaLine != nil {
                    map["OverseaLine"] = self.overseaLine!
                }
                if self.paymentType != nil {
                    map["PaymentType"] = self.paymentType!
                }
                if self.regionLines != nil {
                    map["RegionLines"] = self.regionLines!
                }
                if self.searchEngineLines != nil {
                    map["SearchEngineLines"] = self.searchEngineLines!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.startTimestamp != nil {
                    map["StartTimestamp"] = self.startTimestamp!
                }
                if self.subDomainLevel != nil {
                    map["SubDomainLevel"] = self.subDomainLevel!
                }
                if self.TTLMinValue != nil {
                    map["TTLMinValue"] = self.TTLMinValue!
                }
                if self.URLForwardCount != nil {
                    map["URLForwardCount"] = self.URLForwardCount!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                if self.versionName != nil {
                    map["VersionName"] = self.versionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoRenewal"] as? Bool {
                    self.autoRenewal = value
                }
                if let value = dict["BindCount"] as? Int64 {
                    self.bindCount = value
                }
                if let value = dict["BindDomainCount"] as? Int64 {
                    self.bindDomainCount = value
                }
                if let value = dict["BindDomainUsedCount"] as? Int64 {
                    self.bindDomainUsedCount = value
                }
                if let value = dict["BindUsedCount"] as? Int64 {
                    self.bindUsedCount = value
                }
                if let value = dict["DDosDefendFlow"] as? Int64 {
                    self.DDosDefendFlow = value
                }
                if let value = dict["DDosDefendQuery"] as? Int64 {
                    self.DDosDefendQuery = value
                }
                if let value = dict["DnsSLBCount"] as? Int64 {
                    self.dnsSLBCount = value
                }
                if let value = dict["DnsSecurity"] as? String {
                    self.dnsSecurity = value
                }
                if let value = dict["Domain"] as? String {
                    self.domain = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["EndTimestamp"] as? Int64 {
                    self.endTimestamp = value
                }
                if let value = dict["Gslb"] as? Bool {
                    self.gslb = value
                }
                if let value = dict["ISPLines"] as? String {
                    self.ISPLines = value
                }
                if let value = dict["ISPRegionLines"] as? String {
                    self.ISPRegionLines = value
                }
                if let value = dict["InBlackHole"] as? Bool {
                    self.inBlackHole = value
                }
                if let value = dict["InClean"] as? Bool {
                    self.inClean = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["MonitorFrequency"] as? Int64 {
                    self.monitorFrequency = value
                }
                if let value = dict["MonitorNodeCount"] as? Int64 {
                    self.monitorNodeCount = value
                }
                if let value = dict["MonitorTaskCount"] as? Int64 {
                    self.monitorTaskCount = value
                }
                if let value = dict["OverseaDDosDefendFlow"] as? Int64 {
                    self.overseaDDosDefendFlow = value
                }
                if let value = dict["OverseaLine"] as? String {
                    self.overseaLine = value
                }
                if let value = dict["PaymentType"] as? String {
                    self.paymentType = value
                }
                if let value = dict["RegionLines"] as? Bool {
                    self.regionLines = value
                }
                if let value = dict["SearchEngineLines"] as? String {
                    self.searchEngineLines = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["StartTimestamp"] as? Int64 {
                    self.startTimestamp = value
                }
                if let value = dict["SubDomainLevel"] as? Int64 {
                    self.subDomainLevel = value
                }
                if let value = dict["TTLMinValue"] as? Int64 {
                    self.TTLMinValue = value
                }
                if let value = dict["URLForwardCount"] as? Int64 {
                    self.URLForwardCount = value
                }
                if let value = dict["VersionCode"] as? String {
                    self.versionCode = value
                }
                if let value = dict["VersionName"] as? String {
                    self.versionName = value
                }
            }
        }
        public var dnsProduct: [DescribeDnsProductInstancesResponseBody.DnsProducts.DnsProduct]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsProduct != nil {
                var tmp : [Any] = []
                for k in self.dnsProduct! {
                    tmp.append(k.toMap())
                }
                map["DnsProduct"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DnsProduct"] as? [Any?] {
                var tmp : [DescribeDnsProductInstancesResponseBody.DnsProducts.DnsProduct] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDnsProductInstancesResponseBody.DnsProducts.DnsProduct()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dnsProduct = tmp
            }
        }
    }
    public var dnsProducts: DescribeDnsProductInstancesResponseBody.DnsProducts?

    public var domainType: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dnsProducts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dnsProducts != nil {
            map["DnsProducts"] = self.dnsProducts?.toMap()
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DnsProducts"] as? [String: Any?] {
            var model = DescribeDnsProductInstancesResponseBody.DnsProducts()
            model.fromMap(value)
            self.dnsProducts = model
        }
        if let value = dict["DomainType"] as? String {
            self.domainType = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeDnsProductInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsProductInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDnsProductInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDohAccountStatisticsRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
    }
}

public class DescribeDohAccountStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var timestamp: Int64?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
            if let value = dict["V4HttpCount"] as? Int64 {
                self.v4HttpCount = value
            }
            if let value = dict["V4HttpsCount"] as? Int64 {
                self.v4HttpsCount = value
            }
            if let value = dict["V6HttpCount"] as? Int64 {
                self.v6HttpCount = value
            }
            if let value = dict["V6HttpsCount"] as? Int64 {
                self.v6HttpsCount = value
            }
        }
    }
    public var requestId: String?

    public var statistics: [DescribeDohAccountStatisticsResponseBody.Statistics]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Statistics"] as? [Any?] {
            var tmp : [DescribeDohAccountStatisticsResponseBody.Statistics] = []
            for v in value {
                if v != nil {
                    var model = DescribeDohAccountStatisticsResponseBody.Statistics()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.statistics = tmp
        }
    }
}

public class DescribeDohAccountStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohAccountStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDohAccountStatisticsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDohDomainStatisticsRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
    }
}

public class DescribeDohDomainStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var timestamp: Int64?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
            if let value = dict["V4HttpCount"] as? Int64 {
                self.v4HttpCount = value
            }
            if let value = dict["V4HttpsCount"] as? Int64 {
                self.v4HttpsCount = value
            }
            if let value = dict["V6HttpCount"] as? Int64 {
                self.v6HttpCount = value
            }
            if let value = dict["V6HttpsCount"] as? Int64 {
                self.v6HttpsCount = value
            }
        }
    }
    public var requestId: String?

    public var statistics: [DescribeDohDomainStatisticsResponseBody.Statistics]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Statistics"] as? [Any?] {
            var tmp : [DescribeDohDomainStatisticsResponseBody.Statistics] = []
            for v in value {
                if v != nil {
                    var model = DescribeDohDomainStatisticsResponseBody.Statistics()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.statistics = tmp
        }
    }
}

public class DescribeDohDomainStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohDomainStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDohDomainStatisticsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDohDomainStatisticsSummaryRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
    }
}

public class DescribeDohDomainStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var domainName: String?

        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var ipCount: Int64?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["HttpCount"] as? Int64 {
                self.httpCount = value
            }
            if let value = dict["HttpsCount"] as? Int64 {
                self.httpsCount = value
            }
            if let value = dict["IpCount"] as? Int64 {
                self.ipCount = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
            if let value = dict["V4HttpCount"] as? Int64 {
                self.v4HttpCount = value
            }
            if let value = dict["V4HttpsCount"] as? Int64 {
                self.v4HttpsCount = value
            }
            if let value = dict["V6HttpCount"] as? Int64 {
                self.v6HttpCount = value
            }
            if let value = dict["V6HttpsCount"] as? Int64 {
                self.v6HttpsCount = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: [DescribeDohDomainStatisticsSummaryResponseBody.Statistics]?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Statistics"] as? [Any?] {
            var tmp : [DescribeDohDomainStatisticsSummaryResponseBody.Statistics] = []
            for v in value {
                if v != nil {
                    var model = DescribeDohDomainStatisticsSummaryResponseBody.Statistics()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.statistics = tmp
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeDohDomainStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohDomainStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDohDomainStatisticsSummaryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDohSubDomainStatisticsRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["SubDomain"] as? String {
            self.subDomain = value
        }
    }
}

public class DescribeDohSubDomainStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var timestamp: Int64?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
            if let value = dict["V4HttpCount"] as? Int64 {
                self.v4HttpCount = value
            }
            if let value = dict["V4HttpsCount"] as? Int64 {
                self.v4HttpsCount = value
            }
            if let value = dict["V6HttpCount"] as? Int64 {
                self.v6HttpCount = value
            }
            if let value = dict["V6HttpsCount"] as? Int64 {
                self.v6HttpsCount = value
            }
        }
    }
    public var requestId: String?

    public var statistics: [DescribeDohSubDomainStatisticsResponseBody.Statistics]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Statistics"] as? [Any?] {
            var tmp : [DescribeDohSubDomainStatisticsResponseBody.Statistics] = []
            for v in value {
                if v != nil {
                    var model = DescribeDohSubDomainStatisticsResponseBody.Statistics()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.statistics = tmp
        }
    }
}

public class DescribeDohSubDomainStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohSubDomainStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDohSubDomainStatisticsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDohSubDomainStatisticsSummaryRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startDate: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["SubDomain"] as? String {
            self.subDomain = value
        }
    }
}

public class DescribeDohSubDomainStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var ipCount: Int64?

        public var subDomain: String?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HttpCount"] as? Int64 {
                self.httpCount = value
            }
            if let value = dict["HttpsCount"] as? Int64 {
                self.httpsCount = value
            }
            if let value = dict["IpCount"] as? Int64 {
                self.ipCount = value
            }
            if let value = dict["SubDomain"] as? String {
                self.subDomain = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
            if let value = dict["V4HttpCount"] as? Int64 {
                self.v4HttpCount = value
            }
            if let value = dict["V4HttpsCount"] as? Int64 {
                self.v4HttpsCount = value
            }
            if let value = dict["V6HttpCount"] as? Int64 {
                self.v6HttpCount = value
            }
            if let value = dict["V6HttpsCount"] as? Int64 {
                self.v6HttpsCount = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: [DescribeDohSubDomainStatisticsSummaryResponseBody.Statistics]?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Statistics"] as? [Any?] {
            var tmp : [DescribeDohSubDomainStatisticsSummaryResponseBody.Statistics] = []
            for v in value {
                if v != nil {
                    var model = DescribeDohSubDomainStatisticsSummaryResponseBody.Statistics()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.statistics = tmp
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeDohSubDomainStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohSubDomainStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDohSubDomainStatisticsSummaryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDohUserInfoRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
    }
}

public class DescribeDohUserInfoResponseBody : Tea.TeaModel {
    public var domainCount: Int32?

    public var pdnsId: Int64?

    public var requestId: String?

    public var subDomainCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainCount != nil {
            map["DomainCount"] = self.domainCount!
        }
        if self.pdnsId != nil {
            map["PdnsId"] = self.pdnsId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subDomainCount != nil {
            map["SubDomainCount"] = self.subDomainCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainCount"] as? Int32 {
            self.domainCount = value
        }
        if let value = dict["PdnsId"] as? Int64 {
            self.pdnsId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SubDomainCount"] as? Int32 {
            self.subDomainCount = value
        }
    }
}

public class DescribeDohUserInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohUserInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDohUserInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDomainDnssecInfoRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeDomainDnssecInfoResponseBody : Tea.TeaModel {
    public var algorithm: String?

    public var digest: String?

    public var digestType: String?

    public var domainName: String?

    public var dsRecord: String?

    public var flags: String?

    public var keyTag: String?

    public var publicKey: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithm != nil {
            map["Algorithm"] = self.algorithm!
        }
        if self.digest != nil {
            map["Digest"] = self.digest!
        }
        if self.digestType != nil {
            map["DigestType"] = self.digestType!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.dsRecord != nil {
            map["DsRecord"] = self.dsRecord!
        }
        if self.flags != nil {
            map["Flags"] = self.flags!
        }
        if self.keyTag != nil {
            map["KeyTag"] = self.keyTag!
        }
        if self.publicKey != nil {
            map["PublicKey"] = self.publicKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Algorithm"] as? String {
            self.algorithm = value
        }
        if let value = dict["Digest"] as? String {
            self.digest = value
        }
        if let value = dict["DigestType"] as? String {
            self.digestType = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DsRecord"] as? String {
            self.dsRecord = value
        }
        if let value = dict["Flags"] as? String {
            self.flags = value
        }
        if let value = dict["KeyTag"] as? String {
            self.keyTag = value
        }
        if let value = dict["PublicKey"] as? String {
            self.publicKey = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class DescribeDomainDnssecInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainDnssecInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDomainDnssecInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDomainGroupsRequest : Tea.TeaModel {
    public var keyWord: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["KeyWord"] as? String {
            self.keyWord = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class DescribeDomainGroupsResponseBody : Tea.TeaModel {
    public class DomainGroups : Tea.TeaModel {
        public class DomainGroup : Tea.TeaModel {
            public var domainCount: Int64?

            public var groupId: String?

            public var groupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainCount != nil {
                    map["DomainCount"] = self.domainCount!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DomainCount"] as? Int64 {
                    self.domainCount = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
            }
        }
        public var domainGroup: [DescribeDomainGroupsResponseBody.DomainGroups.DomainGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainGroup != nil {
                var tmp : [Any] = []
                for k in self.domainGroup! {
                    tmp.append(k.toMap())
                }
                map["DomainGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainGroup"] as? [Any?] {
                var tmp : [DescribeDomainGroupsResponseBody.DomainGroups.DomainGroup] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDomainGroupsResponseBody.DomainGroups.DomainGroup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainGroup = tmp
            }
        }
    }
    public var domainGroups: DescribeDomainGroupsResponseBody.DomainGroups?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainGroups != nil {
            map["DomainGroups"] = self.domainGroups?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainGroups"] as? [String: Any?] {
            var model = DescribeDomainGroupsResponseBody.DomainGroups()
            model.fromMap(value)
            self.domainGroups = model
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeDomainGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDomainGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDomainInfoRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var needDetailAttributes: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.needDetailAttributes != nil {
            map["NeedDetailAttributes"] = self.needDetailAttributes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["NeedDetailAttributes"] as? Bool {
            self.needDetailAttributes = value
        }
    }
}

public class DescribeDomainInfoResponseBody : Tea.TeaModel {
    public class AvailableTtls : Tea.TeaModel {
        public var availableTtl: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableTtl != nil {
                map["AvailableTtl"] = self.availableTtl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AvailableTtl"] as? [String] {
                self.availableTtl = value
            }
        }
    }
    public class DnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DnsServer"] as? [String] {
                self.dnsServer = value
            }
        }
    }
    public class RecordLines : Tea.TeaModel {
        public class RecordLine : Tea.TeaModel {
            public var fatherCode: String?

            public var lineCode: String?

            public var lineDisplayName: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineDisplayName != nil {
                    map["LineDisplayName"] = self.lineDisplayName!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FatherCode"] as? String {
                    self.fatherCode = value
                }
                if let value = dict["LineCode"] as? String {
                    self.lineCode = value
                }
                if let value = dict["LineDisplayName"] as? String {
                    self.lineDisplayName = value
                }
                if let value = dict["LineName"] as? String {
                    self.lineName = value
                }
            }
        }
        public var recordLine: [DescribeDomainInfoResponseBody.RecordLines.RecordLine]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordLine != nil {
                var tmp : [Any] = []
                for k in self.recordLine! {
                    tmp.append(k.toMap())
                }
                map["RecordLine"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RecordLine"] as? [Any?] {
                var tmp : [DescribeDomainInfoResponseBody.RecordLines.RecordLine] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDomainInfoResponseBody.RecordLines.RecordLine()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.recordLine = tmp
            }
        }
    }
    public var aliDomain: Bool?

    public var availableTtls: DescribeDomainInfoResponseBody.AvailableTtls?

    public var createTime: String?

    public var dnsServers: DescribeDomainInfoResponseBody.DnsServers?

    public var domainId: String?

    public var domainLoggingSwitchStatus: String?

    public var domainName: String?

    public var groupId: String?

    public var groupName: String?

    public var inBlackHole: Bool?

    public var inClean: Bool?

    public var instanceId: String?

    public var lineType: String?

    public var minTtl: Int64?

    public var punyCode: String?

    public var recordLineTreeJson: String?

    public var recordLines: DescribeDomainInfoResponseBody.RecordLines?

    public var regionLines: Bool?

    public var remark: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var slaveDns: Bool?

    public var subDomain: Bool?

    public var versionCode: String?

    public var versionName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.availableTtls?.validate()
        try self.dnsServers?.validate()
        try self.recordLines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliDomain != nil {
            map["AliDomain"] = self.aliDomain!
        }
        if self.availableTtls != nil {
            map["AvailableTtls"] = self.availableTtls?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.dnsServers != nil {
            map["DnsServers"] = self.dnsServers?.toMap()
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainLoggingSwitchStatus != nil {
            map["DomainLoggingSwitchStatus"] = self.domainLoggingSwitchStatus!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.inBlackHole != nil {
            map["InBlackHole"] = self.inBlackHole!
        }
        if self.inClean != nil {
            map["InClean"] = self.inClean!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lineType != nil {
            map["LineType"] = self.lineType!
        }
        if self.minTtl != nil {
            map["MinTtl"] = self.minTtl!
        }
        if self.punyCode != nil {
            map["PunyCode"] = self.punyCode!
        }
        if self.recordLineTreeJson != nil {
            map["RecordLineTreeJson"] = self.recordLineTreeJson!
        }
        if self.recordLines != nil {
            map["RecordLines"] = self.recordLines?.toMap()
        }
        if self.regionLines != nil {
            map["RegionLines"] = self.regionLines!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.slaveDns != nil {
            map["SlaveDns"] = self.slaveDns!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        if self.versionName != nil {
            map["VersionName"] = self.versionName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliDomain"] as? Bool {
            self.aliDomain = value
        }
        if let value = dict["AvailableTtls"] as? [String: Any?] {
            var model = DescribeDomainInfoResponseBody.AvailableTtls()
            model.fromMap(value)
            self.availableTtls = model
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["DnsServers"] as? [String: Any?] {
            var model = DescribeDomainInfoResponseBody.DnsServers()
            model.fromMap(value)
            self.dnsServers = model
        }
        if let value = dict["DomainId"] as? String {
            self.domainId = value
        }
        if let value = dict["DomainLoggingSwitchStatus"] as? String {
            self.domainLoggingSwitchStatus = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["InBlackHole"] as? Bool {
            self.inBlackHole = value
        }
        if let value = dict["InClean"] as? Bool {
            self.inClean = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["LineType"] as? String {
            self.lineType = value
        }
        if let value = dict["MinTtl"] as? Int64 {
            self.minTtl = value
        }
        if let value = dict["PunyCode"] as? String {
            self.punyCode = value
        }
        if let value = dict["RecordLineTreeJson"] as? String {
            self.recordLineTreeJson = value
        }
        if let value = dict["RecordLines"] as? [String: Any?] {
            var model = DescribeDomainInfoResponseBody.RecordLines()
            model.fromMap(value)
            self.recordLines = model
        }
        if let value = dict["RegionLines"] as? Bool {
            self.regionLines = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SlaveDns"] as? Bool {
            self.slaveDns = value
        }
        if let value = dict["SubDomain"] as? Bool {
            self.subDomain = value
        }
        if let value = dict["VersionCode"] as? String {
            self.versionCode = value
        }
        if let value = dict["VersionName"] as? String {
            self.versionName = value
        }
    }
}

public class DescribeDomainInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDomainInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDomainLogsRequest : Tea.TeaModel {
    public var groupId: String?

    public var keyWord: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var type: String?

    public var endDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.endDate != nil {
            map["endDate"] = self.endDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["KeyWord"] as? String {
            self.keyWord = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["endDate"] as? String {
            self.endDate = value
        }
    }
}

public class DescribeDomainLogsResponseBody : Tea.TeaModel {
    public class DomainLogs : Tea.TeaModel {
        public class DomainLog : Tea.TeaModel {
            public var action: String?

            public var actionTime: String?

            public var actionTimestamp: Int64?

            public var clientIp: String?

            public var domainName: String?

            public var message: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.actionTime != nil {
                    map["ActionTime"] = self.actionTime!
                }
                if self.actionTimestamp != nil {
                    map["ActionTimestamp"] = self.actionTimestamp!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Action"] as? String {
                    self.action = value
                }
                if let value = dict["ActionTime"] as? String {
                    self.actionTime = value
                }
                if let value = dict["ActionTimestamp"] as? Int64 {
                    self.actionTimestamp = value
                }
                if let value = dict["ClientIp"] as? String {
                    self.clientIp = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var domainLog: [DescribeDomainLogsResponseBody.DomainLogs.DomainLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainLog != nil {
                var tmp : [Any] = []
                for k in self.domainLog! {
                    tmp.append(k.toMap())
                }
                map["DomainLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainLog"] as? [Any?] {
                var tmp : [DescribeDomainLogsResponseBody.DomainLogs.DomainLog] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDomainLogsResponseBody.DomainLogs.DomainLog()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainLog = tmp
            }
        }
    }
    public var domainLogs: DescribeDomainLogsResponseBody.DomainLogs?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainLogs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLogs != nil {
            map["DomainLogs"] = self.domainLogs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainLogs"] as? [String: Any?] {
            var model = DescribeDomainLogsResponseBody.DomainLogs()
            model.fromMap(value)
            self.domainLogs = model
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeDomainLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDomainLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDomainNsRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeDomainNsResponseBody : Tea.TeaModel {
    public class DnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DnsServer"] as? [String] {
                self.dnsServer = value
            }
        }
    }
    public class ExpectDnsServers : Tea.TeaModel {
        public var expectDnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expectDnsServer != nil {
                map["ExpectDnsServer"] = self.expectDnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ExpectDnsServer"] as? [String] {
                self.expectDnsServer = value
            }
        }
    }
    public var allAliDns: Bool?

    public var detectFailedReasonCode: String?

    public var dnsServers: DescribeDomainNsResponseBody.DnsServers?

    public var expectDnsServers: DescribeDomainNsResponseBody.ExpectDnsServers?

    public var includeAliDns: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dnsServers?.validate()
        try self.expectDnsServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allAliDns != nil {
            map["AllAliDns"] = self.allAliDns!
        }
        if self.detectFailedReasonCode != nil {
            map["DetectFailedReasonCode"] = self.detectFailedReasonCode!
        }
        if self.dnsServers != nil {
            map["DnsServers"] = self.dnsServers?.toMap()
        }
        if self.expectDnsServers != nil {
            map["ExpectDnsServers"] = self.expectDnsServers?.toMap()
        }
        if self.includeAliDns != nil {
            map["IncludeAliDns"] = self.includeAliDns!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllAliDns"] as? Bool {
            self.allAliDns = value
        }
        if let value = dict["DetectFailedReasonCode"] as? String {
            self.detectFailedReasonCode = value
        }
        if let value = dict["DnsServers"] as? [String: Any?] {
            var model = DescribeDomainNsResponseBody.DnsServers()
            model.fromMap(value)
            self.dnsServers = model
        }
        if let value = dict["ExpectDnsServers"] as? [String: Any?] {
            var model = DescribeDomainNsResponseBody.ExpectDnsServers()
            model.fromMap(value)
            self.expectDnsServers = model
        }
        if let value = dict["IncludeAliDns"] as? Bool {
            self.includeAliDns = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDomainNsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainNsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDomainNsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDomainRecordInfoRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
    }
}

public class DescribeDomainRecordInfoResponseBody : Tea.TeaModel {
    public var domainId: String?

    public var domainName: String?

    public var groupId: String?

    public var groupName: String?

    public var line: String?

    public var locked: Bool?

    public var priority: Int64?

    public var punyCode: String?

    public var RR: String?

    public var recordId: String?

    public var remark: String?

    public var requestId: String?

    public var status: String?

    public var TTL: Int64?

    public var type: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.locked != nil {
            map["Locked"] = self.locked!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.punyCode != nil {
            map["PunyCode"] = self.punyCode!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.TTL != nil {
            map["TTL"] = self.TTL!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainId"] as? String {
            self.domainId = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["Line"] as? String {
            self.line = value
        }
        if let value = dict["Locked"] as? Bool {
            self.locked = value
        }
        if let value = dict["Priority"] as? Int64 {
            self.priority = value
        }
        if let value = dict["PunyCode"] as? String {
            self.punyCode = value
        }
        if let value = dict["RR"] as? String {
            self.RR = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TTL"] as? Int64 {
            self.TTL = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["Value"] as? String {
            self.value = value
        }
    }
}

public class DescribeDomainRecordInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainRecordInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDomainRecordInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDomainRecordsRequest : Tea.TeaModel {
    public var direction: String?

    public var domainName: String?

    public var groupId: Int64?

    public var keyWord: String?

    public var lang: String?

    public var line: String?

    public var orderBy: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var RRKeyWord: String?

    public var searchMode: String?

    public var status: String?

    public var type: String?

    public var typeKeyWord: String?

    public var valueKeyWord: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.RRKeyWord != nil {
            map["RRKeyWord"] = self.RRKeyWord!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.typeKeyWord != nil {
            map["TypeKeyWord"] = self.typeKeyWord!
        }
        if self.valueKeyWord != nil {
            map["ValueKeyWord"] = self.valueKeyWord!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["KeyWord"] as? String {
            self.keyWord = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Line"] as? String {
            self.line = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RRKeyWord"] as? String {
            self.RRKeyWord = value
        }
        if let value = dict["SearchMode"] as? String {
            self.searchMode = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["TypeKeyWord"] as? String {
            self.typeKeyWord = value
        }
        if let value = dict["ValueKeyWord"] as? String {
            self.valueKeyWord = value
        }
    }
}

public class DescribeDomainRecordsResponseBody : Tea.TeaModel {
    public class DomainRecords : Tea.TeaModel {
        public class Record : Tea.TeaModel {
            public var createTimestamp: Int64?

            public var domainName: String?

            public var lbaStatus: Bool?

            public var line: String?

            public var locked: Bool?

            public var priority: Int64?

            public var RR: String?

            public var recordId: String?

            public var remark: String?

            public var status: String?

            public var TTL: Int64?

            public var type: String?

            public var updateTimestamp: Int64?

            public var value: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.lbaStatus != nil {
                    map["LbaStatus"] = self.lbaStatus!
                }
                if self.line != nil {
                    map["Line"] = self.line!
                }
                if self.locked != nil {
                    map["Locked"] = self.locked!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.RR != nil {
                    map["RR"] = self.RR!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.TTL != nil {
                    map["TTL"] = self.TTL!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["LbaStatus"] as? Bool {
                    self.lbaStatus = value
                }
                if let value = dict["Line"] as? String {
                    self.line = value
                }
                if let value = dict["Locked"] as? Bool {
                    self.locked = value
                }
                if let value = dict["Priority"] as? Int64 {
                    self.priority = value
                }
                if let value = dict["RR"] as? String {
                    self.RR = value
                }
                if let value = dict["RecordId"] as? String {
                    self.recordId = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["TTL"] as? Int64 {
                    self.TTL = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
            }
        }
        public var record: [DescribeDomainRecordsResponseBody.DomainRecords.Record]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.record != nil {
                var tmp : [Any] = []
                for k in self.record! {
                    tmp.append(k.toMap())
                }
                map["Record"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Record"] as? [Any?] {
                var tmp : [DescribeDomainRecordsResponseBody.DomainRecords.Record] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDomainRecordsResponseBody.DomainRecords.Record()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.record = tmp
            }
        }
    }
    public var domainRecords: DescribeDomainRecordsResponseBody.DomainRecords?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainRecords?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainRecords != nil {
            map["DomainRecords"] = self.domainRecords?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainRecords"] as? [String: Any?] {
            var model = DescribeDomainRecordsResponseBody.DomainRecords()
            model.fromMap(value)
            self.domainRecords = model
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeDomainRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDomainRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDomainResolveStatisticsSummaryRequest : Tea.TeaModel {
    public var direction: String?

    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchMode: String?

    public var startDate: String?

    public var threshold: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SearchMode"] as? String {
            self.searchMode = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["Threshold"] as? Int64 {
            self.threshold = value
        }
    }
}

public class DescribeDomainResolveStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var count: String?

        public var domainName: String?

        public var domainType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainType != nil {
                map["DomainType"] = self.domainType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Count"] as? String {
                self.count = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["DomainType"] as? String {
                self.domainType = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: [DescribeDomainResolveStatisticsSummaryResponseBody.Statistics]?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Statistics"] as? [Any?] {
            var tmp : [DescribeDomainResolveStatisticsSummaryResponseBody.Statistics] = []
            for v in value {
                if v != nil {
                    var model = DescribeDomainResolveStatisticsSummaryResponseBody.Statistics()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.statistics = tmp
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeDomainResolveStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainResolveStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDomainResolveStatisticsSummaryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDomainStatisticsRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainType: String?

    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DomainType"] as? String {
            self.domainType = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
    }
}

public class DescribeDomainStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public class Statistic : Tea.TeaModel {
            public var count: Int64?

            public var domainName: String?

            public var timestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int64 {
                    self.count = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Timestamp"] as? Int64 {
                    self.timestamp = value
                }
            }
        }
        public var statistic: [DescribeDomainStatisticsResponseBody.Statistics.Statistic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.statistic != nil {
                var tmp : [Any] = []
                for k in self.statistic! {
                    tmp.append(k.toMap())
                }
                map["Statistic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Statistic"] as? [Any?] {
                var tmp : [DescribeDomainStatisticsResponseBody.Statistics.Statistic] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDomainStatisticsResponseBody.Statistics.Statistic()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.statistic = tmp
            }
        }
    }
    public var requestId: String?

    public var statistics: DescribeDomainStatisticsResponseBody.Statistics?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Statistics"] as? [String: Any?] {
            var model = DescribeDomainStatisticsResponseBody.Statistics()
            model.fromMap(value)
            self.statistics = model
        }
    }
}

public class DescribeDomainStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDomainStatisticsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDomainStatisticsSummaryRequest : Tea.TeaModel {
    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var searchMode: String?

    public var startDate: String?

    public var threshold: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["SearchMode"] as? String {
            self.searchMode = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["Threshold"] as? Int64 {
            self.threshold = value
        }
    }
}

public class DescribeDomainStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public class Statistic : Tea.TeaModel {
            public var count: Int64?

            public var domainName: String?

            public var domainType: String?

            public var resolveAnalysisStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.domainType != nil {
                    map["DomainType"] = self.domainType!
                }
                if self.resolveAnalysisStatus != nil {
                    map["resolveAnalysisStatus"] = self.resolveAnalysisStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int64 {
                    self.count = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["DomainType"] as? String {
                    self.domainType = value
                }
                if let value = dict["resolveAnalysisStatus"] as? String {
                    self.resolveAnalysisStatus = value
                }
            }
        }
        public var statistic: [DescribeDomainStatisticsSummaryResponseBody.Statistics.Statistic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.statistic != nil {
                var tmp : [Any] = []
                for k in self.statistic! {
                    tmp.append(k.toMap())
                }
                map["Statistic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Statistic"] as? [Any?] {
                var tmp : [DescribeDomainStatisticsSummaryResponseBody.Statistics.Statistic] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDomainStatisticsSummaryResponseBody.Statistics.Statistic()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.statistic = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: DescribeDomainStatisticsSummaryResponseBody.Statistics?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Statistics"] as? [String: Any?] {
            var model = DescribeDomainStatisticsSummaryResponseBody.Statistics()
            model.fromMap(value)
            self.statistics = model
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeDomainStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDomainStatisticsSummaryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDomainsRequest : Tea.TeaModel {
    public var groupId: String?

    public var keyWord: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceGroupId: String?

    public var searchMode: String?

    public var starmark: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.starmark != nil {
            map["Starmark"] = self.starmark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["KeyWord"] as? String {
            self.keyWord = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SearchMode"] as? String {
            self.searchMode = value
        }
        if let value = dict["Starmark"] as? Bool {
            self.starmark = value
        }
    }
}

public class DescribeDomainsResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class Domain : Tea.TeaModel {
            public class DnsServers : Tea.TeaModel {
                public var dnsServer: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dnsServer != nil {
                        map["DnsServer"] = self.dnsServer!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DnsServer"] as? [String] {
                        self.dnsServer = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeDomainsResponseBody.Domains.Domain.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeDomainsResponseBody.Domains.Domain.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDomainsResponseBody.Domains.Domain.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var aliDomain: Bool?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var dnsServers: DescribeDomainsResponseBody.Domains.Domain.DnsServers?

            public var domainId: String?

            public var domainLoggingSwitchStatus: String?

            public var domainName: String?

            public var groupId: String?

            public var groupName: String?

            public var instanceEndTime: String?

            public var instanceExpired: Bool?

            public var instanceId: String?

            public var punyCode: String?

            public var recordCount: Int64?

            public var registrantEmail: String?

            public var remark: String?

            public var resourceGroupId: String?

            public var slaveDnsStatus: String?

            public var starmark: Bool?

            public var tags: DescribeDomainsResponseBody.Domains.Domain.Tags?

            public var versionCode: String?

            public var versionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dnsServers?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliDomain != nil {
                    map["AliDomain"] = self.aliDomain!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.dnsServers != nil {
                    map["DnsServers"] = self.dnsServers?.toMap()
                }
                if self.domainId != nil {
                    map["DomainId"] = self.domainId!
                }
                if self.domainLoggingSwitchStatus != nil {
                    map["DomainLoggingSwitchStatus"] = self.domainLoggingSwitchStatus!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.instanceEndTime != nil {
                    map["InstanceEndTime"] = self.instanceEndTime!
                }
                if self.instanceExpired != nil {
                    map["InstanceExpired"] = self.instanceExpired!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.punyCode != nil {
                    map["PunyCode"] = self.punyCode!
                }
                if self.recordCount != nil {
                    map["RecordCount"] = self.recordCount!
                }
                if self.registrantEmail != nil {
                    map["RegistrantEmail"] = self.registrantEmail!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.slaveDnsStatus != nil {
                    map["SlaveDnsStatus"] = self.slaveDnsStatus!
                }
                if self.starmark != nil {
                    map["Starmark"] = self.starmark!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                if self.versionName != nil {
                    map["VersionName"] = self.versionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AliDomain"] as? Bool {
                    self.aliDomain = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["DnsServers"] as? [String: Any?] {
                    var model = DescribeDomainsResponseBody.Domains.Domain.DnsServers()
                    model.fromMap(value)
                    self.dnsServers = model
                }
                if let value = dict["DomainId"] as? String {
                    self.domainId = value
                }
                if let value = dict["DomainLoggingSwitchStatus"] as? String {
                    self.domainLoggingSwitchStatus = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["InstanceEndTime"] as? String {
                    self.instanceEndTime = value
                }
                if let value = dict["InstanceExpired"] as? Bool {
                    self.instanceExpired = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["PunyCode"] as? String {
                    self.punyCode = value
                }
                if let value = dict["RecordCount"] as? Int64 {
                    self.recordCount = value
                }
                if let value = dict["RegistrantEmail"] as? String {
                    self.registrantEmail = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SlaveDnsStatus"] as? String {
                    self.slaveDnsStatus = value
                }
                if let value = dict["Starmark"] as? Bool {
                    self.starmark = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeDomainsResponseBody.Domains.Domain.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["VersionCode"] as? String {
                    self.versionCode = value
                }
                if let value = dict["VersionName"] as? String {
                    self.versionName = value
                }
            }
        }
        public var domain: [DescribeDomainsResponseBody.Domains.Domain]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domain != nil {
                var tmp : [Any] = []
                for k in self.domain! {
                    tmp.append(k.toMap())
                }
                map["Domain"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Domain"] as? [Any?] {
                var tmp : [DescribeDomainsResponseBody.Domains.Domain] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDomainsResponseBody.Domains.Domain()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domain = tmp
            }
        }
    }
    public var domains: DescribeDomainsResponseBody.Domains?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domains != nil {
            map["Domains"] = self.domains?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Domains"] as? [String: Any?] {
            var model = DescribeDomainsResponseBody.Domains()
            model.fromMap(value)
            self.domains = model
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDomainsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmAccessStrategiesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class DescribeGtmAccessStrategiesResponseBody : Tea.TeaModel {
    public class Strategies : Tea.TeaModel {
        public class Strategy : Tea.TeaModel {
            public class Lines : Tea.TeaModel {
                public class Line : Tea.TeaModel {
                    public var groupCode: String?

                    public var groupName: String?

                    public var lineCode: String?

                    public var lineName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.groupCode != nil {
                            map["GroupCode"] = self.groupCode!
                        }
                        if self.groupName != nil {
                            map["GroupName"] = self.groupName!
                        }
                        if self.lineCode != nil {
                            map["LineCode"] = self.lineCode!
                        }
                        if self.lineName != nil {
                            map["LineName"] = self.lineName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["GroupCode"] as? String {
                            self.groupCode = value
                        }
                        if let value = dict["GroupName"] as? String {
                            self.groupName = value
                        }
                        if let value = dict["LineCode"] as? String {
                            self.lineCode = value
                        }
                        if let value = dict["LineName"] as? String {
                            self.lineName = value
                        }
                    }
                }
                public var line: [DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.line != nil {
                        var tmp : [Any] = []
                        for k in self.line! {
                            tmp.append(k.toMap())
                        }
                        map["Line"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Line"] as? [Any?] {
                        var tmp : [DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.line = tmp
                    }
                }
            }
            public var accessMode: String?

            public var accessStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var defaultAddrPoolId: String?

            public var defaultAddrPoolMonitorStatus: String?

            public var defaultAddrPoolName: String?

            public var defaultAddrPoolStatus: String?

            public var failoverAddrPoolId: String?

            public var failoverAddrPoolMonitorStatus: String?

            public var failoverAddrPoolName: String?

            public var failoverAddrPoolStatus: String?

            public var instanceId: String?

            public var lines: DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines?

            public var strategyId: String?

            public var strategyMode: String?

            public var strategyName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.lines?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessMode != nil {
                    map["AccessMode"] = self.accessMode!
                }
                if self.accessStatus != nil {
                    map["AccessStatus"] = self.accessStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.defaultAddrPoolId != nil {
                    map["DefaultAddrPoolId"] = self.defaultAddrPoolId!
                }
                if self.defaultAddrPoolMonitorStatus != nil {
                    map["DefaultAddrPoolMonitorStatus"] = self.defaultAddrPoolMonitorStatus!
                }
                if self.defaultAddrPoolName != nil {
                    map["DefaultAddrPoolName"] = self.defaultAddrPoolName!
                }
                if self.defaultAddrPoolStatus != nil {
                    map["DefaultAddrPoolStatus"] = self.defaultAddrPoolStatus!
                }
                if self.failoverAddrPoolId != nil {
                    map["FailoverAddrPoolId"] = self.failoverAddrPoolId!
                }
                if self.failoverAddrPoolMonitorStatus != nil {
                    map["FailoverAddrPoolMonitorStatus"] = self.failoverAddrPoolMonitorStatus!
                }
                if self.failoverAddrPoolName != nil {
                    map["FailoverAddrPoolName"] = self.failoverAddrPoolName!
                }
                if self.failoverAddrPoolStatus != nil {
                    map["FailoverAddrPoolStatus"] = self.failoverAddrPoolStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.lines != nil {
                    map["Lines"] = self.lines?.toMap()
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.strategyMode != nil {
                    map["StrategyMode"] = self.strategyMode!
                }
                if self.strategyName != nil {
                    map["StrategyName"] = self.strategyName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessMode"] as? String {
                    self.accessMode = value
                }
                if let value = dict["AccessStatus"] as? String {
                    self.accessStatus = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["DefaultAddrPoolId"] as? String {
                    self.defaultAddrPoolId = value
                }
                if let value = dict["DefaultAddrPoolMonitorStatus"] as? String {
                    self.defaultAddrPoolMonitorStatus = value
                }
                if let value = dict["DefaultAddrPoolName"] as? String {
                    self.defaultAddrPoolName = value
                }
                if let value = dict["DefaultAddrPoolStatus"] as? String {
                    self.defaultAddrPoolStatus = value
                }
                if let value = dict["FailoverAddrPoolId"] as? String {
                    self.failoverAddrPoolId = value
                }
                if let value = dict["FailoverAddrPoolMonitorStatus"] as? String {
                    self.failoverAddrPoolMonitorStatus = value
                }
                if let value = dict["FailoverAddrPoolName"] as? String {
                    self.failoverAddrPoolName = value
                }
                if let value = dict["FailoverAddrPoolStatus"] as? String {
                    self.failoverAddrPoolStatus = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Lines"] as? [String: Any?] {
                    var model = DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines()
                    model.fromMap(value)
                    self.lines = model
                }
                if let value = dict["StrategyId"] as? String {
                    self.strategyId = value
                }
                if let value = dict["StrategyMode"] as? String {
                    self.strategyMode = value
                }
                if let value = dict["StrategyName"] as? String {
                    self.strategyName = value
                }
            }
        }
        public var strategy: [DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.strategy != nil {
                var tmp : [Any] = []
                for k in self.strategy! {
                    tmp.append(k.toMap())
                }
                map["Strategy"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Strategy"] as? [Any?] {
                var tmp : [DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.strategy = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var strategies: DescribeGtmAccessStrategiesResponseBody.Strategies?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.strategies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategies != nil {
            map["Strategies"] = self.strategies?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Strategies"] as? [String: Any?] {
            var model = DescribeGtmAccessStrategiesResponseBody.Strategies()
            model.fromMap(value)
            self.strategies = model
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeGtmAccessStrategiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmAccessStrategiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmAccessStrategiesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmAccessStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StrategyId"] as? String {
            self.strategyId = value
        }
    }
}

public class DescribeGtmAccessStrategyResponseBody : Tea.TeaModel {
    public class Lines : Tea.TeaModel {
        public class Line : Tea.TeaModel {
            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["GroupCode"] as? String {
                    self.groupCode = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["LineCode"] as? String {
                    self.lineCode = value
                }
                if let value = dict["LineName"] as? String {
                    self.lineName = value
                }
            }
        }
        public var line: [DescribeGtmAccessStrategyResponseBody.Lines.Line]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.line != nil {
                var tmp : [Any] = []
                for k in self.line! {
                    tmp.append(k.toMap())
                }
                map["Line"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Line"] as? [Any?] {
                var tmp : [DescribeGtmAccessStrategyResponseBody.Lines.Line] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGtmAccessStrategyResponseBody.Lines.Line()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.line = tmp
            }
        }
    }
    public var accessMode: String?

    public var accessStatus: String?

    public var defaultAddrPoolMonitorStatus: String?

    public var defaultAddrPoolName: String?

    public var defaultAddrPoolStatus: String?

    public var defultAddrPoolId: String?

    public var failoverAddrPoolId: String?

    public var failoverAddrPoolMonitorStatus: String?

    public var failoverAddrPoolName: String?

    public var failoverAddrPoolStatus: String?

    public var instanceId: String?

    public var lines: DescribeGtmAccessStrategyResponseBody.Lines?

    public var requestId: String?

    public var strategyId: String?

    public var strategyMode: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.accessStatus != nil {
            map["AccessStatus"] = self.accessStatus!
        }
        if self.defaultAddrPoolMonitorStatus != nil {
            map["DefaultAddrPoolMonitorStatus"] = self.defaultAddrPoolMonitorStatus!
        }
        if self.defaultAddrPoolName != nil {
            map["DefaultAddrPoolName"] = self.defaultAddrPoolName!
        }
        if self.defaultAddrPoolStatus != nil {
            map["DefaultAddrPoolStatus"] = self.defaultAddrPoolStatus!
        }
        if self.defultAddrPoolId != nil {
            map["DefultAddrPoolId"] = self.defultAddrPoolId!
        }
        if self.failoverAddrPoolId != nil {
            map["FailoverAddrPoolId"] = self.failoverAddrPoolId!
        }
        if self.failoverAddrPoolMonitorStatus != nil {
            map["FailoverAddrPoolMonitorStatus"] = self.failoverAddrPoolMonitorStatus!
        }
        if self.failoverAddrPoolName != nil {
            map["FailoverAddrPoolName"] = self.failoverAddrPoolName!
        }
        if self.failoverAddrPoolStatus != nil {
            map["FailoverAddrPoolStatus"] = self.failoverAddrPoolStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lines != nil {
            map["Lines"] = self.lines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessMode"] as? String {
            self.accessMode = value
        }
        if let value = dict["AccessStatus"] as? String {
            self.accessStatus = value
        }
        if let value = dict["DefaultAddrPoolMonitorStatus"] as? String {
            self.defaultAddrPoolMonitorStatus = value
        }
        if let value = dict["DefaultAddrPoolName"] as? String {
            self.defaultAddrPoolName = value
        }
        if let value = dict["DefaultAddrPoolStatus"] as? String {
            self.defaultAddrPoolStatus = value
        }
        if let value = dict["DefultAddrPoolId"] as? String {
            self.defultAddrPoolId = value
        }
        if let value = dict["FailoverAddrPoolId"] as? String {
            self.failoverAddrPoolId = value
        }
        if let value = dict["FailoverAddrPoolMonitorStatus"] as? String {
            self.failoverAddrPoolMonitorStatus = value
        }
        if let value = dict["FailoverAddrPoolName"] as? String {
            self.failoverAddrPoolName = value
        }
        if let value = dict["FailoverAddrPoolStatus"] as? String {
            self.failoverAddrPoolStatus = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lines"] as? [String: Any?] {
            var model = DescribeGtmAccessStrategyResponseBody.Lines()
            model.fromMap(value)
            self.lines = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StrategyId"] as? String {
            self.strategyId = value
        }
        if let value = dict["StrategyMode"] as? String {
            self.strategyMode = value
        }
        if let value = dict["StrategyName"] as? String {
            self.strategyName = value
        }
    }
}

public class DescribeGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmAccessStrategyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmAccessStrategyAvailableConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeGtmAccessStrategyAvailableConfigResponseBody : Tea.TeaModel {
    public class AddrPools : Tea.TeaModel {
        public class AddrPool : Tea.TeaModel {
            public var addrPoolId: String?

            public var addrPoolName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrPoolId != nil {
                    map["AddrPoolId"] = self.addrPoolId!
                }
                if self.addrPoolName != nil {
                    map["AddrPoolName"] = self.addrPoolName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddrPoolId"] as? String {
                    self.addrPoolId = value
                }
                if let value = dict["AddrPoolName"] as? String {
                    self.addrPoolName = value
                }
            }
        }
        public var addrPool: [DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools.AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addrPool != nil {
                var tmp : [Any] = []
                for k in self.addrPool! {
                    tmp.append(k.toMap())
                }
                map["AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AddrPool"] as? [Any?] {
                var tmp : [DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools.AddrPool] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools.AddrPool()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.addrPool = tmp
            }
        }
    }
    public class Lines : Tea.TeaModel {
        public class Line : Tea.TeaModel {
            public var fatherCode: String?

            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FatherCode"] as? String {
                    self.fatherCode = value
                }
                if let value = dict["GroupCode"] as? String {
                    self.groupCode = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["LineCode"] as? String {
                    self.lineCode = value
                }
                if let value = dict["LineName"] as? String {
                    self.lineName = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var line: [DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines.Line]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.line != nil {
                var tmp : [Any] = []
                for k in self.line! {
                    tmp.append(k.toMap())
                }
                map["Line"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Line"] as? [Any?] {
                var tmp : [DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines.Line] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines.Line()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.line = tmp
            }
        }
    }
    public var addrPools: DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools?

    public var lines: DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines?

    public var requestId: String?

    public var suggestSetDefaultLine: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrPools?.validate()
        try self.lines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPools != nil {
            map["AddrPools"] = self.addrPools?.toMap()
        }
        if self.lines != nil {
            map["Lines"] = self.lines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.suggestSetDefaultLine != nil {
            map["SuggestSetDefaultLine"] = self.suggestSetDefaultLine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrPools"] as? [String: Any?] {
            var model = DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools()
            model.fromMap(value)
            self.addrPools = model
        }
        if let value = dict["Lines"] as? [String: Any?] {
            var model = DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines()
            model.fromMap(value)
            self.lines = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuggestSetDefaultLine"] as? Bool {
            self.suggestSetDefaultLine = value
        }
    }
}

public class DescribeGtmAccessStrategyAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmAccessStrategyAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmAccessStrategyAvailableConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmAvailableAlertGroupRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeGtmAvailableAlertGroupResponseBody : Tea.TeaModel {
    public var availableAlertGroup: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAlertGroup != nil {
            map["AvailableAlertGroup"] = self.availableAlertGroup!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AvailableAlertGroup"] as? String {
            self.availableAlertGroup = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeGtmAvailableAlertGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmAvailableAlertGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmAvailableAlertGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var needDetailAttributes: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.needDetailAttributes != nil {
            map["NeedDetailAttributes"] = self.needDetailAttributes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["NeedDetailAttributes"] as? Bool {
            self.needDetailAttributes = value
        }
    }
}

public class DescribeGtmInstanceResponseBody : Tea.TeaModel {
    public var accessStrategyNum: Int32?

    public var addressPoolNum: Int32?

    public var alertGroup: String?

    public var cname: String?

    public var cnameMode: String?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var expireTime: String?

    public var expireTimestamp: Int64?

    public var instanceId: String?

    public var instanceName: String?

    public var lbaStrategy: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var ttl: Int32?

    public var userDomainName: String?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessStrategyNum != nil {
            map["AccessStrategyNum"] = self.accessStrategyNum!
        }
        if self.addressPoolNum != nil {
            map["AddressPoolNum"] = self.addressPoolNum!
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.cname != nil {
            map["Cname"] = self.cname!
        }
        if self.cnameMode != nil {
            map["CnameMode"] = self.cnameMode!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.expireTimestamp != nil {
            map["ExpireTimestamp"] = self.expireTimestamp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.userDomainName != nil {
            map["UserDomainName"] = self.userDomainName!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessStrategyNum"] as? Int32 {
            self.accessStrategyNum = value
        }
        if let value = dict["AddressPoolNum"] as? Int32 {
            self.addressPoolNum = value
        }
        if let value = dict["AlertGroup"] as? String {
            self.alertGroup = value
        }
        if let value = dict["Cname"] as? String {
            self.cname = value
        }
        if let value = dict["CnameMode"] as? String {
            self.cnameMode = value
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["ExpireTime"] as? String {
            self.expireTime = value
        }
        if let value = dict["ExpireTimestamp"] as? Int64 {
            self.expireTimestamp = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["LbaStrategy"] as? String {
            self.lbaStrategy = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Ttl"] as? Int32 {
            self.ttl = value
        }
        if let value = dict["UserDomainName"] as? String {
            self.userDomainName = value
        }
        if let value = dict["VersionCode"] as? String {
            self.versionCode = value
        }
    }
}

public class DescribeGtmInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmInstanceAddressPoolRequest : Tea.TeaModel {
    public var addrPoolId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrPoolId"] as? String {
            self.addrPoolId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeGtmInstanceAddressPoolResponseBody : Tea.TeaModel {
    public class Addrs : Tea.TeaModel {
        public class Addr : Tea.TeaModel {
            public var addrId: Int64?

            public var alertStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var lbaWeight: Int32?

            public var mode: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrId != nil {
                    map["AddrId"] = self.addrId!
                }
                if self.alertStatus != nil {
                    map["AlertStatus"] = self.alertStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.lbaWeight != nil {
                    map["LbaWeight"] = self.lbaWeight!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddrId"] as? Int64 {
                    self.addrId = value
                }
                if let value = dict["AlertStatus"] as? String {
                    self.alertStatus = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["LbaWeight"] as? Int32 {
                    self.lbaWeight = value
                }
                if let value = dict["Mode"] as? String {
                    self.mode = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var addr: [DescribeGtmInstanceAddressPoolResponseBody.Addrs.Addr]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                var tmp : [Any] = []
                for k in self.addr! {
                    tmp.append(k.toMap())
                }
                map["Addr"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Addr"] as? [Any?] {
                var tmp : [DescribeGtmInstanceAddressPoolResponseBody.Addrs.Addr] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGtmInstanceAddressPoolResponseBody.Addrs.Addr()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.addr = tmp
            }
        }
    }
    public var addrCount: Int32?

    public var addrPoolId: String?

    public var addrs: DescribeGtmInstanceAddressPoolResponseBody.Addrs?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var minAvailableAddrNum: Int32?

    public var monitorConfigId: String?

    public var monitorStatus: String?

    public var name: String?

    public var requestId: String?

    public var status: String?

    public var type: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrCount != nil {
            map["AddrCount"] = self.addrCount!
        }
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.addrs != nil {
            map["Addrs"] = self.addrs?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.minAvailableAddrNum != nil {
            map["MinAvailableAddrNum"] = self.minAvailableAddrNum!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorStatus != nil {
            map["MonitorStatus"] = self.monitorStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrCount"] as? Int32 {
            self.addrCount = value
        }
        if let value = dict["AddrPoolId"] as? String {
            self.addrPoolId = value
        }
        if let value = dict["Addrs"] as? [String: Any?] {
            var model = DescribeGtmInstanceAddressPoolResponseBody.Addrs()
            model.fromMap(value)
            self.addrs = model
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["MinAvailableAddrNum"] as? Int32 {
            self.minAvailableAddrNum = value
        }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
        if let value = dict["MonitorStatus"] as? String {
            self.monitorStatus = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
        if let value = dict["UpdateTimestamp"] as? Int64 {
            self.updateTimestamp = value
        }
    }
}

public class DescribeGtmInstanceAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmInstanceAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmInstanceAddressPoolsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class DescribeGtmInstanceAddressPoolsResponseBody : Tea.TeaModel {
    public class AddrPools : Tea.TeaModel {
        public class AddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var addrPoolId: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var minAvailableAddrNum: Int32?

            public var monitorConfigId: String?

            public var monitorStatus: String?

            public var name: String?

            public var status: String?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.addrPoolId != nil {
                    map["AddrPoolId"] = self.addrPoolId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.minAvailableAddrNum != nil {
                    map["MinAvailableAddrNum"] = self.minAvailableAddrNum!
                }
                if self.monitorConfigId != nil {
                    map["MonitorConfigId"] = self.monitorConfigId!
                }
                if self.monitorStatus != nil {
                    map["MonitorStatus"] = self.monitorStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddrCount"] as? Int32 {
                    self.addrCount = value
                }
                if let value = dict["AddrPoolId"] as? String {
                    self.addrPoolId = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["MinAvailableAddrNum"] as? Int32 {
                    self.minAvailableAddrNum = value
                }
                if let value = dict["MonitorConfigId"] as? String {
                    self.monitorConfigId = value
                }
                if let value = dict["MonitorStatus"] as? String {
                    self.monitorStatus = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
            }
        }
        public var addrPool: [DescribeGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addrPool != nil {
                var tmp : [Any] = []
                for k in self.addrPool! {
                    tmp.append(k.toMap())
                }
                map["AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AddrPool"] as? [Any?] {
                var tmp : [DescribeGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.addrPool = tmp
            }
        }
    }
    public var addrPools: DescribeGtmInstanceAddressPoolsResponseBody.AddrPools?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPools != nil {
            map["AddrPools"] = self.addrPools?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrPools"] as? [String: Any?] {
            var model = DescribeGtmInstanceAddressPoolsResponseBody.AddrPools()
            model.fromMap(value)
            self.addrPools = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeGtmInstanceAddressPoolsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceAddressPoolsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmInstanceAddressPoolsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmInstanceStatusRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeGtmInstanceStatusResponseBody : Tea.TeaModel {
    public var addrNotAvailableNum: Int32?

    public var addrPoolNotAvailableNum: Int32?

    public var requestId: String?

    public var status: String?

    public var statusReason: String?

    public var strategyNotAvailableNum: Int32?

    public var switchToFailoverStrategyNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrNotAvailableNum != nil {
            map["AddrNotAvailableNum"] = self.addrNotAvailableNum!
        }
        if self.addrPoolNotAvailableNum != nil {
            map["AddrPoolNotAvailableNum"] = self.addrPoolNotAvailableNum!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.statusReason != nil {
            map["StatusReason"] = self.statusReason!
        }
        if self.strategyNotAvailableNum != nil {
            map["StrategyNotAvailableNum"] = self.strategyNotAvailableNum!
        }
        if self.switchToFailoverStrategyNum != nil {
            map["SwitchToFailoverStrategyNum"] = self.switchToFailoverStrategyNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddrNotAvailableNum"] as? Int32 {
            self.addrNotAvailableNum = value
        }
        if let value = dict["AddrPoolNotAvailableNum"] as? Int32 {
            self.addrPoolNotAvailableNum = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["StatusReason"] as? String {
            self.statusReason = value
        }
        if let value = dict["StrategyNotAvailableNum"] as? Int32 {
            self.strategyNotAvailableNum = value
        }
        if let value = dict["SwitchToFailoverStrategyNum"] as? Int32 {
            self.switchToFailoverStrategyNum = value
        }
    }
}

public class DescribeGtmInstanceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmInstanceStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmInstanceSystemCnameRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeGtmInstanceSystemCnameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var systemCname: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemCname != nil {
            map["SystemCname"] = self.systemCname!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SystemCname"] as? String {
            self.systemCname = value
        }
    }
}

public class DescribeGtmInstanceSystemCnameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceSystemCnameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmInstanceSystemCnameResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmInstancesRequest : Tea.TeaModel {
    public var keyword: String?

    public var lang: String?

    public var needDetailAttributes: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.needDetailAttributes != nil {
            map["NeedDetailAttributes"] = self.needDetailAttributes!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["NeedDetailAttributes"] as? Bool {
            self.needDetailAttributes = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class DescribeGtmInstancesResponseBody : Tea.TeaModel {
    public class GtmInstances : Tea.TeaModel {
        public class GtmInstance : Tea.TeaModel {
            public var accessStrategyNum: Int32?

            public var addressPoolNum: Int32?

            public var alertGroup: String?

            public var cname: String?

            public var cnameMode: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var expireTime: String?

            public var expireTimestamp: Int64?

            public var instanceId: String?

            public var instanceName: String?

            public var lbaStrategy: String?

            public var resourceGroupId: String?

            public var ttl: Int32?

            public var userDomainName: String?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessStrategyNum != nil {
                    map["AccessStrategyNum"] = self.accessStrategyNum!
                }
                if self.addressPoolNum != nil {
                    map["AddressPoolNum"] = self.addressPoolNum!
                }
                if self.alertGroup != nil {
                    map["AlertGroup"] = self.alertGroup!
                }
                if self.cname != nil {
                    map["Cname"] = self.cname!
                }
                if self.cnameMode != nil {
                    map["CnameMode"] = self.cnameMode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.expireTimestamp != nil {
                    map["ExpireTimestamp"] = self.expireTimestamp!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.lbaStrategy != nil {
                    map["LbaStrategy"] = self.lbaStrategy!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.userDomainName != nil {
                    map["UserDomainName"] = self.userDomainName!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessStrategyNum"] as? Int32 {
                    self.accessStrategyNum = value
                }
                if let value = dict["AddressPoolNum"] as? Int32 {
                    self.addressPoolNum = value
                }
                if let value = dict["AlertGroup"] as? String {
                    self.alertGroup = value
                }
                if let value = dict["Cname"] as? String {
                    self.cname = value
                }
                if let value = dict["CnameMode"] as? String {
                    self.cnameMode = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["ExpireTime"] as? String {
                    self.expireTime = value
                }
                if let value = dict["ExpireTimestamp"] as? Int64 {
                    self.expireTimestamp = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["LbaStrategy"] as? String {
                    self.lbaStrategy = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Ttl"] as? Int32 {
                    self.ttl = value
                }
                if let value = dict["UserDomainName"] as? String {
                    self.userDomainName = value
                }
                if let value = dict["VersionCode"] as? String {
                    self.versionCode = value
                }
            }
        }
        public var gtmInstance: [DescribeGtmInstancesResponseBody.GtmInstances.GtmInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gtmInstance != nil {
                var tmp : [Any] = []
                for k in self.gtmInstance! {
                    tmp.append(k.toMap())
                }
                map["GtmInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GtmInstance"] as? [Any?] {
                var tmp : [DescribeGtmInstancesResponseBody.GtmInstances.GtmInstance] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGtmInstancesResponseBody.GtmInstances.GtmInstance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.gtmInstance = tmp
            }
        }
    }
    public var gtmInstances: DescribeGtmInstancesResponseBody.GtmInstances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gtmInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gtmInstances != nil {
            map["GtmInstances"] = self.gtmInstances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GtmInstances"] as? [String: Any?] {
            var model = DescribeGtmInstancesResponseBody.GtmInstances()
            model.fromMap(value)
            self.gtmInstances = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeGtmInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmLogsRequest : Tea.TeaModel {
    public var endTimestamp: Int64?

    public var instanceId: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimestamp != nil {
            map["StartTimestamp"] = self.startTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTimestamp"] as? Int64 {
            self.endTimestamp = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartTimestamp"] as? Int64 {
            self.startTimestamp = value
        }
    }
}

public class DescribeGtmLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public class Log : Tea.TeaModel {
            public var content: String?

            public var entityId: String?

            public var entityName: String?

            public var entityType: String?

            public var id: Int64?

            public var operAction: String?

            public var operIp: String?

            public var operTime: String?

            public var operTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.entityId != nil {
                    map["EntityId"] = self.entityId!
                }
                if self.entityName != nil {
                    map["EntityName"] = self.entityName!
                }
                if self.entityType != nil {
                    map["EntityType"] = self.entityType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.operAction != nil {
                    map["OperAction"] = self.operAction!
                }
                if self.operIp != nil {
                    map["OperIp"] = self.operIp!
                }
                if self.operTime != nil {
                    map["OperTime"] = self.operTime!
                }
                if self.operTimestamp != nil {
                    map["OperTimestamp"] = self.operTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["EntityId"] as? String {
                    self.entityId = value
                }
                if let value = dict["EntityName"] as? String {
                    self.entityName = value
                }
                if let value = dict["EntityType"] as? String {
                    self.entityType = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["OperAction"] as? String {
                    self.operAction = value
                }
                if let value = dict["OperIp"] as? String {
                    self.operIp = value
                }
                if let value = dict["OperTime"] as? String {
                    self.operTime = value
                }
                if let value = dict["OperTimestamp"] as? Int64 {
                    self.operTimestamp = value
                }
            }
        }
        public var log: [DescribeGtmLogsResponseBody.Logs.Log]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.log != nil {
                var tmp : [Any] = []
                for k in self.log! {
                    tmp.append(k.toMap())
                }
                map["Log"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Log"] as? [Any?] {
                var tmp : [DescribeGtmLogsResponseBody.Logs.Log] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGtmLogsResponseBody.Logs.Log()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.log = tmp
            }
        }
    }
    public var logs: DescribeGtmLogsResponseBody.Logs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            map["Logs"] = self.logs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Logs"] as? [String: Any?] {
            var model = DescribeGtmLogsResponseBody.Logs()
            model.fromMap(value)
            self.logs = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeGtmLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmMonitorAvailableConfigRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeGtmMonitorAvailableConfigResponseBody : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public class IspCityNode : Tea.TeaModel {
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ispCode: String?

            public var ispName: String?

            public var mainland: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                if self.mainland != nil {
                    map["Mainland"] = self.mainland!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CityCode"] as? String {
                    self.cityCode = value
                }
                if let value = dict["CityName"] as? String {
                    self.cityName = value
                }
                if let value = dict["DefaultSelected"] as? Bool {
                    self.defaultSelected = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["GroupType"] as? String {
                    self.groupType = value
                }
                if let value = dict["IspCode"] as? String {
                    self.ispCode = value
                }
                if let value = dict["IspName"] as? String {
                    self.ispName = value
                }
                if let value = dict["Mainland"] as? Bool {
                    self.mainland = value
                }
            }
        }
        public var ispCityNode: [DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes.IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ispCityNode != nil {
                var tmp : [Any] = []
                for k in self.ispCityNode! {
                    tmp.append(k.toMap())
                }
                map["IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IspCityNode"] as? [Any?] {
                var tmp : [DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes.IspCityNode] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes.IspCityNode()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ispCityNode = tmp
            }
        }
    }
    public var ispCityNodes: DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ispCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ispCityNodes != nil {
            map["IspCityNodes"] = self.ispCityNodes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IspCityNodes"] as? [String: Any?] {
            var model = DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes()
            model.fromMap(value)
            self.ispCityNodes = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeGtmMonitorAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmMonitorAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmMonitorAvailableConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmMonitorConfigRequest : Tea.TeaModel {
    public var lang: String?

    public var monitorConfigId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
    }
}

public class DescribeGtmMonitorConfigResponseBody : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public class IspCityNode : Tea.TeaModel {
            public var cityCode: String?

            public var cityName: String?

            public var countryCode: String?

            public var countryName: String?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.countryCode != nil {
                    map["CountryCode"] = self.countryCode!
                }
                if self.countryName != nil {
                    map["CountryName"] = self.countryName!
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CityCode"] as? String {
                    self.cityCode = value
                }
                if let value = dict["CityName"] as? String {
                    self.cityName = value
                }
                if let value = dict["CountryCode"] as? String {
                    self.countryCode = value
                }
                if let value = dict["CountryName"] as? String {
                    self.countryName = value
                }
                if let value = dict["IspCode"] as? String {
                    self.ispCode = value
                }
                if let value = dict["IspName"] as? String {
                    self.ispName = value
                }
            }
        }
        public var ispCityNode: [DescribeGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ispCityNode != nil {
                var tmp : [Any] = []
                for k in self.ispCityNode! {
                    tmp.append(k.toMap())
                }
                map["IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IspCityNode"] as? [Any?] {
                var tmp : [DescribeGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ispCityNode = tmp
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNodes: DescribeGtmMonitorConfigResponseBody.IspCityNodes?

    public var monitorConfigId: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var requestId: String?

    public var timeout: Int32?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ispCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNodes != nil {
            map["IspCityNodes"] = self.ispCityNodes?.toMap()
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["IspCityNodes"] as? [String: Any?] {
            var model = DescribeGtmMonitorConfigResponseBody.IspCityNodes()
            model.fromMap(value)
            self.ispCityNodes = model
        }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
        if let value = dict["MonitorExtendInfo"] as? String {
            self.monitorExtendInfo = value
        }
        if let value = dict["ProtocolType"] as? String {
            self.protocolType = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
        if let value = dict["UpdateTimestamp"] as? Int64 {
            self.updateTimestamp = value
        }
    }
}

public class DescribeGtmMonitorConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmMonitorConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmMonitorConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["RecoveryPlanId"] as? Int64 {
            self.recoveryPlanId = value
        }
    }
}

public class DescribeGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public class FaultAddrPools : Tea.TeaModel {
        public class FaultAddrPool : Tea.TeaModel {
            public class Addrs : Tea.TeaModel {
                public class Addr : Tea.TeaModel {
                    public var id: Int64?

                    public var mode: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.mode != nil {
                            map["Mode"] = self.mode!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Id"] as? Int64 {
                            self.id = value
                        }
                        if let value = dict["Mode"] as? String {
                            self.mode = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var addr: [DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs.Addr]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.addr != nil {
                        var tmp : [Any] = []
                        for k in self.addr! {
                            tmp.append(k.toMap())
                        }
                        map["Addr"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Addr"] as? [Any?] {
                        var tmp : [DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs.Addr] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs.Addr()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.addr = tmp
                    }
                }
            }
            public var addrPoolId: String?

            public var addrPoolName: String?

            public var addrs: DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addrs?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrPoolId != nil {
                    map["AddrPoolId"] = self.addrPoolId!
                }
                if self.addrPoolName != nil {
                    map["AddrPoolName"] = self.addrPoolName!
                }
                if self.addrs != nil {
                    map["Addrs"] = self.addrs?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddrPoolId"] as? String {
                    self.addrPoolId = value
                }
                if let value = dict["AddrPoolName"] as? String {
                    self.addrPoolName = value
                }
                if let value = dict["Addrs"] as? [String: Any?] {
                    var model = DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs()
                    model.fromMap(value)
                    self.addrs = model
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
            }
        }
        public var faultAddrPool: [DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.faultAddrPool != nil {
                var tmp : [Any] = []
                for k in self.faultAddrPool! {
                    tmp.append(k.toMap())
                }
                map["FaultAddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FaultAddrPool"] as? [Any?] {
                var tmp : [DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.faultAddrPool = tmp
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var faultAddrPoolNum: Int32?

    public var faultAddrPools: DescribeGtmRecoveryPlanResponseBody.FaultAddrPools?

    public var lastExecuteTime: String?

    public var lastExecuteTimestamp: Int64?

    public var lastRollbackTime: String?

    public var lastRollbackTimestamp: Int64?

    public var name: String?

    public var recoveryPlanId: Int64?

    public var remark: String?

    public var requestId: String?

    public var status: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.faultAddrPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.faultAddrPoolNum != nil {
            map["FaultAddrPoolNum"] = self.faultAddrPoolNum!
        }
        if self.faultAddrPools != nil {
            map["FaultAddrPools"] = self.faultAddrPools?.toMap()
        }
        if self.lastExecuteTime != nil {
            map["LastExecuteTime"] = self.lastExecuteTime!
        }
        if self.lastExecuteTimestamp != nil {
            map["LastExecuteTimestamp"] = self.lastExecuteTimestamp!
        }
        if self.lastRollbackTime != nil {
            map["LastRollbackTime"] = self.lastRollbackTime!
        }
        if self.lastRollbackTimestamp != nil {
            map["LastRollbackTimestamp"] = self.lastRollbackTimestamp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["FaultAddrPoolNum"] as? Int32 {
            self.faultAddrPoolNum = value
        }
        if let value = dict["FaultAddrPools"] as? [String: Any?] {
            var model = DescribeGtmRecoveryPlanResponseBody.FaultAddrPools()
            model.fromMap(value)
            self.faultAddrPools = model
        }
        if let value = dict["LastExecuteTime"] as? String {
            self.lastExecuteTime = value
        }
        if let value = dict["LastExecuteTimestamp"] as? Int64 {
            self.lastExecuteTimestamp = value
        }
        if let value = dict["LastRollbackTime"] as? String {
            self.lastRollbackTime = value
        }
        if let value = dict["LastRollbackTimestamp"] as? Int64 {
            self.lastRollbackTimestamp = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RecoveryPlanId"] as? Int64 {
            self.recoveryPlanId = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
        if let value = dict["UpdateTimestamp"] as? Int64 {
            self.updateTimestamp = value
        }
    }
}

public class DescribeGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmRecoveryPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmRecoveryPlanAvailableConfigRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeGtmRecoveryPlanAvailableConfigResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public class AddrPools : Tea.TeaModel {
                public class AddrPool : Tea.TeaModel {
                    public var addrPoolId: String?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.addrPoolId != nil {
                            map["AddrPoolId"] = self.addrPoolId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AddrPoolId"] as? String {
                            self.addrPoolId = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                    }
                }
                public var addrPool: [DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools.AddrPool]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.addrPool != nil {
                        var tmp : [Any] = []
                        for k in self.addrPool! {
                            tmp.append(k.toMap())
                        }
                        map["AddrPool"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AddrPool"] as? [Any?] {
                        var tmp : [DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools.AddrPool] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools.AddrPool()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.addrPool = tmp
                    }
                }
            }
            public var addrPools: DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools?

            public var instanceId: String?

            public var instanceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addrPools?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrPools != nil {
                    map["AddrPools"] = self.addrPools?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddrPools"] as? [String: Any?] {
                    var model = DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools()
                    model.fromMap(value)
                    self.addrPools = model
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
            }
        }
        public var instance: [DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Instance"] as? [Any?] {
                var tmp : [DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instance = tmp
            }
        }
    }
    public var instances: DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instances"] as? [String: Any?] {
            var model = DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances()
            model.fromMap(value)
            self.instances = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeGtmRecoveryPlanAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmRecoveryPlanAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmRecoveryPlanAvailableConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGtmRecoveryPlansRequest : Tea.TeaModel {
    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class DescribeGtmRecoveryPlansResponseBody : Tea.TeaModel {
    public class RecoveryPlans : Tea.TeaModel {
        public class RecoveryPlan : Tea.TeaModel {
            public var createTime: String?

            public var createTimestamp: Int64?

            public var faultAddrPoolNum: Int32?

            public var lastExecuteTime: String?

            public var lastExecuteTimestamp: Int64?

            public var lastRollbackTime: String?

            public var lastRollbackTimestamp: Int64?

            public var name: String?

            public var recoveryPlanId: Int64?

            public var remark: String?

            public var status: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.faultAddrPoolNum != nil {
                    map["FaultAddrPoolNum"] = self.faultAddrPoolNum!
                }
                if self.lastExecuteTime != nil {
                    map["LastExecuteTime"] = self.lastExecuteTime!
                }
                if self.lastExecuteTimestamp != nil {
                    map["LastExecuteTimestamp"] = self.lastExecuteTimestamp!
                }
                if self.lastRollbackTime != nil {
                    map["LastRollbackTime"] = self.lastRollbackTime!
                }
                if self.lastRollbackTimestamp != nil {
                    map["LastRollbackTimestamp"] = self.lastRollbackTimestamp!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.recoveryPlanId != nil {
                    map["RecoveryPlanId"] = self.recoveryPlanId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["FaultAddrPoolNum"] as? Int32 {
                    self.faultAddrPoolNum = value
                }
                if let value = dict["LastExecuteTime"] as? String {
                    self.lastExecuteTime = value
                }
                if let value = dict["LastExecuteTimestamp"] as? Int64 {
                    self.lastExecuteTimestamp = value
                }
                if let value = dict["LastRollbackTime"] as? String {
                    self.lastRollbackTime = value
                }
                if let value = dict["LastRollbackTimestamp"] as? Int64 {
                    self.lastRollbackTimestamp = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["RecoveryPlanId"] as? Int64 {
                    self.recoveryPlanId = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
            }
        }
        public var recoveryPlan: [DescribeGtmRecoveryPlansResponseBody.RecoveryPlans.RecoveryPlan]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recoveryPlan != nil {
                var tmp : [Any] = []
                for k in self.recoveryPlan! {
                    tmp.append(k.toMap())
                }
                map["RecoveryPlan"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RecoveryPlan"] as? [Any?] {
                var tmp : [DescribeGtmRecoveryPlansResponseBody.RecoveryPlans.RecoveryPlan] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGtmRecoveryPlansResponseBody.RecoveryPlans.RecoveryPlan()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.recoveryPlan = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var recoveryPlans: DescribeGtmRecoveryPlansResponseBody.RecoveryPlans?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recoveryPlans?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recoveryPlans != nil {
            map["RecoveryPlans"] = self.recoveryPlans?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RecoveryPlans"] as? [String: Any?] {
            var model = DescribeGtmRecoveryPlansResponseBody.RecoveryPlans()
            model.fromMap(value)
            self.recoveryPlans = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeGtmRecoveryPlansResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmRecoveryPlansResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGtmRecoveryPlansResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceDomainsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class DescribeInstanceDomainsResponseBody : Tea.TeaModel {
    public class InstanceDomains : Tea.TeaModel {
        public var createTime: String?

        public var createTimestamp: Int64?

        public var domainName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["CreateTimestamp"] as? Int64 {
                self.createTimestamp = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
        }
    }
    public var instanceDomains: [DescribeInstanceDomainsResponseBody.InstanceDomains]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceDomains != nil {
            var tmp : [Any] = []
            for k in self.instanceDomains! {
                tmp.append(k.toMap())
            }
            map["InstanceDomains"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceDomains"] as? [Any?] {
            var tmp : [DescribeInstanceDomainsResponseBody.InstanceDomains] = []
            for v in value {
                if v != nil {
                    var model = DescribeInstanceDomainsResponseBody.InstanceDomains()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instanceDomains = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeInstanceDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceDomainsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInternetDnsLogsRequest : Tea.TeaModel {
    public var accountId: Int64?

    public var domainName: String?

    public var endTimestamp: Int64?

    public var lang: String?

    public var module: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var queryCondition: String?

    public var recursionProtocolType: String?

    public var startTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.module != nil {
            map["Module"] = self.module!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryCondition != nil {
            map["QueryCondition"] = self.queryCondition!
        }
        if self.recursionProtocolType != nil {
            map["RecursionProtocolType"] = self.recursionProtocolType!
        }
        if self.startTimestamp != nil {
            map["StartTimestamp"] = self.startTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountId"] as? Int64 {
            self.accountId = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTimestamp"] as? Int64 {
            self.endTimestamp = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Module"] as? String {
            self.module = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["QueryCondition"] as? String {
            self.queryCondition = value
        }
        if let value = dict["RecursionProtocolType"] as? String {
            self.recursionProtocolType = value
        }
        if let value = dict["StartTimestamp"] as? Int64 {
            self.startTimestamp = value
        }
    }
}

public class DescribeInternetDnsLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public class Log : Tea.TeaModel {
            public class Value : Tea.TeaModel {
                public var value: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Value"] as? [String] {
                        self.value = value
                    }
                }
            }
            public var dnsMsgId: String?

            public var flags: String?

            public var logTime: Int64?

            public var protocol_: String?

            public var queryFlags: String?

            public var queryName: String?

            public var queryType: String?

            public var responseTimestamp: String?

            public var rt: Int32?

            public var serverIp: String?

            public var sourceIp: String?

            public var status: String?

            public var subnetIp: String?

            public var value: DescribeInternetDnsLogsResponseBody.Logs.Log.Value?

            public var zoneName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.value?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dnsMsgId != nil {
                    map["DnsMsgId"] = self.dnsMsgId!
                }
                if self.flags != nil {
                    map["Flags"] = self.flags!
                }
                if self.logTime != nil {
                    map["LogTime"] = self.logTime!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.queryFlags != nil {
                    map["QueryFlags"] = self.queryFlags!
                }
                if self.queryName != nil {
                    map["QueryName"] = self.queryName!
                }
                if self.queryType != nil {
                    map["QueryType"] = self.queryType!
                }
                if self.responseTimestamp != nil {
                    map["ResponseTimestamp"] = self.responseTimestamp!
                }
                if self.rt != nil {
                    map["Rt"] = self.rt!
                }
                if self.serverIp != nil {
                    map["ServerIp"] = self.serverIp!
                }
                if self.sourceIp != nil {
                    map["SourceIp"] = self.sourceIp!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.subnetIp != nil {
                    map["SubnetIp"] = self.subnetIp!
                }
                if self.value != nil {
                    map["Value"] = self.value?.toMap()
                }
                if self.zoneName != nil {
                    map["ZoneName"] = self.zoneName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DnsMsgId"] as? String {
                    self.dnsMsgId = value
                }
                if let value = dict["Flags"] as? String {
                    self.flags = value
                }
                if let value = dict["LogTime"] as? Int64 {
                    self.logTime = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["QueryFlags"] as? String {
                    self.queryFlags = value
                }
                if let value = dict["QueryName"] as? String {
                    self.queryName = value
                }
                if let value = dict["QueryType"] as? String {
                    self.queryType = value
                }
                if let value = dict["ResponseTimestamp"] as? String {
                    self.responseTimestamp = value
                }
                if let value = dict["Rt"] as? Int32 {
                    self.rt = value
                }
                if let value = dict["ServerIp"] as? String {
                    self.serverIp = value
                }
                if let value = dict["SourceIp"] as? String {
                    self.sourceIp = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["SubnetIp"] as? String {
                    self.subnetIp = value
                }
                if let value = dict["Value"] as? [String: Any?] {
                    var model = DescribeInternetDnsLogsResponseBody.Logs.Log.Value()
                    model.fromMap(value)
                    self.value = model
                }
                if let value = dict["ZoneName"] as? String {
                    self.zoneName = value
                }
            }
        }
        public var log: [DescribeInternetDnsLogsResponseBody.Logs.Log]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.log != nil {
                var tmp : [Any] = []
                for k in self.log! {
                    tmp.append(k.toMap())
                }
                map["Log"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Log"] as? [Any?] {
                var tmp : [DescribeInternetDnsLogsResponseBody.Logs.Log] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInternetDnsLogsResponseBody.Logs.Log()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.log = tmp
            }
        }
    }
    public var complete: Bool?

    public var curPage: Int32?

    public var logs: DescribeInternetDnsLogsResponseBody.Logs?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalPage: Int32?

    public var totalSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complete != nil {
            map["Complete"] = self.complete!
        }
        if self.curPage != nil {
            map["CurPage"] = self.curPage!
        }
        if self.logs != nil {
            map["Logs"] = self.logs?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        if self.totalSize != nil {
            map["TotalSize"] = self.totalSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Complete"] as? Bool {
            self.complete = value
        }
        if let value = dict["CurPage"] as? Int32 {
            self.curPage = value
        }
        if let value = dict["Logs"] as? [String: Any?] {
            var model = DescribeInternetDnsLogsResponseBody.Logs()
            model.fromMap(value)
            self.logs = model
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
        if let value = dict["TotalSize"] as? Int32 {
            self.totalSize = value
        }
    }
}

public class DescribeInternetDnsLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInternetDnsLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInternetDnsLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIspFlushCacheInstancesRequest : Tea.TeaModel {
    public var direction: String?

    public var isp: String?

    public var keyword: String?

    public var lang: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["Isp"] as? String {
            self.isp = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeIspFlushCacheInstancesResponseBody : Tea.TeaModel {
    public class IspFlushCacheInstances : Tea.TeaModel {
        public class QuotaInfo : Tea.TeaModel {
            public var instanceQuota: Int32?

            public var instanceQuotaUsed: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceQuota != nil {
                    map["InstanceQuota"] = self.instanceQuota!
                }
                if self.instanceQuotaUsed != nil {
                    map["InstanceQuotaUsed"] = self.instanceQuotaUsed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceQuota"] as? Int32 {
                    self.instanceQuota = value
                }
                if let value = dict["InstanceQuotaUsed"] as? Int32 {
                    self.instanceQuotaUsed = value
                }
            }
        }
        public var expireTime: String?

        public var expireTimestamp: Int64?

        public var instanceId: String?

        public var instanceName: String?

        public var isp: String?

        public var quotaInfo: DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances.QuotaInfo?

        public var status: String?

        public var versionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.quotaInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.expireTimestamp != nil {
                map["ExpireTimestamp"] = self.expireTimestamp!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.isp != nil {
                map["Isp"] = self.isp!
            }
            if self.quotaInfo != nil {
                map["QuotaInfo"] = self.quotaInfo?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ExpireTime"] as? String {
                self.expireTime = value
            }
            if let value = dict["ExpireTimestamp"] as? Int64 {
                self.expireTimestamp = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["Isp"] as? String {
                self.isp = value
            }
            if let value = dict["QuotaInfo"] as? [String: Any?] {
                var model = DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances.QuotaInfo()
                model.fromMap(value)
                self.quotaInfo = model
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["VersionCode"] as? String {
                self.versionCode = value
            }
        }
    }
    public var ispFlushCacheInstances: [DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ispFlushCacheInstances != nil {
            var tmp : [Any] = []
            for k in self.ispFlushCacheInstances! {
                tmp.append(k.toMap())
            }
            map["IspFlushCacheInstances"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IspFlushCacheInstances"] as? [Any?] {
            var tmp : [DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances] = []
            for v in value {
                if v != nil {
                    var model = DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ispFlushCacheInstances = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeIspFlushCacheInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIspFlushCacheInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIspFlushCacheInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIspFlushCacheRemainQuotaRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeIspFlushCacheRemainQuotaResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var telecomRemainQuota: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.telecomRemainQuota != nil {
            map["TelecomRemainQuota"] = self.telecomRemainQuota!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TelecomRemainQuota"] as? Int32 {
            self.telecomRemainQuota = value
        }
    }
}

public class DescribeIspFlushCacheRemainQuotaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIspFlushCacheRemainQuotaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIspFlushCacheRemainQuotaResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIspFlushCacheTaskRequest : Tea.TeaModel {
    public var lang: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class DescribeIspFlushCacheTaskResponseBody : Tea.TeaModel {
    public class FlushCacheResults : Tea.TeaModel {
        public class DnsNodes : Tea.TeaModel {
            public class Answers : Tea.TeaModel {
                public var name: String?

                public var record: String?

                public var ttl: Int64?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.record != nil {
                        map["Record"] = self.record!
                    }
                    if self.ttl != nil {
                        map["Ttl"] = self.ttl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Record"] as? String {
                        self.record = value
                    }
                    if let value = dict["Ttl"] as? Int64 {
                        self.ttl = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var answers: [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes.Answers]?

            public var nodeIp: String?

            public var spName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answers != nil {
                    var tmp : [Any] = []
                    for k in self.answers! {
                        tmp.append(k.toMap())
                    }
                    map["Answers"] = tmp
                }
                if self.nodeIp != nil {
                    map["NodeIp"] = self.nodeIp!
                }
                if self.spName != nil {
                    map["SpName"] = self.spName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Answers"] as? [Any?] {
                    var tmp : [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes.Answers] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes.Answers()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.answers = tmp
                }
                if let value = dict["NodeIp"] as? String {
                    self.nodeIp = value
                }
                if let value = dict["SpName"] as? String {
                    self.spName = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var dnsNodes: [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes]?

        public var province: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsNodes != nil {
                var tmp : [Any] = []
                for k in self.dnsNodes! {
                    tmp.append(k.toMap())
                }
                map["DnsNodes"] = tmp
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DnsNodes"] as? [Any?] {
                var tmp : [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes] = []
                for v in value {
                    if v != nil {
                        var model = DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dnsNodes = tmp
            }
            if let value = dict["Province"] as? String {
                self.province = value
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var domainName: String?

    public var flushCacheResults: [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults]?

    public var instanceId: String?

    public var instanceName: String?

    public var isp: String?

    public var requestId: String?

    public var taskId: String?

    public var taskStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.flushCacheResults != nil {
            var tmp : [Any] = []
            for k in self.flushCacheResults! {
                tmp.append(k.toMap())
            }
            map["FlushCacheResults"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["FlushCacheResults"] as? [Any?] {
            var tmp : [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults] = []
            for v in value {
                if v != nil {
                    var model = DescribeIspFlushCacheTaskResponseBody.FlushCacheResults()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.flushCacheResults = tmp
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["Isp"] as? String {
            self.isp = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["TaskStatus"] as? String {
            self.taskStatus = value
        }
    }
}

public class DescribeIspFlushCacheTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIspFlushCacheTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIspFlushCacheTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIspFlushCacheTasksRequest : Tea.TeaModel {
    public var direction: String?

    public var domainName: String?

    public var instanceId: String?

    public var isp: String?

    public var lang: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Isp"] as? String {
            self.isp = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class DescribeIspFlushCacheTasksResponseBody : Tea.TeaModel {
    public class IspFlushCacheTasks : Tea.TeaModel {
        public var createTime: String?

        public var createTimestamp: Int64?

        public var domainName: String?

        public var instanceId: String?

        public var instanceName: String?

        public var isp: String?

        public var taskId: String?

        public var taskStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.isp != nil {
                map["Isp"] = self.isp!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["CreateTimestamp"] as? Int64 {
                self.createTimestamp = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["Isp"] as? String {
                self.isp = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["TaskStatus"] as? String {
                self.taskStatus = value
            }
        }
    }
    public var ispFlushCacheTasks: [DescribeIspFlushCacheTasksResponseBody.IspFlushCacheTasks]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ispFlushCacheTasks != nil {
            var tmp : [Any] = []
            for k in self.ispFlushCacheTasks! {
                tmp.append(k.toMap())
            }
            map["IspFlushCacheTasks"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IspFlushCacheTasks"] as? [Any?] {
            var tmp : [DescribeIspFlushCacheTasksResponseBody.IspFlushCacheTasks] = []
            for v in value {
                if v != nil {
                    var model = DescribeIspFlushCacheTasksResponseBody.IspFlushCacheTasks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ispFlushCacheTasks = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeIspFlushCacheTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIspFlushCacheTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIspFlushCacheTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePdnsAccountSummaryRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
    }
}

public class DescribePdnsAccountSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var domainCount: Int64?

        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var subDomainCount: Int64?

        public var threatCount: Int64?

        public var totalCount: Int64?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainCount != nil {
                map["DomainCount"] = self.domainCount!
            }
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.subDomainCount != nil {
                map["SubDomainCount"] = self.subDomainCount!
            }
            if self.threatCount != nil {
                map["ThreatCount"] = self.threatCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainCount"] as? Int64 {
                self.domainCount = value
            }
            if let value = dict["HttpCount"] as? Int64 {
                self.httpCount = value
            }
            if let value = dict["HttpsCount"] as? Int64 {
                self.httpsCount = value
            }
            if let value = dict["SubDomainCount"] as? Int64 {
                self.subDomainCount = value
            }
            if let value = dict["ThreatCount"] as? Int64 {
                self.threatCount = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
            if let value = dict["UserId"] as? Int64 {
                self.userId = value
            }
        }
    }
    public var data: DescribePdnsAccountSummaryResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribePdnsAccountSummaryResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePdnsAccountSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsAccountSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePdnsAccountSummaryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePdnsAppKeyRequest : Tea.TeaModel {
    public var appKeyId: String?

    public var authCode: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKeyId != nil {
            map["AppKeyId"] = self.appKeyId!
        }
        if self.authCode != nil {
            map["AuthCode"] = self.authCode!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppKeyId"] as? String {
            self.appKeyId = value
        }
        if let value = dict["AuthCode"] as? String {
            self.authCode = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribePdnsAppKeyResponseBody : Tea.TeaModel {
    public class AppKey : Tea.TeaModel {
        public var appKeyId: String?

        public var appKeySecret: String?

        public var createDate: String?

        public var createTimestamp: Int64?

        public var remark: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appKeyId != nil {
                map["AppKeyId"] = self.appKeyId!
            }
            if self.appKeySecret != nil {
                map["AppKeySecret"] = self.appKeySecret!
            }
            if self.createDate != nil {
                map["CreateDate"] = self.createDate!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppKeyId"] as? String {
                self.appKeyId = value
            }
            if let value = dict["AppKeySecret"] as? String {
                self.appKeySecret = value
            }
            if let value = dict["CreateDate"] as? String {
                self.createDate = value
            }
            if let value = dict["CreateTimestamp"] as? Int64 {
                self.createTimestamp = value
            }
            if let value = dict["Remark"] as? String {
                self.remark = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
        }
    }
    public var appKey: DescribePdnsAppKeyResponseBody.AppKey?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appKey?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKey != nil {
            map["AppKey"] = self.appKey?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppKey"] as? [String: Any?] {
            var model = DescribePdnsAppKeyResponseBody.AppKey()
            model.fromMap(value)
            self.appKey = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePdnsAppKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsAppKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePdnsAppKeyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePdnsAppKeysRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribePdnsAppKeysResponseBody : Tea.TeaModel {
    public class AppKeys : Tea.TeaModel {
        public class BindEdgeDnsClusters : Tea.TeaModel {
            public var clusterId: String?

            public var clusterName: String?

            public var clusterUserId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.clusterUserId != nil {
                    map["ClusterUserId"] = self.clusterUserId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ClusterId"] as? String {
                    self.clusterId = value
                }
                if let value = dict["ClusterName"] as? String {
                    self.clusterName = value
                }
                if let value = dict["ClusterUserId"] as? String {
                    self.clusterUserId = value
                }
            }
        }
        public var appKeyId: String?

        public var bindEdgeDnsClusters: [DescribePdnsAppKeysResponseBody.AppKeys.BindEdgeDnsClusters]?

        public var createDate: String?

        public var createTimestamp: Int64?

        public var remark: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appKeyId != nil {
                map["AppKeyId"] = self.appKeyId!
            }
            if self.bindEdgeDnsClusters != nil {
                var tmp : [Any] = []
                for k in self.bindEdgeDnsClusters! {
                    tmp.append(k.toMap())
                }
                map["BindEdgeDnsClusters"] = tmp
            }
            if self.createDate != nil {
                map["CreateDate"] = self.createDate!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppKeyId"] as? String {
                self.appKeyId = value
            }
            if let value = dict["BindEdgeDnsClusters"] as? [Any?] {
                var tmp : [DescribePdnsAppKeysResponseBody.AppKeys.BindEdgeDnsClusters] = []
                for v in value {
                    if v != nil {
                        var model = DescribePdnsAppKeysResponseBody.AppKeys.BindEdgeDnsClusters()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.bindEdgeDnsClusters = tmp
            }
            if let value = dict["CreateDate"] as? String {
                self.createDate = value
            }
            if let value = dict["CreateTimestamp"] as? Int64 {
                self.createTimestamp = value
            }
            if let value = dict["Remark"] as? String {
                self.remark = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
        }
    }
    public var appKeys: [DescribePdnsAppKeysResponseBody.AppKeys]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKeys != nil {
            var tmp : [Any] = []
            for k in self.appKeys! {
                tmp.append(k.toMap())
            }
            map["AppKeys"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppKeys"] as? [Any?] {
            var tmp : [DescribePdnsAppKeysResponseBody.AppKeys] = []
            for v in value {
                if v != nil {
                    var model = DescribePdnsAppKeysResponseBody.AppKeys()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.appKeys = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePdnsAppKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsAppKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePdnsAppKeysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePdnsOperateLogsRequest : Tea.TeaModel {
    public var actionType: String?

    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceType: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["ActionType"] = self.actionType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActionType"] as? String {
            self.actionType = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
    }
}

public class DescribePdnsOperateLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public var action: String?

        public var operateTime: String?

        public var type: String?

        public var content: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.operateTime != nil {
                map["OperateTime"] = self.operateTime!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.content != nil {
                map["content"] = self.content!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Action"] as? String {
                self.action = value
            }
            if let value = dict["OperateTime"] as? String {
                self.operateTime = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["content"] as? String {
                self.content = value
            }
        }
    }
    public var logs: [DescribePdnsOperateLogsResponseBody.Logs]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            var tmp : [Any] = []
            for k in self.logs! {
                tmp.append(k.toMap())
            }
            map["Logs"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Logs"] as? [Any?] {
            var tmp : [DescribePdnsOperateLogsResponseBody.Logs] = []
            for v in value {
                if v != nil {
                    var model = DescribePdnsOperateLogsResponseBody.Logs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.logs = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribePdnsOperateLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsOperateLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePdnsOperateLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePdnsRequestStatisticRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public var subDomain: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["SubDomain"] as? String {
            self.subDomain = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribePdnsRequestStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dohTotalCount: Int64?

        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var ipCount: Int64?

        public var timestamp: Int64?

        public var totalCount: Int64?

        public var udpTotalCount: Int64?

        public var v4Count: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6Count: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dohTotalCount != nil {
                map["DohTotalCount"] = self.dohTotalCount!
            }
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.udpTotalCount != nil {
                map["UdpTotalCount"] = self.udpTotalCount!
            }
            if self.v4Count != nil {
                map["V4Count"] = self.v4Count!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6Count != nil {
                map["V6Count"] = self.v6Count!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DohTotalCount"] as? Int64 {
                self.dohTotalCount = value
            }
            if let value = dict["HttpCount"] as? Int64 {
                self.httpCount = value
            }
            if let value = dict["HttpsCount"] as? Int64 {
                self.httpsCount = value
            }
            if let value = dict["IpCount"] as? Int64 {
                self.ipCount = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
            if let value = dict["UdpTotalCount"] as? Int64 {
                self.udpTotalCount = value
            }
            if let value = dict["V4Count"] as? Int64 {
                self.v4Count = value
            }
            if let value = dict["V4HttpCount"] as? Int64 {
                self.v4HttpCount = value
            }
            if let value = dict["V4HttpsCount"] as? Int64 {
                self.v4HttpsCount = value
            }
            if let value = dict["V6Count"] as? Int64 {
                self.v6Count = value
            }
            if let value = dict["V6HttpCount"] as? Int64 {
                self.v6HttpCount = value
            }
            if let value = dict["V6HttpsCount"] as? Int64 {
                self.v6HttpsCount = value
            }
        }
    }
    public var data: [DescribePdnsRequestStatisticResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribePdnsRequestStatisticResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribePdnsRequestStatisticResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePdnsRequestStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsRequestStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePdnsRequestStatisticResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePdnsRequestStatisticsRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var subDomain: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["SubDomain"] as? String {
            self.subDomain = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribePdnsRequestStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ThreatInfo : Tea.TeaModel {
            public var threatLevel: String?

            public var threatType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.threatLevel != nil {
                    map["ThreatLevel"] = self.threatLevel!
                }
                if self.threatType != nil {
                    map["ThreatType"] = self.threatType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ThreatLevel"] as? String {
                    self.threatLevel = value
                }
                if let value = dict["ThreatType"] as? String {
                    self.threatType = value
                }
            }
        }
        public var dohTotalCount: Int64?

        public var domainName: String?

        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var ipCount: Int64?

        public var maxThreatLevel: String?

        public var subDomain: String?

        public var threatCount: Int64?

        public var threatInfo: [DescribePdnsRequestStatisticsResponseBody.Data.ThreatInfo]?

        public var totalCount: Int64?

        public var udpTotalCount: Int64?

        public var v4Count: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6Count: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dohTotalCount != nil {
                map["DohTotalCount"] = self.dohTotalCount!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.maxThreatLevel != nil {
                map["MaxThreatLevel"] = self.maxThreatLevel!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            if self.threatCount != nil {
                map["ThreatCount"] = self.threatCount!
            }
            if self.threatInfo != nil {
                var tmp : [Any] = []
                for k in self.threatInfo! {
                    tmp.append(k.toMap())
                }
                map["ThreatInfo"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.udpTotalCount != nil {
                map["UdpTotalCount"] = self.udpTotalCount!
            }
            if self.v4Count != nil {
                map["V4Count"] = self.v4Count!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6Count != nil {
                map["V6Count"] = self.v6Count!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DohTotalCount"] as? Int64 {
                self.dohTotalCount = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["HttpCount"] as? Int64 {
                self.httpCount = value
            }
            if let value = dict["HttpsCount"] as? Int64 {
                self.httpsCount = value
            }
            if let value = dict["IpCount"] as? Int64 {
                self.ipCount = value
            }
            if let value = dict["MaxThreatLevel"] as? String {
                self.maxThreatLevel = value
            }
            if let value = dict["SubDomain"] as? String {
                self.subDomain = value
            }
            if let value = dict["ThreatCount"] as? Int64 {
                self.threatCount = value
            }
            if let value = dict["ThreatInfo"] as? [Any?] {
                var tmp : [DescribePdnsRequestStatisticsResponseBody.Data.ThreatInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribePdnsRequestStatisticsResponseBody.Data.ThreatInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.threatInfo = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
            if let value = dict["UdpTotalCount"] as? Int64 {
                self.udpTotalCount = value
            }
            if let value = dict["V4Count"] as? Int64 {
                self.v4Count = value
            }
            if let value = dict["V4HttpCount"] as? Int64 {
                self.v4HttpCount = value
            }
            if let value = dict["V4HttpsCount"] as? Int64 {
                self.v4HttpsCount = value
            }
            if let value = dict["V6Count"] as? Int64 {
                self.v6Count = value
            }
            if let value = dict["V6HttpCount"] as? Int64 {
                self.v6HttpCount = value
            }
            if let value = dict["V6HttpsCount"] as? Int64 {
                self.v6HttpsCount = value
            }
        }
    }
    public var data: [DescribePdnsRequestStatisticsResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribePdnsRequestStatisticsResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribePdnsRequestStatisticsResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribePdnsRequestStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsRequestStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePdnsRequestStatisticsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePdnsThreatLogsRequest : Tea.TeaModel {
    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var threatLevel: String?

    public var threatSourceIp: String?

    public var threatType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threatLevel != nil {
            map["ThreatLevel"] = self.threatLevel!
        }
        if self.threatSourceIp != nil {
            map["ThreatSourceIp"] = self.threatSourceIp!
        }
        if self.threatType != nil {
            map["ThreatType"] = self.threatType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["ThreatLevel"] as? String {
            self.threatLevel = value
        }
        if let value = dict["ThreatSourceIp"] as? String {
            self.threatSourceIp = value
        }
        if let value = dict["ThreatType"] as? String {
            self.threatType = value
        }
    }
}

public class DescribePdnsThreatLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public var sourceIp: String?

        public var subDomain: String?

        public var threatLevel: String?

        public var threatTime: String?

        public var threatType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceIp != nil {
                map["SourceIp"] = self.sourceIp!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            if self.threatLevel != nil {
                map["ThreatLevel"] = self.threatLevel!
            }
            if self.threatTime != nil {
                map["ThreatTime"] = self.threatTime!
            }
            if self.threatType != nil {
                map["ThreatType"] = self.threatType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SourceIp"] as? String {
                self.sourceIp = value
            }
            if let value = dict["SubDomain"] as? String {
                self.subDomain = value
            }
            if let value = dict["ThreatLevel"] as? String {
                self.threatLevel = value
            }
            if let value = dict["ThreatTime"] as? String {
                self.threatTime = value
            }
            if let value = dict["ThreatType"] as? String {
                self.threatType = value
            }
        }
    }
    public var logs: [DescribePdnsThreatLogsResponseBody.Logs]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            var tmp : [Any] = []
            for k in self.logs! {
                tmp.append(k.toMap())
            }
            map["Logs"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Logs"] as? [Any?] {
            var tmp : [DescribePdnsThreatLogsResponseBody.Logs] = []
            for v in value {
                if v != nil {
                    var model = DescribePdnsThreatLogsResponseBody.Logs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.logs = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribePdnsThreatLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsThreatLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePdnsThreatLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePdnsThreatStatisticRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public var threatSourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threatSourceIp != nil {
            map["ThreatSourceIp"] = self.threatSourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["ThreatSourceIp"] as? String {
            self.threatSourceIp = value
        }
    }
}

public class DescribePdnsThreatStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dohTotalCount: Int64?

        public var threatLevel: String?

        public var threatType: String?

        public var timestamp: Int64?

        public var totalCount: Int64?

        public var udpTotalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dohTotalCount != nil {
                map["DohTotalCount"] = self.dohTotalCount!
            }
            if self.threatLevel != nil {
                map["ThreatLevel"] = self.threatLevel!
            }
            if self.threatType != nil {
                map["ThreatType"] = self.threatType!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.udpTotalCount != nil {
                map["UdpTotalCount"] = self.udpTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DohTotalCount"] as? Int64 {
                self.dohTotalCount = value
            }
            if let value = dict["ThreatLevel"] as? String {
                self.threatLevel = value
            }
            if let value = dict["ThreatType"] as? String {
                self.threatType = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
            if let value = dict["UdpTotalCount"] as? Int64 {
                self.udpTotalCount = value
            }
        }
    }
    public var data: [DescribePdnsThreatStatisticResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribePdnsThreatStatisticResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribePdnsThreatStatisticResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePdnsThreatStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsThreatStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePdnsThreatStatisticResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePdnsThreatStatisticsRequest : Tea.TeaModel {
    public var direction: String?

    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var orderBy: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var subDomain: String?

    public var threatLevel: String?

    public var threatSourceIp: String?

    public var threatType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.threatLevel != nil {
            map["ThreatLevel"] = self.threatLevel!
        }
        if self.threatSourceIp != nil {
            map["ThreatSourceIp"] = self.threatSourceIp!
        }
        if self.threatType != nil {
            map["ThreatType"] = self.threatType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["SubDomain"] as? String {
            self.subDomain = value
        }
        if let value = dict["ThreatLevel"] as? String {
            self.threatLevel = value
        }
        if let value = dict["ThreatSourceIp"] as? String {
            self.threatSourceIp = value
        }
        if let value = dict["ThreatType"] as? String {
            self.threatType = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribePdnsThreatStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dohTotalCount: Int64?

        public var domainCount: Int64?

        public var domainName: String?

        public var latestThreatTime: Int64?

        public var maxThreatLevel: String?

        public var sourceIp: String?

        public var subDomain: String?

        public var threatLevel: String?

        public var threatType: String?

        public var totalCount: Int64?

        public var udpTotalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dohTotalCount != nil {
                map["DohTotalCount"] = self.dohTotalCount!
            }
            if self.domainCount != nil {
                map["DomainCount"] = self.domainCount!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.latestThreatTime != nil {
                map["LatestThreatTime"] = self.latestThreatTime!
            }
            if self.maxThreatLevel != nil {
                map["MaxThreatLevel"] = self.maxThreatLevel!
            }
            if self.sourceIp != nil {
                map["SourceIp"] = self.sourceIp!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            if self.threatLevel != nil {
                map["ThreatLevel"] = self.threatLevel!
            }
            if self.threatType != nil {
                map["ThreatType"] = self.threatType!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.udpTotalCount != nil {
                map["UdpTotalCount"] = self.udpTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DohTotalCount"] as? Int64 {
                self.dohTotalCount = value
            }
            if let value = dict["DomainCount"] as? Int64 {
                self.domainCount = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["LatestThreatTime"] as? Int64 {
                self.latestThreatTime = value
            }
            if let value = dict["MaxThreatLevel"] as? String {
                self.maxThreatLevel = value
            }
            if let value = dict["SourceIp"] as? String {
                self.sourceIp = value
            }
            if let value = dict["SubDomain"] as? String {
                self.subDomain = value
            }
            if let value = dict["ThreatLevel"] as? String {
                self.threatLevel = value
            }
            if let value = dict["ThreatType"] as? String {
                self.threatType = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
            if let value = dict["UdpTotalCount"] as? Int64 {
                self.udpTotalCount = value
            }
        }
    }
    public var data: [DescribePdnsThreatStatisticsResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribePdnsThreatStatisticsResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribePdnsThreatStatisticsResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribePdnsThreatStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsThreatStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePdnsThreatStatisticsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePdnsUdpIpSegmentsRequest : Tea.TeaModel {
    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class DescribePdnsUdpIpSegmentsResponseBody : Tea.TeaModel {
    public class IpSegments : Tea.TeaModel {
        public var createDate: String?

        public var createTimestamp: Int64?

        public var id: String?

        public var ip: String?

        public var mask: Int64?

        public var name: String?

        public var secretKey: String?

        public var state: String?

        public var updateDate: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createDate != nil {
                map["CreateDate"] = self.createDate!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.mask != nil {
                map["Mask"] = self.mask!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.secretKey != nil {
                map["SecretKey"] = self.secretKey!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.updateDate != nil {
                map["UpdateDate"] = self.updateDate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateDate"] as? String {
                self.createDate = value
            }
            if let value = dict["CreateTimestamp"] as? Int64 {
                self.createTimestamp = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Ip"] as? String {
                self.ip = value
            }
            if let value = dict["Mask"] as? Int64 {
                self.mask = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["SecretKey"] as? String {
                self.secretKey = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["UpdateDate"] as? String {
                self.updateDate = value
            }
        }
    }
    public var ipSegments: [DescribePdnsUdpIpSegmentsResponseBody.IpSegments]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var totalPages: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipSegments != nil {
            var tmp : [Any] = []
            for k in self.ipSegments! {
                tmp.append(k.toMap())
            }
            map["IpSegments"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IpSegments"] as? [Any?] {
            var tmp : [DescribePdnsUdpIpSegmentsResponseBody.IpSegments] = []
            for v in value {
                if v != nil {
                    var model = DescribePdnsUdpIpSegmentsResponseBody.IpSegments()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ipSegments = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
        if let value = dict["TotalPages"] as? String {
            self.totalPages = value
        }
    }
}

public class DescribePdnsUdpIpSegmentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsUdpIpSegmentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePdnsUdpIpSegmentsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePdnsUserInfoRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribePdnsUserInfoResponseBody : Tea.TeaModel {
    public class UserInfo : Tea.TeaModel {
        public var availableAccessSecurityType: String?

        public var availableService: String?

        public var pdnsId: Int64?

        public var secretKey: String?

        public var serviceType: String?

        public var state: String?

        public var statisticSwitchStatus: String?

        public var stoppedService: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableAccessSecurityType != nil {
                map["AvailableAccessSecurityType"] = self.availableAccessSecurityType!
            }
            if self.availableService != nil {
                map["AvailableService"] = self.availableService!
            }
            if self.pdnsId != nil {
                map["PdnsId"] = self.pdnsId!
            }
            if self.secretKey != nil {
                map["SecretKey"] = self.secretKey!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.statisticSwitchStatus != nil {
                map["StatisticSwitchStatus"] = self.statisticSwitchStatus!
            }
            if self.stoppedService != nil {
                map["StoppedService"] = self.stoppedService!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AvailableAccessSecurityType"] as? String {
                self.availableAccessSecurityType = value
            }
            if let value = dict["AvailableService"] as? String {
                self.availableService = value
            }
            if let value = dict["PdnsId"] as? Int64 {
                self.pdnsId = value
            }
            if let value = dict["SecretKey"] as? String {
                self.secretKey = value
            }
            if let value = dict["ServiceType"] as? String {
                self.serviceType = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["StatisticSwitchStatus"] as? String {
                self.statisticSwitchStatus = value
            }
            if let value = dict["StoppedService"] as? String {
                self.stoppedService = value
            }
        }
    }
    public var requestId: String?

    public var userInfo: DescribePdnsUserInfoResponseBody.UserInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userInfo != nil {
            map["UserInfo"] = self.userInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UserInfo"] as? [String: Any?] {
            var model = DescribePdnsUserInfoResponseBody.UserInfo()
            model.fromMap(value)
            self.userInfo = model
        }
    }
}

public class DescribePdnsUserInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsUserInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePdnsUserInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRecordLogsRequest : Tea.TeaModel {
    public var domainName: String?

    public var keyWord: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var userClientIp: String?

    public var endDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.endDate != nil {
            map["endDate"] = self.endDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["KeyWord"] as? String {
            self.keyWord = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
        if let value = dict["endDate"] as? String {
            self.endDate = value
        }
    }
}

public class DescribeRecordLogsResponseBody : Tea.TeaModel {
    public class RecordLogs : Tea.TeaModel {
        public class RecordLog : Tea.TeaModel {
            public var action: String?

            public var actionTime: String?

            public var actionTimestamp: Int64?

            public var clientIp: String?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.actionTime != nil {
                    map["ActionTime"] = self.actionTime!
                }
                if self.actionTimestamp != nil {
                    map["ActionTimestamp"] = self.actionTimestamp!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Action"] as? String {
                    self.action = value
                }
                if let value = dict["ActionTime"] as? String {
                    self.actionTime = value
                }
                if let value = dict["ActionTimestamp"] as? Int64 {
                    self.actionTimestamp = value
                }
                if let value = dict["ClientIp"] as? String {
                    self.clientIp = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
            }
        }
        public var recordLog: [DescribeRecordLogsResponseBody.RecordLogs.RecordLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordLog != nil {
                var tmp : [Any] = []
                for k in self.recordLog! {
                    tmp.append(k.toMap())
                }
                map["RecordLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RecordLog"] as? [Any?] {
                var tmp : [DescribeRecordLogsResponseBody.RecordLogs.RecordLog] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRecordLogsResponseBody.RecordLogs.RecordLog()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.recordLog = tmp
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var recordLogs: DescribeRecordLogsResponseBody.RecordLogs?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordLogs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordLogs != nil {
            map["RecordLogs"] = self.recordLogs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RecordLogs"] as? [String: Any?] {
            var model = DescribeRecordLogsResponseBody.RecordLogs()
            model.fromMap(value)
            self.recordLogs = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeRecordLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecordLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRecordLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRecordResolveStatisticsSummaryRequest : Tea.TeaModel {
    public var direction: String?

    public var domainName: String?

    public var domainType: String?

    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchMode: String?

    public var startDate: String?

    public var threshold: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DomainType"] as? String {
            self.domainType = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SearchMode"] as? String {
            self.searchMode = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["Threshold"] as? Int64 {
            self.threshold = value
        }
    }
}

public class DescribeRecordResolveStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var count: String?

        public var domainName: String?

        public var domainType: String?

        public var subDomain: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainType != nil {
                map["DomainType"] = self.domainType!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Count"] as? String {
                self.count = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["DomainType"] as? String {
                self.domainType = value
            }
            if let value = dict["SubDomain"] as? String {
                self.subDomain = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: [DescribeRecordResolveStatisticsSummaryResponseBody.Statistics]?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Statistics"] as? [Any?] {
            var tmp : [DescribeRecordResolveStatisticsSummaryResponseBody.Statistics] = []
            for v in value {
                if v != nil {
                    var model = DescribeRecordResolveStatisticsSummaryResponseBody.Statistics()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.statistics = tmp
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeRecordResolveStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecordResolveStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRecordResolveStatisticsSummaryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRecordStatisticsRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainType: String?

    public var endDate: String?

    public var lang: String?

    public var rr: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.rr != nil {
            map["Rr"] = self.rr!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DomainType"] as? String {
            self.domainType = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Rr"] as? String {
            self.rr = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
    }
}

public class DescribeRecordStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public class Statistic : Tea.TeaModel {
            public var count: Int64?

            public var timestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int64 {
                    self.count = value
                }
                if let value = dict["Timestamp"] as? Int64 {
                    self.timestamp = value
                }
            }
        }
        public var statistic: [DescribeRecordStatisticsResponseBody.Statistics.Statistic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.statistic != nil {
                var tmp : [Any] = []
                for k in self.statistic! {
                    tmp.append(k.toMap())
                }
                map["Statistic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Statistic"] as? [Any?] {
                var tmp : [DescribeRecordStatisticsResponseBody.Statistics.Statistic] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRecordStatisticsResponseBody.Statistics.Statistic()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.statistic = tmp
            }
        }
    }
    public var requestId: String?

    public var statistics: DescribeRecordStatisticsResponseBody.Statistics?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Statistics"] as? [String: Any?] {
            var model = DescribeRecordStatisticsResponseBody.Statistics()
            model.fromMap(value)
            self.statistics = model
        }
    }
}

public class DescribeRecordStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecordStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRecordStatisticsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRecordStatisticsSummaryRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainType: String?

    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var searchMode: String?

    public var startDate: String?

    public var threshold: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DomainType"] as? String {
            self.domainType = value
        }
        if let value = dict["EndDate"] as? String {
            self.endDate = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["SearchMode"] as? String {
            self.searchMode = value
        }
        if let value = dict["StartDate"] as? String {
            self.startDate = value
        }
        if let value = dict["Threshold"] as? Int64 {
            self.threshold = value
        }
    }
}

public class DescribeRecordStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public class Statistic : Tea.TeaModel {
            public var count: Int64?

            public var subDomain: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.subDomain != nil {
                    map["SubDomain"] = self.subDomain!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int64 {
                    self.count = value
                }
                if let value = dict["SubDomain"] as? String {
                    self.subDomain = value
                }
            }
        }
        public var statistic: [DescribeRecordStatisticsSummaryResponseBody.Statistics.Statistic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.statistic != nil {
                var tmp : [Any] = []
                for k in self.statistic! {
                    tmp.append(k.toMap())
                }
                map["Statistic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Statistic"] as? [Any?] {
                var tmp : [DescribeRecordStatisticsSummaryResponseBody.Statistics.Statistic] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRecordStatisticsSummaryResponseBody.Statistics.Statistic()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.statistic = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: DescribeRecordStatisticsSummaryResponseBody.Statistics?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Statistics"] as? [String: Any?] {
            var model = DescribeRecordStatisticsSummaryResponseBody.Statistics()
            model.fromMap(value)
            self.statistics = model
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class DescribeRecordStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecordStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRecordStatisticsSummaryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRecursionRecordRequest : Tea.TeaModel {
    public var recordId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
    }
}

public class DescribeRecursionRecordResponseBody : Tea.TeaModel {
    public var createTime: String?

    public var createTimestamp: Int64?

    public var priority: Int32?

    public var recordId: String?

    public var remark: String?

    public var requestId: String?

    public var rr: String?

    public var ttl: Int32?

    public var type: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public var value: String?

    public var weight: Int32?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rr != nil {
            map["Rr"] = self.rr!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Rr"] as? String {
            self.rr = value
        }
        if let value = dict["Ttl"] as? Int32 {
            self.ttl = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
        if let value = dict["UpdateTimestamp"] as? Int64 {
            self.updateTimestamp = value
        }
        if let value = dict["Value"] as? String {
            self.value = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeRecursionRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecursionRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRecursionRecordResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRecursionZoneRequest : Tea.TeaModel {
    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeRecursionZoneResponseBody : Tea.TeaModel {
    public class EffectiveScopes : Tea.TeaModel {
        public class EffectiveScope : Tea.TeaModel {
            public class Scopes : Tea.TeaModel {
                public var scope: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.scope != nil {
                        map["Scope"] = self.scope!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Scope"] as? [String] {
                        self.scope = value
                    }
                }
            }
            public var effectiveType: String?

            public var scopes: DescribeRecursionZoneResponseBody.EffectiveScopes.EffectiveScope.Scopes?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scopes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.effectiveType != nil {
                    map["EffectiveType"] = self.effectiveType!
                }
                if self.scopes != nil {
                    map["Scopes"] = self.scopes?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EffectiveType"] as? String {
                    self.effectiveType = value
                }
                if let value = dict["Scopes"] as? [String: Any?] {
                    var model = DescribeRecursionZoneResponseBody.EffectiveScopes.EffectiveScope.Scopes()
                    model.fromMap(value)
                    self.scopes = model
                }
            }
        }
        public var effectiveScope: [DescribeRecursionZoneResponseBody.EffectiveScopes.EffectiveScope]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.effectiveScope != nil {
                var tmp : [Any] = []
                for k in self.effectiveScope! {
                    tmp.append(k.toMap())
                }
                map["EffectiveScope"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EffectiveScope"] as? [Any?] {
                var tmp : [DescribeRecursionZoneResponseBody.EffectiveScopes.EffectiveScope] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRecursionZoneResponseBody.EffectiveScopes.EffectiveScope()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.effectiveScope = tmp
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var creator: String?

    public var creatorSubType: String?

    public var creatorType: String?

    public var effectiveScopes: DescribeRecursionZoneResponseBody.EffectiveScopes?

    public var proxyPattern: String?

    public var recordCount: Int32?

    public var remark: String?

    public var requestId: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public var userId: String?

    public var zoneId: String?

    public var zoneName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.effectiveScopes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.creatorSubType != nil {
            map["CreatorSubType"] = self.creatorSubType!
        }
        if self.creatorType != nil {
            map["CreatorType"] = self.creatorType!
        }
        if self.effectiveScopes != nil {
            map["EffectiveScopes"] = self.effectiveScopes?.toMap()
        }
        if self.proxyPattern != nil {
            map["ProxyPattern"] = self.proxyPattern!
        }
        if self.recordCount != nil {
            map["RecordCount"] = self.recordCount!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneName != nil {
            map["ZoneName"] = self.zoneName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CreateTimestamp"] as? Int64 {
            self.createTimestamp = value
        }
        if let value = dict["Creator"] as? String {
            self.creator = value
        }
        if let value = dict["CreatorSubType"] as? String {
            self.creatorSubType = value
        }
        if let value = dict["CreatorType"] as? String {
            self.creatorType = value
        }
        if let value = dict["EffectiveScopes"] as? [String: Any?] {
            var model = DescribeRecursionZoneResponseBody.EffectiveScopes()
            model.fromMap(value)
            self.effectiveScopes = model
        }
        if let value = dict["ProxyPattern"] as? String {
            self.proxyPattern = value
        }
        if let value = dict["RecordCount"] as? Int32 {
            self.recordCount = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
        if let value = dict["UpdateTimestamp"] as? Int64 {
            self.updateTimestamp = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["ZoneName"] as? String {
            self.zoneName = value
        }
    }
}

public class DescribeRecursionZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecursionZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRecursionZoneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSubDomainRecordsRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var line: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var subDomain: String?

    public var type: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Line"] as? String {
            self.line = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["SubDomain"] as? String {
            self.subDomain = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
    }
}

public class DescribeSubDomainRecordsResponseBody : Tea.TeaModel {
    public class DomainRecords : Tea.TeaModel {
        public class Record : Tea.TeaModel {
            public var domainName: String?

            public var line: String?

            public var locked: Bool?

            public var priority: Int64?

            public var RR: String?

            public var recordId: String?

            public var remark: String?

            public var status: String?

            public var TTL: Int64?

            public var type: String?

            public var value: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.line != nil {
                    map["Line"] = self.line!
                }
                if self.locked != nil {
                    map["Locked"] = self.locked!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.RR != nil {
                    map["RR"] = self.RR!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.TTL != nil {
                    map["TTL"] = self.TTL!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Line"] as? String {
                    self.line = value
                }
                if let value = dict["Locked"] as? Bool {
                    self.locked = value
                }
                if let value = dict["Priority"] as? Int64 {
                    self.priority = value
                }
                if let value = dict["RR"] as? String {
                    self.RR = value
                }
                if let value = dict["RecordId"] as? String {
                    self.recordId = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["TTL"] as? Int64 {
                    self.TTL = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
            }
        }
        public var record: [DescribeSubDomainRecordsResponseBody.DomainRecords.Record]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.record != nil {
                var tmp : [Any] = []
                for k in self.record! {
                    tmp.append(k.toMap())
                }
                map["Record"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Record"] as? [Any?] {
                var tmp : [DescribeSubDomainRecordsResponseBody.DomainRecords.Record] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSubDomainRecordsResponseBody.DomainRecords.Record()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.record = tmp
            }
        }
    }
    public var domainRecords: DescribeSubDomainRecordsResponseBody.DomainRecords?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainRecords?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainRecords != nil {
            map["DomainRecords"] = self.domainRecords?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainRecords"] as? [String: Any?] {
            var model = DescribeSubDomainRecordsResponseBody.DomainRecords()
            model.fromMap(value)
            self.domainRecords = model
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeSubDomainRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSubDomainRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSubDomainRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSupportLinesRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
    }
}

public class DescribeSupportLinesResponseBody : Tea.TeaModel {
    public class RecordLines : Tea.TeaModel {
        public class RecordLine : Tea.TeaModel {
            public var fatherCode: String?

            public var lineCode: String?

            public var lineDisplayName: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineDisplayName != nil {
                    map["LineDisplayName"] = self.lineDisplayName!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FatherCode"] as? String {
                    self.fatherCode = value
                }
                if let value = dict["LineCode"] as? String {
                    self.lineCode = value
                }
                if let value = dict["LineDisplayName"] as? String {
                    self.lineDisplayName = value
                }
                if let value = dict["LineName"] as? String {
                    self.lineName = value
                }
            }
        }
        public var recordLine: [DescribeSupportLinesResponseBody.RecordLines.RecordLine]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordLine != nil {
                var tmp : [Any] = []
                for k in self.recordLine! {
                    tmp.append(k.toMap())
                }
                map["RecordLine"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RecordLine"] as? [Any?] {
                var tmp : [DescribeSupportLinesResponseBody.RecordLines.RecordLine] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSupportLinesResponseBody.RecordLines.RecordLine()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.recordLine = tmp
            }
        }
    }
    public var recordLines: DescribeSupportLinesResponseBody.RecordLines?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordLines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordLines != nil {
            map["RecordLines"] = self.recordLines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecordLines"] as? [String: Any?] {
            var model = DescribeSupportLinesResponseBody.RecordLines()
            model.fromMap(value)
            self.recordLines = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeSupportLinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSupportLinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSupportLinesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTagsRequest : Tea.TeaModel {
    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class DescribeTagsResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var values: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.values != nil {
                map["Values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Values"] as? [String] {
                self.values = value
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var tags: [DescribeTagsResponseBody.Tags]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [DescribeTagsResponseBody.Tags] = []
            for v in value {
                if v != nil {
                    var model = DescribeTagsResponseBody.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTransferDomainsRequest : Tea.TeaModel {
    public var domainName: String?

    public var fromUserId: Int64?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var targetUserId: Int64?

    public var transferType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.fromUserId != nil {
            map["FromUserId"] = self.fromUserId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        if self.transferType != nil {
            map["TransferType"] = self.transferType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["FromUserId"] as? Int64 {
            self.fromUserId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["TargetUserId"] as? Int64 {
            self.targetUserId = value
        }
        if let value = dict["TransferType"] as? String {
            self.transferType = value
        }
    }
}

public class DescribeTransferDomainsResponseBody : Tea.TeaModel {
    public class DomainTransfers : Tea.TeaModel {
        public class DomainTransfer : Tea.TeaModel {
            public var createTime: String?

            public var createTimestamp: Int64?

            public var domainName: String?

            public var fromUserId: Int64?

            public var id: Int64?

            public var targetUserId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.fromUserId != nil {
                    map["FromUserId"] = self.fromUserId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.targetUserId != nil {
                    map["TargetUserId"] = self.targetUserId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["FromUserId"] as? Int64 {
                    self.fromUserId = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["TargetUserId"] as? Int64 {
                    self.targetUserId = value
                }
            }
        }
        public var domainTransfer: [DescribeTransferDomainsResponseBody.DomainTransfers.DomainTransfer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainTransfer != nil {
                var tmp : [Any] = []
                for k in self.domainTransfer! {
                    tmp.append(k.toMap())
                }
                map["DomainTransfer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainTransfer"] as? [Any?] {
                var tmp : [DescribeTransferDomainsResponseBody.DomainTransfers.DomainTransfer] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTransferDomainsResponseBody.DomainTransfers.DomainTransfer()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainTransfer = tmp
            }
        }
    }
    public var domainTransfers: DescribeTransferDomainsResponseBody.DomainTransfers?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainTransfers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainTransfers != nil {
            map["DomainTransfers"] = self.domainTransfers?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainTransfers"] as? [String: Any?] {
            var model = DescribeTransferDomainsResponseBody.DomainTransfers()
            model.fromMap(value)
            self.domainTransfers = model
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeTransferDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTransferDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTransferDomainsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExecuteGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["RecoveryPlanId"] as? Int64 {
            self.recoveryPlanId = value
        }
    }
}

public class ExecuteGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ExecuteGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExecuteGtmRecoveryPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMainDomainNameRequest : Tea.TeaModel {
    public var inputString: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputString != nil {
            map["InputString"] = self.inputString!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InputString"] as? String {
            self.inputString = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class GetMainDomainNameResponseBody : Tea.TeaModel {
    public var domainLevel: Int64?

    public var domainName: String?

    public var RR: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLevel != nil {
            map["DomainLevel"] = self.domainLevel!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainLevel"] as? Int64 {
            self.domainLevel = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["RR"] as? String {
            self.RR = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetMainDomainNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMainDomainNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMainDomainNameResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTxtRecordForVerifyRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class GetTxtRecordForVerifyResponseBody : Tea.TeaModel {
    public var domainName: String?

    public var parentDomainName: String?

    public var RR: String?

    public var requestId: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.parentDomainName != nil {
            map["ParentDomainName"] = self.parentDomainName!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["ParentDomainName"] as? String {
            self.parentDomainName = value
        }
        if let value = dict["RR"] as? String {
            self.RR = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Value"] as? String {
            self.value = value
        }
    }
}

public class GetTxtRecordForVerifyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTxtRecordForVerifyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTxtRecordForVerifyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCloudGtmAddressPoolsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolName: String?

    public var addressPoolType: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolName != nil {
            map["AddressPoolName"] = self.addressPoolName!
        }
        if self.addressPoolType != nil {
            map["AddressPoolType"] = self.addressPoolType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPoolName"] as? String {
            self.addressPoolName = value
        }
        if let value = dict["AddressPoolType"] as? String {
            self.addressPoolType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class ListCloudGtmAddressPoolsResponseBody : Tea.TeaModel {
    public class AddressPools : Tea.TeaModel {
        public class AddressPool : Tea.TeaModel {
            public class Addresses : Tea.TeaModel {
                public class Address : Tea.TeaModel {
                    public class HealthTasks : Tea.TeaModel {
                        public class HealthTask : Tea.TeaModel {
                            public var port: Int32?

                            public var templateId: String?

                            public var templateName: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.port != nil {
                                    map["Port"] = self.port!
                                }
                                if self.templateId != nil {
                                    map["TemplateId"] = self.templateId!
                                }
                                if self.templateName != nil {
                                    map["TemplateName"] = self.templateName!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Port"] as? Int32 {
                                    self.port = value
                                }
                                if let value = dict["TemplateId"] as? String {
                                    self.templateId = value
                                }
                                if let value = dict["TemplateName"] as? String {
                                    self.templateName = value
                                }
                            }
                        }
                        public var healthTask: [ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks.HealthTask]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.healthTask != nil {
                                var tmp : [Any] = []
                                for k in self.healthTask! {
                                    tmp.append(k.toMap())
                                }
                                map["HealthTask"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["HealthTask"] as? [Any?] {
                                var tmp : [ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks.HealthTask] = []
                                for v in value {
                                    if v != nil {
                                        var model = ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks.HealthTask()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.healthTask = tmp
                            }
                        }
                    }
                    public class RequestSource : Tea.TeaModel {
                        public var requestSource: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.requestSource != nil {
                                map["RequestSource"] = self.requestSource!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["RequestSource"] as? [String] {
                                self.requestSource = value
                            }
                        }
                    }
                    public var address: String?

                    public var addressId: String?

                    public var attributeInfo: String?

                    public var availableMode: String?

                    public var availableStatus: String?

                    public var createTime: String?

                    public var createTimestamp: Int64?

                    public var enableStatus: String?

                    public var healthJudgement: String?

                    public var healthStatus: String?

                    public var healthTasks: ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks?

                    public var manualAvailableStatus: String?

                    public var name: String?

                    public var remark: String?

                    public var requestSource: ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.RequestSource?

                    public var seqNonPreemptiveSchedule: Bool?

                    public var serialNumber: Int32?

                    public var type: String?

                    public var updateTime: String?

                    public var updateTimestamp: Int64?

                    public var weightValue: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.healthTasks?.validate()
                        try self.requestSource?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.addressId != nil {
                            map["AddressId"] = self.addressId!
                        }
                        if self.attributeInfo != nil {
                            map["AttributeInfo"] = self.attributeInfo!
                        }
                        if self.availableMode != nil {
                            map["AvailableMode"] = self.availableMode!
                        }
                        if self.availableStatus != nil {
                            map["AvailableStatus"] = self.availableStatus!
                        }
                        if self.createTime != nil {
                            map["CreateTime"] = self.createTime!
                        }
                        if self.createTimestamp != nil {
                            map["CreateTimestamp"] = self.createTimestamp!
                        }
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.healthJudgement != nil {
                            map["HealthJudgement"] = self.healthJudgement!
                        }
                        if self.healthStatus != nil {
                            map["HealthStatus"] = self.healthStatus!
                        }
                        if self.healthTasks != nil {
                            map["HealthTasks"] = self.healthTasks?.toMap()
                        }
                        if self.manualAvailableStatus != nil {
                            map["ManualAvailableStatus"] = self.manualAvailableStatus!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.remark != nil {
                            map["Remark"] = self.remark!
                        }
                        if self.requestSource != nil {
                            map["RequestSource"] = self.requestSource?.toMap()
                        }
                        if self.seqNonPreemptiveSchedule != nil {
                            map["SeqNonPreemptiveSchedule"] = self.seqNonPreemptiveSchedule!
                        }
                        if self.serialNumber != nil {
                            map["SerialNumber"] = self.serialNumber!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        if self.updateTimestamp != nil {
                            map["UpdateTimestamp"] = self.updateTimestamp!
                        }
                        if self.weightValue != nil {
                            map["WeightValue"] = self.weightValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Address"] as? String {
                            self.address = value
                        }
                        if let value = dict["AddressId"] as? String {
                            self.addressId = value
                        }
                        if let value = dict["AttributeInfo"] as? String {
                            self.attributeInfo = value
                        }
                        if let value = dict["AvailableMode"] as? String {
                            self.availableMode = value
                        }
                        if let value = dict["AvailableStatus"] as? String {
                            self.availableStatus = value
                        }
                        if let value = dict["CreateTime"] as? String {
                            self.createTime = value
                        }
                        if let value = dict["CreateTimestamp"] as? Int64 {
                            self.createTimestamp = value
                        }
                        if let value = dict["EnableStatus"] as? String {
                            self.enableStatus = value
                        }
                        if let value = dict["HealthJudgement"] as? String {
                            self.healthJudgement = value
                        }
                        if let value = dict["HealthStatus"] as? String {
                            self.healthStatus = value
                        }
                        if let value = dict["HealthTasks"] as? [String: Any?] {
                            var model = ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks()
                            model.fromMap(value)
                            self.healthTasks = model
                        }
                        if let value = dict["ManualAvailableStatus"] as? String {
                            self.manualAvailableStatus = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Remark"] as? String {
                            self.remark = value
                        }
                        if let value = dict["RequestSource"] as? [String: Any?] {
                            var model = ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.RequestSource()
                            model.fromMap(value)
                            self.requestSource = model
                        }
                        if let value = dict["SeqNonPreemptiveSchedule"] as? Bool {
                            self.seqNonPreemptiveSchedule = value
                        }
                        if let value = dict["SerialNumber"] as? Int32 {
                            self.serialNumber = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                        if let value = dict["UpdateTime"] as? String {
                            self.updateTime = value
                        }
                        if let value = dict["UpdateTimestamp"] as? Int64 {
                            self.updateTimestamp = value
                        }
                        if let value = dict["WeightValue"] as? Int32 {
                            self.weightValue = value
                        }
                    }
                }
                public var address: [ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.address != nil {
                        var tmp : [Any] = []
                        for k in self.address! {
                            tmp.append(k.toMap())
                        }
                        map["Address"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Address"] as? [Any?] {
                        var tmp : [ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address] = []
                        for v in value {
                            if v != nil {
                                var model = ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.address = tmp
                    }
                }
            }
            public var addressLbStrategy: String?

            public var addressPoolId: String?

            public var addressPoolName: String?

            public var addressPoolType: String?

            public var addresses: ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses?

            public var availableStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var remark: String?

            public var sequenceLbStrategyMode: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addresses?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressLbStrategy != nil {
                    map["AddressLbStrategy"] = self.addressLbStrategy!
                }
                if self.addressPoolId != nil {
                    map["AddressPoolId"] = self.addressPoolId!
                }
                if self.addressPoolName != nil {
                    map["AddressPoolName"] = self.addressPoolName!
                }
                if self.addressPoolType != nil {
                    map["AddressPoolType"] = self.addressPoolType!
                }
                if self.addresses != nil {
                    map["Addresses"] = self.addresses?.toMap()
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddressLbStrategy"] as? String {
                    self.addressLbStrategy = value
                }
                if let value = dict["AddressPoolId"] as? String {
                    self.addressPoolId = value
                }
                if let value = dict["AddressPoolName"] as? String {
                    self.addressPoolName = value
                }
                if let value = dict["AddressPoolType"] as? String {
                    self.addressPoolType = value
                }
                if let value = dict["Addresses"] as? [String: Any?] {
                    var model = ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses()
                    model.fromMap(value)
                    self.addresses = model
                }
                if let value = dict["AvailableStatus"] as? String {
                    self.availableStatus = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["EnableStatus"] as? String {
                    self.enableStatus = value
                }
                if let value = dict["HealthJudgement"] as? String {
                    self.healthJudgement = value
                }
                if let value = dict["HealthStatus"] as? String {
                    self.healthStatus = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["SequenceLbStrategyMode"] as? String {
                    self.sequenceLbStrategyMode = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
            }
        }
        public var addressPool: [ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressPool != nil {
                var tmp : [Any] = []
                for k in self.addressPool! {
                    tmp.append(k.toMap())
                }
                map["AddressPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AddressPool"] as? [Any?] {
                var tmp : [ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool] = []
                for v in value {
                    if v != nil {
                        var model = ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.addressPool = tmp
            }
        }
    }
    public var addressPools: ListCloudGtmAddressPoolsResponseBody.AddressPools?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addressPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPools != nil {
            map["AddressPools"] = self.addressPools?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressPools"] as? [String: Any?] {
            var model = ListCloudGtmAddressPoolsResponseBody.AddressPools()
            model.fromMap(value)
            self.addressPools = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class ListCloudGtmAddressPoolsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmAddressPoolsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCloudGtmAddressPoolsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCloudGtmAddressesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var addressId: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var healthStatus: String?

    public var monitorTemplateId: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.monitorTemplateId != nil {
            map["MonitorTemplateId"] = self.monitorTemplateId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["Address"] as? String {
            self.address = value
        }
        if let value = dict["AddressId"] as? String {
            self.addressId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["HealthStatus"] as? String {
            self.healthStatus = value
        }
        if let value = dict["MonitorTemplateId"] as? String {
            self.monitorTemplateId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class ListCloudGtmAddressesResponseBody : Tea.TeaModel {
    public class Addresses : Tea.TeaModel {
        public class Address : Tea.TeaModel {
            public class HealthTasks : Tea.TeaModel {
                public class HealthTask : Tea.TeaModel {
                    public var monitorStatus: String?

                    public var port: Int32?

                    public var templateId: String?

                    public var templateName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.monitorStatus != nil {
                            map["MonitorStatus"] = self.monitorStatus!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        if self.templateName != nil {
                            map["TemplateName"] = self.templateName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["MonitorStatus"] as? String {
                            self.monitorStatus = value
                        }
                        if let value = dict["Port"] as? Int32 {
                            self.port = value
                        }
                        if let value = dict["TemplateId"] as? String {
                            self.templateId = value
                        }
                        if let value = dict["TemplateName"] as? String {
                            self.templateName = value
                        }
                    }
                }
                public var healthTask: [ListCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks.HealthTask]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.healthTask != nil {
                        var tmp : [Any] = []
                        for k in self.healthTask! {
                            tmp.append(k.toMap())
                        }
                        map["HealthTask"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["HealthTask"] as? [Any?] {
                        var tmp : [ListCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks.HealthTask] = []
                        for v in value {
                            if v != nil {
                                var model = ListCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks.HealthTask()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.healthTask = tmp
                    }
                }
            }
            public var address: String?

            public var addressId: String?

            public var attributeInfo: String?

            public var availableMode: String?

            public var availableStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var healthTasks: ListCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks?

            public var manualAvailableStatus: String?

            public var name: String?

            public var remark: String?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.healthTasks?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.addressId != nil {
                    map["AddressId"] = self.addressId!
                }
                if self.attributeInfo != nil {
                    map["AttributeInfo"] = self.attributeInfo!
                }
                if self.availableMode != nil {
                    map["AvailableMode"] = self.availableMode!
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.healthTasks != nil {
                    map["HealthTasks"] = self.healthTasks?.toMap()
                }
                if self.manualAvailableStatus != nil {
                    map["ManualAvailableStatus"] = self.manualAvailableStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Address"] as? String {
                    self.address = value
                }
                if let value = dict["AddressId"] as? String {
                    self.addressId = value
                }
                if let value = dict["AttributeInfo"] as? String {
                    self.attributeInfo = value
                }
                if let value = dict["AvailableMode"] as? String {
                    self.availableMode = value
                }
                if let value = dict["AvailableStatus"] as? String {
                    self.availableStatus = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["EnableStatus"] as? String {
                    self.enableStatus = value
                }
                if let value = dict["HealthJudgement"] as? String {
                    self.healthJudgement = value
                }
                if let value = dict["HealthStatus"] as? String {
                    self.healthStatus = value
                }
                if let value = dict["HealthTasks"] as? [String: Any?] {
                    var model = ListCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks()
                    model.fromMap(value)
                    self.healthTasks = model
                }
                if let value = dict["ManualAvailableStatus"] as? String {
                    self.manualAvailableStatus = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
            }
        }
        public var address: [ListCloudGtmAddressesResponseBody.Addresses.Address]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                var tmp : [Any] = []
                for k in self.address! {
                    tmp.append(k.toMap())
                }
                map["Address"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Address"] as? [Any?] {
                var tmp : [ListCloudGtmAddressesResponseBody.Addresses.Address] = []
                for v in value {
                    if v != nil {
                        var model = ListCloudGtmAddressesResponseBody.Addresses.Address()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.address = tmp
            }
        }
    }
    public var addresses: ListCloudGtmAddressesResponseBody.Addresses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addresses != nil {
            map["Addresses"] = self.addresses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Addresses"] as? [String: Any?] {
            var model = ListCloudGtmAddressesResponseBody.Addresses()
            model.fromMap(value)
            self.addresses = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class ListCloudGtmAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCloudGtmAddressesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCloudGtmAlertLogsRequest : Tea.TeaModel {
    public var actionType: String?

    public var endTimestamp: Int64?

    public var entityType: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["ActionType"] = self.actionType!
        }
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.entityType != nil {
            map["EntityType"] = self.entityType!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimestamp != nil {
            map["StartTimestamp"] = self.startTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActionType"] as? String {
            self.actionType = value
        }
        if let value = dict["EndTimestamp"] as? Int64 {
            self.endTimestamp = value
        }
        if let value = dict["EntityType"] as? String {
            self.entityType = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartTimestamp"] as? Int64 {
            self.startTimestamp = value
        }
    }
}

public class ListCloudGtmAlertLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public class Log : Tea.TeaModel {
            public var actionType: String?

            public var content: String?

            public var entityType: String?

            public var timestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionType != nil {
                    map["ActionType"] = self.actionType!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.entityType != nil {
                    map["EntityType"] = self.entityType!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActionType"] as? String {
                    self.actionType = value
                }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["EntityType"] as? String {
                    self.entityType = value
                }
                if let value = dict["Timestamp"] as? Int64 {
                    self.timestamp = value
                }
            }
        }
        public var log: [ListCloudGtmAlertLogsResponseBody.Logs.Log]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.log != nil {
                var tmp : [Any] = []
                for k in self.log! {
                    tmp.append(k.toMap())
                }
                map["Log"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Log"] as? [Any?] {
                var tmp : [ListCloudGtmAlertLogsResponseBody.Logs.Log] = []
                for v in value {
                    if v != nil {
                        var model = ListCloudGtmAlertLogsResponseBody.Logs.Log()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.log = tmp
            }
        }
    }
    public var logs: ListCloudGtmAlertLogsResponseBody.Logs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            map["Logs"] = self.logs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Logs"] as? [String: Any?] {
            var model = ListCloudGtmAlertLogsResponseBody.Logs()
            model.fromMap(value)
            self.logs = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class ListCloudGtmAlertLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmAlertLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCloudGtmAlertLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCloudGtmAvailableAlertGroupsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
    }
}

public class ListCloudGtmAvailableAlertGroupsResponseBody : Tea.TeaModel {
    public class AlertGroups : Tea.TeaModel {
        public class AlertGroup : Tea.TeaModel {
            public var groupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
            }
        }
        public var alertGroup: [ListCloudGtmAvailableAlertGroupsResponseBody.AlertGroups.AlertGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertGroup != nil {
                var tmp : [Any] = []
                for k in self.alertGroup! {
                    tmp.append(k.toMap())
                }
                map["AlertGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlertGroup"] as? [Any?] {
                var tmp : [ListCloudGtmAvailableAlertGroupsResponseBody.AlertGroups.AlertGroup] = []
                for v in value {
                    if v != nil {
                        var model = ListCloudGtmAvailableAlertGroupsResponseBody.AlertGroups.AlertGroup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.alertGroup = tmp
            }
        }
    }
    public var alertGroups: ListCloudGtmAvailableAlertGroupsResponseBody.AlertGroups?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertGroups != nil {
            map["AlertGroups"] = self.alertGroups?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertGroups"] as? [String: Any?] {
            var model = ListCloudGtmAvailableAlertGroupsResponseBody.AlertGroups()
            model.fromMap(value)
            self.alertGroups = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListCloudGtmAvailableAlertGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmAvailableAlertGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCloudGtmAvailableAlertGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCloudGtmInstanceConfigsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remark: String?

    public var scheduleDomainName: String?

    public var scheduleZoneName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.scheduleDomainName != nil {
            map["ScheduleDomainName"] = self.scheduleDomainName!
        }
        if self.scheduleZoneName != nil {
            map["ScheduleZoneName"] = self.scheduleZoneName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["ScheduleDomainName"] as? String {
            self.scheduleDomainName = value
        }
        if let value = dict["ScheduleZoneName"] as? String {
            self.scheduleZoneName = value
        }
    }
}

public class ListCloudGtmInstanceConfigsResponseBody : Tea.TeaModel {
    public class InstanceConfigs : Tea.TeaModel {
        public class InstanceConfig : Tea.TeaModel {
            public class AddressPools : Tea.TeaModel {
                public class AddressPool : Tea.TeaModel {
                    public class RequestSource : Tea.TeaModel {
                        public var requestSource: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.requestSource != nil {
                                map["RequestSource"] = self.requestSource!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["RequestSource"] as? [String] {
                                self.requestSource = value
                            }
                        }
                    }
                    public var addressLbStrategy: String?

                    public var addressPoolId: String?

                    public var addressPoolName: String?

                    public var addressPoolType: String?

                    public var availableStatus: String?

                    public var createTime: String?

                    public var createTimestamp: Int64?

                    public var enableStatus: String?

                    public var healthJudgement: String?

                    public var healthStatus: String?

                    public var requestSource: ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool.RequestSource?

                    public var seqNonPreemptiveSchedule: Bool?

                    public var sequenceLbStrategyMode: String?

                    public var serialNumber: Int32?

                    public var updateTime: String?

                    public var updateTimestamp: Int64?

                    public var weightValue: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.requestSource?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.addressLbStrategy != nil {
                            map["AddressLbStrategy"] = self.addressLbStrategy!
                        }
                        if self.addressPoolId != nil {
                            map["AddressPoolId"] = self.addressPoolId!
                        }
                        if self.addressPoolName != nil {
                            map["AddressPoolName"] = self.addressPoolName!
                        }
                        if self.addressPoolType != nil {
                            map["AddressPoolType"] = self.addressPoolType!
                        }
                        if self.availableStatus != nil {
                            map["AvailableStatus"] = self.availableStatus!
                        }
                        if self.createTime != nil {
                            map["CreateTime"] = self.createTime!
                        }
                        if self.createTimestamp != nil {
                            map["CreateTimestamp"] = self.createTimestamp!
                        }
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.healthJudgement != nil {
                            map["HealthJudgement"] = self.healthJudgement!
                        }
                        if self.healthStatus != nil {
                            map["HealthStatus"] = self.healthStatus!
                        }
                        if self.requestSource != nil {
                            map["RequestSource"] = self.requestSource?.toMap()
                        }
                        if self.seqNonPreemptiveSchedule != nil {
                            map["SeqNonPreemptiveSchedule"] = self.seqNonPreemptiveSchedule!
                        }
                        if self.sequenceLbStrategyMode != nil {
                            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                        }
                        if self.serialNumber != nil {
                            map["SerialNumber"] = self.serialNumber!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        if self.updateTimestamp != nil {
                            map["UpdateTimestamp"] = self.updateTimestamp!
                        }
                        if self.weightValue != nil {
                            map["WeightValue"] = self.weightValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AddressLbStrategy"] as? String {
                            self.addressLbStrategy = value
                        }
                        if let value = dict["AddressPoolId"] as? String {
                            self.addressPoolId = value
                        }
                        if let value = dict["AddressPoolName"] as? String {
                            self.addressPoolName = value
                        }
                        if let value = dict["AddressPoolType"] as? String {
                            self.addressPoolType = value
                        }
                        if let value = dict["AvailableStatus"] as? String {
                            self.availableStatus = value
                        }
                        if let value = dict["CreateTime"] as? String {
                            self.createTime = value
                        }
                        if let value = dict["CreateTimestamp"] as? Int64 {
                            self.createTimestamp = value
                        }
                        if let value = dict["EnableStatus"] as? String {
                            self.enableStatus = value
                        }
                        if let value = dict["HealthJudgement"] as? String {
                            self.healthJudgement = value
                        }
                        if let value = dict["HealthStatus"] as? String {
                            self.healthStatus = value
                        }
                        if let value = dict["RequestSource"] as? [String: Any?] {
                            var model = ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool.RequestSource()
                            model.fromMap(value)
                            self.requestSource = model
                        }
                        if let value = dict["SeqNonPreemptiveSchedule"] as? Bool {
                            self.seqNonPreemptiveSchedule = value
                        }
                        if let value = dict["SequenceLbStrategyMode"] as? String {
                            self.sequenceLbStrategyMode = value
                        }
                        if let value = dict["SerialNumber"] as? Int32 {
                            self.serialNumber = value
                        }
                        if let value = dict["UpdateTime"] as? String {
                            self.updateTime = value
                        }
                        if let value = dict["UpdateTimestamp"] as? Int64 {
                            self.updateTimestamp = value
                        }
                        if let value = dict["WeightValue"] as? Int32 {
                            self.weightValue = value
                        }
                    }
                }
                public var addressPool: [ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.addressPool != nil {
                        var tmp : [Any] = []
                        for k in self.addressPool! {
                            tmp.append(k.toMap())
                        }
                        map["AddressPool"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AddressPool"] as? [Any?] {
                        var tmp : [ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool] = []
                        for v in value {
                            if v != nil {
                                var model = ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.addressPool = tmp
                    }
                }
            }
            public var addressPoolLbStrategy: String?

            public var addressPools: ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools?

            public var availableStatus: String?

            public var commodityCode: String?

            public var configId: String?

            public var configLoggingSwitchStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthStatus: String?

            public var instanceId: String?

            public var remark: String?

            public var scheduleDomainName: String?

            public var scheduleHostname: String?

            public var scheduleRrType: String?

            public var scheduleZoneMode: String?

            public var scheduleZoneName: String?

            public var sequenceLbStrategyMode: String?

            public var ttl: Int32?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addressPools?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressPoolLbStrategy != nil {
                    map["AddressPoolLbStrategy"] = self.addressPoolLbStrategy!
                }
                if self.addressPools != nil {
                    map["AddressPools"] = self.addressPools?.toMap()
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.configId != nil {
                    map["ConfigId"] = self.configId!
                }
                if self.configLoggingSwitchStatus != nil {
                    map["ConfigLoggingSwitchStatus"] = self.configLoggingSwitchStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.scheduleDomainName != nil {
                    map["ScheduleDomainName"] = self.scheduleDomainName!
                }
                if self.scheduleHostname != nil {
                    map["ScheduleHostname"] = self.scheduleHostname!
                }
                if self.scheduleRrType != nil {
                    map["ScheduleRrType"] = self.scheduleRrType!
                }
                if self.scheduleZoneMode != nil {
                    map["ScheduleZoneMode"] = self.scheduleZoneMode!
                }
                if self.scheduleZoneName != nil {
                    map["ScheduleZoneName"] = self.scheduleZoneName!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddressPoolLbStrategy"] as? String {
                    self.addressPoolLbStrategy = value
                }
                if let value = dict["AddressPools"] as? [String: Any?] {
                    var model = ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools()
                    model.fromMap(value)
                    self.addressPools = model
                }
                if let value = dict["AvailableStatus"] as? String {
                    self.availableStatus = value
                }
                if let value = dict["CommodityCode"] as? String {
                    self.commodityCode = value
                }
                if let value = dict["ConfigId"] as? String {
                    self.configId = value
                }
                if let value = dict["ConfigLoggingSwitchStatus"] as? String {
                    self.configLoggingSwitchStatus = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["EnableStatus"] as? String {
                    self.enableStatus = value
                }
                if let value = dict["HealthStatus"] as? String {
                    self.healthStatus = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["ScheduleDomainName"] as? String {
                    self.scheduleDomainName = value
                }
                if let value = dict["ScheduleHostname"] as? String {
                    self.scheduleHostname = value
                }
                if let value = dict["ScheduleRrType"] as? String {
                    self.scheduleRrType = value
                }
                if let value = dict["ScheduleZoneMode"] as? String {
                    self.scheduleZoneMode = value
                }
                if let value = dict["ScheduleZoneName"] as? String {
                    self.scheduleZoneName = value
                }
                if let value = dict["SequenceLbStrategyMode"] as? String {
                    self.sequenceLbStrategyMode = value
                }
                if let value = dict["Ttl"] as? Int32 {
                    self.ttl = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
                if let value = dict["VersionCode"] as? String {
                    self.versionCode = value
                }
            }
        }
        public var instanceConfig: [ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceConfig != nil {
                var tmp : [Any] = []
                for k in self.instanceConfig! {
                    tmp.append(k.toMap())
                }
                map["InstanceConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceConfig"] as? [Any?] {
                var tmp : [ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig] = []
                for v in value {
                    if v != nil {
                        var model = ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceConfig = tmp
            }
        }
    }
    public var instanceConfigs: ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceConfigs != nil {
            map["InstanceConfigs"] = self.instanceConfigs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceConfigs"] as? [String: Any?] {
            var model = ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs()
            model.fromMap(value)
            self.instanceConfigs = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class ListCloudGtmInstanceConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmInstanceConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCloudGtmInstanceConfigsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCloudGtmInstancesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var chargeType: String?

    public var clientToken: String?

    public var instanceId: String?

    public var instanceName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ChargeType"] as? String {
            self.chargeType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListCloudGtmInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public var chargeType: String?

            public var commodityCode: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var expireTime: String?

            public var expireTimestamp: Int64?

            public var instanceId: String?

            public var instanceName: String?

            public var monitorTaskQuota: Int32?

            public var monthlyEmailUsed: Int32?

            public var monthlySmsQuota: Int32?

            public var monthlySmsUsed: Int32?

            public var monthlyWebhookUsed: Int32?

            public var scheduleDomainName: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.expireTimestamp != nil {
                    map["ExpireTimestamp"] = self.expireTimestamp!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.monitorTaskQuota != nil {
                    map["MonitorTaskQuota"] = self.monitorTaskQuota!
                }
                if self.monthlyEmailUsed != nil {
                    map["MonthlyEmailUsed"] = self.monthlyEmailUsed!
                }
                if self.monthlySmsQuota != nil {
                    map["MonthlySmsQuota"] = self.monthlySmsQuota!
                }
                if self.monthlySmsUsed != nil {
                    map["MonthlySmsUsed"] = self.monthlySmsUsed!
                }
                if self.monthlyWebhookUsed != nil {
                    map["MonthlyWebhookUsed"] = self.monthlyWebhookUsed!
                }
                if self.scheduleDomainName != nil {
                    map["ScheduleDomainName"] = self.scheduleDomainName!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ChargeType"] as? String {
                    self.chargeType = value
                }
                if let value = dict["CommodityCode"] as? String {
                    self.commodityCode = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["ExpireTime"] as? String {
                    self.expireTime = value
                }
                if let value = dict["ExpireTimestamp"] as? Int64 {
                    self.expireTimestamp = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["MonitorTaskQuota"] as? Int32 {
                    self.monitorTaskQuota = value
                }
                if let value = dict["MonthlyEmailUsed"] as? Int32 {
                    self.monthlyEmailUsed = value
                }
                if let value = dict["MonthlySmsQuota"] as? Int32 {
                    self.monthlySmsQuota = value
                }
                if let value = dict["MonthlySmsUsed"] as? Int32 {
                    self.monthlySmsUsed = value
                }
                if let value = dict["MonthlyWebhookUsed"] as? Int32 {
                    self.monthlyWebhookUsed = value
                }
                if let value = dict["ScheduleDomainName"] as? String {
                    self.scheduleDomainName = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
                if let value = dict["VersionCode"] as? String {
                    self.versionCode = value
                }
            }
        }
        public var instance: [ListCloudGtmInstancesResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Instance"] as? [Any?] {
                var tmp : [ListCloudGtmInstancesResponseBody.Instances.Instance] = []
                for v in value {
                    if v != nil {
                        var model = ListCloudGtmInstancesResponseBody.Instances.Instance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instance = tmp
            }
        }
    }
    public var instances: ListCloudGtmInstancesResponseBody.Instances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instances"] as? [String: Any?] {
            var model = ListCloudGtmInstancesResponseBody.Instances()
            model.fromMap(value)
            self.instances = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class ListCloudGtmInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCloudGtmInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCloudGtmMonitorNodesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
    }
}

public class ListCloudGtmMonitorNodesResponseBody : Tea.TeaModel {
    public class Ipv4IspCityNodes : Tea.TeaModel {
        public class Ipv4IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Ip"] as? [String] {
                        self.ip = value
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var countryCode: String?

            public var countryName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public var nodeId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.countryCode != nil {
                    map["CountryCode"] = self.countryCode!
                }
                if self.countryName != nil {
                    map["CountryName"] = self.countryName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CityCode"] as? String {
                    self.cityCode = value
                }
                if let value = dict["CityName"] as? String {
                    self.cityName = value
                }
                if let value = dict["CountryCode"] as? String {
                    self.countryCode = value
                }
                if let value = dict["CountryName"] as? String {
                    self.countryName = value
                }
                if let value = dict["DefaultSelected"] as? Bool {
                    self.defaultSelected = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["GroupType"] as? String {
                    self.groupType = value
                }
                if let value = dict["Ips"] as? [String: Any?] {
                    var model = ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode.Ips()
                    model.fromMap(value)
                    self.ips = model
                }
                if let value = dict["IspCode"] as? String {
                    self.ispCode = value
                }
                if let value = dict["IspName"] as? String {
                    self.ispName = value
                }
                if let value = dict["NodeId"] as? String {
                    self.nodeId = value
                }
            }
        }
        public var ipv4IspCityNode: [ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.ipv4IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["Ipv4IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv4IspCityNode"] as? [Any?] {
                var tmp : [ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode] = []
                for v in value {
                    if v != nil {
                        var model = ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv4IspCityNode = tmp
            }
        }
    }
    public class Ipv6IspCityNodes : Tea.TeaModel {
        public class Ipv6IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Ip"] as? [String] {
                        self.ip = value
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var countryCode: String?

            public var countryName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public var nodeId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.countryCode != nil {
                    map["CountryCode"] = self.countryCode!
                }
                if self.countryName != nil {
                    map["CountryName"] = self.countryName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CityCode"] as? String {
                    self.cityCode = value
                }
                if let value = dict["CityName"] as? String {
                    self.cityName = value
                }
                if let value = dict["CountryCode"] as? String {
                    self.countryCode = value
                }
                if let value = dict["CountryName"] as? String {
                    self.countryName = value
                }
                if let value = dict["DefaultSelected"] as? Bool {
                    self.defaultSelected = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["GroupType"] as? String {
                    self.groupType = value
                }
                if let value = dict["Ips"] as? [String: Any?] {
                    var model = ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode.Ips()
                    model.fromMap(value)
                    self.ips = model
                }
                if let value = dict["IspCode"] as? String {
                    self.ispCode = value
                }
                if let value = dict["IspName"] as? String {
                    self.ispName = value
                }
                if let value = dict["NodeId"] as? String {
                    self.nodeId = value
                }
            }
        }
        public var ipv6IspCityNode: [ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.ipv6IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["Ipv6IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6IspCityNode"] as? [Any?] {
                var tmp : [ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode] = []
                for v in value {
                    if v != nil {
                        var model = ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv6IspCityNode = tmp
            }
        }
    }
    public var ipv4IspCityNodes: ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes?

    public var ipv6IspCityNodes: ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv4IspCityNodes?.validate()
        try self.ipv6IspCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv4IspCityNodes != nil {
            map["Ipv4IspCityNodes"] = self.ipv4IspCityNodes?.toMap()
        }
        if self.ipv6IspCityNodes != nil {
            map["Ipv6IspCityNodes"] = self.ipv6IspCityNodes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv4IspCityNodes"] as? [String: Any?] {
            var model = ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes()
            model.fromMap(value)
            self.ipv4IspCityNodes = model
        }
        if let value = dict["Ipv6IspCityNodes"] as? [String: Any?] {
            var model = ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes()
            model.fromMap(value)
            self.ipv6IspCityNodes = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListCloudGtmMonitorNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmMonitorNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCloudGtmMonitorNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCloudGtmMonitorTemplatesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ipVersion: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
    }
}

public class ListCloudGtmMonitorTemplatesResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public class IspCityNodes : Tea.TeaModel {
                public class IspCityNode : Tea.TeaModel {
                    public var cityCode: String?

                    public var cityName: String?

                    public var countryCode: String?

                    public var countryName: String?

                    public var groupName: String?

                    public var groupType: String?

                    public var ispCode: String?

                    public var ispName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cityCode != nil {
                            map["CityCode"] = self.cityCode!
                        }
                        if self.cityName != nil {
                            map["CityName"] = self.cityName!
                        }
                        if self.countryCode != nil {
                            map["CountryCode"] = self.countryCode!
                        }
                        if self.countryName != nil {
                            map["CountryName"] = self.countryName!
                        }
                        if self.groupName != nil {
                            map["GroupName"] = self.groupName!
                        }
                        if self.groupType != nil {
                            map["GroupType"] = self.groupType!
                        }
                        if self.ispCode != nil {
                            map["IspCode"] = self.ispCode!
                        }
                        if self.ispName != nil {
                            map["IspName"] = self.ispName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CityCode"] as? String {
                            self.cityCode = value
                        }
                        if let value = dict["CityName"] as? String {
                            self.cityName = value
                        }
                        if let value = dict["CountryCode"] as? String {
                            self.countryCode = value
                        }
                        if let value = dict["CountryName"] as? String {
                            self.countryName = value
                        }
                        if let value = dict["GroupName"] as? String {
                            self.groupName = value
                        }
                        if let value = dict["GroupType"] as? String {
                            self.groupType = value
                        }
                        if let value = dict["IspCode"] as? String {
                            self.ispCode = value
                        }
                        if let value = dict["IspName"] as? String {
                            self.ispName = value
                        }
                    }
                }
                public var ispCityNode: [ListCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes.IspCityNode]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ispCityNode != nil {
                        var tmp : [Any] = []
                        for k in self.ispCityNode! {
                            tmp.append(k.toMap())
                        }
                        map["IspCityNode"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IspCityNode"] as? [Any?] {
                        var tmp : [ListCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes.IspCityNode] = []
                        for v in value {
                            if v != nil {
                                var model = ListCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes.IspCityNode()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.ispCityNode = tmp
                    }
                }
            }
            public var createTime: String?

            public var createTimestamp: Int64?

            public var evaluationCount: Int32?

            public var extendInfo: String?

            public var failureRate: Int32?

            public var interval: Int32?

            public var ipVersion: String?

            public var ispCityNodes: ListCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes?

            public var name: String?

            public var protocol_: String?

            public var remark: String?

            public var templateId: String?

            public var timeout: Int32?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ispCityNodes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.evaluationCount != nil {
                    map["EvaluationCount"] = self.evaluationCount!
                }
                if self.extendInfo != nil {
                    map["ExtendInfo"] = self.extendInfo!
                }
                if self.failureRate != nil {
                    map["FailureRate"] = self.failureRate!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.ispCityNodes != nil {
                    map["IspCityNodes"] = self.ispCityNodes?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["EvaluationCount"] as? Int32 {
                    self.evaluationCount = value
                }
                if let value = dict["ExtendInfo"] as? String {
                    self.extendInfo = value
                }
                if let value = dict["FailureRate"] as? Int32 {
                    self.failureRate = value
                }
                if let value = dict["Interval"] as? Int32 {
                    self.interval = value
                }
                if let value = dict["IpVersion"] as? String {
                    self.ipVersion = value
                }
                if let value = dict["IspCityNodes"] as? [String: Any?] {
                    var model = ListCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes()
                    model.fromMap(value)
                    self.ispCityNodes = model
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["TemplateId"] as? String {
                    self.templateId = value
                }
                if let value = dict["Timeout"] as? Int32 {
                    self.timeout = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
            }
        }
        public var template: [ListCloudGtmMonitorTemplatesResponseBody.Templates.Template]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                var tmp : [Any] = []
                for k in self.template! {
                    tmp.append(k.toMap())
                }
                map["Template"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Template"] as? [Any?] {
                var tmp : [ListCloudGtmMonitorTemplatesResponseBody.Templates.Template] = []
                for v in value {
                    if v != nil {
                        var model = ListCloudGtmMonitorTemplatesResponseBody.Templates.Template()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.template = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var templates: ListCloudGtmMonitorTemplatesResponseBody.Templates?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templates?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templates != nil {
            map["Templates"] = self.templates?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Templates"] as? [String: Any?] {
            var model = ListCloudGtmMonitorTemplatesResponseBody.Templates()
            model.fromMap(value)
            self.templates = model
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class ListCloudGtmMonitorTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmMonitorTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCloudGtmMonitorTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRecursionRecordsRequest : Tea.TeaModel {
    public var enable: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remark: String?

    public var requestSource: String?

    public var rr: String?

    public var ttl: Int32?

    public var type: String?

    public var weight: Int32?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestSource != nil {
            map["RequestSource"] = self.requestSource!
        }
        if self.rr != nil {
            map["Rr"] = self.rr!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Enable"] as? String {
            self.enable = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["RequestSource"] as? String {
            self.requestSource = value
        }
        if let value = dict["Rr"] as? String {
            self.rr = value
        }
        if let value = dict["Ttl"] as? Int32 {
            self.ttl = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class ListRecursionRecordsResponseBody : Tea.TeaModel {
    public class Records : Tea.TeaModel {
        public class Record : Tea.TeaModel {
            public var createTime: String?

            public var createTimestamp: Int64?

            public var creator: Int64?

            public var creatorSubType: String?

            public var creatorType: String?

            public var enableStatus: String?

            public var priority: Int32?

            public var recordId: String?

            public var remark: String?

            public var requestSource: String?

            public var rr: String?

            public var ttl: Int32?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var value: String?

            public var weight: Int32?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.creatorSubType != nil {
                    map["CreatorSubType"] = self.creatorSubType!
                }
                if self.creatorType != nil {
                    map["CreatorType"] = self.creatorType!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.requestSource != nil {
                    map["RequestSource"] = self.requestSource!
                }
                if self.rr != nil {
                    map["Rr"] = self.rr!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["Creator"] as? Int64 {
                    self.creator = value
                }
                if let value = dict["CreatorSubType"] as? String {
                    self.creatorSubType = value
                }
                if let value = dict["CreatorType"] as? String {
                    self.creatorType = value
                }
                if let value = dict["EnableStatus"] as? String {
                    self.enableStatus = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["RecordId"] as? String {
                    self.recordId = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["RequestSource"] as? String {
                    self.requestSource = value
                }
                if let value = dict["Rr"] as? String {
                    self.rr = value
                }
                if let value = dict["Ttl"] as? Int32 {
                    self.ttl = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
                if let value = dict["Weight"] as? Int32 {
                    self.weight = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var record: [ListRecursionRecordsResponseBody.Records.Record]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.record != nil {
                var tmp : [Any] = []
                for k in self.record! {
                    tmp.append(k.toMap())
                }
                map["Record"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Record"] as? [Any?] {
                var tmp : [ListRecursionRecordsResponseBody.Records.Record] = []
                for v in value {
                    if v != nil {
                        var model = ListRecursionRecordsResponseBody.Records.Record()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.record = tmp
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var records: ListRecursionRecordsResponseBody.Records?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.records?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.records != nil {
            map["Records"] = self.records?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Records"] as? [String: Any?] {
            var model = ListRecursionRecordsResponseBody.Records()
            model.fromMap(value)
            self.records = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class ListRecursionRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRecursionRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRecursionRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRecursionZonesRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remark: String?

    public var zoneName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.zoneName != nil {
            map["ZoneName"] = self.zoneName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["ZoneName"] as? String {
            self.zoneName = value
        }
    }
}

public class ListRecursionZonesResponseBody : Tea.TeaModel {
    public class Zones : Tea.TeaModel {
        public class Zone : Tea.TeaModel {
            public class EffectiveScopes : Tea.TeaModel {
                public class EffectiveScope : Tea.TeaModel {
                    public class Scopes : Tea.TeaModel {
                        public var scope: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.scope != nil {
                                map["Scope"] = self.scope!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Scope"] as? [String] {
                                self.scope = value
                            }
                        }
                    }
                    public var effectiveType: String?

                    public var scopes: ListRecursionZonesResponseBody.Zones.Zone.EffectiveScopes.EffectiveScope.Scopes?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.scopes?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.effectiveType != nil {
                            map["EffectiveType"] = self.effectiveType!
                        }
                        if self.scopes != nil {
                            map["Scopes"] = self.scopes?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["EffectiveType"] as? String {
                            self.effectiveType = value
                        }
                        if let value = dict["Scopes"] as? [String: Any?] {
                            var model = ListRecursionZonesResponseBody.Zones.Zone.EffectiveScopes.EffectiveScope.Scopes()
                            model.fromMap(value)
                            self.scopes = model
                        }
                    }
                }
                public var effectiveScope: [ListRecursionZonesResponseBody.Zones.Zone.EffectiveScopes.EffectiveScope]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.effectiveScope != nil {
                        var tmp : [Any] = []
                        for k in self.effectiveScope! {
                            tmp.append(k.toMap())
                        }
                        map["EffectiveScope"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EffectiveScope"] as? [Any?] {
                        var tmp : [ListRecursionZonesResponseBody.Zones.Zone.EffectiveScopes.EffectiveScope] = []
                        for v in value {
                            if v != nil {
                                var model = ListRecursionZonesResponseBody.Zones.Zone.EffectiveScopes.EffectiveScope()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.effectiveScope = tmp
                    }
                }
            }
            public var createTime: String?

            public var createTimestamp: Int64?

            public var creator: String?

            public var creatorSubType: String?

            public var creatorType: String?

            public var effectiveScopes: ListRecursionZonesResponseBody.Zones.Zone.EffectiveScopes?

            public var proxyPattern: String?

            public var recordCount: Int32?

            public var remark: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var zoneId: String?

            public var zoneName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.effectiveScopes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.creatorSubType != nil {
                    map["CreatorSubType"] = self.creatorSubType!
                }
                if self.creatorType != nil {
                    map["CreatorType"] = self.creatorType!
                }
                if self.effectiveScopes != nil {
                    map["EffectiveScopes"] = self.effectiveScopes?.toMap()
                }
                if self.proxyPattern != nil {
                    map["ProxyPattern"] = self.proxyPattern!
                }
                if self.recordCount != nil {
                    map["RecordCount"] = self.recordCount!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                if self.zoneName != nil {
                    map["ZoneName"] = self.zoneName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["Creator"] as? String {
                    self.creator = value
                }
                if let value = dict["CreatorSubType"] as? String {
                    self.creatorSubType = value
                }
                if let value = dict["CreatorType"] as? String {
                    self.creatorType = value
                }
                if let value = dict["EffectiveScopes"] as? [String: Any?] {
                    var model = ListRecursionZonesResponseBody.Zones.Zone.EffectiveScopes()
                    model.fromMap(value)
                    self.effectiveScopes = model
                }
                if let value = dict["ProxyPattern"] as? String {
                    self.proxyPattern = value
                }
                if let value = dict["RecordCount"] as? Int32 {
                    self.recordCount = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
                if let value = dict["ZoneName"] as? String {
                    self.zoneName = value
                }
            }
        }
        public var zone: [ListRecursionZonesResponseBody.Zones.Zone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.zone != nil {
                var tmp : [Any] = []
                for k in self.zone! {
                    tmp.append(k.toMap())
                }
                map["Zone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Zone"] as? [Any?] {
                var tmp : [ListRecursionZonesResponseBody.Zones.Zone] = []
                for v in value {
                    if v != nil {
                        var model = ListRecursionZonesResponseBody.Zones.Zone()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.zone = tmp
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public var zones: ListRecursionZonesResponseBody.Zones?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.zones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        if self.zones != nil {
            map["Zones"] = self.zones?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
        if let value = dict["Zones"] as? [String: Any?] {
            var model = ListRecursionZonesResponseBody.Zones()
            model.fromMap(value)
            self.zones = model
        }
    }
}

public class ListRecursionZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRecursionZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRecursionZonesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var lang: String?

    public var nextToken: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListTagResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: [ListTagResourcesResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResources"] as? [Any?] {
            var tmp : [ListTagResourcesResponseBody.TagResources] = []
            for v in value {
                if v != nil {
                    var model = ListTagResourcesResponseBody.TagResources()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagResources = tmp
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyHichinaDomainDNSRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
    }
}

public class ModifyHichinaDomainDNSResponseBody : Tea.TeaModel {
    public class NewDnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DnsServer"] as? [String] {
                self.dnsServer = value
            }
        }
    }
    public class OriginalDnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DnsServer"] as? [String] {
                self.dnsServer = value
            }
        }
    }
    public var newDnsServers: ModifyHichinaDomainDNSResponseBody.NewDnsServers?

    public var originalDnsServers: ModifyHichinaDomainDNSResponseBody.OriginalDnsServers?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.newDnsServers?.validate()
        try self.originalDnsServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newDnsServers != nil {
            map["NewDnsServers"] = self.newDnsServers?.toMap()
        }
        if self.originalDnsServers != nil {
            map["OriginalDnsServers"] = self.originalDnsServers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NewDnsServers"] as? [String: Any?] {
            var model = ModifyHichinaDomainDNSResponseBody.NewDnsServers()
            model.fromMap(value)
            self.newDnsServers = model
        }
        if let value = dict["OriginalDnsServers"] as? [String: Any?] {
            var model = ModifyHichinaDomainDNSResponseBody.OriginalDnsServers()
            model.fromMap(value)
            self.originalDnsServers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyHichinaDomainDNSResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHichinaDomainDNSResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyHichinaDomainDNSResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MoveDomainResourceGroupRequest : Tea.TeaModel {
    public var lang: String?

    public var newResourceGroupId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["NewResourceGroupId"] as? String {
            self.newResourceGroupId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
    }
}

public class MoveDomainResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class MoveDomainResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveDomainResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MoveDomainResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MoveGtmResourceGroupRequest : Tea.TeaModel {
    public var lang: String?

    public var newResourceGroupId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["NewResourceGroupId"] as? String {
            self.newResourceGroupId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
    }
}

public class MoveGtmResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class MoveGtmResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveGtmResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MoveGtmResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class OperateBatchDomainRequest : Tea.TeaModel {
    public class DomainRecordInfo : Tea.TeaModel {
        public var domain: String?

        public var line: String?

        public var newRr: String?

        public var newType: String?

        public var newValue: String?

        public var priority: Int32?

        public var rr: String?

        public var ttl: Int32?

        public var type: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.line != nil {
                map["Line"] = self.line!
            }
            if self.newRr != nil {
                map["NewRr"] = self.newRr!
            }
            if self.newType != nil {
                map["NewType"] = self.newType!
            }
            if self.newValue != nil {
                map["NewValue"] = self.newValue!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.rr != nil {
                map["Rr"] = self.rr!
            }
            if self.ttl != nil {
                map["Ttl"] = self.ttl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Domain"] as? String {
                self.domain = value
            }
            if let value = dict["Line"] as? String {
                self.line = value
            }
            if let value = dict["NewRr"] as? String {
                self.newRr = value
            }
            if let value = dict["NewType"] as? String {
                self.newType = value
            }
            if let value = dict["NewValue"] as? String {
                self.newValue = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["Rr"] as? String {
                self.rr = value
            }
            if let value = dict["Ttl"] as? Int32 {
                self.ttl = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var domainRecordInfo: [OperateBatchDomainRequest.DomainRecordInfo]?

    public var lang: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainRecordInfo != nil {
            var tmp : [Any] = []
            for k in self.domainRecordInfo! {
                tmp.append(k.toMap())
            }
            map["DomainRecordInfo"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainRecordInfo"] as? [Any?] {
            var tmp : [OperateBatchDomainRequest.DomainRecordInfo] = []
            for v in value {
                if v != nil {
                    var model = OperateBatchDomainRequest.DomainRecordInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.domainRecordInfo = tmp
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class OperateBatchDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
    }
}

public class OperateBatchDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateBatchDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = OperateBatchDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PausePdnsServiceRequest : Tea.TeaModel {
    public var lang: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["ServiceType"] as? String {
            self.serviceType = value
        }
    }
}

public class PausePdnsServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class PausePdnsServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PausePdnsServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PausePdnsServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PreviewGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RecoveryPlanId"] as? Int64 {
            self.recoveryPlanId = value
        }
    }
}

public class PreviewGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public class Previews : Tea.TeaModel {
        public class Preview : Tea.TeaModel {
            public class SwitchInfos : Tea.TeaModel {
                public class SwitchInfo : Tea.TeaModel {
                    public var content: String?

                    public var strategyName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.strategyName != nil {
                            map["StrategyName"] = self.strategyName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Content"] as? String {
                            self.content = value
                        }
                        if let value = dict["StrategyName"] as? String {
                            self.strategyName = value
                        }
                    }
                }
                public var switchInfo: [PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos.SwitchInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.switchInfo != nil {
                        var tmp : [Any] = []
                        for k in self.switchInfo! {
                            tmp.append(k.toMap())
                        }
                        map["SwitchInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SwitchInfo"] as? [Any?] {
                        var tmp : [PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos.SwitchInfo] = []
                        for v in value {
                            if v != nil {
                                var model = PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos.SwitchInfo()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.switchInfo = tmp
                    }
                }
            }
            public var instanceId: String?

            public var name: String?

            public var switchInfos: PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos?

            public var userDomainName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.switchInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.switchInfos != nil {
                    map["SwitchInfos"] = self.switchInfos?.toMap()
                }
                if self.userDomainName != nil {
                    map["UserDomainName"] = self.userDomainName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["SwitchInfos"] as? [String: Any?] {
                    var model = PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos()
                    model.fromMap(value)
                    self.switchInfos = model
                }
                if let value = dict["UserDomainName"] as? String {
                    self.userDomainName = value
                }
            }
        }
        public var preview: [PreviewGtmRecoveryPlanResponseBody.Previews.Preview]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preview != nil {
                var tmp : [Any] = []
                for k in self.preview! {
                    tmp.append(k.toMap())
                }
                map["Preview"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Preview"] as? [Any?] {
                var tmp : [PreviewGtmRecoveryPlanResponseBody.Previews.Preview] = []
                for v in value {
                    if v != nil {
                        var model = PreviewGtmRecoveryPlanResponseBody.Previews.Preview()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.preview = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var previews: PreviewGtmRecoveryPlanResponseBody.Previews?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.previews?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.previews != nil {
            map["Previews"] = self.previews?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Previews"] as? [String: Any?] {
            var model = PreviewGtmRecoveryPlanResponseBody.Previews()
            model.fromMap(value)
            self.previews = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class PreviewGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PreviewGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PreviewGtmRecoveryPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemovePdnsAppKeyRequest : Tea.TeaModel {
    public var appKeyId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKeyId != nil {
            map["AppKeyId"] = self.appKeyId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppKeyId"] as? String {
            self.appKeyId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class RemovePdnsAppKeyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemovePdnsAppKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePdnsAppKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemovePdnsAppKeyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemovePdnsUdpIpSegmentRequest : Tea.TeaModel {
    public var ip: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ip"] as? String {
            self.ip = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class RemovePdnsUdpIpSegmentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemovePdnsUdpIpSegmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePdnsUdpIpSegmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemovePdnsUdpIpSegmentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveRspDomainServerHoldStatusForGatewayRequest : Tea.TeaModel {
    public var clientToken: String?

    public var domainName: String?

    public var statusMsg: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.statusMsg != nil {
            map["StatusMsg"] = self.statusMsg!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["StatusMsg"] as? String {
            self.statusMsg = value
        }
    }
}

public class RemoveRspDomainServerHoldStatusForGatewayResponseBody : Tea.TeaModel {
    public class AccessDeniedDetail : Tea.TeaModel {
        public var authAction: String?

        public var authPrincipalDisplayName: String?

        public var authPrincipalOwnerId: String?

        public var authPrincipalType: String?

        public var encodedDiagnosticMessage: String?

        public var noPermissionType: String?

        public var policyType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authAction != nil {
                map["AuthAction"] = self.authAction!
            }
            if self.authPrincipalDisplayName != nil {
                map["AuthPrincipalDisplayName"] = self.authPrincipalDisplayName!
            }
            if self.authPrincipalOwnerId != nil {
                map["AuthPrincipalOwnerId"] = self.authPrincipalOwnerId!
            }
            if self.authPrincipalType != nil {
                map["AuthPrincipalType"] = self.authPrincipalType!
            }
            if self.encodedDiagnosticMessage != nil {
                map["EncodedDiagnosticMessage"] = self.encodedDiagnosticMessage!
            }
            if self.noPermissionType != nil {
                map["NoPermissionType"] = self.noPermissionType!
            }
            if self.policyType != nil {
                map["PolicyType"] = self.policyType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AuthAction"] as? String {
                self.authAction = value
            }
            if let value = dict["AuthPrincipalDisplayName"] as? String {
                self.authPrincipalDisplayName = value
            }
            if let value = dict["AuthPrincipalOwnerId"] as? String {
                self.authPrincipalOwnerId = value
            }
            if let value = dict["AuthPrincipalType"] as? String {
                self.authPrincipalType = value
            }
            if let value = dict["EncodedDiagnosticMessage"] as? String {
                self.encodedDiagnosticMessage = value
            }
            if let value = dict["NoPermissionType"] as? String {
                self.noPermissionType = value
            }
            if let value = dict["PolicyType"] as? String {
                self.policyType = value
            }
        }
    }
    public class Data : Tea.TeaModel {
        public var domainName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
        }
    }
    public var accessDeniedDetail: RemoveRspDomainServerHoldStatusForGatewayResponseBody.AccessDeniedDetail?

    public var data: RemoveRspDomainServerHoldStatusForGatewayResponseBody.Data?

    public var recoverableError: Bool?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accessDeniedDetail?.validate()
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail?.toMap()
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.recoverableError != nil {
            map["RecoverableError"] = self.recoverableError!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? [String: Any?] {
            var model = RemoveRspDomainServerHoldStatusForGatewayResponseBody.AccessDeniedDetail()
            model.fromMap(value)
            self.accessDeniedDetail = model
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = RemoveRspDomainServerHoldStatusForGatewayResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RecoverableError"] as? Bool {
            self.recoverableError = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class RemoveRspDomainServerHoldStatusForGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveRspDomainServerHoldStatusForGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveRspDomainServerHoldStatusForGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReplaceCloudGtmAddressPoolAddressRequest : Tea.TeaModel {
    public class Addresses : Tea.TeaModel {
        public var addressId: String?

        public var requestSource: [String]?

        public var serialNumber: Int32?

        public var weightValue: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressId != nil {
                map["AddressId"] = self.addressId!
            }
            if self.requestSource != nil {
                map["RequestSource"] = self.requestSource!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.weightValue != nil {
                map["WeightValue"] = self.weightValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AddressId"] as? String {
                self.addressId = value
            }
            if let value = dict["RequestSource"] as? [String] {
                self.requestSource = value
            }
            if let value = dict["SerialNumber"] as? Int32 {
                self.serialNumber = value
            }
            if let value = dict["WeightValue"] as? Int32 {
                self.weightValue = value
            }
        }
    }
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var addresses: [ReplaceCloudGtmAddressPoolAddressRequest.Addresses]?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.addresses != nil {
            var tmp : [Any] = []
            for k in self.addresses! {
                tmp.append(k.toMap())
            }
            map["Addresses"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["Addresses"] as? [Any?] {
            var tmp : [ReplaceCloudGtmAddressPoolAddressRequest.Addresses] = []
            for v in value {
                if v != nil {
                    var model = ReplaceCloudGtmAddressPoolAddressRequest.Addresses()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.addresses = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class ReplaceCloudGtmAddressPoolAddressShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var addressesShrink: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.addressesShrink != nil {
            map["Addresses"] = self.addressesShrink!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["Addresses"] as? String {
            self.addressesShrink = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class ReplaceCloudGtmAddressPoolAddressResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ReplaceCloudGtmAddressPoolAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReplaceCloudGtmAddressPoolAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReplaceCloudGtmAddressPoolAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReplaceCloudGtmInstanceConfigAddressPoolRequest : Tea.TeaModel {
    public class AddressPools : Tea.TeaModel {
        public var addressPoolId: String?

        public var requestSource: [String]?

        public var serialNumber: Int32?

        public var weightValue: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressPoolId != nil {
                map["AddressPoolId"] = self.addressPoolId!
            }
            if self.requestSource != nil {
                map["RequestSource"] = self.requestSource!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.weightValue != nil {
                map["WeightValue"] = self.weightValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AddressPoolId"] as? String {
                self.addressPoolId = value
            }
            if let value = dict["RequestSource"] as? [String] {
                self.requestSource = value
            }
            if let value = dict["SerialNumber"] as? Int32 {
                self.serialNumber = value
            }
            if let value = dict["WeightValue"] as? Int32 {
                self.weightValue = value
            }
        }
    }
    public var acceptLanguage: String?

    public var addressPools: [ReplaceCloudGtmInstanceConfigAddressPoolRequest.AddressPools]?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPools != nil {
            var tmp : [Any] = []
            for k in self.addressPools! {
                tmp.append(k.toMap())
            }
            map["AddressPools"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPools"] as? [Any?] {
            var tmp : [ReplaceCloudGtmInstanceConfigAddressPoolRequest.AddressPools] = []
            for v in value {
                if v != nil {
                    var model = ReplaceCloudGtmInstanceConfigAddressPoolRequest.AddressPools()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.addressPools = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class ReplaceCloudGtmInstanceConfigAddressPoolShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolsShrink: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolsShrink != nil {
            map["AddressPools"] = self.addressPoolsShrink!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPools"] as? String {
            self.addressPoolsShrink = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class ReplaceCloudGtmInstanceConfigAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ReplaceCloudGtmInstanceConfigAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReplaceCloudGtmInstanceConfigAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReplaceCloudGtmInstanceConfigAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResumePdnsServiceRequest : Tea.TeaModel {
    public var lang: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["ServiceType"] as? String {
            self.serviceType = value
        }
    }
}

public class ResumePdnsServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ResumePdnsServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumePdnsServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResumePdnsServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RetrieveDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class RetrieveDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RetrieveDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetrieveDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RetrieveDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RollbackGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["RecoveryPlanId"] as? Int64 {
            self.recoveryPlanId = value
        }
    }
}

public class RollbackGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RollbackGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RollbackGtmRecoveryPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SearchCloudGtmAddressPoolsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolName: String?

    public var addressPoolType: String?

    public var availableStatus: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var healthStatus: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolName != nil {
            map["AddressPoolName"] = self.addressPoolName!
        }
        if self.addressPoolType != nil {
            map["AddressPoolType"] = self.addressPoolType!
        }
        if self.availableStatus != nil {
            map["AvailableStatus"] = self.availableStatus!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPoolName"] as? String {
            self.addressPoolName = value
        }
        if let value = dict["AddressPoolType"] as? String {
            self.addressPoolType = value
        }
        if let value = dict["AvailableStatus"] as? String {
            self.availableStatus = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["HealthStatus"] as? String {
            self.healthStatus = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class SearchCloudGtmAddressPoolsResponseBody : Tea.TeaModel {
    public class AddressPools : Tea.TeaModel {
        public class AddressPool : Tea.TeaModel {
            public class Addresses : Tea.TeaModel {
                public class Address : Tea.TeaModel {
                    public class HealthTasks : Tea.TeaModel {
                        public class HealthTask : Tea.TeaModel {
                            public var port: Int32?

                            public var templateId: String?

                            public var templateName: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.port != nil {
                                    map["Port"] = self.port!
                                }
                                if self.templateId != nil {
                                    map["TemplateId"] = self.templateId!
                                }
                                if self.templateName != nil {
                                    map["TemplateName"] = self.templateName!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Port"] as? Int32 {
                                    self.port = value
                                }
                                if let value = dict["TemplateId"] as? String {
                                    self.templateId = value
                                }
                                if let value = dict["TemplateName"] as? String {
                                    self.templateName = value
                                }
                            }
                        }
                        public var healthTask: [SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks.HealthTask]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.healthTask != nil {
                                var tmp : [Any] = []
                                for k in self.healthTask! {
                                    tmp.append(k.toMap())
                                }
                                map["HealthTask"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["HealthTask"] as? [Any?] {
                                var tmp : [SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks.HealthTask] = []
                                for v in value {
                                    if v != nil {
                                        var model = SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks.HealthTask()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.healthTask = tmp
                            }
                        }
                    }
                    public var address: String?

                    public var addressId: String?

                    public var attributeInfo: String?

                    public var availableMode: String?

                    public var availableStatus: String?

                    public var createTime: String?

                    public var createTimestamp: Int64?

                    public var enableStatus: String?

                    public var healthJudgement: String?

                    public var healthStatus: String?

                    public var healthTasks: SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks?

                    public var manualAvailableStatus: String?

                    public var name: String?

                    public var remark: String?

                    public var requestSource: String?

                    public var serialNumber: Int32?

                    public var type: String?

                    public var updateTime: String?

                    public var updateTimestamp: Int64?

                    public var weightValue: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.healthTasks?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.addressId != nil {
                            map["AddressId"] = self.addressId!
                        }
                        if self.attributeInfo != nil {
                            map["AttributeInfo"] = self.attributeInfo!
                        }
                        if self.availableMode != nil {
                            map["AvailableMode"] = self.availableMode!
                        }
                        if self.availableStatus != nil {
                            map["AvailableStatus"] = self.availableStatus!
                        }
                        if self.createTime != nil {
                            map["CreateTime"] = self.createTime!
                        }
                        if self.createTimestamp != nil {
                            map["CreateTimestamp"] = self.createTimestamp!
                        }
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.healthJudgement != nil {
                            map["HealthJudgement"] = self.healthJudgement!
                        }
                        if self.healthStatus != nil {
                            map["HealthStatus"] = self.healthStatus!
                        }
                        if self.healthTasks != nil {
                            map["HealthTasks"] = self.healthTasks?.toMap()
                        }
                        if self.manualAvailableStatus != nil {
                            map["ManualAvailableStatus"] = self.manualAvailableStatus!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.remark != nil {
                            map["Remark"] = self.remark!
                        }
                        if self.requestSource != nil {
                            map["RequestSource"] = self.requestSource!
                        }
                        if self.serialNumber != nil {
                            map["SerialNumber"] = self.serialNumber!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        if self.updateTimestamp != nil {
                            map["UpdateTimestamp"] = self.updateTimestamp!
                        }
                        if self.weightValue != nil {
                            map["WeightValue"] = self.weightValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Address"] as? String {
                            self.address = value
                        }
                        if let value = dict["AddressId"] as? String {
                            self.addressId = value
                        }
                        if let value = dict["AttributeInfo"] as? String {
                            self.attributeInfo = value
                        }
                        if let value = dict["AvailableMode"] as? String {
                            self.availableMode = value
                        }
                        if let value = dict["AvailableStatus"] as? String {
                            self.availableStatus = value
                        }
                        if let value = dict["CreateTime"] as? String {
                            self.createTime = value
                        }
                        if let value = dict["CreateTimestamp"] as? Int64 {
                            self.createTimestamp = value
                        }
                        if let value = dict["EnableStatus"] as? String {
                            self.enableStatus = value
                        }
                        if let value = dict["HealthJudgement"] as? String {
                            self.healthJudgement = value
                        }
                        if let value = dict["HealthStatus"] as? String {
                            self.healthStatus = value
                        }
                        if let value = dict["HealthTasks"] as? [String: Any?] {
                            var model = SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks()
                            model.fromMap(value)
                            self.healthTasks = model
                        }
                        if let value = dict["ManualAvailableStatus"] as? String {
                            self.manualAvailableStatus = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Remark"] as? String {
                            self.remark = value
                        }
                        if let value = dict["RequestSource"] as? String {
                            self.requestSource = value
                        }
                        if let value = dict["SerialNumber"] as? Int32 {
                            self.serialNumber = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                        if let value = dict["UpdateTime"] as? String {
                            self.updateTime = value
                        }
                        if let value = dict["UpdateTimestamp"] as? Int64 {
                            self.updateTimestamp = value
                        }
                        if let value = dict["WeightValue"] as? Int32 {
                            self.weightValue = value
                        }
                    }
                }
                public var address: [SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.address != nil {
                        var tmp : [Any] = []
                        for k in self.address! {
                            tmp.append(k.toMap())
                        }
                        map["Address"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Address"] as? [Any?] {
                        var tmp : [SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address] = []
                        for v in value {
                            if v != nil {
                                var model = SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.address = tmp
                    }
                }
            }
            public var addressLbStrategy: String?

            public var addressPoolId: String?

            public var addressPoolName: String?

            public var addressPoolType: String?

            public var addresses: SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses?

            public var availableStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var remark: String?

            public var sequenceLbStrategyMode: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addresses?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressLbStrategy != nil {
                    map["AddressLbStrategy"] = self.addressLbStrategy!
                }
                if self.addressPoolId != nil {
                    map["AddressPoolId"] = self.addressPoolId!
                }
                if self.addressPoolName != nil {
                    map["AddressPoolName"] = self.addressPoolName!
                }
                if self.addressPoolType != nil {
                    map["AddressPoolType"] = self.addressPoolType!
                }
                if self.addresses != nil {
                    map["Addresses"] = self.addresses?.toMap()
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddressLbStrategy"] as? String {
                    self.addressLbStrategy = value
                }
                if let value = dict["AddressPoolId"] as? String {
                    self.addressPoolId = value
                }
                if let value = dict["AddressPoolName"] as? String {
                    self.addressPoolName = value
                }
                if let value = dict["AddressPoolType"] as? String {
                    self.addressPoolType = value
                }
                if let value = dict["Addresses"] as? [String: Any?] {
                    var model = SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses()
                    model.fromMap(value)
                    self.addresses = model
                }
                if let value = dict["AvailableStatus"] as? String {
                    self.availableStatus = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["EnableStatus"] as? String {
                    self.enableStatus = value
                }
                if let value = dict["HealthJudgement"] as? String {
                    self.healthJudgement = value
                }
                if let value = dict["HealthStatus"] as? String {
                    self.healthStatus = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["SequenceLbStrategyMode"] as? String {
                    self.sequenceLbStrategyMode = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
            }
        }
        public var addressPool: [SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressPool != nil {
                var tmp : [Any] = []
                for k in self.addressPool! {
                    tmp.append(k.toMap())
                }
                map["AddressPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AddressPool"] as? [Any?] {
                var tmp : [SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool] = []
                for v in value {
                    if v != nil {
                        var model = SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.addressPool = tmp
            }
        }
    }
    public var addressPools: SearchCloudGtmAddressPoolsResponseBody.AddressPools?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addressPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPools != nil {
            map["AddressPools"] = self.addressPools?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressPools"] as? [String: Any?] {
            var model = SearchCloudGtmAddressPoolsResponseBody.AddressPools()
            model.fromMap(value)
            self.addressPools = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class SearchCloudGtmAddressPoolsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchCloudGtmAddressPoolsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SearchCloudGtmAddressPoolsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SearchCloudGtmAddressesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var addressId: String?

    public var availableStatus: String?

    public var enableStatus: String?

    public var healthStatus: String?

    public var monitorTemplateName: String?

    public var nameSearchCondition: String?

    public var names: [String]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remarkSearchCondition: String?

    public var remarks: [String]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.availableStatus != nil {
            map["AvailableStatus"] = self.availableStatus!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.monitorTemplateName != nil {
            map["MonitorTemplateName"] = self.monitorTemplateName!
        }
        if self.nameSearchCondition != nil {
            map["NameSearchCondition"] = self.nameSearchCondition!
        }
        if self.names != nil {
            map["Names"] = self.names!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remarkSearchCondition != nil {
            map["RemarkSearchCondition"] = self.remarkSearchCondition!
        }
        if self.remarks != nil {
            map["Remarks"] = self.remarks!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["Address"] as? String {
            self.address = value
        }
        if let value = dict["AddressId"] as? String {
            self.addressId = value
        }
        if let value = dict["AvailableStatus"] as? String {
            self.availableStatus = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["HealthStatus"] as? String {
            self.healthStatus = value
        }
        if let value = dict["MonitorTemplateName"] as? String {
            self.monitorTemplateName = value
        }
        if let value = dict["NameSearchCondition"] as? String {
            self.nameSearchCondition = value
        }
        if let value = dict["Names"] as? [String] {
            self.names = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RemarkSearchCondition"] as? String {
            self.remarkSearchCondition = value
        }
        if let value = dict["Remarks"] as? [String] {
            self.remarks = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class SearchCloudGtmAddressesResponseBody : Tea.TeaModel {
    public class Addresses : Tea.TeaModel {
        public class Address : Tea.TeaModel {
            public class HealthTasks : Tea.TeaModel {
                public class HealthTask : Tea.TeaModel {
                    public var monitorStatus: String?

                    public var port: Int32?

                    public var templateId: String?

                    public var templateName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.monitorStatus != nil {
                            map["MonitorStatus"] = self.monitorStatus!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        if self.templateName != nil {
                            map["TemplateName"] = self.templateName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["MonitorStatus"] as? String {
                            self.monitorStatus = value
                        }
                        if let value = dict["Port"] as? Int32 {
                            self.port = value
                        }
                        if let value = dict["TemplateId"] as? String {
                            self.templateId = value
                        }
                        if let value = dict["TemplateName"] as? String {
                            self.templateName = value
                        }
                    }
                }
                public var healthTask: [SearchCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks.HealthTask]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.healthTask != nil {
                        var tmp : [Any] = []
                        for k in self.healthTask! {
                            tmp.append(k.toMap())
                        }
                        map["HealthTask"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["HealthTask"] as? [Any?] {
                        var tmp : [SearchCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks.HealthTask] = []
                        for v in value {
                            if v != nil {
                                var model = SearchCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks.HealthTask()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.healthTask = tmp
                    }
                }
            }
            public var address: String?

            public var addressId: String?

            public var attributeInfo: String?

            public var availableMode: String?

            public var availableStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var healthTasks: SearchCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks?

            public var manualAvailableStatus: String?

            public var name: String?

            public var remark: String?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.healthTasks?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.addressId != nil {
                    map["AddressId"] = self.addressId!
                }
                if self.attributeInfo != nil {
                    map["AttributeInfo"] = self.attributeInfo!
                }
                if self.availableMode != nil {
                    map["AvailableMode"] = self.availableMode!
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.healthTasks != nil {
                    map["HealthTasks"] = self.healthTasks?.toMap()
                }
                if self.manualAvailableStatus != nil {
                    map["ManualAvailableStatus"] = self.manualAvailableStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Address"] as? String {
                    self.address = value
                }
                if let value = dict["AddressId"] as? String {
                    self.addressId = value
                }
                if let value = dict["AttributeInfo"] as? String {
                    self.attributeInfo = value
                }
                if let value = dict["AvailableMode"] as? String {
                    self.availableMode = value
                }
                if let value = dict["AvailableStatus"] as? String {
                    self.availableStatus = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["EnableStatus"] as? String {
                    self.enableStatus = value
                }
                if let value = dict["HealthJudgement"] as? String {
                    self.healthJudgement = value
                }
                if let value = dict["HealthStatus"] as? String {
                    self.healthStatus = value
                }
                if let value = dict["HealthTasks"] as? [String: Any?] {
                    var model = SearchCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks()
                    model.fromMap(value)
                    self.healthTasks = model
                }
                if let value = dict["ManualAvailableStatus"] as? String {
                    self.manualAvailableStatus = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
            }
        }
        public var address: [SearchCloudGtmAddressesResponseBody.Addresses.Address]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                var tmp : [Any] = []
                for k in self.address! {
                    tmp.append(k.toMap())
                }
                map["Address"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Address"] as? [Any?] {
                var tmp : [SearchCloudGtmAddressesResponseBody.Addresses.Address] = []
                for v in value {
                    if v != nil {
                        var model = SearchCloudGtmAddressesResponseBody.Addresses.Address()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.address = tmp
            }
        }
    }
    public var addresses: SearchCloudGtmAddressesResponseBody.Addresses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addresses != nil {
            map["Addresses"] = self.addresses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Addresses"] as? [String: Any?] {
            var model = SearchCloudGtmAddressesResponseBody.Addresses()
            model.fromMap(value)
            self.addresses = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class SearchCloudGtmAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchCloudGtmAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SearchCloudGtmAddressesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SearchCloudGtmInstanceConfigsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var availableStatus: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var healthStatus: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remark: String?

    public var scheduleDomainName: String?

    public var scheduleZoneName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.availableStatus != nil {
            map["AvailableStatus"] = self.availableStatus!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.scheduleDomainName != nil {
            map["ScheduleDomainName"] = self.scheduleDomainName!
        }
        if self.scheduleZoneName != nil {
            map["ScheduleZoneName"] = self.scheduleZoneName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AvailableStatus"] as? String {
            self.availableStatus = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["HealthStatus"] as? String {
            self.healthStatus = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["ScheduleDomainName"] as? String {
            self.scheduleDomainName = value
        }
        if let value = dict["ScheduleZoneName"] as? String {
            self.scheduleZoneName = value
        }
    }
}

public class SearchCloudGtmInstanceConfigsResponseBody : Tea.TeaModel {
    public class InstanceConfigs : Tea.TeaModel {
        public class InstanceConfig : Tea.TeaModel {
            public class AddressPools : Tea.TeaModel {
                public class AddressPool : Tea.TeaModel {
                    public class RequestSource : Tea.TeaModel {
                        public var requestSource: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.requestSource != nil {
                                map["RequestSource"] = self.requestSource!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["RequestSource"] as? [String] {
                                self.requestSource = value
                            }
                        }
                    }
                    public var addressLbStrategy: String?

                    public var addressPoolId: String?

                    public var addressPoolName: String?

                    public var addressPoolType: String?

                    public var availableStatus: String?

                    public var createTime: String?

                    public var createTimestamp: Int64?

                    public var enableStatus: String?

                    public var healthJudgement: String?

                    public var healthStatus: String?

                    public var requestSource: SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool.RequestSource?

                    public var seqNonPreemptiveSchedule: Bool?

                    public var sequenceLbStrategyMode: String?

                    public var serialNumber: Int32?

                    public var updateTime: String?

                    public var updateTimestamp: Int64?

                    public var weightValue: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.requestSource?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.addressLbStrategy != nil {
                            map["AddressLbStrategy"] = self.addressLbStrategy!
                        }
                        if self.addressPoolId != nil {
                            map["AddressPoolId"] = self.addressPoolId!
                        }
                        if self.addressPoolName != nil {
                            map["AddressPoolName"] = self.addressPoolName!
                        }
                        if self.addressPoolType != nil {
                            map["AddressPoolType"] = self.addressPoolType!
                        }
                        if self.availableStatus != nil {
                            map["AvailableStatus"] = self.availableStatus!
                        }
                        if self.createTime != nil {
                            map["CreateTime"] = self.createTime!
                        }
                        if self.createTimestamp != nil {
                            map["CreateTimestamp"] = self.createTimestamp!
                        }
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.healthJudgement != nil {
                            map["HealthJudgement"] = self.healthJudgement!
                        }
                        if self.healthStatus != nil {
                            map["HealthStatus"] = self.healthStatus!
                        }
                        if self.requestSource != nil {
                            map["RequestSource"] = self.requestSource?.toMap()
                        }
                        if self.seqNonPreemptiveSchedule != nil {
                            map["SeqNonPreemptiveSchedule"] = self.seqNonPreemptiveSchedule!
                        }
                        if self.sequenceLbStrategyMode != nil {
                            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                        }
                        if self.serialNumber != nil {
                            map["SerialNumber"] = self.serialNumber!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        if self.updateTimestamp != nil {
                            map["UpdateTimestamp"] = self.updateTimestamp!
                        }
                        if self.weightValue != nil {
                            map["WeightValue"] = self.weightValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AddressLbStrategy"] as? String {
                            self.addressLbStrategy = value
                        }
                        if let value = dict["AddressPoolId"] as? String {
                            self.addressPoolId = value
                        }
                        if let value = dict["AddressPoolName"] as? String {
                            self.addressPoolName = value
                        }
                        if let value = dict["AddressPoolType"] as? String {
                            self.addressPoolType = value
                        }
                        if let value = dict["AvailableStatus"] as? String {
                            self.availableStatus = value
                        }
                        if let value = dict["CreateTime"] as? String {
                            self.createTime = value
                        }
                        if let value = dict["CreateTimestamp"] as? Int64 {
                            self.createTimestamp = value
                        }
                        if let value = dict["EnableStatus"] as? String {
                            self.enableStatus = value
                        }
                        if let value = dict["HealthJudgement"] as? String {
                            self.healthJudgement = value
                        }
                        if let value = dict["HealthStatus"] as? String {
                            self.healthStatus = value
                        }
                        if let value = dict["RequestSource"] as? [String: Any?] {
                            var model = SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool.RequestSource()
                            model.fromMap(value)
                            self.requestSource = model
                        }
                        if let value = dict["SeqNonPreemptiveSchedule"] as? Bool {
                            self.seqNonPreemptiveSchedule = value
                        }
                        if let value = dict["SequenceLbStrategyMode"] as? String {
                            self.sequenceLbStrategyMode = value
                        }
                        if let value = dict["SerialNumber"] as? Int32 {
                            self.serialNumber = value
                        }
                        if let value = dict["UpdateTime"] as? String {
                            self.updateTime = value
                        }
                        if let value = dict["UpdateTimestamp"] as? Int64 {
                            self.updateTimestamp = value
                        }
                        if let value = dict["WeightValue"] as? Int32 {
                            self.weightValue = value
                        }
                    }
                }
                public var addressPool: [SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.addressPool != nil {
                        var tmp : [Any] = []
                        for k in self.addressPool! {
                            tmp.append(k.toMap())
                        }
                        map["AddressPool"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AddressPool"] as? [Any?] {
                        var tmp : [SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool] = []
                        for v in value {
                            if v != nil {
                                var model = SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.addressPool = tmp
                    }
                }
            }
            public var addressPoolLbStrategy: String?

            public var addressPools: SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools?

            public var availableStatus: String?

            public var commodityCode: String?

            public var configId: String?

            public var configLoggingSwitchStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthStatus: String?

            public var instanceId: String?

            public var remark: String?

            public var scheduleDomainName: String?

            public var scheduleHostname: String?

            public var scheduleRrType: String?

            public var scheduleZoneMode: String?

            public var scheduleZoneName: String?

            public var sequenceLbStrategyMode: String?

            public var ttl: Int32?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addressPools?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressPoolLbStrategy != nil {
                    map["AddressPoolLbStrategy"] = self.addressPoolLbStrategy!
                }
                if self.addressPools != nil {
                    map["AddressPools"] = self.addressPools?.toMap()
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.configId != nil {
                    map["ConfigId"] = self.configId!
                }
                if self.configLoggingSwitchStatus != nil {
                    map["ConfigLoggingSwitchStatus"] = self.configLoggingSwitchStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.scheduleDomainName != nil {
                    map["ScheduleDomainName"] = self.scheduleDomainName!
                }
                if self.scheduleHostname != nil {
                    map["ScheduleHostname"] = self.scheduleHostname!
                }
                if self.scheduleRrType != nil {
                    map["ScheduleRrType"] = self.scheduleRrType!
                }
                if self.scheduleZoneMode != nil {
                    map["ScheduleZoneMode"] = self.scheduleZoneMode!
                }
                if self.scheduleZoneName != nil {
                    map["ScheduleZoneName"] = self.scheduleZoneName!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddressPoolLbStrategy"] as? String {
                    self.addressPoolLbStrategy = value
                }
                if let value = dict["AddressPools"] as? [String: Any?] {
                    var model = SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools()
                    model.fromMap(value)
                    self.addressPools = model
                }
                if let value = dict["AvailableStatus"] as? String {
                    self.availableStatus = value
                }
                if let value = dict["CommodityCode"] as? String {
                    self.commodityCode = value
                }
                if let value = dict["ConfigId"] as? String {
                    self.configId = value
                }
                if let value = dict["ConfigLoggingSwitchStatus"] as? String {
                    self.configLoggingSwitchStatus = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["EnableStatus"] as? String {
                    self.enableStatus = value
                }
                if let value = dict["HealthStatus"] as? String {
                    self.healthStatus = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["ScheduleDomainName"] as? String {
                    self.scheduleDomainName = value
                }
                if let value = dict["ScheduleHostname"] as? String {
                    self.scheduleHostname = value
                }
                if let value = dict["ScheduleRrType"] as? String {
                    self.scheduleRrType = value
                }
                if let value = dict["ScheduleZoneMode"] as? String {
                    self.scheduleZoneMode = value
                }
                if let value = dict["ScheduleZoneName"] as? String {
                    self.scheduleZoneName = value
                }
                if let value = dict["SequenceLbStrategyMode"] as? String {
                    self.sequenceLbStrategyMode = value
                }
                if let value = dict["Ttl"] as? Int32 {
                    self.ttl = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
                if let value = dict["VersionCode"] as? String {
                    self.versionCode = value
                }
            }
        }
        public var instanceConfig: [SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceConfig != nil {
                var tmp : [Any] = []
                for k in self.instanceConfig! {
                    tmp.append(k.toMap())
                }
                map["InstanceConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceConfig"] as? [Any?] {
                var tmp : [SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig] = []
                for v in value {
                    if v != nil {
                        var model = SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceConfig = tmp
            }
        }
    }
    public var instanceConfigs: SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceConfigs != nil {
            map["InstanceConfigs"] = self.instanceConfigs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceConfigs"] as? [String: Any?] {
            var model = SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs()
            model.fromMap(value)
            self.instanceConfigs = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class SearchCloudGtmInstanceConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchCloudGtmInstanceConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SearchCloudGtmInstanceConfigsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SearchCloudGtmInstancesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var chargeType: String?

    public var clientToken: String?

    public var instanceId: String?

    public var instanceName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ChargeType"] as? String {
            self.chargeType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class SearchCloudGtmInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public var chargeType: String?

            public var commodityCode: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var expireTime: Int64?

            public var expireTimestamp: String?

            public var instanceId: String?

            public var instanceName: String?

            public var monitorTaskQuota: Int32?

            public var monthlyEmailUsed: Int32?

            public var monthlySmsQuota: Int32?

            public var monthlySmsUsed: Int32?

            public var monthlyWebhookUsed: Int32?

            public var scheduleDomainName: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.expireTimestamp != nil {
                    map["ExpireTimestamp"] = self.expireTimestamp!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.monitorTaskQuota != nil {
                    map["MonitorTaskQuota"] = self.monitorTaskQuota!
                }
                if self.monthlyEmailUsed != nil {
                    map["MonthlyEmailUsed"] = self.monthlyEmailUsed!
                }
                if self.monthlySmsQuota != nil {
                    map["MonthlySmsQuota"] = self.monthlySmsQuota!
                }
                if self.monthlySmsUsed != nil {
                    map["MonthlySmsUsed"] = self.monthlySmsUsed!
                }
                if self.monthlyWebhookUsed != nil {
                    map["MonthlyWebhookUsed"] = self.monthlyWebhookUsed!
                }
                if self.scheduleDomainName != nil {
                    map["ScheduleDomainName"] = self.scheduleDomainName!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ChargeType"] as? String {
                    self.chargeType = value
                }
                if let value = dict["CommodityCode"] as? String {
                    self.commodityCode = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["ExpireTime"] as? Int64 {
                    self.expireTime = value
                }
                if let value = dict["ExpireTimestamp"] as? String {
                    self.expireTimestamp = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["MonitorTaskQuota"] as? Int32 {
                    self.monitorTaskQuota = value
                }
                if let value = dict["MonthlyEmailUsed"] as? Int32 {
                    self.monthlyEmailUsed = value
                }
                if let value = dict["MonthlySmsQuota"] as? Int32 {
                    self.monthlySmsQuota = value
                }
                if let value = dict["MonthlySmsUsed"] as? Int32 {
                    self.monthlySmsUsed = value
                }
                if let value = dict["MonthlyWebhookUsed"] as? Int32 {
                    self.monthlyWebhookUsed = value
                }
                if let value = dict["ScheduleDomainName"] as? String {
                    self.scheduleDomainName = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
                if let value = dict["VersionCode"] as? String {
                    self.versionCode = value
                }
            }
        }
        public var instance: [SearchCloudGtmInstancesResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Instance"] as? [Any?] {
                var tmp : [SearchCloudGtmInstancesResponseBody.Instances.Instance] = []
                for v in value {
                    if v != nil {
                        var model = SearchCloudGtmInstancesResponseBody.Instances.Instance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instance = tmp
            }
        }
    }
    public var instances: SearchCloudGtmInstancesResponseBody.Instances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instances"] as? [String: Any?] {
            var model = SearchCloudGtmInstancesResponseBody.Instances()
            model.fromMap(value)
            self.instances = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class SearchCloudGtmInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchCloudGtmInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SearchCloudGtmInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SearchCloudGtmMonitorTemplatesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ipVersion: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["IpVersion"] as? String {
            self.ipVersion = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
    }
}

public class SearchCloudGtmMonitorTemplatesResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public class IspCityNodes : Tea.TeaModel {
                public class IspCityNode : Tea.TeaModel {
                    public var cityCode: String?

                    public var cityName: String?

                    public var countryCode: String?

                    public var countryName: String?

                    public var groupName: String?

                    public var groupType: String?

                    public var ispCode: String?

                    public var ispName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cityCode != nil {
                            map["CityCode"] = self.cityCode!
                        }
                        if self.cityName != nil {
                            map["CityName"] = self.cityName!
                        }
                        if self.countryCode != nil {
                            map["CountryCode"] = self.countryCode!
                        }
                        if self.countryName != nil {
                            map["CountryName"] = self.countryName!
                        }
                        if self.groupName != nil {
                            map["GroupName"] = self.groupName!
                        }
                        if self.groupType != nil {
                            map["GroupType"] = self.groupType!
                        }
                        if self.ispCode != nil {
                            map["IspCode"] = self.ispCode!
                        }
                        if self.ispName != nil {
                            map["IspName"] = self.ispName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CityCode"] as? String {
                            self.cityCode = value
                        }
                        if let value = dict["CityName"] as? String {
                            self.cityName = value
                        }
                        if let value = dict["CountryCode"] as? String {
                            self.countryCode = value
                        }
                        if let value = dict["CountryName"] as? String {
                            self.countryName = value
                        }
                        if let value = dict["GroupName"] as? String {
                            self.groupName = value
                        }
                        if let value = dict["GroupType"] as? String {
                            self.groupType = value
                        }
                        if let value = dict["IspCode"] as? String {
                            self.ispCode = value
                        }
                        if let value = dict["IspName"] as? String {
                            self.ispName = value
                        }
                    }
                }
                public var ispCityNode: [SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes.IspCityNode]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ispCityNode != nil {
                        var tmp : [Any] = []
                        for k in self.ispCityNode! {
                            tmp.append(k.toMap())
                        }
                        map["IspCityNode"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IspCityNode"] as? [Any?] {
                        var tmp : [SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes.IspCityNode] = []
                        for v in value {
                            if v != nil {
                                var model = SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes.IspCityNode()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.ispCityNode = tmp
                    }
                }
            }
            public var createTime: String?

            public var createTimestamp: Int64?

            public var evaluationCount: Int32?

            public var extendInfo: String?

            public var failureRate: Int32?

            public var interval: Int32?

            public var ipVersion: String?

            public var ispCityNodes: SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes?

            public var name: String?

            public var protocol_: String?

            public var remark: String?

            public var templateId: String?

            public var timeout: Int32?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ispCityNodes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.evaluationCount != nil {
                    map["EvaluationCount"] = self.evaluationCount!
                }
                if self.extendInfo != nil {
                    map["ExtendInfo"] = self.extendInfo!
                }
                if self.failureRate != nil {
                    map["FailureRate"] = self.failureRate!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.ispCityNodes != nil {
                    map["IspCityNodes"] = self.ispCityNodes?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["EvaluationCount"] as? Int32 {
                    self.evaluationCount = value
                }
                if let value = dict["ExtendInfo"] as? String {
                    self.extendInfo = value
                }
                if let value = dict["FailureRate"] as? Int32 {
                    self.failureRate = value
                }
                if let value = dict["Interval"] as? Int32 {
                    self.interval = value
                }
                if let value = dict["IpVersion"] as? String {
                    self.ipVersion = value
                }
                if let value = dict["IspCityNodes"] as? [String: Any?] {
                    var model = SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes()
                    model.fromMap(value)
                    self.ispCityNodes = model
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["TemplateId"] as? String {
                    self.templateId = value
                }
                if let value = dict["Timeout"] as? Int32 {
                    self.timeout = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
            }
        }
        public var template: [SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                var tmp : [Any] = []
                for k in self.template! {
                    tmp.append(k.toMap())
                }
                map["Template"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Template"] as? [Any?] {
                var tmp : [SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template] = []
                for v in value {
                    if v != nil {
                        var model = SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.template = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var templates: SearchCloudGtmMonitorTemplatesResponseBody.Templates?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templates?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templates != nil {
            map["Templates"] = self.templates?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Templates"] as? [String: Any?] {
            var model = SearchCloudGtmMonitorTemplatesResponseBody.Templates()
            model.fromMap(value)
            self.templates = model
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class SearchCloudGtmMonitorTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchCloudGtmMonitorTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SearchCloudGtmMonitorTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SearchRecursionRecordsRequest : Tea.TeaModel {
    public var direction: String?

    public var enableStatus: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remark: String?

    public var requestSource: String?

    public var rr: String?

    public var ttl: Int32?

    public var type: String?

    public var value: String?

    public var weight: Int32?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestSource != nil {
            map["RequestSource"] = self.requestSource!
        }
        if self.rr != nil {
            map["Rr"] = self.rr!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["RequestSource"] as? String {
            self.requestSource = value
        }
        if let value = dict["Rr"] as? String {
            self.rr = value
        }
        if let value = dict["Ttl"] as? Int32 {
            self.ttl = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["Value"] as? String {
            self.value = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class SearchRecursionRecordsResponseBody : Tea.TeaModel {
    public class Records : Tea.TeaModel {
        public class Record : Tea.TeaModel {
            public var createTime: String?

            public var createTimestamp: Int64?

            public var creator: Int64?

            public var creatorSubType: String?

            public var creatorType: String?

            public var enableStatus: String?

            public var priority: Int32?

            public var recordId: String?

            public var remark: String?

            public var requestSource: String?

            public var rr: String?

            public var ttl: Int32?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var value: String?

            public var weight: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.creatorSubType != nil {
                    map["CreatorSubType"] = self.creatorSubType!
                }
                if self.creatorType != nil {
                    map["CreatorType"] = self.creatorType!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.requestSource != nil {
                    map["RequestSource"] = self.requestSource!
                }
                if self.rr != nil {
                    map["Rr"] = self.rr!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["Creator"] as? Int64 {
                    self.creator = value
                }
                if let value = dict["CreatorSubType"] as? String {
                    self.creatorSubType = value
                }
                if let value = dict["CreatorType"] as? String {
                    self.creatorType = value
                }
                if let value = dict["EnableStatus"] as? String {
                    self.enableStatus = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["RecordId"] as? String {
                    self.recordId = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["RequestSource"] as? String {
                    self.requestSource = value
                }
                if let value = dict["Rr"] as? String {
                    self.rr = value
                }
                if let value = dict["Ttl"] as? Int32 {
                    self.ttl = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
                if let value = dict["Weight"] as? String {
                    self.weight = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var record: [SearchRecursionRecordsResponseBody.Records.Record]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.record != nil {
                var tmp : [Any] = []
                for k in self.record! {
                    tmp.append(k.toMap())
                }
                map["Record"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Record"] as? [Any?] {
                var tmp : [SearchRecursionRecordsResponseBody.Records.Record] = []
                for v in value {
                    if v != nil {
                        var model = SearchRecursionRecordsResponseBody.Records.Record()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.record = tmp
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var records: SearchRecursionRecordsResponseBody.Records?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.records?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.records != nil {
            map["Records"] = self.records?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Records"] as? [String: Any?] {
            var model = SearchRecursionRecordsResponseBody.Records()
            model.fromMap(value)
            self.records = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
    }
}

public class SearchRecursionRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchRecursionRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SearchRecursionRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SearchRecursionZonesRequest : Tea.TeaModel {
    public class EffectiveScopes : Tea.TeaModel {
        public var effectiveType: String?

        public var scope: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.effectiveType != nil {
                map["EffectiveType"] = self.effectiveType!
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EffectiveType"] as? String {
                self.effectiveType = value
            }
            if let value = dict["Scope"] as? [String] {
                self.scope = value
            }
        }
    }
    public var direction: String?

    public var effectiveScopes: [SearchRecursionZonesRequest.EffectiveScopes]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remark: String?

    public var zoneName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.effectiveScopes != nil {
            var tmp : [Any] = []
            for k in self.effectiveScopes! {
                tmp.append(k.toMap())
            }
            map["EffectiveScopes"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.zoneName != nil {
            map["ZoneName"] = self.zoneName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["EffectiveScopes"] as? [Any?] {
            var tmp : [SearchRecursionZonesRequest.EffectiveScopes] = []
            for v in value {
                if v != nil {
                    var model = SearchRecursionZonesRequest.EffectiveScopes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.effectiveScopes = tmp
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["ZoneName"] as? String {
            self.zoneName = value
        }
    }
}

public class SearchRecursionZonesShrinkRequest : Tea.TeaModel {
    public var direction: String?

    public var effectiveScopesShrink: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remark: String?

    public var zoneName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.effectiveScopesShrink != nil {
            map["EffectiveScopes"] = self.effectiveScopesShrink!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.zoneName != nil {
            map["ZoneName"] = self.zoneName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["EffectiveScopes"] as? String {
            self.effectiveScopesShrink = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["ZoneName"] as? String {
            self.zoneName = value
        }
    }
}

public class SearchRecursionZonesResponseBody : Tea.TeaModel {
    public class Zones : Tea.TeaModel {
        public class Zone : Tea.TeaModel {
            public class EffectiveScopes : Tea.TeaModel {
                public class EffectiveScope : Tea.TeaModel {
                    public class Scopes : Tea.TeaModel {
                        public var scope: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.scope != nil {
                                map["Scope"] = self.scope!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Scope"] as? [String] {
                                self.scope = value
                            }
                        }
                    }
                    public var effectiveType: String?

                    public var scopes: SearchRecursionZonesResponseBody.Zones.Zone.EffectiveScopes.EffectiveScope.Scopes?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.scopes?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.effectiveType != nil {
                            map["EffectiveType"] = self.effectiveType!
                        }
                        if self.scopes != nil {
                            map["Scopes"] = self.scopes?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["EffectiveType"] as? String {
                            self.effectiveType = value
                        }
                        if let value = dict["Scopes"] as? [String: Any?] {
                            var model = SearchRecursionZonesResponseBody.Zones.Zone.EffectiveScopes.EffectiveScope.Scopes()
                            model.fromMap(value)
                            self.scopes = model
                        }
                    }
                }
                public var effectiveScope: [SearchRecursionZonesResponseBody.Zones.Zone.EffectiveScopes.EffectiveScope]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.effectiveScope != nil {
                        var tmp : [Any] = []
                        for k in self.effectiveScope! {
                            tmp.append(k.toMap())
                        }
                        map["EffectiveScope"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EffectiveScope"] as? [Any?] {
                        var tmp : [SearchRecursionZonesResponseBody.Zones.Zone.EffectiveScopes.EffectiveScope] = []
                        for v in value {
                            if v != nil {
                                var model = SearchRecursionZonesResponseBody.Zones.Zone.EffectiveScopes.EffectiveScope()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.effectiveScope = tmp
                    }
                }
            }
            public var createTime: String?

            public var createTimestamp: Int64?

            public var creator: String?

            public var creatorSubType: String?

            public var creatorType: String?

            public var effectiveScopes: SearchRecursionZonesResponseBody.Zones.Zone.EffectiveScopes?

            public var proxyPattern: String?

            public var recordCount: Int32?

            public var remark: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var zoneId: String?

            public var zoneName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.effectiveScopes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.creatorSubType != nil {
                    map["CreatorSubType"] = self.creatorSubType!
                }
                if self.creatorType != nil {
                    map["CreatorType"] = self.creatorType!
                }
                if self.effectiveScopes != nil {
                    map["EffectiveScopes"] = self.effectiveScopes?.toMap()
                }
                if self.proxyPattern != nil {
                    map["ProxyPattern"] = self.proxyPattern!
                }
                if self.recordCount != nil {
                    map["RecordCount"] = self.recordCount!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                if self.zoneName != nil {
                    map["ZoneName"] = self.zoneName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["Creator"] as? String {
                    self.creator = value
                }
                if let value = dict["CreatorSubType"] as? String {
                    self.creatorSubType = value
                }
                if let value = dict["CreatorType"] as? String {
                    self.creatorType = value
                }
                if let value = dict["EffectiveScopes"] as? [String: Any?] {
                    var model = SearchRecursionZonesResponseBody.Zones.Zone.EffectiveScopes()
                    model.fromMap(value)
                    self.effectiveScopes = model
                }
                if let value = dict["ProxyPattern"] as? String {
                    self.proxyPattern = value
                }
                if let value = dict["RecordCount"] as? Int32 {
                    self.recordCount = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
                if let value = dict["UpdateTimestamp"] as? Int64 {
                    self.updateTimestamp = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
                if let value = dict["ZoneName"] as? String {
                    self.zoneName = value
                }
            }
        }
        public var zone: [SearchRecursionZonesResponseBody.Zones.Zone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.zone != nil {
                var tmp : [Any] = []
                for k in self.zone! {
                    tmp.append(k.toMap())
                }
                map["Zone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Zone"] as? [Any?] {
                var tmp : [SearchRecursionZonesResponseBody.Zones.Zone] = []
                for v in value {
                    if v != nil {
                        var model = SearchRecursionZonesResponseBody.Zones.Zone()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.zone = tmp
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public var zones: SearchRecursionZonesResponseBody.Zones?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.zones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        if self.zones != nil {
            map["Zones"] = self.zones?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalItems"] as? Int32 {
            self.totalItems = value
        }
        if let value = dict["TotalPages"] as? Int32 {
            self.totalPages = value
        }
        if let value = dict["Zones"] as? [String: Any?] {
            var model = SearchRecursionZonesResponseBody.Zones()
            model.fromMap(value)
            self.zones = model
        }
    }
}

public class SearchRecursionZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchRecursionZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SearchRecursionZonesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetCloudGtmInstanceConfigLogSwitchRequest : Tea.TeaModel {
    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class SetCloudGtmInstanceConfigLogSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class SetCloudGtmInstanceConfigLogSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetCloudGtmInstanceConfigLogSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetCloudGtmInstanceConfigLogSwitchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetDNSSLBStatusRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var line: String?

    public var open_: Bool?

    public var subDomain: String?

    public var type: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.open_ != nil {
            map["Open"] = self.open_!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Line"] as? String {
            self.line = value
        }
        if let value = dict["Open"] as? Bool {
            self.open_ = value
        }
        if let value = dict["SubDomain"] as? String {
            self.subDomain = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
    }
}

public class SetDNSSLBStatusResponseBody : Tea.TeaModel {
    public var open_: Bool?

    public var recordCount: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.open_ != nil {
            map["Open"] = self.open_!
        }
        if self.recordCount != nil {
            map["RecordCount"] = self.recordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Open"] as? Bool {
            self.open_ = value
        }
        if let value = dict["RecordCount"] as? Int64 {
            self.recordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetDNSSLBStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDNSSLBStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetDNSSLBStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetDnsGtmAccessModeRequest : Tea.TeaModel {
    public var accessMode: String?

    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessMode"] as? String {
            self.accessMode = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StrategyId"] as? String {
            self.strategyId = value
        }
    }
}

public class SetDnsGtmAccessModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetDnsGtmAccessModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDnsGtmAccessModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetDnsGtmAccessModeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetDnsGtmMonitorStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var monitorConfigId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class SetDnsGtmMonitorStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetDnsGtmMonitorStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDnsGtmMonitorStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetDnsGtmMonitorStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetDomainDnssecStatusRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class SetDomainDnssecStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetDomainDnssecStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDomainDnssecStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetDomainDnssecStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetDomainRecordStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var status: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
    }
}

public class SetDomainRecordStatusResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class SetDomainRecordStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDomainRecordStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetDomainRecordStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetGtmAccessModeRequest : Tea.TeaModel {
    public var accessMode: String?

    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessMode"] as? String {
            self.accessMode = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StrategyId"] as? String {
            self.strategyId = value
        }
    }
}

public class SetGtmAccessModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetGtmAccessModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetGtmAccessModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetGtmAccessModeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetGtmMonitorStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var monitorConfigId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class SetGtmMonitorStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetGtmMonitorStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetGtmMonitorStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetGtmMonitorStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SubmitIspFlushCacheTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public var domainName: String?

    public var isp: [String]?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Isp"] as? [String] {
            self.isp = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class SubmitIspFlushCacheTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SubmitIspFlushCacheTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitIspFlushCacheTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SubmitIspFlushCacheTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SwitchDnsGtmInstanceStrategyModeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var strategyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StrategyMode"] as? String {
            self.strategyMode = value
        }
    }
}

public class SwitchDnsGtmInstanceStrategyModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SwitchDnsGtmInstanceStrategyModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchDnsGtmInstanceStrategyModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SwitchDnsGtmInstanceStrategyModeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var lang: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = TagResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TransferDomainRequest : Tea.TeaModel {
    public var domainNames: String?

    public var lang: String?

    public var remark: String?

    public var targetUserId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainNames"] as? String {
            self.domainNames = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["TargetUserId"] as? Int64 {
            self.targetUserId = value
        }
    }
}

public class TransferDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
    }
}

public class TransferDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransferDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TransferDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnbindInstanceDomainsRequest : Tea.TeaModel {
    public var domainNames: String?

    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainNames"] as? String {
            self.domainNames = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class UnbindInstanceDomainsResponseBody : Tea.TeaModel {
    public var failedCount: Int32?

    public var requestId: String?

    public var successCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FailedCount"] as? Int32 {
            self.failedCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessCount"] as? Int32 {
            self.successCount = value
        }
    }
}

public class UnbindInstanceDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindInstanceDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnbindInstanceDomainsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var lang: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["All"] as? Bool {
            self.all = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TagKey"] as? [String] {
            self.tagKey = value
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UntagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAppKeyStateRequest : Tea.TeaModel {
    public var appKeyId: String?

    public var lang: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKeyId != nil {
            map["AppKeyId"] = self.appKeyId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppKeyId"] as? String {
            self.appKeyId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
    }
}

public class UpdateAppKeyStateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateAppKeyStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAppKeyStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAppKeyStateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressRequest : Tea.TeaModel {
    public class HealthTasks : Tea.TeaModel {
        public var port: Int32?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Port"] as? Int32 {
                self.port = value
            }
            if let value = dict["TemplateId"] as? String {
                self.templateId = value
            }
        }
    }
    public var acceptLanguage: String?

    public var address: String?

    public var addressId: String?

    public var attributeInfo: String?

    public var clientToken: String?

    public var healthJudgement: String?

    public var healthTasks: [UpdateCloudGtmAddressRequest.HealthTasks]?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.attributeInfo != nil {
            map["AttributeInfo"] = self.attributeInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.healthTasks != nil {
            var tmp : [Any] = []
            for k in self.healthTasks! {
                tmp.append(k.toMap())
            }
            map["HealthTasks"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["Address"] as? String {
            self.address = value
        }
        if let value = dict["AddressId"] as? String {
            self.addressId = value
        }
        if let value = dict["AttributeInfo"] as? String {
            self.attributeInfo = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["HealthJudgement"] as? String {
            self.healthJudgement = value
        }
        if let value = dict["HealthTasks"] as? [Any?] {
            var tmp : [UpdateCloudGtmAddressRequest.HealthTasks] = []
            for v in value {
                if v != nil {
                    var model = UpdateCloudGtmAddressRequest.HealthTasks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.healthTasks = tmp
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class UpdateCloudGtmAddressShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var addressId: String?

    public var attributeInfo: String?

    public var clientToken: String?

    public var healthJudgement: String?

    public var healthTasksShrink: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.attributeInfo != nil {
            map["AttributeInfo"] = self.attributeInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.healthTasksShrink != nil {
            map["HealthTasks"] = self.healthTasksShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["Address"] as? String {
            self.address = value
        }
        if let value = dict["AddressId"] as? String {
            self.addressId = value
        }
        if let value = dict["AttributeInfo"] as? String {
            self.attributeInfo = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["HealthJudgement"] as? String {
            self.healthJudgement = value
        }
        if let value = dict["HealthTasks"] as? String {
            self.healthTasksShrink = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class UpdateCloudGtmAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressEnableStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressId: String?

    public var clientToken: String?

    public var enableStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressId"] as? String {
            self.addressId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
    }
}

public class UpdateCloudGtmAddressEnableStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmAddressEnableStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressEnableStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmAddressEnableStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressManualAvailableStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressId: String?

    public var availableMode: String?

    public var clientToken: String?

    public var manualAvailableStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.availableMode != nil {
            map["AvailableMode"] = self.availableMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.manualAvailableStatus != nil {
            map["ManualAvailableStatus"] = self.manualAvailableStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressId"] as? String {
            self.addressId = value
        }
        if let value = dict["AvailableMode"] as? String {
            self.availableMode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ManualAvailableStatus"] as? String {
            self.manualAvailableStatus = value
        }
    }
}

public class UpdateCloudGtmAddressManualAvailableStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmAddressManualAvailableStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressManualAvailableStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmAddressManualAvailableStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressPoolBasicConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var addressPoolName: String?

    public var clientToken: String?

    public var healthJudgement: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.addressPoolName != nil {
            map["AddressPoolName"] = self.addressPoolName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["AddressPoolName"] as? String {
            self.addressPoolName = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["HealthJudgement"] as? String {
            self.healthJudgement = value
        }
    }
}

public class UpdateCloudGtmAddressPoolBasicConfigResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmAddressPoolBasicConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressPoolBasicConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmAddressPoolBasicConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressPoolEnableStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var clientToken: String?

    public var enableStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
    }
}

public class UpdateCloudGtmAddressPoolEnableStatusResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmAddressPoolEnableStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressPoolEnableStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmAddressPoolEnableStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressPoolLbStrategyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressLbStrategy: String?

    public var addressPoolId: String?

    public var clientToken: String?

    public var sequenceLbStrategyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressLbStrategy != nil {
            map["AddressLbStrategy"] = self.addressLbStrategy!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.sequenceLbStrategyMode != nil {
            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressLbStrategy"] as? String {
            self.addressLbStrategy = value
        }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["SequenceLbStrategyMode"] as? String {
            self.sequenceLbStrategyMode = value
        }
    }
}

public class UpdateCloudGtmAddressPoolLbStrategyResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmAddressPoolLbStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressPoolLbStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmAddressPoolLbStrategyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressPoolRemarkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var clientToken: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class UpdateCloudGtmAddressPoolRemarkResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressPoolId"] as? String {
            self.addressPoolId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmAddressPoolRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressPoolRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmAddressPoolRemarkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressRemarkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressId: String?

    public var clientToken: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressId"] as? String {
            self.addressId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class UpdateCloudGtmAddressRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmAddressRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmAddressRemarkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmGlobalAlertRequest : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public var dingtalkNotice: Bool?

        public var emailNotice: Bool?

        public var noticeType: String?

        public var smsNotice: Bool?

        public var threshold: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingtalkNotice != nil {
                map["DingtalkNotice"] = self.dingtalkNotice!
            }
            if self.emailNotice != nil {
                map["EmailNotice"] = self.emailNotice!
            }
            if self.noticeType != nil {
                map["NoticeType"] = self.noticeType!
            }
            if self.smsNotice != nil {
                map["SmsNotice"] = self.smsNotice!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DingtalkNotice"] as? Bool {
                self.dingtalkNotice = value
            }
            if let value = dict["EmailNotice"] as? Bool {
                self.emailNotice = value
            }
            if let value = dict["NoticeType"] as? String {
                self.noticeType = value
            }
            if let value = dict["SmsNotice"] as? Bool {
                self.smsNotice = value
            }
            if let value = dict["Threshold"] as? Int32 {
                self.threshold = value
            }
        }
    }
    public var acceptLanguage: String?

    public var alertConfig: [UpdateCloudGtmGlobalAlertRequest.AlertConfig]?

    public var alertGroup: [String]?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.alertConfig != nil {
            var tmp : [Any] = []
            for k in self.alertConfig! {
                tmp.append(k.toMap())
            }
            map["AlertConfig"] = tmp
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AlertConfig"] as? [Any?] {
            var tmp : [UpdateCloudGtmGlobalAlertRequest.AlertConfig] = []
            for v in value {
                if v != nil {
                    var model = UpdateCloudGtmGlobalAlertRequest.AlertConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.alertConfig = tmp
        }
        if let value = dict["AlertGroup"] as? [String] {
            self.alertGroup = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateCloudGtmGlobalAlertShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var alertConfigShrink: String?

    public var alertGroupShrink: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.alertConfigShrink != nil {
            map["AlertConfig"] = self.alertConfigShrink!
        }
        if self.alertGroupShrink != nil {
            map["AlertGroup"] = self.alertGroupShrink!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AlertConfig"] as? String {
            self.alertConfigShrink = value
        }
        if let value = dict["AlertGroup"] as? String {
            self.alertGroupShrink = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateCloudGtmGlobalAlertResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmGlobalAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmGlobalAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmGlobalAlertResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmInstanceConfigAlertRequest : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public var dingtalkNotice: Bool?

        public var emailNotice: Bool?

        public var noticeType: String?

        public var smsNotice: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingtalkNotice != nil {
                map["DingtalkNotice"] = self.dingtalkNotice!
            }
            if self.emailNotice != nil {
                map["EmailNotice"] = self.emailNotice!
            }
            if self.noticeType != nil {
                map["NoticeType"] = self.noticeType!
            }
            if self.smsNotice != nil {
                map["SmsNotice"] = self.smsNotice!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DingtalkNotice"] as? Bool {
                self.dingtalkNotice = value
            }
            if let value = dict["EmailNotice"] as? Bool {
                self.emailNotice = value
            }
            if let value = dict["NoticeType"] as? String {
                self.noticeType = value
            }
            if let value = dict["SmsNotice"] as? Bool {
                self.smsNotice = value
            }
        }
    }
    public var acceptLanguage: String?

    public var alertConfig: [UpdateCloudGtmInstanceConfigAlertRequest.AlertConfig]?

    public var alertGroup: [String]?

    public var alertMode: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.alertConfig != nil {
            var tmp : [Any] = []
            for k in self.alertConfig! {
                tmp.append(k.toMap())
            }
            map["AlertConfig"] = tmp
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.alertMode != nil {
            map["AlertMode"] = self.alertMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AlertConfig"] as? [Any?] {
            var tmp : [UpdateCloudGtmInstanceConfigAlertRequest.AlertConfig] = []
            for v in value {
                if v != nil {
                    var model = UpdateCloudGtmInstanceConfigAlertRequest.AlertConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.alertConfig = tmp
        }
        if let value = dict["AlertGroup"] as? [String] {
            self.alertGroup = value
        }
        if let value = dict["AlertMode"] as? String {
            self.alertMode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class UpdateCloudGtmInstanceConfigAlertShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var alertConfigShrink: String?

    public var alertGroupShrink: String?

    public var alertMode: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.alertConfigShrink != nil {
            map["AlertConfig"] = self.alertConfigShrink!
        }
        if self.alertGroupShrink != nil {
            map["AlertGroup"] = self.alertGroupShrink!
        }
        if self.alertMode != nil {
            map["AlertMode"] = self.alertMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AlertConfig"] as? String {
            self.alertConfigShrink = value
        }
        if let value = dict["AlertGroup"] as? String {
            self.alertGroupShrink = value
        }
        if let value = dict["AlertMode"] as? String {
            self.alertMode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class UpdateCloudGtmInstanceConfigAlertResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmInstanceConfigAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmInstanceConfigAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmInstanceConfigAlertResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmInstanceConfigBasicRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public var scheduleHostname: String?

    public var scheduleZoneName: String?

    public var ttl: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scheduleHostname != nil {
            map["ScheduleHostname"] = self.scheduleHostname!
        }
        if self.scheduleZoneName != nil {
            map["ScheduleZoneName"] = self.scheduleZoneName!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["ScheduleHostname"] as? String {
            self.scheduleHostname = value
        }
        if let value = dict["ScheduleZoneName"] as? String {
            self.scheduleZoneName = value
        }
        if let value = dict["Ttl"] as? Int32 {
            self.ttl = value
        }
    }
}

public class UpdateCloudGtmInstanceConfigBasicResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmInstanceConfigBasicResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmInstanceConfigBasicResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmInstanceConfigBasicResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmInstanceConfigEnableStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var configId: String?

    public var enableStatus: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class UpdateCloudGtmInstanceConfigEnableStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmInstanceConfigEnableStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmInstanceConfigEnableStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmInstanceConfigEnableStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmInstanceConfigLbStrategyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolLbStrategy: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public var sequenceLbStrategyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolLbStrategy != nil {
            map["AddressPoolLbStrategy"] = self.addressPoolLbStrategy!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sequenceLbStrategyMode != nil {
            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["AddressPoolLbStrategy"] as? String {
            self.addressPoolLbStrategy = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["SequenceLbStrategyMode"] as? String {
            self.sequenceLbStrategyMode = value
        }
    }
}

public class UpdateCloudGtmInstanceConfigLbStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmInstanceConfigLbStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmInstanceConfigLbStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmInstanceConfigLbStrategyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmInstanceConfigRemarkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class UpdateCloudGtmInstanceConfigRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmInstanceConfigRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmInstanceConfigRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmInstanceConfigRemarkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmInstanceNameRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var instanceId: String?

    public var instanceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
    }
}

public class UpdateCloudGtmInstanceNameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmInstanceNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmInstanceNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmInstanceNameResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmMonitorTemplateRequest : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CityCode"] as? String {
                self.cityCode = value
            }
            if let value = dict["IspCode"] as? String {
                self.ispCode = value
            }
        }
    }
    public var acceptLanguage: String?

    public var clientToken: String?

    public var evaluationCount: Int32?

    public var extendInfo: String?

    public var failureRate: Int32?

    public var interval: Int32?

    public var ispCityNodes: [UpdateCloudGtmMonitorTemplateRequest.IspCityNodes]?

    public var name: String?

    public var templateId: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.failureRate != nil {
            map["FailureRate"] = self.failureRate!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNodes != nil {
            var tmp : [Any] = []
            for k in self.ispCityNodes! {
                tmp.append(k.toMap())
            }
            map["IspCityNodes"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["ExtendInfo"] as? String {
            self.extendInfo = value
        }
        if let value = dict["FailureRate"] as? Int32 {
            self.failureRate = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["IspCityNodes"] as? [Any?] {
            var tmp : [UpdateCloudGtmMonitorTemplateRequest.IspCityNodes] = []
            for v in value {
                if v != nil {
                    var model = UpdateCloudGtmMonitorTemplateRequest.IspCityNodes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ispCityNodes = tmp
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class UpdateCloudGtmMonitorTemplateShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var evaluationCount: Int32?

    public var extendInfo: String?

    public var failureRate: Int32?

    public var interval: Int32?

    public var ispCityNodesShrink: String?

    public var name: String?

    public var templateId: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.failureRate != nil {
            map["FailureRate"] = self.failureRate!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNodesShrink != nil {
            map["IspCityNodes"] = self.ispCityNodesShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["ExtendInfo"] as? String {
            self.extendInfo = value
        }
        if let value = dict["FailureRate"] as? Int32 {
            self.failureRate = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["IspCityNodes"] as? String {
            self.ispCityNodesShrink = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class UpdateCloudGtmMonitorTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmMonitorTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmMonitorTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmMonitorTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCloudGtmMonitorTemplateRemarkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var remark: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
    }
}

public class UpdateCloudGtmMonitorTemplateRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCloudGtmMonitorTemplateRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmMonitorTemplateRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCloudGtmMonitorTemplateRemarkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCustomLineRequest : Tea.TeaModel {
    public class IpSegment : Tea.TeaModel {
        public var endIp: String?

        public var startIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endIp != nil {
                map["EndIp"] = self.endIp!
            }
            if self.startIp != nil {
                map["StartIp"] = self.startIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EndIp"] as? String {
                self.endIp = value
            }
            if let value = dict["StartIp"] as? String {
                self.startIp = value
            }
        }
    }
    public var ipSegment: [UpdateCustomLineRequest.IpSegment]?

    public var lang: String?

    public var lineId: Int64?

    public var lineName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipSegment != nil {
            var tmp : [Any] = []
            for k in self.ipSegment! {
                tmp.append(k.toMap())
            }
            map["IpSegment"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lineId != nil {
            map["LineId"] = self.lineId!
        }
        if self.lineName != nil {
            map["LineName"] = self.lineName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IpSegment"] as? [Any?] {
            var tmp : [UpdateCustomLineRequest.IpSegment] = []
            for v in value {
                if v != nil {
                    var model = UpdateCustomLineRequest.IpSegment()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ipSegment = tmp
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["LineId"] as? Int64 {
            self.lineId = value
        }
        if let value = dict["LineName"] as? String {
            self.lineName = value
        }
    }
}

public class UpdateCustomLineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateCustomLineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomLineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCustomLineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDNSSLBWeightRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var userClientIp: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class UpdateDNSSLBWeightResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class UpdateDNSSLBWeightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDNSSLBWeightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDNSSLBWeightResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDnsCacheDomainRequest : Tea.TeaModel {
    public class SourceDnsServer : Tea.TeaModel {
        public var host: String?

        public var port: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Host"] as? String {
                self.host = value
            }
            if let value = dict["Port"] as? String {
                self.port = value
            }
        }
    }
    public var cacheTtlMax: Int32?

    public var cacheTtlMin: Int32?

    public var domainName: String?

    public var instanceId: String?

    public var lang: String?

    public var sourceDnsServer: [UpdateDnsCacheDomainRequest.SourceDnsServer]?

    public var sourceEdns: String?

    public var sourceProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cacheTtlMax != nil {
            map["CacheTtlMax"] = self.cacheTtlMax!
        }
        if self.cacheTtlMin != nil {
            map["CacheTtlMin"] = self.cacheTtlMin!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceDnsServer != nil {
            var tmp : [Any] = []
            for k in self.sourceDnsServer! {
                tmp.append(k.toMap())
            }
            map["SourceDnsServer"] = tmp
        }
        if self.sourceEdns != nil {
            map["SourceEdns"] = self.sourceEdns!
        }
        if self.sourceProtocol != nil {
            map["SourceProtocol"] = self.sourceProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CacheTtlMax"] as? Int32 {
            self.cacheTtlMax = value
        }
        if let value = dict["CacheTtlMin"] as? Int32 {
            self.cacheTtlMin = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["SourceDnsServer"] as? [Any?] {
            var tmp : [UpdateDnsCacheDomainRequest.SourceDnsServer] = []
            for v in value {
                if v != nil {
                    var model = UpdateDnsCacheDomainRequest.SourceDnsServer()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.sourceDnsServer = tmp
        }
        if let value = dict["SourceEdns"] as? String {
            self.sourceEdns = value
        }
        if let value = dict["SourceProtocol"] as? String {
            self.sourceProtocol = value
        }
    }
}

public class UpdateDnsCacheDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateDnsCacheDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsCacheDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDnsCacheDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDnsCacheDomainRemarkRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class UpdateDnsCacheDomainRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateDnsCacheDomainRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsCacheDomainRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDnsCacheDomainRemarkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDnsGtmAccessStrategyRequest : Tea.TeaModel {
    public class DefaultAddrPool : Tea.TeaModel {
        public var id: String?

        public var lbaWeight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["LbaWeight"] as? Int32 {
                self.lbaWeight = value
            }
        }
    }
    public class FailoverAddrPool : Tea.TeaModel {
        public var id: String?

        public var lbaWeight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["LbaWeight"] as? Int32 {
                self.lbaWeight = value
            }
        }
    }
    public var accessMode: String?

    public var defaultAddrPool: [UpdateDnsGtmAccessStrategyRequest.DefaultAddrPool]?

    public var defaultAddrPoolType: String?

    public var defaultLatencyOptimization: String?

    public var defaultLbaStrategy: String?

    public var defaultMaxReturnAddrNum: Int32?

    public var defaultMinAvailableAddrNum: Int32?

    public var failoverAddrPool: [UpdateDnsGtmAccessStrategyRequest.FailoverAddrPool]?

    public var failoverAddrPoolType: String?

    public var failoverLatencyOptimization: String?

    public var failoverLbaStrategy: String?

    public var failoverMaxReturnAddrNum: Int32?

    public var failoverMinAvailableAddrNum: Int32?

    public var lang: String?

    public var lines: String?

    public var strategyId: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.defaultAddrPool != nil {
            var tmp : [Any] = []
            for k in self.defaultAddrPool! {
                tmp.append(k.toMap())
            }
            map["DefaultAddrPool"] = tmp
        }
        if self.defaultAddrPoolType != nil {
            map["DefaultAddrPoolType"] = self.defaultAddrPoolType!
        }
        if self.defaultLatencyOptimization != nil {
            map["DefaultLatencyOptimization"] = self.defaultLatencyOptimization!
        }
        if self.defaultLbaStrategy != nil {
            map["DefaultLbaStrategy"] = self.defaultLbaStrategy!
        }
        if self.defaultMaxReturnAddrNum != nil {
            map["DefaultMaxReturnAddrNum"] = self.defaultMaxReturnAddrNum!
        }
        if self.defaultMinAvailableAddrNum != nil {
            map["DefaultMinAvailableAddrNum"] = self.defaultMinAvailableAddrNum!
        }
        if self.failoverAddrPool != nil {
            var tmp : [Any] = []
            for k in self.failoverAddrPool! {
                tmp.append(k.toMap())
            }
            map["FailoverAddrPool"] = tmp
        }
        if self.failoverAddrPoolType != nil {
            map["FailoverAddrPoolType"] = self.failoverAddrPoolType!
        }
        if self.failoverLatencyOptimization != nil {
            map["FailoverLatencyOptimization"] = self.failoverLatencyOptimization!
        }
        if self.failoverLbaStrategy != nil {
            map["FailoverLbaStrategy"] = self.failoverLbaStrategy!
        }
        if self.failoverMaxReturnAddrNum != nil {
            map["FailoverMaxReturnAddrNum"] = self.failoverMaxReturnAddrNum!
        }
        if self.failoverMinAvailableAddrNum != nil {
            map["FailoverMinAvailableAddrNum"] = self.failoverMinAvailableAddrNum!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lines != nil {
            map["Lines"] = self.lines!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessMode"] as? String {
            self.accessMode = value
        }
        if let value = dict["DefaultAddrPool"] as? [Any?] {
            var tmp : [UpdateDnsGtmAccessStrategyRequest.DefaultAddrPool] = []
            for v in value {
                if v != nil {
                    var model = UpdateDnsGtmAccessStrategyRequest.DefaultAddrPool()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.defaultAddrPool = tmp
        }
        if let value = dict["DefaultAddrPoolType"] as? String {
            self.defaultAddrPoolType = value
        }
        if let value = dict["DefaultLatencyOptimization"] as? String {
            self.defaultLatencyOptimization = value
        }
        if let value = dict["DefaultLbaStrategy"] as? String {
            self.defaultLbaStrategy = value
        }
        if let value = dict["DefaultMaxReturnAddrNum"] as? Int32 {
            self.defaultMaxReturnAddrNum = value
        }
        if let value = dict["DefaultMinAvailableAddrNum"] as? Int32 {
            self.defaultMinAvailableAddrNum = value
        }
        if let value = dict["FailoverAddrPool"] as? [Any?] {
            var tmp : [UpdateDnsGtmAccessStrategyRequest.FailoverAddrPool] = []
            for v in value {
                if v != nil {
                    var model = UpdateDnsGtmAccessStrategyRequest.FailoverAddrPool()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.failoverAddrPool = tmp
        }
        if let value = dict["FailoverAddrPoolType"] as? String {
            self.failoverAddrPoolType = value
        }
        if let value = dict["FailoverLatencyOptimization"] as? String {
            self.failoverLatencyOptimization = value
        }
        if let value = dict["FailoverLbaStrategy"] as? String {
            self.failoverLbaStrategy = value
        }
        if let value = dict["FailoverMaxReturnAddrNum"] as? Int32 {
            self.failoverMaxReturnAddrNum = value
        }
        if let value = dict["FailoverMinAvailableAddrNum"] as? Int32 {
            self.failoverMinAvailableAddrNum = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Lines"] as? String {
            self.lines = value
        }
        if let value = dict["StrategyId"] as? String {
            self.strategyId = value
        }
        if let value = dict["StrategyName"] as? String {
            self.strategyName = value
        }
    }
}

public class UpdateDnsGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StrategyId"] as? String {
            self.strategyId = value
        }
    }
}

public class UpdateDnsGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDnsGtmAccessStrategyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDnsGtmAddressPoolRequest : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public var addr: String?

        public var attributeInfo: String?

        public var lbaWeight: Int32?

        public var mode: String?

        public var remark: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                map["Addr"] = self.addr!
            }
            if self.attributeInfo != nil {
                map["AttributeInfo"] = self.attributeInfo!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Addr"] as? String {
                self.addr = value
            }
            if let value = dict["AttributeInfo"] as? String {
                self.attributeInfo = value
            }
            if let value = dict["LbaWeight"] as? Int32 {
                self.lbaWeight = value
            }
            if let value = dict["Mode"] as? String {
                self.mode = value
            }
            if let value = dict["Remark"] as? String {
                self.remark = value
            }
        }
    }
    public var addr: [UpdateDnsGtmAddressPoolRequest.Addr]?

    public var addrPoolId: String?

    public var lang: String?

    public var lbaStrategy: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            var tmp : [Any] = []
            for k in self.addr! {
                tmp.append(k.toMap())
            }
            map["Addr"] = tmp
        }
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Addr"] as? [Any?] {
            var tmp : [UpdateDnsGtmAddressPoolRequest.Addr] = []
            for v in value {
                if v != nil {
                    var model = UpdateDnsGtmAddressPoolRequest.Addr()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.addr = tmp
        }
        if let value = dict["AddrPoolId"] as? String {
            self.addrPoolId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["LbaStrategy"] as? String {
            self.lbaStrategy = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class UpdateDnsGtmAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateDnsGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDnsGtmAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDnsGtmInstanceGlobalConfigRequest : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public var dingtalkNotice: Bool?

        public var emailNotice: Bool?

        public var noticeType: String?

        public var smsNotice: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingtalkNotice != nil {
                map["DingtalkNotice"] = self.dingtalkNotice!
            }
            if self.emailNotice != nil {
                map["EmailNotice"] = self.emailNotice!
            }
            if self.noticeType != nil {
                map["NoticeType"] = self.noticeType!
            }
            if self.smsNotice != nil {
                map["SmsNotice"] = self.smsNotice!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DingtalkNotice"] as? Bool {
                self.dingtalkNotice = value
            }
            if let value = dict["EmailNotice"] as? Bool {
                self.emailNotice = value
            }
            if let value = dict["NoticeType"] as? String {
                self.noticeType = value
            }
            if let value = dict["SmsNotice"] as? Bool {
                self.smsNotice = value
            }
        }
    }
    public var alertConfig: [UpdateDnsGtmInstanceGlobalConfigRequest.AlertConfig]?

    public var alertGroup: String?

    public var cnameType: String?

    public var forceUpdate: Bool?

    public var instanceId: String?

    public var instanceName: String?

    public var lang: String?

    public var publicCnameMode: String?

    public var publicRr: String?

    public var publicUserDomainName: String?

    public var publicZoneName: String?

    public var ttl: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConfig != nil {
            var tmp : [Any] = []
            for k in self.alertConfig! {
                tmp.append(k.toMap())
            }
            map["AlertConfig"] = tmp
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.cnameType != nil {
            map["CnameType"] = self.cnameType!
        }
        if self.forceUpdate != nil {
            map["ForceUpdate"] = self.forceUpdate!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.publicCnameMode != nil {
            map["PublicCnameMode"] = self.publicCnameMode!
        }
        if self.publicRr != nil {
            map["PublicRr"] = self.publicRr!
        }
        if self.publicUserDomainName != nil {
            map["PublicUserDomainName"] = self.publicUserDomainName!
        }
        if self.publicZoneName != nil {
            map["PublicZoneName"] = self.publicZoneName!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertConfig"] as? [Any?] {
            var tmp : [UpdateDnsGtmInstanceGlobalConfigRequest.AlertConfig] = []
            for v in value {
                if v != nil {
                    var model = UpdateDnsGtmInstanceGlobalConfigRequest.AlertConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.alertConfig = tmp
        }
        if let value = dict["AlertGroup"] as? String {
            self.alertGroup = value
        }
        if let value = dict["CnameType"] as? String {
            self.cnameType = value
        }
        if let value = dict["ForceUpdate"] as? Bool {
            self.forceUpdate = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["PublicCnameMode"] as? String {
            self.publicCnameMode = value
        }
        if let value = dict["PublicRr"] as? String {
            self.publicRr = value
        }
        if let value = dict["PublicUserDomainName"] as? String {
            self.publicUserDomainName = value
        }
        if let value = dict["PublicZoneName"] as? String {
            self.publicZoneName = value
        }
        if let value = dict["Ttl"] as? Int32 {
            self.ttl = value
        }
    }
}

public class UpdateDnsGtmInstanceGlobalConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateDnsGtmInstanceGlobalConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsGtmInstanceGlobalConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDnsGtmInstanceGlobalConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDnsGtmMonitorRequest : Tea.TeaModel {
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CityCode"] as? String {
                self.cityCode = value
            }
            if let value = dict["IspCode"] as? String {
                self.ispCode = value
            }
        }
    }
    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNode: [UpdateDnsGtmMonitorRequest.IspCityNode]?

    public var lang: String?

    public var monitorConfigId: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["IspCityNode"] as? [Any?] {
            var tmp : [UpdateDnsGtmMonitorRequest.IspCityNode] = []
            for v in value {
                if v != nil {
                    var model = UpdateDnsGtmMonitorRequest.IspCityNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ispCityNode = tmp
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
        if let value = dict["MonitorExtendInfo"] as? String {
            self.monitorExtendInfo = value
        }
        if let value = dict["ProtocolType"] as? String {
            self.protocolType = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class UpdateDnsGtmMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateDnsGtmMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsGtmMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDnsGtmMonitorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDomainGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class UpdateDomainGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateDomainGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDomainGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDomainRecordRequest : Tea.TeaModel {
    public var lang: String?

    public var line: String?

    public var priority: Int64?

    public var RR: String?

    public var recordId: String?

    public var TTL: Int64?

    public var type: String?

    public var userClientIp: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.TTL != nil {
            map["TTL"] = self.TTL!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Line"] as? String {
            self.line = value
        }
        if let value = dict["Priority"] as? Int64 {
            self.priority = value
        }
        if let value = dict["RR"] as? String {
            self.RR = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["TTL"] as? Int64 {
            self.TTL = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
        if let value = dict["Value"] as? String {
            self.value = value
        }
    }
}

public class UpdateDomainRecordResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateDomainRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDomainRecordResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDomainRecordRemarkRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var remark: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["UserClientIp"] as? String {
            self.userClientIp = value
        }
    }
}

public class UpdateDomainRecordRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateDomainRecordRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainRecordRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDomainRecordRemarkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDomainRemarkRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class UpdateDomainRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateDomainRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDomainRemarkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateGtmAccessStrategyRequest : Tea.TeaModel {
    public var accessLines: String?

    public var defaultAddrPoolId: String?

    public var failoverAddrPoolId: String?

    public var lang: String?

    public var strategyId: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessLines != nil {
            map["AccessLines"] = self.accessLines!
        }
        if self.defaultAddrPoolId != nil {
            map["DefaultAddrPoolId"] = self.defaultAddrPoolId!
        }
        if self.failoverAddrPoolId != nil {
            map["FailoverAddrPoolId"] = self.failoverAddrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessLines"] as? String {
            self.accessLines = value
        }
        if let value = dict["DefaultAddrPoolId"] as? String {
            self.defaultAddrPoolId = value
        }
        if let value = dict["FailoverAddrPoolId"] as? String {
            self.failoverAddrPoolId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["StrategyId"] as? String {
            self.strategyId = value
        }
        if let value = dict["StrategyName"] as? String {
            self.strategyName = value
        }
    }
}

public class UpdateGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateGtmAccessStrategyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateGtmAddressPoolRequest : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public var lbaWeight: Int32?

        public var mode: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LbaWeight"] as? Int32 {
                self.lbaWeight = value
            }
            if let value = dict["Mode"] as? String {
                self.mode = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var addr: [UpdateGtmAddressPoolRequest.Addr]?

    public var addrPoolId: String?

    public var lang: String?

    public var minAvailableAddrNum: Int32?

    public var name: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            var tmp : [Any] = []
            for k in self.addr! {
                tmp.append(k.toMap())
            }
            map["Addr"] = tmp
        }
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.minAvailableAddrNum != nil {
            map["MinAvailableAddrNum"] = self.minAvailableAddrNum!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Addr"] as? [Any?] {
            var tmp : [UpdateGtmAddressPoolRequest.Addr] = []
            for v in value {
                if v != nil {
                    var model = UpdateGtmAddressPoolRequest.Addr()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.addr = tmp
        }
        if let value = dict["AddrPoolId"] as? String {
            self.addrPoolId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["MinAvailableAddrNum"] as? Int32 {
            self.minAvailableAddrNum = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class UpdateGtmAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateGtmAddressPoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateGtmInstanceGlobalConfigRequest : Tea.TeaModel {
    public var alertGroup: String?

    public var cnameCustomDomainName: String?

    public var cnameMode: String?

    public var instanceId: String?

    public var instanceName: String?

    public var lang: String?

    public var lbaStrategy: String?

    public var ttl: Int32?

    public var userDomainName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.cnameCustomDomainName != nil {
            map["CnameCustomDomainName"] = self.cnameCustomDomainName!
        }
        if self.cnameMode != nil {
            map["CnameMode"] = self.cnameMode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.userDomainName != nil {
            map["UserDomainName"] = self.userDomainName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertGroup"] as? String {
            self.alertGroup = value
        }
        if let value = dict["CnameCustomDomainName"] as? String {
            self.cnameCustomDomainName = value
        }
        if let value = dict["CnameMode"] as? String {
            self.cnameMode = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["LbaStrategy"] as? String {
            self.lbaStrategy = value
        }
        if let value = dict["Ttl"] as? Int32 {
            self.ttl = value
        }
        if let value = dict["UserDomainName"] as? String {
            self.userDomainName = value
        }
    }
}

public class UpdateGtmInstanceGlobalConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateGtmInstanceGlobalConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmInstanceGlobalConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateGtmInstanceGlobalConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateGtmMonitorRequest : Tea.TeaModel {
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CityCode"] as? String {
                self.cityCode = value
            }
            if let value = dict["IspCode"] as? String {
                self.ispCode = value
            }
        }
    }
    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNode: [UpdateGtmMonitorRequest.IspCityNode]?

    public var lang: String?

    public var monitorConfigId: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EvaluationCount"] as? Int32 {
            self.evaluationCount = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["IspCityNode"] as? [Any?] {
            var tmp : [UpdateGtmMonitorRequest.IspCityNode] = []
            for v in value {
                if v != nil {
                    var model = UpdateGtmMonitorRequest.IspCityNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ispCityNode = tmp
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["MonitorConfigId"] as? String {
            self.monitorConfigId = value
        }
        if let value = dict["MonitorExtendInfo"] as? String {
            self.monitorExtendInfo = value
        }
        if let value = dict["ProtocolType"] as? String {
            self.protocolType = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class UpdateGtmMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateGtmMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateGtmMonitorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateGtmRecoveryPlanRequest : Tea.TeaModel {
    public var faultAddrPool: String?

    public var lang: String?

    public var name: String?

    public var recoveryPlanId: Int64?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.faultAddrPool != nil {
            map["FaultAddrPool"] = self.faultAddrPool!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FaultAddrPool"] as? String {
            self.faultAddrPool = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RecoveryPlanId"] as? Int64 {
            self.recoveryPlanId = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class UpdateGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateGtmRecoveryPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateIspFlushCacheInstanceConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class UpdateIspFlushCacheInstanceConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateIspFlushCacheInstanceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIspFlushCacheInstanceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateIspFlushCacheInstanceConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRecursionRecordRequest : Tea.TeaModel {
    public var clientToken: String?

    public var priority: Int32?

    public var recordId: String?

    public var requestSource: String?

    public var rr: String?

    public var ttl: Int32?

    public var type: String?

    public var value: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestSource != nil {
            map["RequestSource"] = self.requestSource!
        }
        if self.rr != nil {
            map["Rr"] = self.rr!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["RequestSource"] as? String {
            self.requestSource = value
        }
        if let value = dict["Rr"] as? String {
            self.rr = value
        }
        if let value = dict["Ttl"] as? Int32 {
            self.ttl = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["Value"] as? String {
            self.value = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class UpdateRecursionRecordResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateRecursionRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRecursionRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRecursionRecordResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRecursionRecordEnableStatusRequest : Tea.TeaModel {
    public var clientToken: String?

    public var enableStatus: String?

    public var recordId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
    }
}

public class UpdateRecursionRecordEnableStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateRecursionRecordEnableStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRecursionRecordEnableStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRecursionRecordEnableStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRecursionRecordRemarkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var recordId: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class UpdateRecursionRecordRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateRecursionRecordRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRecursionRecordRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRecursionRecordRemarkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRecursionRecordWeightRequest : Tea.TeaModel {
    public var clientToken: String?

    public var recordId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["Weight"] as? Int32 {
            self.weight = value
        }
    }
}

public class UpdateRecursionRecordWeightResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateRecursionRecordWeightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRecursionRecordWeightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRecursionRecordWeightResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRecursionRecordWeightEnableStatusRequest : Tea.TeaModel {
    public var clientToken: String?

    public var enableStatus: String?

    public var requestSource: String?

    public var rr: String?

    public var type: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.requestSource != nil {
            map["RequestSource"] = self.requestSource!
        }
        if self.rr != nil {
            map["Rr"] = self.rr!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EnableStatus"] as? String {
            self.enableStatus = value
        }
        if let value = dict["RequestSource"] as? String {
            self.requestSource = value
        }
        if let value = dict["Rr"] as? String {
            self.rr = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class UpdateRecursionRecordWeightEnableStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateRecursionRecordWeightEnableStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRecursionRecordWeightEnableStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRecursionRecordWeightEnableStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRecursionZoneEffectiveScopeRequest : Tea.TeaModel {
    public class EffectiveScopes : Tea.TeaModel {
        public var effectiveType: String?

        public var scope: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.effectiveType != nil {
                map["EffectiveType"] = self.effectiveType!
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EffectiveType"] as? String {
                self.effectiveType = value
            }
            if let value = dict["Scope"] as? [String] {
                self.scope = value
            }
        }
    }
    public var clientToken: String?

    public var effectiveScopes: [UpdateRecursionZoneEffectiveScopeRequest.EffectiveScopes]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.effectiveScopes != nil {
            var tmp : [Any] = []
            for k in self.effectiveScopes! {
                tmp.append(k.toMap())
            }
            map["EffectiveScopes"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EffectiveScopes"] as? [Any?] {
            var tmp : [UpdateRecursionZoneEffectiveScopeRequest.EffectiveScopes] = []
            for v in value {
                if v != nil {
                    var model = UpdateRecursionZoneEffectiveScopeRequest.EffectiveScopes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.effectiveScopes = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class UpdateRecursionZoneEffectiveScopeShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var effectiveScopesShrink: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.effectiveScopesShrink != nil {
            map["EffectiveScopes"] = self.effectiveScopesShrink!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EffectiveScopes"] as? String {
            self.effectiveScopesShrink = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class UpdateRecursionZoneEffectiveScopeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateRecursionZoneEffectiveScopeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRecursionZoneEffectiveScopeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRecursionZoneEffectiveScopeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRecursionZoneProxyPatternRequest : Tea.TeaModel {
    public var clientToken: String?

    public var proxyPattern: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.proxyPattern != nil {
            map["ProxyPattern"] = self.proxyPattern!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ProxyPattern"] as? String {
            self.proxyPattern = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class UpdateRecursionZoneProxyPatternResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateRecursionZoneProxyPatternResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRecursionZoneProxyPatternResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRecursionZoneProxyPatternResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRecursionZoneRemarkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var remark: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class UpdateRecursionZoneRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateRecursionZoneRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRecursionZoneRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRecursionZoneRemarkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRspDomainServerProhibitStatusForGatewayRequest : Tea.TeaModel {
    public class AddStatusList : Tea.TeaModel {
        public var status: String?

        public var statusMsg: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusMsg != nil {
                map["StatusMsg"] = self.statusMsg!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["StatusMsg"] as? String {
                self.statusMsg = value
            }
        }
    }
    public class DeleteStatusList : Tea.TeaModel {
        public var status: String?

        public var statusMsg: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusMsg != nil {
                map["StatusMsg"] = self.statusMsg!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["StatusMsg"] as? String {
                self.statusMsg = value
            }
        }
    }
    public var addStatusList: [UpdateRspDomainServerProhibitStatusForGatewayRequest.AddStatusList]?

    public var clientToken: String?

    public var deleteStatusList: [UpdateRspDomainServerProhibitStatusForGatewayRequest.DeleteStatusList]?

    public var domainName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addStatusList != nil {
            var tmp : [Any] = []
            for k in self.addStatusList! {
                tmp.append(k.toMap())
            }
            map["AddStatusList"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.deleteStatusList != nil {
            var tmp : [Any] = []
            for k in self.deleteStatusList! {
                tmp.append(k.toMap())
            }
            map["DeleteStatusList"] = tmp
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddStatusList"] as? [Any?] {
            var tmp : [UpdateRspDomainServerProhibitStatusForGatewayRequest.AddStatusList] = []
            for v in value {
                if v != nil {
                    var model = UpdateRspDomainServerProhibitStatusForGatewayRequest.AddStatusList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.addStatusList = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DeleteStatusList"] as? [Any?] {
            var tmp : [UpdateRspDomainServerProhibitStatusForGatewayRequest.DeleteStatusList] = []
            for v in value {
                if v != nil {
                    var model = UpdateRspDomainServerProhibitStatusForGatewayRequest.DeleteStatusList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.deleteStatusList = tmp
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
    }
}

public class UpdateRspDomainServerProhibitStatusForGatewayResponseBody : Tea.TeaModel {
    public class AccessDeniedDetail : Tea.TeaModel {
        public var authAction: String?

        public var authPrincipalDisplayName: String?

        public var authPrincipalOwnerId: String?

        public var authPrincipalType: String?

        public var encodedDiagnosticMessage: String?

        public var noPermissionType: String?

        public var policyType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authAction != nil {
                map["AuthAction"] = self.authAction!
            }
            if self.authPrincipalDisplayName != nil {
                map["AuthPrincipalDisplayName"] = self.authPrincipalDisplayName!
            }
            if self.authPrincipalOwnerId != nil {
                map["AuthPrincipalOwnerId"] = self.authPrincipalOwnerId!
            }
            if self.authPrincipalType != nil {
                map["AuthPrincipalType"] = self.authPrincipalType!
            }
            if self.encodedDiagnosticMessage != nil {
                map["EncodedDiagnosticMessage"] = self.encodedDiagnosticMessage!
            }
            if self.noPermissionType != nil {
                map["NoPermissionType"] = self.noPermissionType!
            }
            if self.policyType != nil {
                map["PolicyType"] = self.policyType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AuthAction"] as? String {
                self.authAction = value
            }
            if let value = dict["AuthPrincipalDisplayName"] as? String {
                self.authPrincipalDisplayName = value
            }
            if let value = dict["AuthPrincipalOwnerId"] as? String {
                self.authPrincipalOwnerId = value
            }
            if let value = dict["AuthPrincipalType"] as? String {
                self.authPrincipalType = value
            }
            if let value = dict["EncodedDiagnosticMessage"] as? String {
                self.encodedDiagnosticMessage = value
            }
            if let value = dict["NoPermissionType"] as? String {
                self.noPermissionType = value
            }
            if let value = dict["PolicyType"] as? String {
                self.policyType = value
            }
        }
    }
    public class Data : Tea.TeaModel {
        public class StatusList : Tea.TeaModel {
            public var domainName: String?

            public var status: String?

            public var statusMsg: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.statusMsg != nil {
                    map["StatusMsg"] = self.statusMsg!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["StatusMsg"] as? String {
                    self.statusMsg = value
                }
            }
        }
        public var domainName: String?

        public var statusList: [UpdateRspDomainServerProhibitStatusForGatewayResponseBody.Data.StatusList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.statusList != nil {
                var tmp : [Any] = []
                for k in self.statusList! {
                    tmp.append(k.toMap())
                }
                map["StatusList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["StatusList"] as? [Any?] {
                var tmp : [UpdateRspDomainServerProhibitStatusForGatewayResponseBody.Data.StatusList] = []
                for v in value {
                    if v != nil {
                        var model = UpdateRspDomainServerProhibitStatusForGatewayResponseBody.Data.StatusList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.statusList = tmp
            }
        }
    }
    public var accessDeniedDetail: UpdateRspDomainServerProhibitStatusForGatewayResponseBody.AccessDeniedDetail?

    public var data: UpdateRspDomainServerProhibitStatusForGatewayResponseBody.Data?

    public var recoverableError: Bool?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accessDeniedDetail?.validate()
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail?.toMap()
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.recoverableError != nil {
            map["RecoverableError"] = self.recoverableError!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? [String: Any?] {
            var model = UpdateRspDomainServerProhibitStatusForGatewayResponseBody.AccessDeniedDetail()
            model.fromMap(value)
            self.accessDeniedDetail = model
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateRspDomainServerProhibitStatusForGatewayResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RecoverableError"] as? Bool {
            self.recoverableError = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateRspDomainServerProhibitStatusForGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRspDomainServerProhibitStatusForGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRspDomainServerProhibitStatusForGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ValidateDnsGtmCnameRrCanUseRequest : Tea.TeaModel {
    public var cnameMode: String?

    public var cnameRr: String?

    public var cnameType: String?

    public var cnameZone: String?

    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cnameMode != nil {
            map["CnameMode"] = self.cnameMode!
        }
        if self.cnameRr != nil {
            map["CnameRr"] = self.cnameRr!
        }
        if self.cnameType != nil {
            map["CnameType"] = self.cnameType!
        }
        if self.cnameZone != nil {
            map["CnameZone"] = self.cnameZone!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CnameMode"] as? String {
            self.cnameMode = value
        }
        if let value = dict["CnameRr"] as? String {
            self.cnameRr = value
        }
        if let value = dict["CnameType"] as? String {
            self.cnameType = value
        }
        if let value = dict["CnameZone"] as? String {
            self.cnameZone = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class ValidateDnsGtmCnameRrCanUseResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ValidateDnsGtmCnameRrCanUseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateDnsGtmCnameRrCanUseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ValidateDnsGtmCnameRrCanUseResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ValidatePdnsUdpIpSegmentRequest : Tea.TeaModel {
    public var ip: String?

    public var ipToken: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.ipToken != nil {
            map["IpToken"] = self.ipToken!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ip"] as? String {
            self.ip = value
        }
        if let value = dict["IpToken"] as? String {
            self.ipToken = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
    }
}

public class ValidatePdnsUdpIpSegmentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ValidatePdnsUdpIpSegmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidatePdnsUdpIpSegmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ValidatePdnsUdpIpSegmentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
