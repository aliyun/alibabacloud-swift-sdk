import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddCustomLineRequest : Tea.TeaModel {
    public class IpSegment : Tea.TeaModel {
        public var endIp: String?

        public var startIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endIp != nil {
                map["EndIp"] = self.endIp!
            }
            if self.startIp != nil {
                map["StartIp"] = self.startIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndIp") {
                self.endIp = dict["EndIp"] as! String
            }
            if dict.keys.contains("StartIp") {
                self.startIp = dict["StartIp"] as! String
            }
        }
    }
    public var domainName: String?

    public var ipSegment: [AddCustomLineRequest.IpSegment]?

    public var lang: String?

    public var lineName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ipSegment != nil {
            var tmp : [Any] = []
            for k in self.ipSegment! {
                tmp.append(k.toMap())
            }
            map["IpSegment"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lineName != nil {
            map["LineName"] = self.lineName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("IpSegment") {
            var tmp : [AddCustomLineRequest.IpSegment] = []
            for v in dict["IpSegment"] as! [Any] {
                var model = AddCustomLineRequest.IpSegment()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ipSegment = tmp
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LineName") {
            self.lineName = dict["LineName"] as! String
        }
    }
}

public class AddCustomLineResponseBody : Tea.TeaModel {
    public var lineCode: String?

    public var lineId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lineCode != nil {
            map["LineCode"] = self.lineCode!
        }
        if self.lineId != nil {
            map["LineId"] = self.lineId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LineCode") {
            self.lineCode = dict["LineCode"] as! String
        }
        if dict.keys.contains("LineId") {
            self.lineId = dict["LineId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCustomLineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCustomLineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCustomLineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDnsCacheDomainRequest : Tea.TeaModel {
    public class SourceDnsServer : Tea.TeaModel {
        public var host: String?

        public var port: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
        }
    }
    public var cacheTtlMax: Int32?

    public var cacheTtlMin: Int32?

    public var domainName: String?

    public var instanceId: String?

    public var lang: String?

    public var remark: String?

    public var sourceDnsServer: [AddDnsCacheDomainRequest.SourceDnsServer]?

    public var sourceEdns: String?

    public var sourceProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cacheTtlMax != nil {
            map["CacheTtlMax"] = self.cacheTtlMax!
        }
        if self.cacheTtlMin != nil {
            map["CacheTtlMin"] = self.cacheTtlMin!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.sourceDnsServer != nil {
            var tmp : [Any] = []
            for k in self.sourceDnsServer! {
                tmp.append(k.toMap())
            }
            map["SourceDnsServer"] = tmp
        }
        if self.sourceEdns != nil {
            map["SourceEdns"] = self.sourceEdns!
        }
        if self.sourceProtocol != nil {
            map["SourceProtocol"] = self.sourceProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CacheTtlMax") {
            self.cacheTtlMax = dict["CacheTtlMax"] as! Int32
        }
        if dict.keys.contains("CacheTtlMin") {
            self.cacheTtlMin = dict["CacheTtlMin"] as! Int32
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SourceDnsServer") {
            var tmp : [AddDnsCacheDomainRequest.SourceDnsServer] = []
            for v in dict["SourceDnsServer"] as! [Any] {
                var model = AddDnsCacheDomainRequest.SourceDnsServer()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sourceDnsServer = tmp
        }
        if dict.keys.contains("SourceEdns") {
            self.sourceEdns = dict["SourceEdns"] as! String
        }
        if dict.keys.contains("SourceProtocol") {
            self.sourceProtocol = dict["SourceProtocol"] as! String
        }
    }
}

public class AddDnsCacheDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDnsCacheDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDnsCacheDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDnsCacheDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDnsGtmAccessStrategyRequest : Tea.TeaModel {
    public class DefaultAddrPool : Tea.TeaModel {
        public var id: String?

        public var lbaWeight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
        }
    }
    public class FailoverAddrPool : Tea.TeaModel {
        public var id: String?

        public var lbaWeight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
        }
    }
    public var defaultAddrPool: [AddDnsGtmAccessStrategyRequest.DefaultAddrPool]?

    public var defaultAddrPoolType: String?

    public var defaultLatencyOptimization: String?

    public var defaultLbaStrategy: String?

    public var defaultMaxReturnAddrNum: Int32?

    public var defaultMinAvailableAddrNum: Int32?

    public var failoverAddrPool: [AddDnsGtmAccessStrategyRequest.FailoverAddrPool]?

    public var failoverAddrPoolType: String?

    public var failoverLatencyOptimization: String?

    public var failoverLbaStrategy: String?

    public var failoverMaxReturnAddrNum: Int32?

    public var failoverMinAvailableAddrNum: Int32?

    public var instanceId: String?

    public var lang: String?

    public var lines: String?

    public var strategyMode: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultAddrPool != nil {
            var tmp : [Any] = []
            for k in self.defaultAddrPool! {
                tmp.append(k.toMap())
            }
            map["DefaultAddrPool"] = tmp
        }
        if self.defaultAddrPoolType != nil {
            map["DefaultAddrPoolType"] = self.defaultAddrPoolType!
        }
        if self.defaultLatencyOptimization != nil {
            map["DefaultLatencyOptimization"] = self.defaultLatencyOptimization!
        }
        if self.defaultLbaStrategy != nil {
            map["DefaultLbaStrategy"] = self.defaultLbaStrategy!
        }
        if self.defaultMaxReturnAddrNum != nil {
            map["DefaultMaxReturnAddrNum"] = self.defaultMaxReturnAddrNum!
        }
        if self.defaultMinAvailableAddrNum != nil {
            map["DefaultMinAvailableAddrNum"] = self.defaultMinAvailableAddrNum!
        }
        if self.failoverAddrPool != nil {
            var tmp : [Any] = []
            for k in self.failoverAddrPool! {
                tmp.append(k.toMap())
            }
            map["FailoverAddrPool"] = tmp
        }
        if self.failoverAddrPoolType != nil {
            map["FailoverAddrPoolType"] = self.failoverAddrPoolType!
        }
        if self.failoverLatencyOptimization != nil {
            map["FailoverLatencyOptimization"] = self.failoverLatencyOptimization!
        }
        if self.failoverLbaStrategy != nil {
            map["FailoverLbaStrategy"] = self.failoverLbaStrategy!
        }
        if self.failoverMaxReturnAddrNum != nil {
            map["FailoverMaxReturnAddrNum"] = self.failoverMaxReturnAddrNum!
        }
        if self.failoverMinAvailableAddrNum != nil {
            map["FailoverMinAvailableAddrNum"] = self.failoverMinAvailableAddrNum!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lines != nil {
            map["Lines"] = self.lines!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefaultAddrPool") {
            var tmp : [AddDnsGtmAccessStrategyRequest.DefaultAddrPool] = []
            for v in dict["DefaultAddrPool"] as! [Any] {
                var model = AddDnsGtmAccessStrategyRequest.DefaultAddrPool()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.defaultAddrPool = tmp
        }
        if dict.keys.contains("DefaultAddrPoolType") {
            self.defaultAddrPoolType = dict["DefaultAddrPoolType"] as! String
        }
        if dict.keys.contains("DefaultLatencyOptimization") {
            self.defaultLatencyOptimization = dict["DefaultLatencyOptimization"] as! String
        }
        if dict.keys.contains("DefaultLbaStrategy") {
            self.defaultLbaStrategy = dict["DefaultLbaStrategy"] as! String
        }
        if dict.keys.contains("DefaultMaxReturnAddrNum") {
            self.defaultMaxReturnAddrNum = dict["DefaultMaxReturnAddrNum"] as! Int32
        }
        if dict.keys.contains("DefaultMinAvailableAddrNum") {
            self.defaultMinAvailableAddrNum = dict["DefaultMinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("FailoverAddrPool") {
            var tmp : [AddDnsGtmAccessStrategyRequest.FailoverAddrPool] = []
            for v in dict["FailoverAddrPool"] as! [Any] {
                var model = AddDnsGtmAccessStrategyRequest.FailoverAddrPool()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.failoverAddrPool = tmp
        }
        if dict.keys.contains("FailoverAddrPoolType") {
            self.failoverAddrPoolType = dict["FailoverAddrPoolType"] as! String
        }
        if dict.keys.contains("FailoverLatencyOptimization") {
            self.failoverLatencyOptimization = dict["FailoverLatencyOptimization"] as! String
        }
        if dict.keys.contains("FailoverLbaStrategy") {
            self.failoverLbaStrategy = dict["FailoverLbaStrategy"] as! String
        }
        if dict.keys.contains("FailoverMaxReturnAddrNum") {
            self.failoverMaxReturnAddrNum = dict["FailoverMaxReturnAddrNum"] as! Int32
        }
        if dict.keys.contains("FailoverMinAvailableAddrNum") {
            self.failoverMinAvailableAddrNum = dict["FailoverMinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Lines") {
            self.lines = dict["Lines"] as! String
        }
        if dict.keys.contains("StrategyMode") {
            self.strategyMode = dict["StrategyMode"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class AddDnsGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class AddDnsGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDnsGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDnsGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDnsGtmAddressPoolRequest : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public var addr: String?

        public var attributeInfo: String?

        public var lbaWeight: Int32?

        public var mode: String?

        public var remark: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                map["Addr"] = self.addr!
            }
            if self.attributeInfo != nil {
                map["AttributeInfo"] = self.attributeInfo!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Addr") {
                self.addr = dict["Addr"] as! String
            }
            if dict.keys.contains("AttributeInfo") {
                self.attributeInfo = dict["AttributeInfo"] as! String
            }
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! String
            }
            if dict.keys.contains("Remark") {
                self.remark = dict["Remark"] as! String
            }
        }
    }
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var addr: [AddDnsGtmAddressPoolRequest.Addr]?

    public var evaluationCount: Int32?

    public var instanceId: String?

    public var interval: Int32?

    public var ispCityNode: [AddDnsGtmAddressPoolRequest.IspCityNode]?

    public var lang: String?

    public var lbaStrategy: String?

    public var monitorExtendInfo: String?

    public var monitorStatus: String?

    public var name: String?

    public var protocolType: String?

    public var timeout: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            var tmp : [Any] = []
            for k in self.addr! {
                tmp.append(k.toMap())
            }
            map["Addr"] = tmp
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.monitorStatus != nil {
            map["MonitorStatus"] = self.monitorStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addr") {
            var tmp : [AddDnsGtmAddressPoolRequest.Addr] = []
            for v in dict["Addr"] as! [Any] {
                var model = AddDnsGtmAddressPoolRequest.Addr()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.addr = tmp
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNode") {
            var tmp : [AddDnsGtmAddressPoolRequest.IspCityNode] = []
            for v in dict["IspCityNode"] as! [Any] {
                var model = AddDnsGtmAddressPoolRequest.IspCityNode()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ispCityNode = tmp
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LbaStrategy") {
            self.lbaStrategy = dict["LbaStrategy"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("MonitorStatus") {
            self.monitorStatus = dict["MonitorStatus"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddDnsGtmAddressPoolResponseBody : Tea.TeaModel {
    public var addrPoolId: String?

    public var monitorConfigId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDnsGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDnsGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDnsGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDnsGtmMonitorRequest : Tea.TeaModel {
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var addrPoolId: String?

    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNode: [AddDnsGtmMonitorRequest.IspCityNode]?

    public var lang: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNode") {
            var tmp : [AddDnsGtmMonitorRequest.IspCityNode] = []
            for v in dict["IspCityNode"] as! [Any] {
                var model = AddDnsGtmMonitorRequest.IspCityNode()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ispCityNode = tmp
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class AddDnsGtmMonitorResponseBody : Tea.TeaModel {
    public var monitorConfigId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDnsGtmMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDnsGtmMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDnsGtmMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var lang: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class AddDomainResponseBody : Tea.TeaModel {
    public class DnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServer") {
                self.dnsServer = dict["DnsServer"] as! [String]
            }
        }
    }
    public var dnsServers: AddDomainResponseBody.DnsServers?

    public var domainId: String?

    public var domainName: String?

    public var groupId: String?

    public var groupName: String?

    public var punyCode: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dnsServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dnsServers != nil {
            map["DnsServers"] = self.dnsServers?.toMap()
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.punyCode != nil {
            map["PunyCode"] = self.punyCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DnsServers") {
            var model = AddDomainResponseBody.DnsServers()
            model.fromMap(dict["DnsServers"] as! [String: Any])
            self.dnsServers = model
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("PunyCode") {
            self.punyCode = dict["PunyCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDomainBackupRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var periodType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.periodType != nil {
            map["PeriodType"] = self.periodType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PeriodType") {
            self.periodType = dict["PeriodType"] as! String
        }
    }
}

public class AddDomainBackupResponseBody : Tea.TeaModel {
    public var domainName: String?

    public var periodType: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.periodType != nil {
            map["PeriodType"] = self.periodType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("PeriodType") {
            self.periodType = dict["PeriodType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDomainBackupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDomainBackupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDomainBackupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDomainGroupRequest : Tea.TeaModel {
    public var groupName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class AddDomainGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDomainGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDomainGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDomainGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDomainRecordRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var line: String?

    public var priority: Int64?

    public var RR: String?

    public var TTL: Int64?

    public var type: String?

    public var userClientIp: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.TTL != nil {
            map["TTL"] = self.TTL!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Line") {
            self.line = dict["Line"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int64
        }
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("TTL") {
            self.TTL = dict["TTL"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class AddDomainRecordResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDomainRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDomainRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDomainRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGtmAccessStrategyRequest : Tea.TeaModel {
    public var accessLines: String?

    public var defaultAddrPoolId: String?

    public var failoverAddrPoolId: String?

    public var instanceId: String?

    public var lang: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessLines != nil {
            map["AccessLines"] = self.accessLines!
        }
        if self.defaultAddrPoolId != nil {
            map["DefaultAddrPoolId"] = self.defaultAddrPoolId!
        }
        if self.failoverAddrPoolId != nil {
            map["FailoverAddrPoolId"] = self.failoverAddrPoolId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessLines") {
            self.accessLines = dict["AccessLines"] as! String
        }
        if dict.keys.contains("DefaultAddrPoolId") {
            self.defaultAddrPoolId = dict["DefaultAddrPoolId"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolId") {
            self.failoverAddrPoolId = dict["FailoverAddrPoolId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class AddGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class AddGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGtmAddressPoolRequest : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public var lbaWeight: Int32?

        public var mode: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var addr: [AddGtmAddressPoolRequest.Addr]?

    public var evaluationCount: Int32?

    public var instanceId: String?

    public var interval: Int32?

    public var ispCityNode: [AddGtmAddressPoolRequest.IspCityNode]?

    public var lang: String?

    public var minAvailableAddrNum: Int32?

    public var monitorExtendInfo: String?

    public var monitorStatus: String?

    public var name: String?

    public var protocolType: String?

    public var timeout: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            var tmp : [Any] = []
            for k in self.addr! {
                tmp.append(k.toMap())
            }
            map["Addr"] = tmp
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.minAvailableAddrNum != nil {
            map["MinAvailableAddrNum"] = self.minAvailableAddrNum!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.monitorStatus != nil {
            map["MonitorStatus"] = self.monitorStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addr") {
            var tmp : [AddGtmAddressPoolRequest.Addr] = []
            for v in dict["Addr"] as! [Any] {
                var model = AddGtmAddressPoolRequest.Addr()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.addr = tmp
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNode") {
            var tmp : [AddGtmAddressPoolRequest.IspCityNode] = []
            for v in dict["IspCityNode"] as! [Any] {
                var model = AddGtmAddressPoolRequest.IspCityNode()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ispCityNode = tmp
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MinAvailableAddrNum") {
            self.minAvailableAddrNum = dict["MinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("MonitorStatus") {
            self.monitorStatus = dict["MonitorStatus"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddGtmAddressPoolResponseBody : Tea.TeaModel {
    public var addrPoolId: String?

    public var monitorConfigId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGtmMonitorRequest : Tea.TeaModel {
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var addrPoolId: String?

    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNode: [AddGtmMonitorRequest.IspCityNode]?

    public var lang: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNode") {
            var tmp : [AddGtmMonitorRequest.IspCityNode] = []
            for v in dict["IspCityNode"] as! [Any] {
                var model = AddGtmMonitorRequest.IspCityNode()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ispCityNode = tmp
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class AddGtmMonitorResponseBody : Tea.TeaModel {
    public var monitorConfigId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddGtmMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGtmMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGtmMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddGtmRecoveryPlanRequest : Tea.TeaModel {
    public var faultAddrPool: String?

    public var lang: String?

    public var name: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.faultAddrPool != nil {
            map["FaultAddrPool"] = self.faultAddrPool!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FaultAddrPool") {
            self.faultAddrPool = dict["FaultAddrPool"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class AddGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var recoveryPlanId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindInstanceDomainsRequest : Tea.TeaModel {
    public var domainNames: String?

    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class BindInstanceDomainsResponseBody : Tea.TeaModel {
    public var failedCount: Int32?

    public var requestId: String?

    public var successCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedCount") {
            self.failedCount = dict["FailedCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessCount") {
            self.successCount = dict["SuccessCount"] as! Int32
        }
    }
}

public class BindInstanceDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindInstanceDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindInstanceDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeDomainGroupRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class ChangeDomainGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeDomainGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeDomainGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeDomainGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeDomainOfDnsProductRequest : Tea.TeaModel {
    public var force: Bool?

    public var instanceId: String?

    public var lang: String?

    public var newDomain: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.newDomain != nil {
            map["NewDomain"] = self.newDomain!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NewDomain") {
            self.newDomain = dict["NewDomain"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class ChangeDomainOfDnsProductResponseBody : Tea.TeaModel {
    public var originalDomain: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.originalDomain != nil {
            map["OriginalDomain"] = self.originalDomain!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OriginalDomain") {
            self.originalDomain = dict["OriginalDomain"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeDomainOfDnsProductResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeDomainOfDnsProductResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeDomainOfDnsProductResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopyGtmConfigRequest : Tea.TeaModel {
    public var copyType: String?

    public var lang: String?

    public var sourceId: String?

    public var targetId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.copyType != nil {
            map["CopyType"] = self.copyType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceId != nil {
            map["SourceId"] = self.sourceId!
        }
        if self.targetId != nil {
            map["TargetId"] = self.targetId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CopyType") {
            self.copyType = dict["CopyType"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceId") {
            self.sourceId = dict["SourceId"] as! String
        }
        if dict.keys.contains("TargetId") {
            self.targetId = dict["TargetId"] as! String
        }
    }
}

public class CopyGtmConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CopyGtmConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyGtmConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CopyGtmConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCloudGtmAddressRequest : Tea.TeaModel {
    public class HealthTasks : Tea.TeaModel {
        public var port: Int32?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var address: String?

    public var attributeInfo: String?

    public var availableMode: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var healthJudgement: String?

    public var healthTasks: [CreateCloudGtmAddressRequest.HealthTasks]?

    public var manualAvailableStatus: String?

    public var name: String?

    public var remark: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.attributeInfo != nil {
            map["AttributeInfo"] = self.attributeInfo!
        }
        if self.availableMode != nil {
            map["AvailableMode"] = self.availableMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.healthTasks != nil {
            var tmp : [Any] = []
            for k in self.healthTasks! {
                tmp.append(k.toMap())
            }
            map["HealthTasks"] = tmp
        }
        if self.manualAvailableStatus != nil {
            map["ManualAvailableStatus"] = self.manualAvailableStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("AttributeInfo") {
            self.attributeInfo = dict["AttributeInfo"] as! String
        }
        if dict.keys.contains("AvailableMode") {
            self.availableMode = dict["AvailableMode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("HealthJudgement") {
            self.healthJudgement = dict["HealthJudgement"] as! String
        }
        if dict.keys.contains("HealthTasks") {
            var tmp : [CreateCloudGtmAddressRequest.HealthTasks] = []
            for v in dict["HealthTasks"] as! [Any] {
                var model = CreateCloudGtmAddressRequest.HealthTasks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.healthTasks = tmp
        }
        if dict.keys.contains("ManualAvailableStatus") {
            self.manualAvailableStatus = dict["ManualAvailableStatus"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateCloudGtmAddressShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var attributeInfo: String?

    public var availableMode: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var healthJudgement: String?

    public var healthTasksShrink: String?

    public var manualAvailableStatus: String?

    public var name: String?

    public var remark: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.attributeInfo != nil {
            map["AttributeInfo"] = self.attributeInfo!
        }
        if self.availableMode != nil {
            map["AvailableMode"] = self.availableMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.healthTasksShrink != nil {
            map["HealthTasks"] = self.healthTasksShrink!
        }
        if self.manualAvailableStatus != nil {
            map["ManualAvailableStatus"] = self.manualAvailableStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("AttributeInfo") {
            self.attributeInfo = dict["AttributeInfo"] as! String
        }
        if dict.keys.contains("AvailableMode") {
            self.availableMode = dict["AvailableMode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("HealthJudgement") {
            self.healthJudgement = dict["HealthJudgement"] as! String
        }
        if dict.keys.contains("HealthTasks") {
            self.healthTasksShrink = dict["HealthTasks"] as! String
        }
        if dict.keys.contains("ManualAvailableStatus") {
            self.manualAvailableStatus = dict["ManualAvailableStatus"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateCloudGtmAddressResponseBody : Tea.TeaModel {
    public var addressId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressId") {
            self.addressId = dict["AddressId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateCloudGtmAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudGtmAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCloudGtmAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCloudGtmAddressPoolRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolName: String?

    public var addressPoolType: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var healthJudgement: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolName != nil {
            map["AddressPoolName"] = self.addressPoolName!
        }
        if self.addressPoolType != nil {
            map["AddressPoolType"] = self.addressPoolType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPoolName") {
            self.addressPoolName = dict["AddressPoolName"] as! String
        }
        if dict.keys.contains("AddressPoolType") {
            self.addressPoolType = dict["AddressPoolType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("HealthJudgement") {
            self.healthJudgement = dict["HealthJudgement"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class CreateCloudGtmAddressPoolResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateCloudGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCloudGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCloudGtmInstanceConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var instanceId: String?

    public var remark: String?

    public var scheduleHostname: String?

    public var scheduleRrType: String?

    public var scheduleZoneMode: String?

    public var scheduleZoneName: String?

    public var ttl: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.scheduleHostname != nil {
            map["ScheduleHostname"] = self.scheduleHostname!
        }
        if self.scheduleRrType != nil {
            map["ScheduleRrType"] = self.scheduleRrType!
        }
        if self.scheduleZoneMode != nil {
            map["ScheduleZoneMode"] = self.scheduleZoneMode!
        }
        if self.scheduleZoneName != nil {
            map["ScheduleZoneName"] = self.scheduleZoneName!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("ScheduleHostname") {
            self.scheduleHostname = dict["ScheduleHostname"] as! String
        }
        if dict.keys.contains("ScheduleRrType") {
            self.scheduleRrType = dict["ScheduleRrType"] as! String
        }
        if dict.keys.contains("ScheduleZoneMode") {
            self.scheduleZoneMode = dict["ScheduleZoneMode"] as! String
        }
        if dict.keys.contains("ScheduleZoneName") {
            self.scheduleZoneName = dict["ScheduleZoneName"] as! String
        }
        if dict.keys.contains("Ttl") {
            self.ttl = dict["Ttl"] as! Int32
        }
    }
}

public class CreateCloudGtmInstanceConfigResponseBody : Tea.TeaModel {
    public var configId: Bool?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateCloudGtmInstanceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudGtmInstanceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCloudGtmInstanceConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCloudGtmMonitorTemplateRequest : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var clientToken: String?

    public var evaluationCount: Int32?

    public var extendInfo: String?

    public var failureRate: Int32?

    public var interval: Int32?

    public var ipVersion: String?

    public var ispCityNodes: [CreateCloudGtmMonitorTemplateRequest.IspCityNodes]?

    public var name: String?

    public var protocol_: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.failureRate != nil {
            map["FailureRate"] = self.failureRate!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ispCityNodes != nil {
            var tmp : [Any] = []
            for k in self.ispCityNodes! {
                tmp.append(k.toMap())
            }
            map["IspCityNodes"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("ExtendInfo") {
            self.extendInfo = dict["ExtendInfo"] as! String
        }
        if dict.keys.contains("FailureRate") {
            self.failureRate = dict["FailureRate"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("IspCityNodes") {
            var tmp : [CreateCloudGtmMonitorTemplateRequest.IspCityNodes] = []
            for v in dict["IspCityNodes"] as! [Any] {
                var model = CreateCloudGtmMonitorTemplateRequest.IspCityNodes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ispCityNodes = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class CreateCloudGtmMonitorTemplateShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var evaluationCount: Int32?

    public var extendInfo: String?

    public var failureRate: Int32?

    public var interval: Int32?

    public var ipVersion: String?

    public var ispCityNodesShrink: String?

    public var name: String?

    public var protocol_: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.failureRate != nil {
            map["FailureRate"] = self.failureRate!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ispCityNodesShrink != nil {
            map["IspCityNodes"] = self.ispCityNodesShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("ExtendInfo") {
            self.extendInfo = dict["ExtendInfo"] as! String
        }
        if dict.keys.contains("FailureRate") {
            self.failureRate = dict["FailureRate"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("IspCityNodes") {
            self.ispCityNodesShrink = dict["IspCityNodes"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class CreateCloudGtmMonitorTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateCloudGtmMonitorTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudGtmMonitorTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCloudGtmMonitorTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePdnsAppKeyRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class CreatePdnsAppKeyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePdnsAppKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePdnsAppKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePdnsAppKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePdnsUdpIpSegmentRequest : Tea.TeaModel {
    public var ip: String?

    public var ipToken: String?

    public var lang: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.ipToken != nil {
            map["IpToken"] = self.ipToken!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("IpToken") {
            self.ipToken = dict["IpToken"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class CreatePdnsUdpIpSegmentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var validMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.validMessage != nil {
            map["ValidMessage"] = self.validMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ValidMessage") {
            self.validMessage = dict["ValidMessage"] as! String
        }
    }
}

public class CreatePdnsUdpIpSegmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePdnsUdpIpSegmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePdnsUdpIpSegmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCloudGtmAddressRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressId") {
            self.addressId = dict["AddressId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class DeleteCloudGtmAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCloudGtmAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCloudGtmAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCloudGtmAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCloudGtmAddressPoolRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class DeleteCloudGtmAddressPoolResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCloudGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCloudGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCloudGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCloudGtmInstanceConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DeleteCloudGtmInstanceConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCloudGtmInstanceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCloudGtmInstanceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCloudGtmInstanceConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCloudGtmMonitorTemplateRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteCloudGtmMonitorTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCloudGtmMonitorTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCloudGtmMonitorTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCloudGtmMonitorTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomLinesRequest : Tea.TeaModel {
    public var lang: String?

    public var lineIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lineIds != nil {
            map["LineIds"] = self.lineIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LineIds") {
            self.lineIds = dict["LineIds"] as! String
        }
    }
}

public class DeleteCustomLinesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomLinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomLinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustomLinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDnsCacheDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DeleteDnsCacheDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDnsCacheDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDnsCacheDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDnsCacheDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDnsGtmAccessStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class DeleteDnsGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDnsGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDnsGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDnsGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDnsGtmAddressPoolRequest : Tea.TeaModel {
    public var addrPoolId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DeleteDnsGtmAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDnsGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDnsGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDnsGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DeleteDomainResponseBody : Tea.TeaModel {
    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDomainGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DeleteDomainGroupResponseBody : Tea.TeaModel {
    public var groupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDomainGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDomainGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDomainRecordRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DeleteDomainRecordResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDomainRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDomainRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGtmAccessStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class DeleteGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGtmAddressPoolRequest : Tea.TeaModel {
    public var addrPoolId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DeleteGtmAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
    }
}

public class DeleteGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSubDomainRecordsRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var RR: String?

    public var type: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DeleteSubDomainRecordsResponseBody : Tea.TeaModel {
    public var RR: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DeleteSubDomainRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSubDomainRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSubDomainRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBatchResultCountRequest : Tea.TeaModel {
    public var batchType: String?

    public var lang: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchType != nil {
            map["BatchType"] = self.batchType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchType") {
            self.batchType = dict["BatchType"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class DescribeBatchResultCountResponseBody : Tea.TeaModel {
    public var batchType: String?

    public var failedCount: Int32?

    public var reason: String?

    public var requestId: String?

    public var status: Int32?

    public var successCount: Int32?

    public var taskId: Int64?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchType != nil {
            map["BatchType"] = self.batchType!
        }
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchType") {
            self.batchType = dict["BatchType"] as! String
        }
        if dict.keys.contains("FailedCount") {
            self.failedCount = dict["FailedCount"] as! Int32
        }
        if dict.keys.contains("Reason") {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("SuccessCount") {
            self.successCount = dict["SuccessCount"] as! Int32
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeBatchResultCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBatchResultCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBatchResultCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBatchResultDetailRequest : Tea.TeaModel {
    public var batchType: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchType != nil {
            map["BatchType"] = self.batchType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchType") {
            self.batchType = dict["BatchType"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class DescribeBatchResultDetailResponseBody : Tea.TeaModel {
    public class BatchResultDetails : Tea.TeaModel {
        public class BatchResultDetail : Tea.TeaModel {
            public var batchType: String?

            public var domain: String?

            public var line: String?

            public var newRr: String?

            public var newValue: String?

            public var operateDateStr: String?

            public var priority: String?

            public var reason: String?

            public var recordId: String?

            public var remark: String?

            public var rr: String?

            public var rrStatus: String?

            public var status: Bool?

            public var ttl: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchType != nil {
                    map["BatchType"] = self.batchType!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.line != nil {
                    map["Line"] = self.line!
                }
                if self.newRr != nil {
                    map["NewRr"] = self.newRr!
                }
                if self.newValue != nil {
                    map["NewValue"] = self.newValue!
                }
                if self.operateDateStr != nil {
                    map["OperateDateStr"] = self.operateDateStr!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.rr != nil {
                    map["Rr"] = self.rr!
                }
                if self.rrStatus != nil {
                    map["RrStatus"] = self.rrStatus!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BatchType") {
                    self.batchType = dict["BatchType"] as! String
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("Line") {
                    self.line = dict["Line"] as! String
                }
                if dict.keys.contains("NewRr") {
                    self.newRr = dict["NewRr"] as! String
                }
                if dict.keys.contains("NewValue") {
                    self.newValue = dict["NewValue"] as! String
                }
                if dict.keys.contains("OperateDateStr") {
                    self.operateDateStr = dict["OperateDateStr"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! String
                }
                if dict.keys.contains("Reason") {
                    self.reason = dict["Reason"] as! String
                }
                if dict.keys.contains("RecordId") {
                    self.recordId = dict["RecordId"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("Rr") {
                    self.rr = dict["Rr"] as! String
                }
                if dict.keys.contains("RrStatus") {
                    self.rrStatus = dict["RrStatus"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Bool
                }
                if dict.keys.contains("Ttl") {
                    self.ttl = dict["Ttl"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var batchResultDetail: [DescribeBatchResultDetailResponseBody.BatchResultDetails.BatchResultDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchResultDetail != nil {
                var tmp : [Any] = []
                for k in self.batchResultDetail! {
                    tmp.append(k.toMap())
                }
                map["BatchResultDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BatchResultDetail") {
                var tmp : [DescribeBatchResultDetailResponseBody.BatchResultDetails.BatchResultDetail] = []
                for v in dict["BatchResultDetail"] as! [Any] {
                    var model = DescribeBatchResultDetailResponseBody.BatchResultDetails.BatchResultDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.batchResultDetail = tmp
            }
        }
    }
    public var batchResultDetails: DescribeBatchResultDetailResponseBody.BatchResultDetails?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.batchResultDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchResultDetails != nil {
            map["BatchResultDetails"] = self.batchResultDetails?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchResultDetails") {
            var model = DescribeBatchResultDetailResponseBody.BatchResultDetails()
            model.fromMap(dict["BatchResultDetails"] as! [String: Any])
            self.batchResultDetails = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeBatchResultDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBatchResultDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBatchResultDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudGtmAddressRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressId") {
            self.addressId = dict["AddressId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class DescribeCloudGtmAddressResponseBody : Tea.TeaModel {
    public class HealthTasks : Tea.TeaModel {
        public class HealthTask : Tea.TeaModel {
            public var monitorStatus: String?

            public var port: Int32?

            public var templateId: String?

            public var templateName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.monitorStatus != nil {
                    map["MonitorStatus"] = self.monitorStatus!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MonitorStatus") {
                    self.monitorStatus = dict["MonitorStatus"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! String
                }
                if dict.keys.contains("TemplateName") {
                    self.templateName = dict["TemplateName"] as! String
                }
            }
        }
        public var healthTask: [DescribeCloudGtmAddressResponseBody.HealthTasks.HealthTask]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.healthTask != nil {
                var tmp : [Any] = []
                for k in self.healthTask! {
                    tmp.append(k.toMap())
                }
                map["HealthTask"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HealthTask") {
                var tmp : [DescribeCloudGtmAddressResponseBody.HealthTasks.HealthTask] = []
                for v in dict["HealthTask"] as! [Any] {
                    var model = DescribeCloudGtmAddressResponseBody.HealthTasks.HealthTask()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.healthTask = tmp
            }
        }
    }
    public var address: String?

    public var addressId: String?

    public var attributeInfo: String?

    public var availableMode: String?

    public var availableStatus: String?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var enableStatus: String?

    public var healthJudgement: String?

    public var healthStatus: String?

    public var healthTasks: DescribeCloudGtmAddressResponseBody.HealthTasks?

    public var manualAvailableStatus: String?

    public var name: String?

    public var remark: String?

    public var requestId: String?

    public var type: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.healthTasks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.attributeInfo != nil {
            map["AttributeInfo"] = self.attributeInfo!
        }
        if self.availableMode != nil {
            map["AvailableMode"] = self.availableMode!
        }
        if self.availableStatus != nil {
            map["AvailableStatus"] = self.availableStatus!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.healthTasks != nil {
            map["HealthTasks"] = self.healthTasks?.toMap()
        }
        if self.manualAvailableStatus != nil {
            map["ManualAvailableStatus"] = self.manualAvailableStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("AddressId") {
            self.addressId = dict["AddressId"] as! String
        }
        if dict.keys.contains("AttributeInfo") {
            self.attributeInfo = dict["AttributeInfo"] as! String
        }
        if dict.keys.contains("AvailableMode") {
            self.availableMode = dict["AvailableMode"] as! String
        }
        if dict.keys.contains("AvailableStatus") {
            self.availableStatus = dict["AvailableStatus"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("HealthJudgement") {
            self.healthJudgement = dict["HealthJudgement"] as! String
        }
        if dict.keys.contains("HealthStatus") {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("HealthTasks") {
            var model = DescribeCloudGtmAddressResponseBody.HealthTasks()
            model.fromMap(dict["HealthTasks"] as! [String: Any])
            self.healthTasks = model
        }
        if dict.keys.contains("ManualAvailableStatus") {
            self.manualAvailableStatus = dict["ManualAvailableStatus"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
    }
}

public class DescribeCloudGtmAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudGtmAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudGtmAddressPoolRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class DescribeCloudGtmAddressPoolResponseBody : Tea.TeaModel {
    public class Addresses : Tea.TeaModel {
        public class Address : Tea.TeaModel {
            public class HealthTasks : Tea.TeaModel {
                public class HealthTask : Tea.TeaModel {
                    public var port: Int32?

                    public var templateId: String?

                    public var templateName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        if self.templateName != nil {
                            map["TemplateName"] = self.templateName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                        if dict.keys.contains("TemplateName") {
                            self.templateName = dict["TemplateName"] as! String
                        }
                    }
                }
                public var healthTask: [DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.HealthTasks.HealthTask]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.healthTask != nil {
                        var tmp : [Any] = []
                        for k in self.healthTask! {
                            tmp.append(k.toMap())
                        }
                        map["HealthTask"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HealthTask") {
                        var tmp : [DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.HealthTasks.HealthTask] = []
                        for v in dict["HealthTask"] as! [Any] {
                            var model = DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.HealthTasks.HealthTask()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.healthTask = tmp
                    }
                }
            }
            public class RequestSource : Tea.TeaModel {
                public var requestSource: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.requestSource != nil {
                        map["RequestSource"] = self.requestSource!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RequestSource") {
                        self.requestSource = dict["RequestSource"] as! [String]
                    }
                }
            }
            public var address: String?

            public var addressId: String?

            public var attributeInfo: String?

            public var availableMode: String?

            public var availableStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var healthTasks: DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.HealthTasks?

            public var manualAvailableStatus: String?

            public var name: String?

            public var remark: String?

            public var requestSource: DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.RequestSource?

            public var seqNonPreemptiveSchedule: Bool?

            public var serialNumber: Int32?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var weightValue: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.healthTasks?.validate()
                try self.requestSource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.addressId != nil {
                    map["AddressId"] = self.addressId!
                }
                if self.attributeInfo != nil {
                    map["AttributeInfo"] = self.attributeInfo!
                }
                if self.availableMode != nil {
                    map["AvailableMode"] = self.availableMode!
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.healthTasks != nil {
                    map["HealthTasks"] = self.healthTasks?.toMap()
                }
                if self.manualAvailableStatus != nil {
                    map["ManualAvailableStatus"] = self.manualAvailableStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.requestSource != nil {
                    map["RequestSource"] = self.requestSource?.toMap()
                }
                if self.seqNonPreemptiveSchedule != nil {
                    map["SeqNonPreemptiveSchedule"] = self.seqNonPreemptiveSchedule!
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.weightValue != nil {
                    map["WeightValue"] = self.weightValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("AddressId") {
                    self.addressId = dict["AddressId"] as! String
                }
                if dict.keys.contains("AttributeInfo") {
                    self.attributeInfo = dict["AttributeInfo"] as! String
                }
                if dict.keys.contains("AvailableMode") {
                    self.availableMode = dict["AvailableMode"] as! String
                }
                if dict.keys.contains("AvailableStatus") {
                    self.availableStatus = dict["AvailableStatus"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("EnableStatus") {
                    self.enableStatus = dict["EnableStatus"] as! String
                }
                if dict.keys.contains("HealthJudgement") {
                    self.healthJudgement = dict["HealthJudgement"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("HealthTasks") {
                    var model = DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.HealthTasks()
                    model.fromMap(dict["HealthTasks"] as! [String: Any])
                    self.healthTasks = model
                }
                if dict.keys.contains("ManualAvailableStatus") {
                    self.manualAvailableStatus = dict["ManualAvailableStatus"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("RequestSource") {
                    var model = DescribeCloudGtmAddressPoolResponseBody.Addresses.Address.RequestSource()
                    model.fromMap(dict["RequestSource"] as! [String: Any])
                    self.requestSource = model
                }
                if dict.keys.contains("SeqNonPreemptiveSchedule") {
                    self.seqNonPreemptiveSchedule = dict["SeqNonPreemptiveSchedule"] as! Bool
                }
                if dict.keys.contains("SerialNumber") {
                    self.serialNumber = dict["SerialNumber"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
                if dict.keys.contains("WeightValue") {
                    self.weightValue = dict["WeightValue"] as! Int32
                }
            }
        }
        public var address: [DescribeCloudGtmAddressPoolResponseBody.Addresses.Address]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                var tmp : [Any] = []
                for k in self.address! {
                    tmp.append(k.toMap())
                }
                map["Address"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") {
                var tmp : [DescribeCloudGtmAddressPoolResponseBody.Addresses.Address] = []
                for v in dict["Address"] as! [Any] {
                    var model = DescribeCloudGtmAddressPoolResponseBody.Addresses.Address()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.address = tmp
            }
        }
    }
    public var addressLbStrategy: String?

    public var addressPoolId: String?

    public var addressPoolName: String?

    public var addressPoolType: String?

    public var addresses: DescribeCloudGtmAddressPoolResponseBody.Addresses?

    public var availableStatus: String?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var enableStatus: String?

    public var healthJudgement: String?

    public var healthStatus: String?

    public var remark: String?

    public var requestId: String?

    public var sequenceLbStrategyMode: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressLbStrategy != nil {
            map["AddressLbStrategy"] = self.addressLbStrategy!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.addressPoolName != nil {
            map["AddressPoolName"] = self.addressPoolName!
        }
        if self.addressPoolType != nil {
            map["AddressPoolType"] = self.addressPoolType!
        }
        if self.addresses != nil {
            map["Addresses"] = self.addresses?.toMap()
        }
        if self.availableStatus != nil {
            map["AvailableStatus"] = self.availableStatus!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sequenceLbStrategyMode != nil {
            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressLbStrategy") {
            self.addressLbStrategy = dict["AddressLbStrategy"] as! String
        }
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("AddressPoolName") {
            self.addressPoolName = dict["AddressPoolName"] as! String
        }
        if dict.keys.contains("AddressPoolType") {
            self.addressPoolType = dict["AddressPoolType"] as! String
        }
        if dict.keys.contains("Addresses") {
            var model = DescribeCloudGtmAddressPoolResponseBody.Addresses()
            model.fromMap(dict["Addresses"] as! [String: Any])
            self.addresses = model
        }
        if dict.keys.contains("AvailableStatus") {
            self.availableStatus = dict["AvailableStatus"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("HealthJudgement") {
            self.healthJudgement = dict["HealthJudgement"] as! String
        }
        if dict.keys.contains("HealthStatus") {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SequenceLbStrategyMode") {
            self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
    }
}

public class DescribeCloudGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudGtmAddressPoolReferenceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class DescribeCloudGtmAddressPoolReferenceResponseBody : Tea.TeaModel {
    public class InstanceConfigs : Tea.TeaModel {
        public class InstanceConfig : Tea.TeaModel {
            public var addressPoolLbStrategy: String?

            public var availableStatus: String?

            public var configId: String?

            public var enableStatus: String?

            public var healthStatus: String?

            public var instanceId: String?

            public var instanceName: String?

            public var remark: String?

            public var scheduleDomainName: String?

            public var scheduleHostname: String?

            public var scheduleRrType: String?

            public var scheduleZoneName: String?

            public var sequenceLbStrategyMode: String?

            public var ttl: Int32?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressPoolLbStrategy != nil {
                    map["AddressPoolLbStrategy"] = self.addressPoolLbStrategy!
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.configId != nil {
                    map["ConfigId"] = self.configId!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.scheduleDomainName != nil {
                    map["ScheduleDomainName"] = self.scheduleDomainName!
                }
                if self.scheduleHostname != nil {
                    map["ScheduleHostname"] = self.scheduleHostname!
                }
                if self.scheduleRrType != nil {
                    map["ScheduleRrType"] = self.scheduleRrType!
                }
                if self.scheduleZoneName != nil {
                    map["ScheduleZoneName"] = self.scheduleZoneName!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddressPoolLbStrategy") {
                    self.addressPoolLbStrategy = dict["AddressPoolLbStrategy"] as! String
                }
                if dict.keys.contains("AvailableStatus") {
                    self.availableStatus = dict["AvailableStatus"] as! String
                }
                if dict.keys.contains("ConfigId") {
                    self.configId = dict["ConfigId"] as! String
                }
                if dict.keys.contains("EnableStatus") {
                    self.enableStatus = dict["EnableStatus"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("ScheduleDomainName") {
                    self.scheduleDomainName = dict["ScheduleDomainName"] as! String
                }
                if dict.keys.contains("ScheduleHostname") {
                    self.scheduleHostname = dict["ScheduleHostname"] as! String
                }
                if dict.keys.contains("ScheduleRrType") {
                    self.scheduleRrType = dict["ScheduleRrType"] as! String
                }
                if dict.keys.contains("ScheduleZoneName") {
                    self.scheduleZoneName = dict["ScheduleZoneName"] as! String
                }
                if dict.keys.contains("SequenceLbStrategyMode") {
                    self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
                }
                if dict.keys.contains("Ttl") {
                    self.ttl = dict["Ttl"] as! Int32
                }
                if dict.keys.contains("VersionCode") {
                    self.versionCode = dict["VersionCode"] as! String
                }
            }
        }
        public var instanceConfig: [DescribeCloudGtmAddressPoolReferenceResponseBody.InstanceConfigs.InstanceConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceConfig != nil {
                var tmp : [Any] = []
                for k in self.instanceConfig! {
                    tmp.append(k.toMap())
                }
                map["InstanceConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceConfig") {
                var tmp : [DescribeCloudGtmAddressPoolReferenceResponseBody.InstanceConfigs.InstanceConfig] = []
                for v in dict["InstanceConfig"] as! [Any] {
                    var model = DescribeCloudGtmAddressPoolReferenceResponseBody.InstanceConfigs.InstanceConfig()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceConfig = tmp
            }
        }
    }
    public var addressPoolId: String?

    public var addressPoolName: String?

    public var instanceConfigs: DescribeCloudGtmAddressPoolReferenceResponseBody.InstanceConfigs?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.addressPoolName != nil {
            map["AddressPoolName"] = self.addressPoolName!
        }
        if self.instanceConfigs != nil {
            map["InstanceConfigs"] = self.instanceConfigs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("AddressPoolName") {
            self.addressPoolName = dict["AddressPoolName"] as! String
        }
        if dict.keys.contains("InstanceConfigs") {
            var model = DescribeCloudGtmAddressPoolReferenceResponseBody.InstanceConfigs()
            model.fromMap(dict["InstanceConfigs"] as! [String: Any])
            self.instanceConfigs = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCloudGtmAddressPoolReferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmAddressPoolReferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudGtmAddressPoolReferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudGtmAddressReferenceRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressId") {
            self.addressId = dict["AddressId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class DescribeCloudGtmAddressReferenceResponseBody : Tea.TeaModel {
    public class AddressPools : Tea.TeaModel {
        public class AddressPool : Tea.TeaModel {
            public class InstanceConfigs : Tea.TeaModel {
                public class InstanceConfig : Tea.TeaModel {
                    public var addressPoolLbStrategy: String?

                    public var availableStatus: String?

                    public var configId: String?

                    public var enableStatus: String?

                    public var healthStatus: String?

                    public var instanceId: String?

                    public var instanceName: String?

                    public var remark: String?

                    public var scheduleDomainName: String?

                    public var scheduleHostname: String?

                    public var scheduleRrType: String?

                    public var scheduleZoneName: String?

                    public var sequenceLbStrategyMode: String?

                    public var ttl: Int32?

                    public var versionCode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.addressPoolLbStrategy != nil {
                            map["AddressPoolLbStrategy"] = self.addressPoolLbStrategy!
                        }
                        if self.availableStatus != nil {
                            map["AvailableStatus"] = self.availableStatus!
                        }
                        if self.configId != nil {
                            map["ConfigId"] = self.configId!
                        }
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.healthStatus != nil {
                            map["HealthStatus"] = self.healthStatus!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.instanceName != nil {
                            map["InstanceName"] = self.instanceName!
                        }
                        if self.remark != nil {
                            map["Remark"] = self.remark!
                        }
                        if self.scheduleDomainName != nil {
                            map["ScheduleDomainName"] = self.scheduleDomainName!
                        }
                        if self.scheduleHostname != nil {
                            map["ScheduleHostname"] = self.scheduleHostname!
                        }
                        if self.scheduleRrType != nil {
                            map["ScheduleRrType"] = self.scheduleRrType!
                        }
                        if self.scheduleZoneName != nil {
                            map["ScheduleZoneName"] = self.scheduleZoneName!
                        }
                        if self.sequenceLbStrategyMode != nil {
                            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                        }
                        if self.ttl != nil {
                            map["Ttl"] = self.ttl!
                        }
                        if self.versionCode != nil {
                            map["VersionCode"] = self.versionCode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AddressPoolLbStrategy") {
                            self.addressPoolLbStrategy = dict["AddressPoolLbStrategy"] as! String
                        }
                        if dict.keys.contains("AvailableStatus") {
                            self.availableStatus = dict["AvailableStatus"] as! String
                        }
                        if dict.keys.contains("ConfigId") {
                            self.configId = dict["ConfigId"] as! String
                        }
                        if dict.keys.contains("EnableStatus") {
                            self.enableStatus = dict["EnableStatus"] as! String
                        }
                        if dict.keys.contains("HealthStatus") {
                            self.healthStatus = dict["HealthStatus"] as! String
                        }
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("InstanceName") {
                            self.instanceName = dict["InstanceName"] as! String
                        }
                        if dict.keys.contains("Remark") {
                            self.remark = dict["Remark"] as! String
                        }
                        if dict.keys.contains("ScheduleDomainName") {
                            self.scheduleDomainName = dict["ScheduleDomainName"] as! String
                        }
                        if dict.keys.contains("ScheduleHostname") {
                            self.scheduleHostname = dict["ScheduleHostname"] as! String
                        }
                        if dict.keys.contains("ScheduleRrType") {
                            self.scheduleRrType = dict["ScheduleRrType"] as! String
                        }
                        if dict.keys.contains("ScheduleZoneName") {
                            self.scheduleZoneName = dict["ScheduleZoneName"] as! String
                        }
                        if dict.keys.contains("SequenceLbStrategyMode") {
                            self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
                        }
                        if dict.keys.contains("Ttl") {
                            self.ttl = dict["Ttl"] as! Int32
                        }
                        if dict.keys.contains("VersionCode") {
                            self.versionCode = dict["VersionCode"] as! String
                        }
                    }
                }
                public var instanceConfig: [DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool.InstanceConfigs.InstanceConfig]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceConfig != nil {
                        var tmp : [Any] = []
                        for k in self.instanceConfig! {
                            tmp.append(k.toMap())
                        }
                        map["InstanceConfig"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceConfig") {
                        var tmp : [DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool.InstanceConfigs.InstanceConfig] = []
                        for v in dict["InstanceConfig"] as! [Any] {
                            var model = DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool.InstanceConfigs.InstanceConfig()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.instanceConfig = tmp
                    }
                }
            }
            public var addressLbStrategy: String?

            public var addressPoolId: String?

            public var addressPoolName: String?

            public var addressPoolType: String?

            public var availableStatus: String?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var instanceConfigs: DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool.InstanceConfigs?

            public var remark: String?

            public var sequenceLbStrategyMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.instanceConfigs?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressLbStrategy != nil {
                    map["AddressLbStrategy"] = self.addressLbStrategy!
                }
                if self.addressPoolId != nil {
                    map["AddressPoolId"] = self.addressPoolId!
                }
                if self.addressPoolName != nil {
                    map["AddressPoolName"] = self.addressPoolName!
                }
                if self.addressPoolType != nil {
                    map["AddressPoolType"] = self.addressPoolType!
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.instanceConfigs != nil {
                    map["InstanceConfigs"] = self.instanceConfigs?.toMap()
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddressLbStrategy") {
                    self.addressLbStrategy = dict["AddressLbStrategy"] as! String
                }
                if dict.keys.contains("AddressPoolId") {
                    self.addressPoolId = dict["AddressPoolId"] as! String
                }
                if dict.keys.contains("AddressPoolName") {
                    self.addressPoolName = dict["AddressPoolName"] as! String
                }
                if dict.keys.contains("AddressPoolType") {
                    self.addressPoolType = dict["AddressPoolType"] as! String
                }
                if dict.keys.contains("AvailableStatus") {
                    self.availableStatus = dict["AvailableStatus"] as! String
                }
                if dict.keys.contains("EnableStatus") {
                    self.enableStatus = dict["EnableStatus"] as! String
                }
                if dict.keys.contains("HealthJudgement") {
                    self.healthJudgement = dict["HealthJudgement"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("InstanceConfigs") {
                    var model = DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool.InstanceConfigs()
                    model.fromMap(dict["InstanceConfigs"] as! [String: Any])
                    self.instanceConfigs = model
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("SequenceLbStrategyMode") {
                    self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
                }
            }
        }
        public var addressPool: [DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressPool != nil {
                var tmp : [Any] = []
                for k in self.addressPool! {
                    tmp.append(k.toMap())
                }
                map["AddressPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddressPool") {
                var tmp : [DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool] = []
                for v in dict["AddressPool"] as! [Any] {
                    var model = DescribeCloudGtmAddressReferenceResponseBody.AddressPools.AddressPool()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.addressPool = tmp
            }
        }
    }
    public var address: String?

    public var addressId: String?

    public var addressPools: DescribeCloudGtmAddressReferenceResponseBody.AddressPools?

    public var name: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addressPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.addressPools != nil {
            map["AddressPools"] = self.addressPools?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("AddressId") {
            self.addressId = dict["AddressId"] as! String
        }
        if dict.keys.contains("AddressPools") {
            var model = DescribeCloudGtmAddressReferenceResponseBody.AddressPools()
            model.fromMap(dict["AddressPools"] as! [String: Any])
            self.addressPools = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCloudGtmAddressReferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmAddressReferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudGtmAddressReferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudGtmGlobalAlertRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class DescribeCloudGtmGlobalAlertResponseBody : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public class AlertConfig : Tea.TeaModel {
            public var dingtalkNotice: Bool?

            public var emailNotice: Bool?

            public var noticeType: String?

            public var smsNotice: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dingtalkNotice != nil {
                    map["DingtalkNotice"] = self.dingtalkNotice!
                }
                if self.emailNotice != nil {
                    map["EmailNotice"] = self.emailNotice!
                }
                if self.noticeType != nil {
                    map["NoticeType"] = self.noticeType!
                }
                if self.smsNotice != nil {
                    map["SmsNotice"] = self.smsNotice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DingtalkNotice") {
                    self.dingtalkNotice = dict["DingtalkNotice"] as! Bool
                }
                if dict.keys.contains("EmailNotice") {
                    self.emailNotice = dict["EmailNotice"] as! Bool
                }
                if dict.keys.contains("NoticeType") {
                    self.noticeType = dict["NoticeType"] as! String
                }
                if dict.keys.contains("SmsNotice") {
                    self.smsNotice = dict["SmsNotice"] as! Bool
                }
            }
        }
        public var alertConfig: [DescribeCloudGtmGlobalAlertResponseBody.AlertConfig.AlertConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertConfig != nil {
                var tmp : [Any] = []
                for k in self.alertConfig! {
                    tmp.append(k.toMap())
                }
                map["AlertConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertConfig") {
                var tmp : [DescribeCloudGtmGlobalAlertResponseBody.AlertConfig.AlertConfig] = []
                for v in dict["AlertConfig"] as! [Any] {
                    var model = DescribeCloudGtmGlobalAlertResponseBody.AlertConfig.AlertConfig()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertConfig = tmp
            }
        }
    }
    public class AlertGroup : Tea.TeaModel {
        public var alertGroup: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertGroup != nil {
                map["AlertGroup"] = self.alertGroup!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertGroup") {
                self.alertGroup = dict["AlertGroup"] as! [String]
            }
        }
    }
    public var alertConfig: DescribeCloudGtmGlobalAlertResponseBody.AlertConfig?

    public var alertGroup: DescribeCloudGtmGlobalAlertResponseBody.AlertGroup?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertConfig?.validate()
        try self.alertGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConfig != nil {
            map["AlertConfig"] = self.alertConfig?.toMap()
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertConfig") {
            var model = DescribeCloudGtmGlobalAlertResponseBody.AlertConfig()
            model.fromMap(dict["AlertConfig"] as! [String: Any])
            self.alertConfig = model
        }
        if dict.keys.contains("AlertGroup") {
            var model = DescribeCloudGtmGlobalAlertResponseBody.AlertGroup()
            model.fromMap(dict["AlertGroup"] as! [String: Any])
            self.alertGroup = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCloudGtmGlobalAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmGlobalAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudGtmGlobalAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudGtmInstanceConfigAlertRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeCloudGtmInstanceConfigAlertResponseBody : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public class AlertConfig : Tea.TeaModel {
            public var dingtalkNotice: Bool?

            public var emailNotice: Bool?

            public var noticeType: String?

            public var smsNotice: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dingtalkNotice != nil {
                    map["DingtalkNotice"] = self.dingtalkNotice!
                }
                if self.emailNotice != nil {
                    map["EmailNotice"] = self.emailNotice!
                }
                if self.noticeType != nil {
                    map["NoticeType"] = self.noticeType!
                }
                if self.smsNotice != nil {
                    map["SmsNotice"] = self.smsNotice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DingtalkNotice") {
                    self.dingtalkNotice = dict["DingtalkNotice"] as! Bool
                }
                if dict.keys.contains("EmailNotice") {
                    self.emailNotice = dict["EmailNotice"] as! Bool
                }
                if dict.keys.contains("NoticeType") {
                    self.noticeType = dict["NoticeType"] as! String
                }
                if dict.keys.contains("SmsNotice") {
                    self.smsNotice = dict["SmsNotice"] as! Bool
                }
            }
        }
        public var alertConfig: [DescribeCloudGtmInstanceConfigAlertResponseBody.AlertConfig.AlertConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertConfig != nil {
                var tmp : [Any] = []
                for k in self.alertConfig! {
                    tmp.append(k.toMap())
                }
                map["AlertConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertConfig") {
                var tmp : [DescribeCloudGtmInstanceConfigAlertResponseBody.AlertConfig.AlertConfig] = []
                for v in dict["AlertConfig"] as! [Any] {
                    var model = DescribeCloudGtmInstanceConfigAlertResponseBody.AlertConfig.AlertConfig()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertConfig = tmp
            }
        }
    }
    public class AlertGroup : Tea.TeaModel {
        public var alertGroup: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertGroup != nil {
                map["AlertGroup"] = self.alertGroup!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertGroup") {
                self.alertGroup = dict["AlertGroup"] as! [String]
            }
        }
    }
    public var alertConfig: DescribeCloudGtmInstanceConfigAlertResponseBody.AlertConfig?

    public var alertGroup: DescribeCloudGtmInstanceConfigAlertResponseBody.AlertGroup?

    public var alertMode: String?

    public var configId: String?

    public var instanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertConfig?.validate()
        try self.alertGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConfig != nil {
            map["AlertConfig"] = self.alertConfig?.toMap()
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup?.toMap()
        }
        if self.alertMode != nil {
            map["AlertMode"] = self.alertMode!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertConfig") {
            var model = DescribeCloudGtmInstanceConfigAlertResponseBody.AlertConfig()
            model.fromMap(dict["AlertConfig"] as! [String: Any])
            self.alertConfig = model
        }
        if dict.keys.contains("AlertGroup") {
            var model = DescribeCloudGtmInstanceConfigAlertResponseBody.AlertGroup()
            model.fromMap(dict["AlertGroup"] as! [String: Any])
            self.alertGroup = model
        }
        if dict.keys.contains("AlertMode") {
            self.alertMode = dict["AlertMode"] as! String
        }
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCloudGtmInstanceConfigAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmInstanceConfigAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudGtmInstanceConfigAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudGtmInstanceConfigFullInfoRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeCloudGtmInstanceConfigFullInfoResponseBody : Tea.TeaModel {
    public class AddressPools : Tea.TeaModel {
        public class AddressPool : Tea.TeaModel {
            public class Addresses : Tea.TeaModel {
                public class Address : Tea.TeaModel {
                    public class RequestSource : Tea.TeaModel {
                        public var requestSource: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.requestSource != nil {
                                map["RequestSource"] = self.requestSource!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("RequestSource") {
                                self.requestSource = dict["RequestSource"] as! [String]
                            }
                        }
                    }
                    public var address: String?

                    public var addressId: String?

                    public var attributeInfo: String?

                    public var availableMode: String?

                    public var availableStatus: String?

                    public var createTime: String?

                    public var createTimestamp: Int64?

                    public var enableStatus: String?

                    public var healthJudgement: String?

                    public var healthStatus: String?

                    public var manualAvailableStatus: String?

                    public var name: String?

                    public var remark: String?

                    public var requestSource: DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses.Address.RequestSource?

                    public var seqNonPreemptiveSchedule: Bool?

                    public var serialNumber: Int32?

                    public var type: String?

                    public var updateTime: String?

                    public var updateTimestamp: Int64?

                    public var weightValue: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.requestSource?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.addressId != nil {
                            map["AddressId"] = self.addressId!
                        }
                        if self.attributeInfo != nil {
                            map["AttributeInfo"] = self.attributeInfo!
                        }
                        if self.availableMode != nil {
                            map["AvailableMode"] = self.availableMode!
                        }
                        if self.availableStatus != nil {
                            map["AvailableStatus"] = self.availableStatus!
                        }
                        if self.createTime != nil {
                            map["CreateTime"] = self.createTime!
                        }
                        if self.createTimestamp != nil {
                            map["CreateTimestamp"] = self.createTimestamp!
                        }
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.healthJudgement != nil {
                            map["HealthJudgement"] = self.healthJudgement!
                        }
                        if self.healthStatus != nil {
                            map["HealthStatus"] = self.healthStatus!
                        }
                        if self.manualAvailableStatus != nil {
                            map["ManualAvailableStatus"] = self.manualAvailableStatus!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.remark != nil {
                            map["Remark"] = self.remark!
                        }
                        if self.requestSource != nil {
                            map["RequestSource"] = self.requestSource?.toMap()
                        }
                        if self.seqNonPreemptiveSchedule != nil {
                            map["SeqNonPreemptiveSchedule"] = self.seqNonPreemptiveSchedule!
                        }
                        if self.serialNumber != nil {
                            map["SerialNumber"] = self.serialNumber!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        if self.updateTimestamp != nil {
                            map["UpdateTimestamp"] = self.updateTimestamp!
                        }
                        if self.weightValue != nil {
                            map["WeightValue"] = self.weightValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("AddressId") {
                            self.addressId = dict["AddressId"] as! String
                        }
                        if dict.keys.contains("AttributeInfo") {
                            self.attributeInfo = dict["AttributeInfo"] as! String
                        }
                        if dict.keys.contains("AvailableMode") {
                            self.availableMode = dict["AvailableMode"] as! String
                        }
                        if dict.keys.contains("AvailableStatus") {
                            self.availableStatus = dict["AvailableStatus"] as! String
                        }
                        if dict.keys.contains("CreateTime") {
                            self.createTime = dict["CreateTime"] as! String
                        }
                        if dict.keys.contains("CreateTimestamp") {
                            self.createTimestamp = dict["CreateTimestamp"] as! Int64
                        }
                        if dict.keys.contains("EnableStatus") {
                            self.enableStatus = dict["EnableStatus"] as! String
                        }
                        if dict.keys.contains("HealthJudgement") {
                            self.healthJudgement = dict["HealthJudgement"] as! String
                        }
                        if dict.keys.contains("HealthStatus") {
                            self.healthStatus = dict["HealthStatus"] as! String
                        }
                        if dict.keys.contains("ManualAvailableStatus") {
                            self.manualAvailableStatus = dict["ManualAvailableStatus"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Remark") {
                            self.remark = dict["Remark"] as! String
                        }
                        if dict.keys.contains("RequestSource") {
                            var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses.Address.RequestSource()
                            model.fromMap(dict["RequestSource"] as! [String: Any])
                            self.requestSource = model
                        }
                        if dict.keys.contains("SeqNonPreemptiveSchedule") {
                            self.seqNonPreemptiveSchedule = dict["SeqNonPreemptiveSchedule"] as! Bool
                        }
                        if dict.keys.contains("SerialNumber") {
                            self.serialNumber = dict["SerialNumber"] as! Int32
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("UpdateTime") {
                            self.updateTime = dict["UpdateTime"] as! String
                        }
                        if dict.keys.contains("UpdateTimestamp") {
                            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                        }
                        if dict.keys.contains("WeightValue") {
                            self.weightValue = dict["WeightValue"] as! Int32
                        }
                    }
                }
                public var address: [DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses.Address]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.address != nil {
                        var tmp : [Any] = []
                        for k in self.address! {
                            tmp.append(k.toMap())
                        }
                        map["Address"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Address") {
                        var tmp : [DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses.Address] = []
                        for v in dict["Address"] as! [Any] {
                            var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses.Address()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.address = tmp
                    }
                }
            }
            public class RequestSource : Tea.TeaModel {
                public var requestSource: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.requestSource != nil {
                        map["RequestSource"] = self.requestSource!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RequestSource") {
                        self.requestSource = dict["RequestSource"] as! [String]
                    }
                }
            }
            public var addressLbStrategy: String?

            public var addressPoolId: String?

            public var addressPoolName: String?

            public var addressPoolType: String?

            public var addresses: DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses?

            public var availableStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var requestSource: DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.RequestSource?

            public var seqNonPreemptiveSchedule: Bool?

            public var sequenceLbStrategyMode: String?

            public var serialNumber: Int32?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var weightValue: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addresses?.validate()
                try self.requestSource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressLbStrategy != nil {
                    map["AddressLbStrategy"] = self.addressLbStrategy!
                }
                if self.addressPoolId != nil {
                    map["AddressPoolId"] = self.addressPoolId!
                }
                if self.addressPoolName != nil {
                    map["AddressPoolName"] = self.addressPoolName!
                }
                if self.addressPoolType != nil {
                    map["AddressPoolType"] = self.addressPoolType!
                }
                if self.addresses != nil {
                    map["Addresses"] = self.addresses?.toMap()
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.requestSource != nil {
                    map["RequestSource"] = self.requestSource?.toMap()
                }
                if self.seqNonPreemptiveSchedule != nil {
                    map["SeqNonPreemptiveSchedule"] = self.seqNonPreemptiveSchedule!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.weightValue != nil {
                    map["WeightValue"] = self.weightValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddressLbStrategy") {
                    self.addressLbStrategy = dict["AddressLbStrategy"] as! String
                }
                if dict.keys.contains("AddressPoolId") {
                    self.addressPoolId = dict["AddressPoolId"] as! String
                }
                if dict.keys.contains("AddressPoolName") {
                    self.addressPoolName = dict["AddressPoolName"] as! String
                }
                if dict.keys.contains("AddressPoolType") {
                    self.addressPoolType = dict["AddressPoolType"] as! String
                }
                if dict.keys.contains("Addresses") {
                    var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.Addresses()
                    model.fromMap(dict["Addresses"] as! [String: Any])
                    self.addresses = model
                }
                if dict.keys.contains("AvailableStatus") {
                    self.availableStatus = dict["AvailableStatus"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("EnableStatus") {
                    self.enableStatus = dict["EnableStatus"] as! String
                }
                if dict.keys.contains("HealthJudgement") {
                    self.healthJudgement = dict["HealthJudgement"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("RequestSource") {
                    var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool.RequestSource()
                    model.fromMap(dict["RequestSource"] as! [String: Any])
                    self.requestSource = model
                }
                if dict.keys.contains("SeqNonPreemptiveSchedule") {
                    self.seqNonPreemptiveSchedule = dict["SeqNonPreemptiveSchedule"] as! Bool
                }
                if dict.keys.contains("SequenceLbStrategyMode") {
                    self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
                }
                if dict.keys.contains("SerialNumber") {
                    self.serialNumber = dict["SerialNumber"] as! Int32
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
                if dict.keys.contains("WeightValue") {
                    self.weightValue = dict["WeightValue"] as! Int32
                }
            }
        }
        public var addressPool: [DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressPool != nil {
                var tmp : [Any] = []
                for k in self.addressPool! {
                    tmp.append(k.toMap())
                }
                map["AddressPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddressPool") {
                var tmp : [DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool] = []
                for v in dict["AddressPool"] as! [Any] {
                    var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools.AddressPool()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.addressPool = tmp
            }
        }
    }
    public var addressPoolLbStrategy: String?

    public var addressPools: DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools?

    public var alertConfig: String?

    public var alertGroup: String?

    public var availableStatus: String?

    public var commodityCode: String?

    public var configId: String?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var enableStatus: String?

    public var healthStatus: String?

    public var instanceId: String?

    public var instanceName: String?

    public var remark: String?

    public var requestId: String?

    public var scheduleDomainName: String?

    public var scheduleHostname: String?

    public var scheduleRrType: String?

    public var scheduleZoneMode: String?

    public var scheduleZoneName: String?

    public var sequenceLbStrategyMode: String?

    public var ttl: Int32?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addressPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolLbStrategy != nil {
            map["AddressPoolLbStrategy"] = self.addressPoolLbStrategy!
        }
        if self.addressPools != nil {
            map["AddressPools"] = self.addressPools?.toMap()
        }
        if self.alertConfig != nil {
            map["AlertConfig"] = self.alertConfig!
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.availableStatus != nil {
            map["AvailableStatus"] = self.availableStatus!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduleDomainName != nil {
            map["ScheduleDomainName"] = self.scheduleDomainName!
        }
        if self.scheduleHostname != nil {
            map["ScheduleHostname"] = self.scheduleHostname!
        }
        if self.scheduleRrType != nil {
            map["ScheduleRrType"] = self.scheduleRrType!
        }
        if self.scheduleZoneMode != nil {
            map["ScheduleZoneMode"] = self.scheduleZoneMode!
        }
        if self.scheduleZoneName != nil {
            map["ScheduleZoneName"] = self.scheduleZoneName!
        }
        if self.sequenceLbStrategyMode != nil {
            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressPoolLbStrategy") {
            self.addressPoolLbStrategy = dict["AddressPoolLbStrategy"] as! String
        }
        if dict.keys.contains("AddressPools") {
            var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody.AddressPools()
            model.fromMap(dict["AddressPools"] as! [String: Any])
            self.addressPools = model
        }
        if dict.keys.contains("AlertConfig") {
            self.alertConfig = dict["AlertConfig"] as! String
        }
        if dict.keys.contains("AlertGroup") {
            self.alertGroup = dict["AlertGroup"] as! String
        }
        if dict.keys.contains("AvailableStatus") {
            self.availableStatus = dict["AvailableStatus"] as! String
        }
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("HealthStatus") {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScheduleDomainName") {
            self.scheduleDomainName = dict["ScheduleDomainName"] as! String
        }
        if dict.keys.contains("ScheduleHostname") {
            self.scheduleHostname = dict["ScheduleHostname"] as! String
        }
        if dict.keys.contains("ScheduleRrType") {
            self.scheduleRrType = dict["ScheduleRrType"] as! String
        }
        if dict.keys.contains("ScheduleZoneMode") {
            self.scheduleZoneMode = dict["ScheduleZoneMode"] as! String
        }
        if dict.keys.contains("ScheduleZoneName") {
            self.scheduleZoneName = dict["ScheduleZoneName"] as! String
        }
        if dict.keys.contains("SequenceLbStrategyMode") {
            self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
        }
        if dict.keys.contains("Ttl") {
            self.ttl = dict["Ttl"] as! Int32
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
    }
}

public class DescribeCloudGtmInstanceConfigFullInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmInstanceConfigFullInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudGtmInstanceConfigFullInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudGtmMonitorTemplateRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DescribeCloudGtmMonitorTemplateResponseBody : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public class IspCityNode : Tea.TeaModel {
            public var cityCode: String?

            public var cityName: String?

            public var countryCode: String?

            public var countryName: String?

            public var groupName: String?

            public var groupType: String?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.countryCode != nil {
                    map["CountryCode"] = self.countryCode!
                }
                if self.countryName != nil {
                    map["CountryName"] = self.countryName!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("CountryCode") {
                    self.countryCode = dict["CountryCode"] as! String
                }
                if dict.keys.contains("CountryName") {
                    self.countryName = dict["CountryName"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") {
                    self.groupType = dict["GroupType"] as! String
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
            }
        }
        public var ispCityNode: [DescribeCloudGtmMonitorTemplateResponseBody.IspCityNodes.IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ispCityNode != nil {
                var tmp : [Any] = []
                for k in self.ispCityNode! {
                    tmp.append(k.toMap())
                }
                map["IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IspCityNode") {
                var tmp : [DescribeCloudGtmMonitorTemplateResponseBody.IspCityNodes.IspCityNode] = []
                for v in dict["IspCityNode"] as! [Any] {
                    var model = DescribeCloudGtmMonitorTemplateResponseBody.IspCityNodes.IspCityNode()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ispCityNode = tmp
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var evaluationCount: Int32?

    public var extendInfo: String?

    public var failureRate: Int32?

    public var interval: Int32?

    public var ipVersion: String?

    public var ispCityNodes: DescribeCloudGtmMonitorTemplateResponseBody.IspCityNodes?

    public var name: String?

    public var protocol_: String?

    public var remark: String?

    public var requestId: String?

    public var templateId: String?

    public var timeout: Int32?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ispCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.failureRate != nil {
            map["FailureRate"] = self.failureRate!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ispCityNodes != nil {
            map["IspCityNodes"] = self.ispCityNodes?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("ExtendInfo") {
            self.extendInfo = dict["ExtendInfo"] as! String
        }
        if dict.keys.contains("FailureRate") {
            self.failureRate = dict["FailureRate"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("IspCityNodes") {
            var model = DescribeCloudGtmMonitorTemplateResponseBody.IspCityNodes()
            model.fromMap(dict["IspCityNodes"] as! [String: Any])
            self.ispCityNodes = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
    }
}

public class DescribeCloudGtmMonitorTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmMonitorTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudGtmMonitorTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudGtmSummaryRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class DescribeCloudGtmSummaryResponseBody : Tea.TeaModel {
    public var instanceTotalCount: Int32?

    public var monitorTaskTotalCount: Int32?

    public var monitorTaskTotalQuota: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTotalCount != nil {
            map["InstanceTotalCount"] = self.instanceTotalCount!
        }
        if self.monitorTaskTotalCount != nil {
            map["MonitorTaskTotalCount"] = self.monitorTaskTotalCount!
        }
        if self.monitorTaskTotalQuota != nil {
            map["MonitorTaskTotalQuota"] = self.monitorTaskTotalQuota!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceTotalCount") {
            self.instanceTotalCount = dict["InstanceTotalCount"] as! Int32
        }
        if dict.keys.contains("MonitorTaskTotalCount") {
            self.monitorTaskTotalCount = dict["MonitorTaskTotalCount"] as! Int32
        }
        if dict.keys.contains("MonitorTaskTotalQuota") {
            self.monitorTaskTotalQuota = dict["MonitorTaskTotalQuota"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCloudGtmSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudGtmSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudGtmSystemLinesResponseBody : Tea.TeaModel {
    public class SystemLines : Tea.TeaModel {
        public class SystemLine : Tea.TeaModel {
            public var code: String?

            public var displayName: String?

            public var isAvailable: Bool?

            public var name: String?

            public var parentCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.isAvailable != nil {
                    map["IsAvailable"] = self.isAvailable!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parentCode != nil {
                    map["ParentCode"] = self.parentCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("IsAvailable") {
                    self.isAvailable = dict["IsAvailable"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ParentCode") {
                    self.parentCode = dict["ParentCode"] as! String
                }
            }
        }
        public var systemLine: [DescribeCloudGtmSystemLinesResponseBody.SystemLines.SystemLine]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemLine != nil {
                var tmp : [Any] = []
                for k in self.systemLine! {
                    tmp.append(k.toMap())
                }
                map["SystemLine"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SystemLine") {
                var tmp : [DescribeCloudGtmSystemLinesResponseBody.SystemLines.SystemLine] = []
                for v in dict["SystemLine"] as! [Any] {
                    var model = DescribeCloudGtmSystemLinesResponseBody.SystemLines.SystemLine()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.systemLine = tmp
            }
        }
    }
    public var requestId: String?

    public var systemLines: DescribeCloudGtmSystemLinesResponseBody.SystemLines?

    public var systemLinesTree: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemLines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemLines != nil {
            map["SystemLines"] = self.systemLines?.toMap()
        }
        if self.systemLinesTree != nil {
            map["SystemLinesTree"] = self.systemLinesTree!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemLines") {
            var model = DescribeCloudGtmSystemLinesResponseBody.SystemLines()
            model.fromMap(dict["SystemLines"] as! [String: Any])
            self.systemLines = model
        }
        if dict.keys.contains("SystemLinesTree") {
            self.systemLinesTree = dict["SystemLinesTree"] as! String
        }
    }
}

public class DescribeCloudGtmSystemLinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudGtmSystemLinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudGtmSystemLinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomLineRequest : Tea.TeaModel {
    public var lang: String?

    public var lineId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lineId != nil {
            map["LineId"] = self.lineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LineId") {
            self.lineId = dict["LineId"] as! Int64
        }
    }
}

public class DescribeCustomLineResponseBody : Tea.TeaModel {
    public class IpSegmentList : Tea.TeaModel {
        public var endIp: String?

        public var startIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endIp != nil {
                map["EndIp"] = self.endIp!
            }
            if self.startIp != nil {
                map["StartIp"] = self.startIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndIp") {
                self.endIp = dict["EndIp"] as! String
            }
            if dict.keys.contains("StartIp") {
                self.startIp = dict["StartIp"] as! String
            }
        }
    }
    public var code: String?

    public var domainName: String?

    public var id: Int64?

    public var ipSegmentList: [DescribeCustomLineResponseBody.IpSegmentList]?

    public var name: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ipSegmentList != nil {
            var tmp : [Any] = []
            for k in self.ipSegmentList! {
                tmp.append(k.toMap())
            }
            map["IpSegmentList"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IpSegmentList") {
            var tmp : [DescribeCustomLineResponseBody.IpSegmentList] = []
            for v in dict["IpSegmentList"] as! [Any] {
                var model = DescribeCustomLineResponseBody.IpSegmentList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ipSegmentList = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCustomLineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomLineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCustomLineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomLinesRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribeCustomLinesResponseBody : Tea.TeaModel {
    public class CustomLines : Tea.TeaModel {
        public var code: String?

        public var id: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var customLines: [DescribeCustomLinesResponseBody.CustomLines]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customLines != nil {
            var tmp : [Any] = []
            for k in self.customLines! {
                tmp.append(k.toMap())
            }
            map["CustomLines"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomLines") {
            var tmp : [DescribeCustomLinesResponseBody.CustomLines] = []
            for v in dict["CustomLines"] as! [Any] {
                var model = DescribeCustomLinesResponseBody.CustomLines()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customLines = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeCustomLinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomLinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCustomLinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDNSSLBSubDomainsRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var rr: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.rr != nil {
            map["Rr"] = self.rr!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Rr") {
            self.rr = dict["Rr"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DescribeDNSSLBSubDomainsResponseBody : Tea.TeaModel {
    public class SlbSubDomains : Tea.TeaModel {
        public class SlbSubDomain : Tea.TeaModel {
            public class LineAlgorithms : Tea.TeaModel {
                public class LineAlgorithm : Tea.TeaModel {
                    public var line: String?

                    public var open_: Bool?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.line != nil {
                            map["Line"] = self.line!
                        }
                        if self.open_ != nil {
                            map["Open"] = self.open_!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Line") {
                            self.line = dict["Line"] as! String
                        }
                        if dict.keys.contains("Open") {
                            self.open_ = dict["Open"] as! Bool
                        }
                    }
                }
                public var lineAlgorithm: [DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms.LineAlgorithm]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lineAlgorithm != nil {
                        var tmp : [Any] = []
                        for k in self.lineAlgorithm! {
                            tmp.append(k.toMap())
                        }
                        map["LineAlgorithm"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LineAlgorithm") {
                        var tmp : [DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms.LineAlgorithm] = []
                        for v in dict["LineAlgorithm"] as! [Any] {
                            var model = DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms.LineAlgorithm()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.lineAlgorithm = tmp
                    }
                }
            }
            public var lineAlgorithms: DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms?

            public var open_: Bool?

            public var recordCount: Int64?

            public var subDomain: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.lineAlgorithms?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.lineAlgorithms != nil {
                    map["LineAlgorithms"] = self.lineAlgorithms?.toMap()
                }
                if self.open_ != nil {
                    map["Open"] = self.open_!
                }
                if self.recordCount != nil {
                    map["RecordCount"] = self.recordCount!
                }
                if self.subDomain != nil {
                    map["SubDomain"] = self.subDomain!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LineAlgorithms") {
                    var model = DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain.LineAlgorithms()
                    model.fromMap(dict["LineAlgorithms"] as! [String: Any])
                    self.lineAlgorithms = model
                }
                if dict.keys.contains("Open") {
                    self.open_ = dict["Open"] as! Bool
                }
                if dict.keys.contains("RecordCount") {
                    self.recordCount = dict["RecordCount"] as! Int64
                }
                if dict.keys.contains("SubDomain") {
                    self.subDomain = dict["SubDomain"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var slbSubDomain: [DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbSubDomain != nil {
                var tmp : [Any] = []
                for k in self.slbSubDomain! {
                    tmp.append(k.toMap())
                }
                map["SlbSubDomain"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SlbSubDomain") {
                var tmp : [DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain] = []
                for v in dict["SlbSubDomain"] as! [Any] {
                    var model = DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains.SlbSubDomain()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.slbSubDomain = tmp
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var slbSubDomains: DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.slbSubDomains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.slbSubDomains != nil {
            map["SlbSubDomains"] = self.slbSubDomains?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SlbSubDomains") {
            var model = DescribeDNSSLBSubDomainsResponseBody.SlbSubDomains()
            model.fromMap(dict["SlbSubDomains"] as! [String: Any])
            self.slbSubDomains = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDNSSLBSubDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDNSSLBSubDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDNSSLBSubDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsCacheDomainsRequest : Tea.TeaModel {
    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribeDnsCacheDomainsResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class SourceDnsServers : Tea.TeaModel {
            public var host: String?

            public var port: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
            }
        }
        public var cacheTtlMax: Int32?

        public var cacheTtlMin: Int32?

        public var createTime: String?

        public var createTimestamp: Int64?

        public var domainId: String?

        public var domainName: String?

        public var expireTime: String?

        public var expireTimestamp: Int64?

        public var instanceId: String?

        public var remark: String?

        public var sourceDnsServers: [DescribeDnsCacheDomainsResponseBody.Domains.SourceDnsServers]?

        public var sourceEdns: String?

        public var sourceProtocol: String?

        public var updateTime: String?

        public var updateTimestamp: Int64?

        public var versionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cacheTtlMax != nil {
                map["CacheTtlMax"] = self.cacheTtlMax!
            }
            if self.cacheTtlMin != nil {
                map["CacheTtlMin"] = self.cacheTtlMin!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.expireTimestamp != nil {
                map["ExpireTimestamp"] = self.expireTimestamp!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.sourceDnsServers != nil {
                var tmp : [Any] = []
                for k in self.sourceDnsServers! {
                    tmp.append(k.toMap())
                }
                map["SourceDnsServers"] = tmp
            }
            if self.sourceEdns != nil {
                map["SourceEdns"] = self.sourceEdns!
            }
            if self.sourceProtocol != nil {
                map["SourceProtocol"] = self.sourceProtocol!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.updateTimestamp != nil {
                map["UpdateTimestamp"] = self.updateTimestamp!
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CacheTtlMax") {
                self.cacheTtlMax = dict["CacheTtlMax"] as! Int32
            }
            if dict.keys.contains("CacheTtlMin") {
                self.cacheTtlMin = dict["CacheTtlMin"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("DomainId") {
                self.domainId = dict["DomainId"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("ExpireTimestamp") {
                self.expireTimestamp = dict["ExpireTimestamp"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Remark") {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("SourceDnsServers") {
                var tmp : [DescribeDnsCacheDomainsResponseBody.Domains.SourceDnsServers] = []
                for v in dict["SourceDnsServers"] as! [Any] {
                    var model = DescribeDnsCacheDomainsResponseBody.Domains.SourceDnsServers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sourceDnsServers = tmp
            }
            if dict.keys.contains("SourceEdns") {
                self.sourceEdns = dict["SourceEdns"] as! String
            }
            if dict.keys.contains("SourceProtocol") {
                self.sourceProtocol = dict["SourceProtocol"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
            if dict.keys.contains("UpdateTimestamp") {
                self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
            }
            if dict.keys.contains("VersionCode") {
                self.versionCode = dict["VersionCode"] as! String
            }
        }
    }
    public var domains: [DescribeDnsCacheDomainsResponseBody.Domains]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domains != nil {
            var tmp : [Any] = []
            for k in self.domains! {
                tmp.append(k.toMap())
            }
            map["Domains"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Domains") {
            var tmp : [DescribeDnsCacheDomainsResponseBody.Domains] = []
            for v in dict["Domains"] as! [Any] {
                var model = DescribeDnsCacheDomainsResponseBody.Domains()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.domains = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDnsCacheDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsCacheDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsCacheDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmAccessStrategiesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var strategyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StrategyMode") {
            self.strategyMode = dict["StrategyMode"] as! String
        }
    }
}

public class DescribeDnsGtmAccessStrategiesResponseBody : Tea.TeaModel {
    public class Strategies : Tea.TeaModel {
        public class Strategy : Tea.TeaModel {
            public class EffectiveAddrPools : Tea.TeaModel {
                public class EffectiveAddrPool : Tea.TeaModel {
                    public var addrCount: Int32?

                    public var id: String?

                    public var lbaWeight: Int32?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.addrCount != nil {
                            map["AddrCount"] = self.addrCount!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.lbaWeight != nil {
                            map["LbaWeight"] = self.lbaWeight!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AddrCount") {
                            self.addrCount = dict["AddrCount"] as! Int32
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("LbaWeight") {
                            self.lbaWeight = dict["LbaWeight"] as! Int32
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public var effectiveAddrPool: [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools.EffectiveAddrPool]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.effectiveAddrPool != nil {
                        var tmp : [Any] = []
                        for k in self.effectiveAddrPool! {
                            tmp.append(k.toMap())
                        }
                        map["EffectiveAddrPool"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EffectiveAddrPool") {
                        var tmp : [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools.EffectiveAddrPool] = []
                        for v in dict["EffectiveAddrPool"] as! [Any] {
                            var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools.EffectiveAddrPool()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.effectiveAddrPool = tmp
                    }
                }
            }
            public class Lines : Tea.TeaModel {
                public class Line : Tea.TeaModel {
                    public var groupCode: String?

                    public var groupName: String?

                    public var lineCode: String?

                    public var lineName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.groupCode != nil {
                            map["GroupCode"] = self.groupCode!
                        }
                        if self.groupName != nil {
                            map["GroupName"] = self.groupName!
                        }
                        if self.lineCode != nil {
                            map["LineCode"] = self.lineCode!
                        }
                        if self.lineName != nil {
                            map["LineName"] = self.lineName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("GroupCode") {
                            self.groupCode = dict["GroupCode"] as! String
                        }
                        if dict.keys.contains("GroupName") {
                            self.groupName = dict["GroupName"] as! String
                        }
                        if dict.keys.contains("LineCode") {
                            self.lineCode = dict["LineCode"] as! String
                        }
                        if dict.keys.contains("LineName") {
                            self.lineName = dict["LineName"] as! String
                        }
                    }
                }
                public var line: [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.line != nil {
                        var tmp : [Any] = []
                        for k in self.line! {
                            tmp.append(k.toMap())
                        }
                        map["Line"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Line") {
                        var tmp : [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line] = []
                        for v in dict["Line"] as! [Any] {
                            var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.line = tmp
                    }
                }
            }
            public var createTime: String?

            public var createTimestamp: Int64?

            public var effectiveAddrPoolGroupType: String?

            public var effectiveAddrPoolType: String?

            public var effectiveAddrPools: DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools?

            public var effectiveLbaStrategy: String?

            public var lines: DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines?

            public var strategyId: String?

            public var strategyName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.effectiveAddrPools?.validate()
                try self.lines?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.effectiveAddrPoolGroupType != nil {
                    map["EffectiveAddrPoolGroupType"] = self.effectiveAddrPoolGroupType!
                }
                if self.effectiveAddrPoolType != nil {
                    map["EffectiveAddrPoolType"] = self.effectiveAddrPoolType!
                }
                if self.effectiveAddrPools != nil {
                    map["EffectiveAddrPools"] = self.effectiveAddrPools?.toMap()
                }
                if self.effectiveLbaStrategy != nil {
                    map["EffectiveLbaStrategy"] = self.effectiveLbaStrategy!
                }
                if self.lines != nil {
                    map["Lines"] = self.lines?.toMap()
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.strategyName != nil {
                    map["StrategyName"] = self.strategyName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("EffectiveAddrPoolGroupType") {
                    self.effectiveAddrPoolGroupType = dict["EffectiveAddrPoolGroupType"] as! String
                }
                if dict.keys.contains("EffectiveAddrPoolType") {
                    self.effectiveAddrPoolType = dict["EffectiveAddrPoolType"] as! String
                }
                if dict.keys.contains("EffectiveAddrPools") {
                    var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.EffectiveAddrPools()
                    model.fromMap(dict["EffectiveAddrPools"] as! [String: Any])
                    self.effectiveAddrPools = model
                }
                if dict.keys.contains("EffectiveLbaStrategy") {
                    self.effectiveLbaStrategy = dict["EffectiveLbaStrategy"] as! String
                }
                if dict.keys.contains("Lines") {
                    var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines()
                    model.fromMap(dict["Lines"] as! [String: Any])
                    self.lines = model
                }
                if dict.keys.contains("StrategyId") {
                    self.strategyId = dict["StrategyId"] as! String
                }
                if dict.keys.contains("StrategyName") {
                    self.strategyName = dict["StrategyName"] as! String
                }
            }
        }
        public var strategy: [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.strategy != nil {
                var tmp : [Any] = []
                for k in self.strategy! {
                    tmp.append(k.toMap())
                }
                map["Strategy"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Strategy") {
                var tmp : [DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy] = []
                for v in dict["Strategy"] as! [Any] {
                    var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies.Strategy()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.strategy = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var strategies: DescribeDnsGtmAccessStrategiesResponseBody.Strategies?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.strategies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategies != nil {
            map["Strategies"] = self.strategies?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Strategies") {
            var model = DescribeDnsGtmAccessStrategiesResponseBody.Strategies()
            model.fromMap(dict["Strategies"] as! [String: Any])
            self.strategies = model
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDnsGtmAccessStrategiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAccessStrategiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmAccessStrategiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmAccessStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class DescribeDnsGtmAccessStrategyResponseBody : Tea.TeaModel {
    public class DefaultAddrPools : Tea.TeaModel {
        public class DefaultAddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var lbaWeight: Int32?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.lbaWeight != nil {
                    map["LbaWeight"] = self.lbaWeight!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("LbaWeight") {
                    self.lbaWeight = dict["LbaWeight"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var defaultAddrPool: [DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools.DefaultAddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultAddrPool != nil {
                var tmp : [Any] = []
                for k in self.defaultAddrPool! {
                    tmp.append(k.toMap())
                }
                map["DefaultAddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultAddrPool") {
                var tmp : [DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools.DefaultAddrPool] = []
                for v in dict["DefaultAddrPool"] as! [Any] {
                    var model = DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools.DefaultAddrPool()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.defaultAddrPool = tmp
            }
        }
    }
    public class FailoverAddrPools : Tea.TeaModel {
        public class FailoverAddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var lbaWeight: Int32?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.lbaWeight != nil {
                    map["LbaWeight"] = self.lbaWeight!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("LbaWeight") {
                    self.lbaWeight = dict["LbaWeight"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var failoverAddrPool: [DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools.FailoverAddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failoverAddrPool != nil {
                var tmp : [Any] = []
                for k in self.failoverAddrPool! {
                    tmp.append(k.toMap())
                }
                map["FailoverAddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailoverAddrPool") {
                var tmp : [DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools.FailoverAddrPool] = []
                for v in dict["FailoverAddrPool"] as! [Any] {
                    var model = DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools.FailoverAddrPool()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.failoverAddrPool = tmp
            }
        }
    }
    public class Lines : Tea.TeaModel {
        public class Line : Tea.TeaModel {
            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupCode") {
                    self.groupCode = dict["GroupCode"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
            }
        }
        public var line: [DescribeDnsGtmAccessStrategyResponseBody.Lines.Line]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.line != nil {
                var tmp : [Any] = []
                for k in self.line! {
                    tmp.append(k.toMap())
                }
                map["Line"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Line") {
                var tmp : [DescribeDnsGtmAccessStrategyResponseBody.Lines.Line] = []
                for v in dict["Line"] as! [Any] {
                    var model = DescribeDnsGtmAccessStrategyResponseBody.Lines.Line()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.line = tmp
            }
        }
    }
    public var accessMode: String?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var defaultAddrPoolGroupStatus: String?

    public var defaultAddrPoolType: String?

    public var defaultAddrPools: DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools?

    public var defaultAvailableAddrNum: Int32?

    public var defaultLatencyOptimization: String?

    public var defaultLbaStrategy: String?

    public var defaultMaxReturnAddrNum: Int32?

    public var defaultMinAvailableAddrNum: Int32?

    public var effectiveAddrPoolGroupType: String?

    public var failoverAddrPoolGroupStatus: String?

    public var failoverAddrPoolType: String?

    public var failoverAddrPools: DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools?

    public var failoverAvailableAddrNum: Int32?

    public var failoverLatencyOptimization: String?

    public var failoverLbaStrategy: String?

    public var failoverMaxReturnAddrNum: Int32?

    public var failoverMinAvailableAddrNum: Int32?

    public var instanceId: String?

    public var lines: DescribeDnsGtmAccessStrategyResponseBody.Lines?

    public var requestId: String?

    public var strategyId: String?

    public var strategyMode: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.defaultAddrPools?.validate()
        try self.failoverAddrPools?.validate()
        try self.lines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.defaultAddrPoolGroupStatus != nil {
            map["DefaultAddrPoolGroupStatus"] = self.defaultAddrPoolGroupStatus!
        }
        if self.defaultAddrPoolType != nil {
            map["DefaultAddrPoolType"] = self.defaultAddrPoolType!
        }
        if self.defaultAddrPools != nil {
            map["DefaultAddrPools"] = self.defaultAddrPools?.toMap()
        }
        if self.defaultAvailableAddrNum != nil {
            map["DefaultAvailableAddrNum"] = self.defaultAvailableAddrNum!
        }
        if self.defaultLatencyOptimization != nil {
            map["DefaultLatencyOptimization"] = self.defaultLatencyOptimization!
        }
        if self.defaultLbaStrategy != nil {
            map["DefaultLbaStrategy"] = self.defaultLbaStrategy!
        }
        if self.defaultMaxReturnAddrNum != nil {
            map["DefaultMaxReturnAddrNum"] = self.defaultMaxReturnAddrNum!
        }
        if self.defaultMinAvailableAddrNum != nil {
            map["DefaultMinAvailableAddrNum"] = self.defaultMinAvailableAddrNum!
        }
        if self.effectiveAddrPoolGroupType != nil {
            map["EffectiveAddrPoolGroupType"] = self.effectiveAddrPoolGroupType!
        }
        if self.failoverAddrPoolGroupStatus != nil {
            map["FailoverAddrPoolGroupStatus"] = self.failoverAddrPoolGroupStatus!
        }
        if self.failoverAddrPoolType != nil {
            map["FailoverAddrPoolType"] = self.failoverAddrPoolType!
        }
        if self.failoverAddrPools != nil {
            map["FailoverAddrPools"] = self.failoverAddrPools?.toMap()
        }
        if self.failoverAvailableAddrNum != nil {
            map["FailoverAvailableAddrNum"] = self.failoverAvailableAddrNum!
        }
        if self.failoverLatencyOptimization != nil {
            map["FailoverLatencyOptimization"] = self.failoverLatencyOptimization!
        }
        if self.failoverLbaStrategy != nil {
            map["FailoverLbaStrategy"] = self.failoverLbaStrategy!
        }
        if self.failoverMaxReturnAddrNum != nil {
            map["FailoverMaxReturnAddrNum"] = self.failoverMaxReturnAddrNum!
        }
        if self.failoverMinAvailableAddrNum != nil {
            map["FailoverMinAvailableAddrNum"] = self.failoverMinAvailableAddrNum!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lines != nil {
            map["Lines"] = self.lines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessMode") {
            self.accessMode = dict["AccessMode"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("DefaultAddrPoolGroupStatus") {
            self.defaultAddrPoolGroupStatus = dict["DefaultAddrPoolGroupStatus"] as! String
        }
        if dict.keys.contains("DefaultAddrPoolType") {
            self.defaultAddrPoolType = dict["DefaultAddrPoolType"] as! String
        }
        if dict.keys.contains("DefaultAddrPools") {
            var model = DescribeDnsGtmAccessStrategyResponseBody.DefaultAddrPools()
            model.fromMap(dict["DefaultAddrPools"] as! [String: Any])
            self.defaultAddrPools = model
        }
        if dict.keys.contains("DefaultAvailableAddrNum") {
            self.defaultAvailableAddrNum = dict["DefaultAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("DefaultLatencyOptimization") {
            self.defaultLatencyOptimization = dict["DefaultLatencyOptimization"] as! String
        }
        if dict.keys.contains("DefaultLbaStrategy") {
            self.defaultLbaStrategy = dict["DefaultLbaStrategy"] as! String
        }
        if dict.keys.contains("DefaultMaxReturnAddrNum") {
            self.defaultMaxReturnAddrNum = dict["DefaultMaxReturnAddrNum"] as! Int32
        }
        if dict.keys.contains("DefaultMinAvailableAddrNum") {
            self.defaultMinAvailableAddrNum = dict["DefaultMinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("EffectiveAddrPoolGroupType") {
            self.effectiveAddrPoolGroupType = dict["EffectiveAddrPoolGroupType"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolGroupStatus") {
            self.failoverAddrPoolGroupStatus = dict["FailoverAddrPoolGroupStatus"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolType") {
            self.failoverAddrPoolType = dict["FailoverAddrPoolType"] as! String
        }
        if dict.keys.contains("FailoverAddrPools") {
            var model = DescribeDnsGtmAccessStrategyResponseBody.FailoverAddrPools()
            model.fromMap(dict["FailoverAddrPools"] as! [String: Any])
            self.failoverAddrPools = model
        }
        if dict.keys.contains("FailoverAvailableAddrNum") {
            self.failoverAvailableAddrNum = dict["FailoverAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("FailoverLatencyOptimization") {
            self.failoverLatencyOptimization = dict["FailoverLatencyOptimization"] as! String
        }
        if dict.keys.contains("FailoverLbaStrategy") {
            self.failoverLbaStrategy = dict["FailoverLbaStrategy"] as! String
        }
        if dict.keys.contains("FailoverMaxReturnAddrNum") {
            self.failoverMaxReturnAddrNum = dict["FailoverMaxReturnAddrNum"] as! Int32
        }
        if dict.keys.contains("FailoverMinAvailableAddrNum") {
            self.failoverMinAvailableAddrNum = dict["FailoverMinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lines") {
            var model = DescribeDnsGtmAccessStrategyResponseBody.Lines()
            model.fromMap(dict["Lines"] as! [String: Any])
            self.lines = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
        if dict.keys.contains("StrategyMode") {
            self.strategyMode = dict["StrategyMode"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class DescribeDnsGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmAccessStrategyAvailableConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var strategyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyMode") {
            self.strategyMode = dict["StrategyMode"] as! String
        }
    }
}

public class DescribeDnsGtmAccessStrategyAvailableConfigResponseBody : Tea.TeaModel {
    public class DomainAddrPools : Tea.TeaModel {
        public class DomainAddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var domainAddrPool: [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools.DomainAddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainAddrPool != nil {
                var tmp : [Any] = []
                for k in self.domainAddrPool! {
                    tmp.append(k.toMap())
                }
                map["DomainAddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainAddrPool") {
                var tmp : [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools.DomainAddrPool] = []
                for v in dict["DomainAddrPool"] as! [Any] {
                    var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools.DomainAddrPool()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainAddrPool = tmp
            }
        }
    }
    public class Ipv4AddrPools : Tea.TeaModel {
        public class Ipv4AddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var ipv4AddrPool: [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools.Ipv4AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4AddrPool != nil {
                var tmp : [Any] = []
                for k in self.ipv4AddrPool! {
                    tmp.append(k.toMap())
                }
                map["Ipv4AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv4AddrPool") {
                var tmp : [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools.Ipv4AddrPool] = []
                for v in dict["Ipv4AddrPool"] as! [Any] {
                    var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools.Ipv4AddrPool()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv4AddrPool = tmp
            }
        }
    }
    public class Ipv6AddrPools : Tea.TeaModel {
        public class Ipv6AddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var ipv6AddrPool: [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools.Ipv6AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6AddrPool != nil {
                var tmp : [Any] = []
                for k in self.ipv6AddrPool! {
                    tmp.append(k.toMap())
                }
                map["Ipv6AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6AddrPool") {
                var tmp : [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools.Ipv6AddrPool] = []
                for v in dict["Ipv6AddrPool"] as! [Any] {
                    var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools.Ipv6AddrPool()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6AddrPool = tmp
            }
        }
    }
    public class Lines : Tea.TeaModel {
        public class Line : Tea.TeaModel {
            public var fatherCode: String?

            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FatherCode") {
                    self.fatherCode = dict["FatherCode"] as! String
                }
                if dict.keys.contains("GroupCode") {
                    self.groupCode = dict["GroupCode"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
            }
        }
        public var line: [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines.Line]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.line != nil {
                var tmp : [Any] = []
                for k in self.line! {
                    tmp.append(k.toMap())
                }
                map["Line"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Line") {
                var tmp : [DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines.Line] = []
                for v in dict["Line"] as! [Any] {
                    var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines.Line()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.line = tmp
            }
        }
    }
    public class SelectedDomainLines : Tea.TeaModel {
        public var selectedDomainLine: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.selectedDomainLine != nil {
                map["SelectedDomainLine"] = self.selectedDomainLine!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SelectedDomainLine") {
                self.selectedDomainLine = dict["SelectedDomainLine"] as! [String]
            }
        }
    }
    public class SelectedIpv4Lines : Tea.TeaModel {
        public var selectedIpv4Line: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.selectedIpv4Line != nil {
                map["SelectedIpv4Line"] = self.selectedIpv4Line!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SelectedIpv4Line") {
                self.selectedIpv4Line = dict["SelectedIpv4Line"] as! [String]
            }
        }
    }
    public class SelectedIpv6Lines : Tea.TeaModel {
        public var selectedIpv6Line: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.selectedIpv6Line != nil {
                map["SelectedIpv6Line"] = self.selectedIpv6Line!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SelectedIpv6Line") {
                self.selectedIpv6Line = dict["SelectedIpv6Line"] as! [String]
            }
        }
    }
    public var domainAddrPools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools?

    public var ipv4AddrPools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools?

    public var ipv6AddrPools: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools?

    public var lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines?

    public var requestId: String?

    public var selectedDomainLines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedDomainLines?

    public var selectedIpv4Lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedIpv4Lines?

    public var selectedIpv6Lines: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedIpv6Lines?

    public var suggestSetDefaultLine: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainAddrPools?.validate()
        try self.ipv4AddrPools?.validate()
        try self.ipv6AddrPools?.validate()
        try self.lines?.validate()
        try self.selectedDomainLines?.validate()
        try self.selectedIpv4Lines?.validate()
        try self.selectedIpv6Lines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainAddrPools != nil {
            map["DomainAddrPools"] = self.domainAddrPools?.toMap()
        }
        if self.ipv4AddrPools != nil {
            map["Ipv4AddrPools"] = self.ipv4AddrPools?.toMap()
        }
        if self.ipv6AddrPools != nil {
            map["Ipv6AddrPools"] = self.ipv6AddrPools?.toMap()
        }
        if self.lines != nil {
            map["Lines"] = self.lines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.selectedDomainLines != nil {
            map["SelectedDomainLines"] = self.selectedDomainLines?.toMap()
        }
        if self.selectedIpv4Lines != nil {
            map["SelectedIpv4Lines"] = self.selectedIpv4Lines?.toMap()
        }
        if self.selectedIpv6Lines != nil {
            map["SelectedIpv6Lines"] = self.selectedIpv6Lines?.toMap()
        }
        if self.suggestSetDefaultLine != nil {
            map["SuggestSetDefaultLine"] = self.suggestSetDefaultLine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainAddrPools") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.DomainAddrPools()
            model.fromMap(dict["DomainAddrPools"] as! [String: Any])
            self.domainAddrPools = model
        }
        if dict.keys.contains("Ipv4AddrPools") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv4AddrPools()
            model.fromMap(dict["Ipv4AddrPools"] as! [String: Any])
            self.ipv4AddrPools = model
        }
        if dict.keys.contains("Ipv6AddrPools") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Ipv6AddrPools()
            model.fromMap(dict["Ipv6AddrPools"] as! [String: Any])
            self.ipv6AddrPools = model
        }
        if dict.keys.contains("Lines") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.Lines()
            model.fromMap(dict["Lines"] as! [String: Any])
            self.lines = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SelectedDomainLines") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedDomainLines()
            model.fromMap(dict["SelectedDomainLines"] as! [String: Any])
            self.selectedDomainLines = model
        }
        if dict.keys.contains("SelectedIpv4Lines") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedIpv4Lines()
            model.fromMap(dict["SelectedIpv4Lines"] as! [String: Any])
            self.selectedIpv4Lines = model
        }
        if dict.keys.contains("SelectedIpv6Lines") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody.SelectedIpv6Lines()
            model.fromMap(dict["SelectedIpv6Lines"] as! [String: Any])
            self.selectedIpv6Lines = model
        }
        if dict.keys.contains("SuggestSetDefaultLine") {
            self.suggestSetDefaultLine = dict["SuggestSetDefaultLine"] as! Bool
        }
    }
}

public class DescribeDnsGtmAccessStrategyAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAccessStrategyAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmAccessStrategyAvailableConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmAddrAttributeInfoRequest : Tea.TeaModel {
    public var addrs: String?

    public var lang: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrs != nil {
            map["Addrs"] = self.addrs!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addrs") {
            self.addrs = dict["Addrs"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeDnsGtmAddrAttributeInfoResponseBody : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public class Addr : Tea.TeaModel {
            public class AttributeInfo : Tea.TeaModel {
                public var fatherCode: String?

                public var groupCode: String?

                public var groupName: String?

                public var lineCode: String?

                public var lineName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fatherCode != nil {
                        map["FatherCode"] = self.fatherCode!
                    }
                    if self.groupCode != nil {
                        map["GroupCode"] = self.groupCode!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.lineCode != nil {
                        map["LineCode"] = self.lineCode!
                    }
                    if self.lineName != nil {
                        map["LineName"] = self.lineName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FatherCode") {
                        self.fatherCode = dict["FatherCode"] as! String
                    }
                    if dict.keys.contains("GroupCode") {
                        self.groupCode = dict["GroupCode"] as! String
                    }
                    if dict.keys.contains("GroupName") {
                        self.groupName = dict["GroupName"] as! String
                    }
                    if dict.keys.contains("LineCode") {
                        self.lineCode = dict["LineCode"] as! String
                    }
                    if dict.keys.contains("LineName") {
                        self.lineName = dict["LineName"] as! String
                    }
                }
            }
            public var addr: String?

            public var attributeInfo: DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr.AttributeInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.attributeInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addr != nil {
                    map["Addr"] = self.addr!
                }
                if self.attributeInfo != nil {
                    map["AttributeInfo"] = self.attributeInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Addr") {
                    self.addr = dict["Addr"] as! String
                }
                if dict.keys.contains("AttributeInfo") {
                    var model = DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr.AttributeInfo()
                    model.fromMap(dict["AttributeInfo"] as! [String: Any])
                    self.attributeInfo = model
                }
            }
        }
        public var addr: [DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                var tmp : [Any] = []
                for k in self.addr! {
                    tmp.append(k.toMap())
                }
                map["Addr"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Addr") {
                var tmp : [DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr] = []
                for v in dict["Addr"] as! [Any] {
                    var model = DescribeDnsGtmAddrAttributeInfoResponseBody.Addr.Addr()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.addr = tmp
            }
        }
    }
    public var addr: DescribeDnsGtmAddrAttributeInfoResponseBody.Addr?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addr?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            map["Addr"] = self.addr?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addr") {
            var model = DescribeDnsGtmAddrAttributeInfoResponseBody.Addr()
            model.fromMap(dict["Addr"] as! [String: Any])
            self.addr = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDnsGtmAddrAttributeInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAddrAttributeInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmAddrAttributeInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmAddressPoolAvailableConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmAddressPoolAvailableConfigResponseBody : Tea.TeaModel {
    public class AttributeInfos : Tea.TeaModel {
        public class AttributeInfo : Tea.TeaModel {
            public var fatherCode: String?

            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FatherCode") {
                    self.fatherCode = dict["FatherCode"] as! String
                }
                if dict.keys.contains("GroupCode") {
                    self.groupCode = dict["GroupCode"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
            }
        }
        public var attributeInfo: [DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos.AttributeInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attributeInfo != nil {
                var tmp : [Any] = []
                for k in self.attributeInfo! {
                    tmp.append(k.toMap())
                }
                map["AttributeInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttributeInfo") {
                var tmp : [DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos.AttributeInfo] = []
                for v in dict["AttributeInfo"] as! [Any] {
                    var model = DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos.AttributeInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attributeInfo = tmp
            }
        }
    }
    public var attributeInfos: DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.attributeInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributeInfos != nil {
            map["AttributeInfos"] = self.attributeInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttributeInfos") {
            var model = DescribeDnsGtmAddressPoolAvailableConfigResponseBody.AttributeInfos()
            model.fromMap(dict["AttributeInfos"] as! [String: Any])
            self.attributeInfos = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDnsGtmAddressPoolAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAddressPoolAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmAddressPoolAvailableConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmAvailableAlertGroupRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmAvailableAlertGroupResponseBody : Tea.TeaModel {
    public var availableAlertGroup: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAlertGroup != nil {
            map["AvailableAlertGroup"] = self.availableAlertGroup!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableAlertGroup") {
            self.availableAlertGroup = dict["AvailableAlertGroup"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDnsGtmAvailableAlertGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmAvailableAlertGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmAvailableAlertGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmInstanceResponseBody : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public class AlertConfig : Tea.TeaModel {
            public class AlertConfig : Tea.TeaModel {
                public var dingtalkNotice: Bool?

                public var emailNotice: Bool?

                public var noticeType: String?

                public var smsNotice: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dingtalkNotice != nil {
                        map["DingtalkNotice"] = self.dingtalkNotice!
                    }
                    if self.emailNotice != nil {
                        map["EmailNotice"] = self.emailNotice!
                    }
                    if self.noticeType != nil {
                        map["NoticeType"] = self.noticeType!
                    }
                    if self.smsNotice != nil {
                        map["SmsNotice"] = self.smsNotice!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DingtalkNotice") {
                        self.dingtalkNotice = dict["DingtalkNotice"] as! Bool
                    }
                    if dict.keys.contains("EmailNotice") {
                        self.emailNotice = dict["EmailNotice"] as! Bool
                    }
                    if dict.keys.contains("NoticeType") {
                        self.noticeType = dict["NoticeType"] as! String
                    }
                    if dict.keys.contains("SmsNotice") {
                        self.smsNotice = dict["SmsNotice"] as! Bool
                    }
                }
            }
            public var alertConfig: [DescribeDnsGtmInstanceResponseBody.Config.AlertConfig.AlertConfig]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertConfig != nil {
                    var tmp : [Any] = []
                    for k in self.alertConfig! {
                        tmp.append(k.toMap())
                    }
                    map["AlertConfig"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertConfig") {
                    var tmp : [DescribeDnsGtmInstanceResponseBody.Config.AlertConfig.AlertConfig] = []
                    for v in dict["AlertConfig"] as! [Any] {
                        var model = DescribeDnsGtmInstanceResponseBody.Config.AlertConfig.AlertConfig()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.alertConfig = tmp
                }
            }
        }
        public var alertConfig: DescribeDnsGtmInstanceResponseBody.Config.AlertConfig?

        public var alertGroup: String?

        public var cnameType: String?

        public var instanceName: String?

        public var pubicZoneName: String?

        public var publicCnameMode: String?

        public var publicRr: String?

        public var publicUserDomainName: String?

        public var strategyMode: String?

        public var ttl: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.alertConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertConfig != nil {
                map["AlertConfig"] = self.alertConfig?.toMap()
            }
            if self.alertGroup != nil {
                map["AlertGroup"] = self.alertGroup!
            }
            if self.cnameType != nil {
                map["CnameType"] = self.cnameType!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.pubicZoneName != nil {
                map["PubicZoneName"] = self.pubicZoneName!
            }
            if self.publicCnameMode != nil {
                map["PublicCnameMode"] = self.publicCnameMode!
            }
            if self.publicRr != nil {
                map["PublicRr"] = self.publicRr!
            }
            if self.publicUserDomainName != nil {
                map["PublicUserDomainName"] = self.publicUserDomainName!
            }
            if self.strategyMode != nil {
                map["StrategyMode"] = self.strategyMode!
            }
            if self.ttl != nil {
                map["Ttl"] = self.ttl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertConfig") {
                var model = DescribeDnsGtmInstanceResponseBody.Config.AlertConfig()
                model.fromMap(dict["AlertConfig"] as! [String: Any])
                self.alertConfig = model
            }
            if dict.keys.contains("AlertGroup") {
                self.alertGroup = dict["AlertGroup"] as! String
            }
            if dict.keys.contains("CnameType") {
                self.cnameType = dict["CnameType"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("PubicZoneName") {
                self.pubicZoneName = dict["PubicZoneName"] as! String
            }
            if dict.keys.contains("PublicCnameMode") {
                self.publicCnameMode = dict["PublicCnameMode"] as! String
            }
            if dict.keys.contains("PublicRr") {
                self.publicRr = dict["PublicRr"] as! String
            }
            if dict.keys.contains("PublicUserDomainName") {
                self.publicUserDomainName = dict["PublicUserDomainName"] as! String
            }
            if dict.keys.contains("StrategyMode") {
                self.strategyMode = dict["StrategyMode"] as! String
            }
            if dict.keys.contains("Ttl") {
                self.ttl = dict["Ttl"] as! Int32
            }
        }
    }
    public class UsedQuota : Tea.TeaModel {
        public var dingtalkUsedCount: Int32?

        public var emailUsedCount: Int32?

        public var smsUsedCount: Int32?

        public var taskUsedCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingtalkUsedCount != nil {
                map["DingtalkUsedCount"] = self.dingtalkUsedCount!
            }
            if self.emailUsedCount != nil {
                map["EmailUsedCount"] = self.emailUsedCount!
            }
            if self.smsUsedCount != nil {
                map["SmsUsedCount"] = self.smsUsedCount!
            }
            if self.taskUsedCount != nil {
                map["TaskUsedCount"] = self.taskUsedCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DingtalkUsedCount") {
                self.dingtalkUsedCount = dict["DingtalkUsedCount"] as! Int32
            }
            if dict.keys.contains("EmailUsedCount") {
                self.emailUsedCount = dict["EmailUsedCount"] as! Int32
            }
            if dict.keys.contains("SmsUsedCount") {
                self.smsUsedCount = dict["SmsUsedCount"] as! Int32
            }
            if dict.keys.contains("TaskUsedCount") {
                self.taskUsedCount = dict["TaskUsedCount"] as! Int32
            }
        }
    }
    public var config: DescribeDnsGtmInstanceResponseBody.Config?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var expireTime: String?

    public var expireTimestamp: Int64?

    public var instanceId: String?

    public var paymentType: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var smsQuota: Int32?

    public var taskQuota: Int32?

    public var usedQuota: DescribeDnsGtmInstanceResponseBody.UsedQuota?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.config?.validate()
        try self.usedQuota?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.expireTimestamp != nil {
            map["ExpireTimestamp"] = self.expireTimestamp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.smsQuota != nil {
            map["SmsQuota"] = self.smsQuota!
        }
        if self.taskQuota != nil {
            map["TaskQuota"] = self.taskQuota!
        }
        if self.usedQuota != nil {
            map["UsedQuota"] = self.usedQuota?.toMap()
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            var model = DescribeDnsGtmInstanceResponseBody.Config()
            model.fromMap(dict["Config"] as! [String: Any])
            self.config = model
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("ExpireTime") {
            self.expireTime = dict["ExpireTime"] as! String
        }
        if dict.keys.contains("ExpireTimestamp") {
            self.expireTimestamp = dict["ExpireTimestamp"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SmsQuota") {
            self.smsQuota = dict["SmsQuota"] as! Int32
        }
        if dict.keys.contains("TaskQuota") {
            self.taskQuota = dict["TaskQuota"] as! Int32
        }
        if dict.keys.contains("UsedQuota") {
            var model = DescribeDnsGtmInstanceResponseBody.UsedQuota()
            model.fromMap(dict["UsedQuota"] as! [String: Any])
            self.usedQuota = model
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
    }
}

public class DescribeDnsGtmInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolRequest : Tea.TeaModel {
    public var addrPoolId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolResponseBody : Tea.TeaModel {
    public class Addrs : Tea.TeaModel {
        public class Addr : Tea.TeaModel {
            public var addr: String?

            public var alertStatus: String?

            public var attributeInfo: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var lbaWeight: Int32?

            public var mode: String?

            public var remark: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addr != nil {
                    map["Addr"] = self.addr!
                }
                if self.alertStatus != nil {
                    map["AlertStatus"] = self.alertStatus!
                }
                if self.attributeInfo != nil {
                    map["AttributeInfo"] = self.attributeInfo!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.lbaWeight != nil {
                    map["LbaWeight"] = self.lbaWeight!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Addr") {
                    self.addr = dict["Addr"] as! String
                }
                if dict.keys.contains("AlertStatus") {
                    self.alertStatus = dict["AlertStatus"] as! String
                }
                if dict.keys.contains("AttributeInfo") {
                    self.attributeInfo = dict["AttributeInfo"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("LbaWeight") {
                    self.lbaWeight = dict["LbaWeight"] as! Int32
                }
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var addr: [DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs.Addr]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                var tmp : [Any] = []
                for k in self.addr! {
                    tmp.append(k.toMap())
                }
                map["Addr"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Addr") {
                var tmp : [DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs.Addr] = []
                for v in dict["Addr"] as! [Any] {
                    var model = DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs.Addr()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.addr = tmp
            }
        }
    }
    public var addrCount: Int32?

    public var addrPoolId: String?

    public var addrs: DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var lbaStrategy: String?

    public var monitorConfigId: String?

    public var monitorStatus: String?

    public var name: String?

    public var requestId: String?

    public var type: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrCount != nil {
            map["AddrCount"] = self.addrCount!
        }
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.addrs != nil {
            map["Addrs"] = self.addrs?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorStatus != nil {
            map["MonitorStatus"] = self.monitorStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrCount") {
            self.addrCount = dict["AddrCount"] as! Int32
        }
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Addrs") {
            var model = DescribeDnsGtmInstanceAddressPoolResponseBody.Addrs()
            model.fromMap(dict["Addrs"] as! [String: Any])
            self.addrs = model
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("LbaStrategy") {
            self.lbaStrategy = dict["LbaStrategy"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("MonitorStatus") {
            self.monitorStatus = dict["MonitorStatus"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmInstanceAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolsResponseBody : Tea.TeaModel {
    public class AddrPools : Tea.TeaModel {
        public class AddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var addrPoolId: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var lbaStrategy: String?

            public var monitorConfigId: String?

            public var monitorStatus: String?

            public var name: String?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.addrPoolId != nil {
                    map["AddrPoolId"] = self.addrPoolId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.lbaStrategy != nil {
                    map["LbaStrategy"] = self.lbaStrategy!
                }
                if self.monitorConfigId != nil {
                    map["MonitorConfigId"] = self.monitorConfigId!
                }
                if self.monitorStatus != nil {
                    map["MonitorStatus"] = self.monitorStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("AddrPoolId") {
                    self.addrPoolId = dict["AddrPoolId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("LbaStrategy") {
                    self.lbaStrategy = dict["LbaStrategy"] as! String
                }
                if dict.keys.contains("MonitorConfigId") {
                    self.monitorConfigId = dict["MonitorConfigId"] as! String
                }
                if dict.keys.contains("MonitorStatus") {
                    self.monitorStatus = dict["MonitorStatus"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var addrPool: [DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addrPool != nil {
                var tmp : [Any] = []
                for k in self.addrPool! {
                    tmp.append(k.toMap())
                }
                map["AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddrPool") {
                var tmp : [DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool] = []
                for v in dict["AddrPool"] as! [Any] {
                    var model = DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.addrPool = tmp
            }
        }
    }
    public var addrPools: DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPools != nil {
            map["AddrPools"] = self.addrPools?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPools") {
            var model = DescribeDnsGtmInstanceAddressPoolsResponseBody.AddrPools()
            model.fromMap(dict["AddrPools"] as! [String: Any])
            self.addrPools = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDnsGtmInstanceAddressPoolsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceAddressPoolsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmInstanceAddressPoolsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceStatusRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmInstanceStatusResponseBody : Tea.TeaModel {
    public var addrAvailableNum: Int32?

    public var addrNotAvailableNum: Int32?

    public var addrPoolGroupNotAvailableNum: Int32?

    public var requestId: String?

    public var strategyNotAvailableNum: Int32?

    public var switchToFailoverStrategyNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrAvailableNum != nil {
            map["AddrAvailableNum"] = self.addrAvailableNum!
        }
        if self.addrNotAvailableNum != nil {
            map["AddrNotAvailableNum"] = self.addrNotAvailableNum!
        }
        if self.addrPoolGroupNotAvailableNum != nil {
            map["AddrPoolGroupNotAvailableNum"] = self.addrPoolGroupNotAvailableNum!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyNotAvailableNum != nil {
            map["StrategyNotAvailableNum"] = self.strategyNotAvailableNum!
        }
        if self.switchToFailoverStrategyNum != nil {
            map["SwitchToFailoverStrategyNum"] = self.switchToFailoverStrategyNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrAvailableNum") {
            self.addrAvailableNum = dict["AddrAvailableNum"] as! Int32
        }
        if dict.keys.contains("AddrNotAvailableNum") {
            self.addrNotAvailableNum = dict["AddrNotAvailableNum"] as! Int32
        }
        if dict.keys.contains("AddrPoolGroupNotAvailableNum") {
            self.addrPoolGroupNotAvailableNum = dict["AddrPoolGroupNotAvailableNum"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StrategyNotAvailableNum") {
            self.strategyNotAvailableNum = dict["StrategyNotAvailableNum"] as! Int32
        }
        if dict.keys.contains("SwitchToFailoverStrategyNum") {
            self.switchToFailoverStrategyNum = dict["SwitchToFailoverStrategyNum"] as! Int32
        }
    }
}

public class DescribeDnsGtmInstanceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmInstanceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstanceSystemCnameRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmInstanceSystemCnameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var systemCname: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemCname != nil {
            map["SystemCname"] = self.systemCname!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemCname") {
            self.systemCname = dict["SystemCname"] as! String
        }
    }
}

public class DescribeDnsGtmInstanceSystemCnameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstanceSystemCnameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmInstanceSystemCnameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmInstancesRequest : Tea.TeaModel {
    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeDnsGtmInstancesResponseBody : Tea.TeaModel {
    public class GtmInstances : Tea.TeaModel {
        public class Config : Tea.TeaModel {
            public class AlertConfig : Tea.TeaModel {
                public var dingtalkNotice: String?

                public var emailNotice: String?

                public var noticeType: String?

                public var smsNotice: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dingtalkNotice != nil {
                        map["DingtalkNotice"] = self.dingtalkNotice!
                    }
                    if self.emailNotice != nil {
                        map["EmailNotice"] = self.emailNotice!
                    }
                    if self.noticeType != nil {
                        map["NoticeType"] = self.noticeType!
                    }
                    if self.smsNotice != nil {
                        map["SmsNotice"] = self.smsNotice!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DingtalkNotice") {
                        self.dingtalkNotice = dict["DingtalkNotice"] as! String
                    }
                    if dict.keys.contains("EmailNotice") {
                        self.emailNotice = dict["EmailNotice"] as! String
                    }
                    if dict.keys.contains("NoticeType") {
                        self.noticeType = dict["NoticeType"] as! String
                    }
                    if dict.keys.contains("SmsNotice") {
                        self.smsNotice = dict["SmsNotice"] as! String
                    }
                }
            }
            public var alertConfig: [DescribeDnsGtmInstancesResponseBody.GtmInstances.Config.AlertConfig]?

            public var alertGroup: String?

            public var cnameType: String?

            public var instanceName: String?

            public var publicCnameMode: String?

            public var publicRr: String?

            public var publicUserDomainName: String?

            public var publicZoneName: String?

            public var strategyMode: String?

            public var ttl: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertConfig != nil {
                    var tmp : [Any] = []
                    for k in self.alertConfig! {
                        tmp.append(k.toMap())
                    }
                    map["AlertConfig"] = tmp
                }
                if self.alertGroup != nil {
                    map["AlertGroup"] = self.alertGroup!
                }
                if self.cnameType != nil {
                    map["CnameType"] = self.cnameType!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.publicCnameMode != nil {
                    map["PublicCnameMode"] = self.publicCnameMode!
                }
                if self.publicRr != nil {
                    map["PublicRr"] = self.publicRr!
                }
                if self.publicUserDomainName != nil {
                    map["PublicUserDomainName"] = self.publicUserDomainName!
                }
                if self.publicZoneName != nil {
                    map["PublicZoneName"] = self.publicZoneName!
                }
                if self.strategyMode != nil {
                    map["StrategyMode"] = self.strategyMode!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertConfig") {
                    var tmp : [DescribeDnsGtmInstancesResponseBody.GtmInstances.Config.AlertConfig] = []
                    for v in dict["AlertConfig"] as! [Any] {
                        var model = DescribeDnsGtmInstancesResponseBody.GtmInstances.Config.AlertConfig()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.alertConfig = tmp
                }
                if dict.keys.contains("AlertGroup") {
                    self.alertGroup = dict["AlertGroup"] as! String
                }
                if dict.keys.contains("CnameType") {
                    self.cnameType = dict["CnameType"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("PublicCnameMode") {
                    self.publicCnameMode = dict["PublicCnameMode"] as! String
                }
                if dict.keys.contains("PublicRr") {
                    self.publicRr = dict["PublicRr"] as! String
                }
                if dict.keys.contains("PublicUserDomainName") {
                    self.publicUserDomainName = dict["PublicUserDomainName"] as! String
                }
                if dict.keys.contains("PublicZoneName") {
                    self.publicZoneName = dict["PublicZoneName"] as! String
                }
                if dict.keys.contains("StrategyMode") {
                    self.strategyMode = dict["StrategyMode"] as! String
                }
                if dict.keys.contains("Ttl") {
                    self.ttl = dict["Ttl"] as! Int32
                }
            }
        }
        public class UsedQuota : Tea.TeaModel {
            public var dingtalkUsedCount: Int32?

            public var emailUsedCount: Int32?

            public var smsUsedCount: Int32?

            public var taskUsedCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dingtalkUsedCount != nil {
                    map["DingtalkUsedCount"] = self.dingtalkUsedCount!
                }
                if self.emailUsedCount != nil {
                    map["EmailUsedCount"] = self.emailUsedCount!
                }
                if self.smsUsedCount != nil {
                    map["SmsUsedCount"] = self.smsUsedCount!
                }
                if self.taskUsedCount != nil {
                    map["TaskUsedCount"] = self.taskUsedCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DingtalkUsedCount") {
                    self.dingtalkUsedCount = dict["DingtalkUsedCount"] as! Int32
                }
                if dict.keys.contains("EmailUsedCount") {
                    self.emailUsedCount = dict["EmailUsedCount"] as! Int32
                }
                if dict.keys.contains("SmsUsedCount") {
                    self.smsUsedCount = dict["SmsUsedCount"] as! Int32
                }
                if dict.keys.contains("TaskUsedCount") {
                    self.taskUsedCount = dict["TaskUsedCount"] as! Int32
                }
            }
        }
        public var config: DescribeDnsGtmInstancesResponseBody.GtmInstances.Config?

        public var createTime: String?

        public var createTimestamp: Int64?

        public var expireTime: String?

        public var expireTimestamp: Int64?

        public var instanceId: String?

        public var paymentType: String?

        public var resourceGroupId: String?

        public var smsQuota: Int32?

        public var taskQuota: Int32?

        public var usedQuota: DescribeDnsGtmInstancesResponseBody.GtmInstances.UsedQuota?

        public var versionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.config?.validate()
            try self.usedQuota?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.expireTimestamp != nil {
                map["ExpireTimestamp"] = self.expireTimestamp!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.paymentType != nil {
                map["PaymentType"] = self.paymentType!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.smsQuota != nil {
                map["SmsQuota"] = self.smsQuota!
            }
            if self.taskQuota != nil {
                map["TaskQuota"] = self.taskQuota!
            }
            if self.usedQuota != nil {
                map["UsedQuota"] = self.usedQuota?.toMap()
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") {
                var model = DescribeDnsGtmInstancesResponseBody.GtmInstances.Config()
                model.fromMap(dict["Config"] as! [String: Any])
                self.config = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("ExpireTimestamp") {
                self.expireTimestamp = dict["ExpireTimestamp"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("PaymentType") {
                self.paymentType = dict["PaymentType"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("SmsQuota") {
                self.smsQuota = dict["SmsQuota"] as! Int32
            }
            if dict.keys.contains("TaskQuota") {
                self.taskQuota = dict["TaskQuota"] as! Int32
            }
            if dict.keys.contains("UsedQuota") {
                var model = DescribeDnsGtmInstancesResponseBody.GtmInstances.UsedQuota()
                model.fromMap(dict["UsedQuota"] as! [String: Any])
                self.usedQuota = model
            }
            if dict.keys.contains("VersionCode") {
                self.versionCode = dict["VersionCode"] as! String
            }
        }
    }
    public var gtmInstances: [DescribeDnsGtmInstancesResponseBody.GtmInstances]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gtmInstances != nil {
            var tmp : [Any] = []
            for k in self.gtmInstances! {
                tmp.append(k.toMap())
            }
            map["GtmInstances"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GtmInstances") {
            var tmp : [DescribeDnsGtmInstancesResponseBody.GtmInstances] = []
            for v in dict["GtmInstances"] as! [Any] {
                var model = DescribeDnsGtmInstancesResponseBody.GtmInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.gtmInstances = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDnsGtmInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmLogsRequest : Tea.TeaModel {
    public var endTimestamp: Int64?

    public var instanceId: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimestamp != nil {
            map["StartTimestamp"] = self.startTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTimestamp") {
            self.endTimestamp = dict["EndTimestamp"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTimestamp") {
            self.startTimestamp = dict["StartTimestamp"] as! Int64
        }
    }
}

public class DescribeDnsGtmLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public class Log : Tea.TeaModel {
            public var content: String?

            public var entityId: String?

            public var entityName: String?

            public var entityType: String?

            public var id: Int64?

            public var operAction: String?

            public var operTime: String?

            public var operTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.entityId != nil {
                    map["EntityId"] = self.entityId!
                }
                if self.entityName != nil {
                    map["EntityName"] = self.entityName!
                }
                if self.entityType != nil {
                    map["EntityType"] = self.entityType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.operAction != nil {
                    map["OperAction"] = self.operAction!
                }
                if self.operTime != nil {
                    map["OperTime"] = self.operTime!
                }
                if self.operTimestamp != nil {
                    map["OperTimestamp"] = self.operTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("EntityId") {
                    self.entityId = dict["EntityId"] as! String
                }
                if dict.keys.contains("EntityName") {
                    self.entityName = dict["EntityName"] as! String
                }
                if dict.keys.contains("EntityType") {
                    self.entityType = dict["EntityType"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("OperAction") {
                    self.operAction = dict["OperAction"] as! String
                }
                if dict.keys.contains("OperTime") {
                    self.operTime = dict["OperTime"] as! String
                }
                if dict.keys.contains("OperTimestamp") {
                    self.operTimestamp = dict["OperTimestamp"] as! Int64
                }
            }
        }
        public var log: [DescribeDnsGtmLogsResponseBody.Logs.Log]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.log != nil {
                var tmp : [Any] = []
                for k in self.log! {
                    tmp.append(k.toMap())
                }
                map["Log"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Log") {
                var tmp : [DescribeDnsGtmLogsResponseBody.Logs.Log] = []
                for v in dict["Log"] as! [Any] {
                    var model = DescribeDnsGtmLogsResponseBody.Logs.Log()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.log = tmp
            }
        }
    }
    public var logs: DescribeDnsGtmLogsResponseBody.Logs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            map["Logs"] = self.logs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logs") {
            var model = DescribeDnsGtmLogsResponseBody.Logs()
            model.fromMap(dict["Logs"] as! [String: Any])
            self.logs = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDnsGtmLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmMonitorAvailableConfigRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDnsGtmMonitorAvailableConfigResponseBody : Tea.TeaModel {
    public class DomainIpv4IspCityNodes : Tea.TeaModel {
        public class DomainIpv4IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! [String]
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("DefaultSelected") {
                    self.defaultSelected = dict["DefaultSelected"] as! Bool
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") {
                    self.groupType = dict["GroupType"] as! String
                }
                if dict.keys.contains("Ips") {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode.Ips()
                    model.fromMap(dict["Ips"] as! [String: Any])
                    self.ips = model
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
            }
        }
        public var domainIpv4IspCityNode: [DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainIpv4IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.domainIpv4IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["DomainIpv4IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainIpv4IspCityNode") {
                var tmp : [DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode] = []
                for v in dict["DomainIpv4IspCityNode"] as! [Any] {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes.DomainIpv4IspCityNode()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainIpv4IspCityNode = tmp
            }
        }
    }
    public class DomainIpv6IspCityNodes : Tea.TeaModel {
        public class DomainIpv6IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ip") {
                        self.ip = dict["ip"] as! [String]
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("DefaultSelected") {
                    self.defaultSelected = dict["DefaultSelected"] as! Bool
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") {
                    self.groupType = dict["GroupType"] as! String
                }
                if dict.keys.contains("Ips") {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode.Ips()
                    model.fromMap(dict["Ips"] as! [String: Any])
                    self.ips = model
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
            }
        }
        public var domainIpv6IspCityNode: [DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainIpv6IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.domainIpv6IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["DomainIpv6IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainIpv6IspCityNode") {
                var tmp : [DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode] = []
                for v in dict["DomainIpv6IspCityNode"] as! [Any] {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes.DomainIpv6IspCityNode()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainIpv6IspCityNode = tmp
            }
        }
    }
    public class Ipv4IspCityNodes : Tea.TeaModel {
        public class Ipv4IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! [String]
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("DefaultSelected") {
                    self.defaultSelected = dict["DefaultSelected"] as! Bool
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") {
                    self.groupType = dict["GroupType"] as! String
                }
                if dict.keys.contains("Ips") {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode.Ips()
                    model.fromMap(dict["Ips"] as! [String: Any])
                    self.ips = model
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
            }
        }
        public var ipv4IspCityNode: [DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.ipv4IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["Ipv4IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv4IspCityNode") {
                var tmp : [DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode] = []
                for v in dict["Ipv4IspCityNode"] as! [Any] {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv4IspCityNode = tmp
            }
        }
    }
    public class Ipv6IspCityNodes : Tea.TeaModel {
        public class Ipv6IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! [String]
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("DefaultSelected") {
                    self.defaultSelected = dict["DefaultSelected"] as! Bool
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") {
                    self.groupType = dict["GroupType"] as! String
                }
                if dict.keys.contains("Ips") {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode.Ips()
                    model.fromMap(dict["Ips"] as! [String: Any])
                    self.ips = model
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
            }
        }
        public var ipv6IspCityNode: [DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.ipv6IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["Ipv6IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6IspCityNode") {
                var tmp : [DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode] = []
                for v in dict["Ipv6IspCityNode"] as! [Any] {
                    var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6IspCityNode = tmp
            }
        }
    }
    public var domainIpv4IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes?

    public var domainIpv6IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes?

    public var ipv4IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes?

    public var ipv6IspCityNodes: DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainIpv4IspCityNodes?.validate()
        try self.domainIpv6IspCityNodes?.validate()
        try self.ipv4IspCityNodes?.validate()
        try self.ipv6IspCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainIpv4IspCityNodes != nil {
            map["DomainIpv4IspCityNodes"] = self.domainIpv4IspCityNodes?.toMap()
        }
        if self.domainIpv6IspCityNodes != nil {
            map["DomainIpv6IspCityNodes"] = self.domainIpv6IspCityNodes?.toMap()
        }
        if self.ipv4IspCityNodes != nil {
            map["Ipv4IspCityNodes"] = self.ipv4IspCityNodes?.toMap()
        }
        if self.ipv6IspCityNodes != nil {
            map["Ipv6IspCityNodes"] = self.ipv6IspCityNodes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainIpv4IspCityNodes") {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv4IspCityNodes()
            model.fromMap(dict["DomainIpv4IspCityNodes"] as! [String: Any])
            self.domainIpv4IspCityNodes = model
        }
        if dict.keys.contains("DomainIpv6IspCityNodes") {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.DomainIpv6IspCityNodes()
            model.fromMap(dict["DomainIpv6IspCityNodes"] as! [String: Any])
            self.domainIpv6IspCityNodes = model
        }
        if dict.keys.contains("Ipv4IspCityNodes") {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv4IspCityNodes()
            model.fromMap(dict["Ipv4IspCityNodes"] as! [String: Any])
            self.ipv4IspCityNodes = model
        }
        if dict.keys.contains("Ipv6IspCityNodes") {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody.Ipv6IspCityNodes()
            model.fromMap(dict["Ipv6IspCityNodes"] as! [String: Any])
            self.ipv6IspCityNodes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDnsGtmMonitorAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmMonitorAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmMonitorAvailableConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsGtmMonitorConfigRequest : Tea.TeaModel {
    public var lang: String?

    public var monitorConfigId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
    }
}

public class DescribeDnsGtmMonitorConfigResponseBody : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public class IspCityNode : Tea.TeaModel {
            public var cityCode: String?

            public var cityName: String?

            public var countryCode: String?

            public var countryName: String?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.countryCode != nil {
                    map["CountryCode"] = self.countryCode!
                }
                if self.countryName != nil {
                    map["CountryName"] = self.countryName!
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("CountryCode") {
                    self.countryCode = dict["CountryCode"] as! String
                }
                if dict.keys.contains("CountryName") {
                    self.countryName = dict["CountryName"] as! String
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
            }
        }
        public var ispCityNode: [DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ispCityNode != nil {
                var tmp : [Any] = []
                for k in self.ispCityNode! {
                    tmp.append(k.toMap())
                }
                map["IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IspCityNode") {
                var tmp : [DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode] = []
                for v in dict["IspCityNode"] as! [Any] {
                    var model = DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ispCityNode = tmp
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNodes: DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes?

    public var monitorConfigId: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var requestId: String?

    public var timeout: Int32?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ispCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNodes != nil {
            map["IspCityNodes"] = self.ispCityNodes?.toMap()
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNodes") {
            var model = DescribeDnsGtmMonitorConfigResponseBody.IspCityNodes()
            model.fromMap(dict["IspCityNodes"] as! [String: Any])
            self.ispCityNodes = model
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
    }
}

public class DescribeDnsGtmMonitorConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsGtmMonitorConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsGtmMonitorConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsProductInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DescribeDnsProductInstanceResponseBody : Tea.TeaModel {
    public class DnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServer") {
                self.dnsServer = dict["DnsServer"] as! [String]
            }
        }
    }
    public var autoRenewal: Bool?

    public var bindCount: Int64?

    public var bindDomainCount: Int64?

    public var bindDomainUsedCount: Int64?

    public var bindUsedCount: Int64?

    public var DDosDefendFlow: Int64?

    public var DDosDefendQuery: Int64?

    public var dnsSLBCount: Int64?

    public var dnsSecurity: String?

    public var dnsServers: DescribeDnsProductInstanceResponseBody.DnsServers?

    public var domain: String?

    public var domainType: String?

    public var endTime: String?

    public var endTimestamp: Int64?

    public var gslb: Bool?

    public var ISPLines: String?

    public var ISPRegionLines: String?

    public var inBlackHole: Bool?

    public var inClean: Bool?

    public var instanceId: String?

    public var monitorFrequency: Int64?

    public var monitorNodeCount: Int64?

    public var monitorTaskCount: Int64?

    public var overseaDDosDefendFlow: Int64?

    public var overseaLine: String?

    public var paymentType: String?

    public var regionLines: Bool?

    public var requestId: String?

    public var searchEngineLines: String?

    public var startTime: String?

    public var startTimestamp: Int64?

    public var subDomainLevel: Int64?

    public var TTLMinValue: Int64?

    public var URLForwardCount: Int64?

    public var versionCode: String?

    public var versionName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dnsServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenewal != nil {
            map["AutoRenewal"] = self.autoRenewal!
        }
        if self.bindCount != nil {
            map["BindCount"] = self.bindCount!
        }
        if self.bindDomainCount != nil {
            map["BindDomainCount"] = self.bindDomainCount!
        }
        if self.bindDomainUsedCount != nil {
            map["BindDomainUsedCount"] = self.bindDomainUsedCount!
        }
        if self.bindUsedCount != nil {
            map["BindUsedCount"] = self.bindUsedCount!
        }
        if self.DDosDefendFlow != nil {
            map["DDosDefendFlow"] = self.DDosDefendFlow!
        }
        if self.DDosDefendQuery != nil {
            map["DDosDefendQuery"] = self.DDosDefendQuery!
        }
        if self.dnsSLBCount != nil {
            map["DnsSLBCount"] = self.dnsSLBCount!
        }
        if self.dnsSecurity != nil {
            map["DnsSecurity"] = self.dnsSecurity!
        }
        if self.dnsServers != nil {
            map["DnsServers"] = self.dnsServers?.toMap()
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.gslb != nil {
            map["Gslb"] = self.gslb!
        }
        if self.ISPLines != nil {
            map["ISPLines"] = self.ISPLines!
        }
        if self.ISPRegionLines != nil {
            map["ISPRegionLines"] = self.ISPRegionLines!
        }
        if self.inBlackHole != nil {
            map["InBlackHole"] = self.inBlackHole!
        }
        if self.inClean != nil {
            map["InClean"] = self.inClean!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.monitorFrequency != nil {
            map["MonitorFrequency"] = self.monitorFrequency!
        }
        if self.monitorNodeCount != nil {
            map["MonitorNodeCount"] = self.monitorNodeCount!
        }
        if self.monitorTaskCount != nil {
            map["MonitorTaskCount"] = self.monitorTaskCount!
        }
        if self.overseaDDosDefendFlow != nil {
            map["OverseaDDosDefendFlow"] = self.overseaDDosDefendFlow!
        }
        if self.overseaLine != nil {
            map["OverseaLine"] = self.overseaLine!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.regionLines != nil {
            map["RegionLines"] = self.regionLines!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchEngineLines != nil {
            map["SearchEngineLines"] = self.searchEngineLines!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.startTimestamp != nil {
            map["StartTimestamp"] = self.startTimestamp!
        }
        if self.subDomainLevel != nil {
            map["SubDomainLevel"] = self.subDomainLevel!
        }
        if self.TTLMinValue != nil {
            map["TTLMinValue"] = self.TTLMinValue!
        }
        if self.URLForwardCount != nil {
            map["URLForwardCount"] = self.URLForwardCount!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        if self.versionName != nil {
            map["VersionName"] = self.versionName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenewal") {
            self.autoRenewal = dict["AutoRenewal"] as! Bool
        }
        if dict.keys.contains("BindCount") {
            self.bindCount = dict["BindCount"] as! Int64
        }
        if dict.keys.contains("BindDomainCount") {
            self.bindDomainCount = dict["BindDomainCount"] as! Int64
        }
        if dict.keys.contains("BindDomainUsedCount") {
            self.bindDomainUsedCount = dict["BindDomainUsedCount"] as! Int64
        }
        if dict.keys.contains("BindUsedCount") {
            self.bindUsedCount = dict["BindUsedCount"] as! Int64
        }
        if dict.keys.contains("DDosDefendFlow") {
            self.DDosDefendFlow = dict["DDosDefendFlow"] as! Int64
        }
        if dict.keys.contains("DDosDefendQuery") {
            self.DDosDefendQuery = dict["DDosDefendQuery"] as! Int64
        }
        if dict.keys.contains("DnsSLBCount") {
            self.dnsSLBCount = dict["DnsSLBCount"] as! Int64
        }
        if dict.keys.contains("DnsSecurity") {
            self.dnsSecurity = dict["DnsSecurity"] as! String
        }
        if dict.keys.contains("DnsServers") {
            var model = DescribeDnsProductInstanceResponseBody.DnsServers()
            model.fromMap(dict["DnsServers"] as! [String: Any])
            self.dnsServers = model
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("DomainType") {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EndTimestamp") {
            self.endTimestamp = dict["EndTimestamp"] as! Int64
        }
        if dict.keys.contains("Gslb") {
            self.gslb = dict["Gslb"] as! Bool
        }
        if dict.keys.contains("ISPLines") {
            self.ISPLines = dict["ISPLines"] as! String
        }
        if dict.keys.contains("ISPRegionLines") {
            self.ISPRegionLines = dict["ISPRegionLines"] as! String
        }
        if dict.keys.contains("InBlackHole") {
            self.inBlackHole = dict["InBlackHole"] as! Bool
        }
        if dict.keys.contains("InClean") {
            self.inClean = dict["InClean"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MonitorFrequency") {
            self.monitorFrequency = dict["MonitorFrequency"] as! Int64
        }
        if dict.keys.contains("MonitorNodeCount") {
            self.monitorNodeCount = dict["MonitorNodeCount"] as! Int64
        }
        if dict.keys.contains("MonitorTaskCount") {
            self.monitorTaskCount = dict["MonitorTaskCount"] as! Int64
        }
        if dict.keys.contains("OverseaDDosDefendFlow") {
            self.overseaDDosDefendFlow = dict["OverseaDDosDefendFlow"] as! Int64
        }
        if dict.keys.contains("OverseaLine") {
            self.overseaLine = dict["OverseaLine"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("RegionLines") {
            self.regionLines = dict["RegionLines"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchEngineLines") {
            self.searchEngineLines = dict["SearchEngineLines"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StartTimestamp") {
            self.startTimestamp = dict["StartTimestamp"] as! Int64
        }
        if dict.keys.contains("SubDomainLevel") {
            self.subDomainLevel = dict["SubDomainLevel"] as! Int64
        }
        if dict.keys.contains("TTLMinValue") {
            self.TTLMinValue = dict["TTLMinValue"] as! Int64
        }
        if dict.keys.contains("URLForwardCount") {
            self.URLForwardCount = dict["URLForwardCount"] as! Int64
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
        if dict.keys.contains("VersionName") {
            self.versionName = dict["VersionName"] as! String
        }
    }
}

public class DescribeDnsProductInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsProductInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsProductInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDnsProductInstancesRequest : Tea.TeaModel {
    public var direction: String?

    public var domainType: String?

    public var lang: String?

    public var orderBy: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var userClientIp: String?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("DomainType") {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
    }
}

public class DescribeDnsProductInstancesResponseBody : Tea.TeaModel {
    public class DnsProducts : Tea.TeaModel {
        public class DnsProduct : Tea.TeaModel {
            public var autoRenewal: Bool?

            public var bindCount: Int64?

            public var bindDomainCount: Int64?

            public var bindDomainUsedCount: Int64?

            public var bindUsedCount: Int64?

            public var DDosDefendFlow: Int64?

            public var DDosDefendQuery: Int64?

            public var dnsSLBCount: Int64?

            public var dnsSecurity: String?

            public var domain: String?

            public var endTime: String?

            public var endTimestamp: Int64?

            public var gslb: Bool?

            public var ISPLines: String?

            public var ISPRegionLines: String?

            public var inBlackHole: Bool?

            public var inClean: Bool?

            public var instanceId: String?

            public var monitorFrequency: Int64?

            public var monitorNodeCount: Int64?

            public var monitorTaskCount: Int64?

            public var overseaDDosDefendFlow: Int64?

            public var overseaLine: String?

            public var paymentType: String?

            public var regionLines: Bool?

            public var searchEngineLines: String?

            public var startTime: String?

            public var startTimestamp: Int64?

            public var subDomainLevel: Int64?

            public var TTLMinValue: Int64?

            public var URLForwardCount: Int64?

            public var versionCode: String?

            public var versionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoRenewal != nil {
                    map["AutoRenewal"] = self.autoRenewal!
                }
                if self.bindCount != nil {
                    map["BindCount"] = self.bindCount!
                }
                if self.bindDomainCount != nil {
                    map["BindDomainCount"] = self.bindDomainCount!
                }
                if self.bindDomainUsedCount != nil {
                    map["BindDomainUsedCount"] = self.bindDomainUsedCount!
                }
                if self.bindUsedCount != nil {
                    map["BindUsedCount"] = self.bindUsedCount!
                }
                if self.DDosDefendFlow != nil {
                    map["DDosDefendFlow"] = self.DDosDefendFlow!
                }
                if self.DDosDefendQuery != nil {
                    map["DDosDefendQuery"] = self.DDosDefendQuery!
                }
                if self.dnsSLBCount != nil {
                    map["DnsSLBCount"] = self.dnsSLBCount!
                }
                if self.dnsSecurity != nil {
                    map["DnsSecurity"] = self.dnsSecurity!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.endTimestamp != nil {
                    map["EndTimestamp"] = self.endTimestamp!
                }
                if self.gslb != nil {
                    map["Gslb"] = self.gslb!
                }
                if self.ISPLines != nil {
                    map["ISPLines"] = self.ISPLines!
                }
                if self.ISPRegionLines != nil {
                    map["ISPRegionLines"] = self.ISPRegionLines!
                }
                if self.inBlackHole != nil {
                    map["InBlackHole"] = self.inBlackHole!
                }
                if self.inClean != nil {
                    map["InClean"] = self.inClean!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.monitorFrequency != nil {
                    map["MonitorFrequency"] = self.monitorFrequency!
                }
                if self.monitorNodeCount != nil {
                    map["MonitorNodeCount"] = self.monitorNodeCount!
                }
                if self.monitorTaskCount != nil {
                    map["MonitorTaskCount"] = self.monitorTaskCount!
                }
                if self.overseaDDosDefendFlow != nil {
                    map["OverseaDDosDefendFlow"] = self.overseaDDosDefendFlow!
                }
                if self.overseaLine != nil {
                    map["OverseaLine"] = self.overseaLine!
                }
                if self.paymentType != nil {
                    map["PaymentType"] = self.paymentType!
                }
                if self.regionLines != nil {
                    map["RegionLines"] = self.regionLines!
                }
                if self.searchEngineLines != nil {
                    map["SearchEngineLines"] = self.searchEngineLines!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.startTimestamp != nil {
                    map["StartTimestamp"] = self.startTimestamp!
                }
                if self.subDomainLevel != nil {
                    map["SubDomainLevel"] = self.subDomainLevel!
                }
                if self.TTLMinValue != nil {
                    map["TTLMinValue"] = self.TTLMinValue!
                }
                if self.URLForwardCount != nil {
                    map["URLForwardCount"] = self.URLForwardCount!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                if self.versionName != nil {
                    map["VersionName"] = self.versionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoRenewal") {
                    self.autoRenewal = dict["AutoRenewal"] as! Bool
                }
                if dict.keys.contains("BindCount") {
                    self.bindCount = dict["BindCount"] as! Int64
                }
                if dict.keys.contains("BindDomainCount") {
                    self.bindDomainCount = dict["BindDomainCount"] as! Int64
                }
                if dict.keys.contains("BindDomainUsedCount") {
                    self.bindDomainUsedCount = dict["BindDomainUsedCount"] as! Int64
                }
                if dict.keys.contains("BindUsedCount") {
                    self.bindUsedCount = dict["BindUsedCount"] as! Int64
                }
                if dict.keys.contains("DDosDefendFlow") {
                    self.DDosDefendFlow = dict["DDosDefendFlow"] as! Int64
                }
                if dict.keys.contains("DDosDefendQuery") {
                    self.DDosDefendQuery = dict["DDosDefendQuery"] as! Int64
                }
                if dict.keys.contains("DnsSLBCount") {
                    self.dnsSLBCount = dict["DnsSLBCount"] as! Int64
                }
                if dict.keys.contains("DnsSecurity") {
                    self.dnsSecurity = dict["DnsSecurity"] as! String
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("EndTimestamp") {
                    self.endTimestamp = dict["EndTimestamp"] as! Int64
                }
                if dict.keys.contains("Gslb") {
                    self.gslb = dict["Gslb"] as! Bool
                }
                if dict.keys.contains("ISPLines") {
                    self.ISPLines = dict["ISPLines"] as! String
                }
                if dict.keys.contains("ISPRegionLines") {
                    self.ISPRegionLines = dict["ISPRegionLines"] as! String
                }
                if dict.keys.contains("InBlackHole") {
                    self.inBlackHole = dict["InBlackHole"] as! Bool
                }
                if dict.keys.contains("InClean") {
                    self.inClean = dict["InClean"] as! Bool
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("MonitorFrequency") {
                    self.monitorFrequency = dict["MonitorFrequency"] as! Int64
                }
                if dict.keys.contains("MonitorNodeCount") {
                    self.monitorNodeCount = dict["MonitorNodeCount"] as! Int64
                }
                if dict.keys.contains("MonitorTaskCount") {
                    self.monitorTaskCount = dict["MonitorTaskCount"] as! Int64
                }
                if dict.keys.contains("OverseaDDosDefendFlow") {
                    self.overseaDDosDefendFlow = dict["OverseaDDosDefendFlow"] as! Int64
                }
                if dict.keys.contains("OverseaLine") {
                    self.overseaLine = dict["OverseaLine"] as! String
                }
                if dict.keys.contains("PaymentType") {
                    self.paymentType = dict["PaymentType"] as! String
                }
                if dict.keys.contains("RegionLines") {
                    self.regionLines = dict["RegionLines"] as! Bool
                }
                if dict.keys.contains("SearchEngineLines") {
                    self.searchEngineLines = dict["SearchEngineLines"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("StartTimestamp") {
                    self.startTimestamp = dict["StartTimestamp"] as! Int64
                }
                if dict.keys.contains("SubDomainLevel") {
                    self.subDomainLevel = dict["SubDomainLevel"] as! Int64
                }
                if dict.keys.contains("TTLMinValue") {
                    self.TTLMinValue = dict["TTLMinValue"] as! Int64
                }
                if dict.keys.contains("URLForwardCount") {
                    self.URLForwardCount = dict["URLForwardCount"] as! Int64
                }
                if dict.keys.contains("VersionCode") {
                    self.versionCode = dict["VersionCode"] as! String
                }
                if dict.keys.contains("VersionName") {
                    self.versionName = dict["VersionName"] as! String
                }
            }
        }
        public var dnsProduct: [DescribeDnsProductInstancesResponseBody.DnsProducts.DnsProduct]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsProduct != nil {
                var tmp : [Any] = []
                for k in self.dnsProduct! {
                    tmp.append(k.toMap())
                }
                map["DnsProduct"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsProduct") {
                var tmp : [DescribeDnsProductInstancesResponseBody.DnsProducts.DnsProduct] = []
                for v in dict["DnsProduct"] as! [Any] {
                    var model = DescribeDnsProductInstancesResponseBody.DnsProducts.DnsProduct()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dnsProduct = tmp
            }
        }
    }
    public var dnsProducts: DescribeDnsProductInstancesResponseBody.DnsProducts?

    public var domainType: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dnsProducts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dnsProducts != nil {
            map["DnsProducts"] = self.dnsProducts?.toMap()
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DnsProducts") {
            var model = DescribeDnsProductInstancesResponseBody.DnsProducts()
            model.fromMap(dict["DnsProducts"] as! [String: Any])
            self.dnsProducts = model
        }
        if dict.keys.contains("DomainType") {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDnsProductInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDnsProductInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDnsProductInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDohAccountStatisticsRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeDohAccountStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var timestamp: Int64?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var statistics: [DescribeDohAccountStatisticsResponseBody.Statistics]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var tmp : [DescribeDohAccountStatisticsResponseBody.Statistics] = []
            for v in dict["Statistics"] as! [Any] {
                var model = DescribeDohAccountStatisticsResponseBody.Statistics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.statistics = tmp
        }
    }
}

public class DescribeDohAccountStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohAccountStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDohAccountStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDohDomainStatisticsRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeDohDomainStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var timestamp: Int64?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var statistics: [DescribeDohDomainStatisticsResponseBody.Statistics]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var tmp : [DescribeDohDomainStatisticsResponseBody.Statistics] = []
            for v in dict["Statistics"] as! [Any] {
                var model = DescribeDohDomainStatisticsResponseBody.Statistics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.statistics = tmp
        }
    }
}

public class DescribeDohDomainStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohDomainStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDohDomainStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDohDomainStatisticsSummaryRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeDohDomainStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var domainName: String?

        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var ipCount: Int64?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("HttpCount") {
                self.httpCount = dict["HttpCount"] as! Int64
            }
            if dict.keys.contains("HttpsCount") {
                self.httpsCount = dict["HttpsCount"] as! Int64
            }
            if dict.keys.contains("IpCount") {
                self.ipCount = dict["IpCount"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: [DescribeDohDomainStatisticsSummaryResponseBody.Statistics]?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var tmp : [DescribeDohDomainStatisticsSummaryResponseBody.Statistics] = []
            for v in dict["Statistics"] as! [Any] {
                var model = DescribeDohDomainStatisticsSummaryResponseBody.Statistics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.statistics = tmp
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDohDomainStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohDomainStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDohDomainStatisticsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDohSubDomainStatisticsRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
    }
}

public class DescribeDohSubDomainStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var timestamp: Int64?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var statistics: [DescribeDohSubDomainStatisticsResponseBody.Statistics]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var tmp : [DescribeDohSubDomainStatisticsResponseBody.Statistics] = []
            for v in dict["Statistics"] as! [Any] {
                var model = DescribeDohSubDomainStatisticsResponseBody.Statistics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.statistics = tmp
        }
    }
}

public class DescribeDohSubDomainStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohSubDomainStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDohSubDomainStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDohSubDomainStatisticsSummaryRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startDate: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
    }
}

public class DescribeDohSubDomainStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var ipCount: Int64?

        public var subDomain: String?

        public var totalCount: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HttpCount") {
                self.httpCount = dict["HttpCount"] as! Int64
            }
            if dict.keys.contains("HttpsCount") {
                self.httpsCount = dict["HttpsCount"] as! Int64
            }
            if dict.keys.contains("IpCount") {
                self.ipCount = dict["IpCount"] as! Int64
            }
            if dict.keys.contains("SubDomain") {
                self.subDomain = dict["SubDomain"] as! String
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: [DescribeDohSubDomainStatisticsSummaryResponseBody.Statistics]?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var tmp : [DescribeDohSubDomainStatisticsSummaryResponseBody.Statistics] = []
            for v in dict["Statistics"] as! [Any] {
                var model = DescribeDohSubDomainStatisticsSummaryResponseBody.Statistics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.statistics = tmp
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDohSubDomainStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohSubDomainStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDohSubDomainStatisticsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDohUserInfoRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeDohUserInfoResponseBody : Tea.TeaModel {
    public var domainCount: Int32?

    public var pdnsId: Int64?

    public var requestId: String?

    public var subDomainCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainCount != nil {
            map["DomainCount"] = self.domainCount!
        }
        if self.pdnsId != nil {
            map["PdnsId"] = self.pdnsId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subDomainCount != nil {
            map["SubDomainCount"] = self.subDomainCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainCount") {
            self.domainCount = dict["DomainCount"] as! Int32
        }
        if dict.keys.contains("PdnsId") {
            self.pdnsId = dict["PdnsId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubDomainCount") {
            self.subDomainCount = dict["SubDomainCount"] as! Int32
        }
    }
}

public class DescribeDohUserInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDohUserInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDohUserInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainDnssecInfoRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDomainDnssecInfoResponseBody : Tea.TeaModel {
    public var algorithm: String?

    public var digest: String?

    public var digestType: String?

    public var domainName: String?

    public var dsRecord: String?

    public var flags: String?

    public var keyTag: String?

    public var publicKey: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithm != nil {
            map["Algorithm"] = self.algorithm!
        }
        if self.digest != nil {
            map["Digest"] = self.digest!
        }
        if self.digestType != nil {
            map["DigestType"] = self.digestType!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.dsRecord != nil {
            map["DsRecord"] = self.dsRecord!
        }
        if self.flags != nil {
            map["Flags"] = self.flags!
        }
        if self.keyTag != nil {
            map["KeyTag"] = self.keyTag!
        }
        if self.publicKey != nil {
            map["PublicKey"] = self.publicKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Algorithm") {
            self.algorithm = dict["Algorithm"] as! String
        }
        if dict.keys.contains("Digest") {
            self.digest = dict["Digest"] as! String
        }
        if dict.keys.contains("DigestType") {
            self.digestType = dict["DigestType"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DsRecord") {
            self.dsRecord = dict["DsRecord"] as! String
        }
        if dict.keys.contains("Flags") {
            self.flags = dict["Flags"] as! String
        }
        if dict.keys.contains("KeyTag") {
            self.keyTag = dict["KeyTag"] as! String
        }
        if dict.keys.contains("PublicKey") {
            self.publicKey = dict["PublicKey"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeDomainDnssecInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainDnssecInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainDnssecInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainGroupsRequest : Tea.TeaModel {
    public var keyWord: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribeDomainGroupsResponseBody : Tea.TeaModel {
    public class DomainGroups : Tea.TeaModel {
        public class DomainGroup : Tea.TeaModel {
            public var domainCount: Int64?

            public var groupId: String?

            public var groupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainCount != nil {
                    map["DomainCount"] = self.domainCount!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainCount") {
                    self.domainCount = dict["DomainCount"] as! Int64
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
            }
        }
        public var domainGroup: [DescribeDomainGroupsResponseBody.DomainGroups.DomainGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainGroup != nil {
                var tmp : [Any] = []
                for k in self.domainGroup! {
                    tmp.append(k.toMap())
                }
                map["DomainGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainGroup") {
                var tmp : [DescribeDomainGroupsResponseBody.DomainGroups.DomainGroup] = []
                for v in dict["DomainGroup"] as! [Any] {
                    var model = DescribeDomainGroupsResponseBody.DomainGroups.DomainGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainGroup = tmp
            }
        }
    }
    public var domainGroups: DescribeDomainGroupsResponseBody.DomainGroups?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainGroups != nil {
            map["DomainGroups"] = self.domainGroups?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainGroups") {
            var model = DescribeDomainGroupsResponseBody.DomainGroups()
            model.fromMap(dict["DomainGroups"] as! [String: Any])
            self.domainGroups = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDomainGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainInfoRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var needDetailAttributes: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.needDetailAttributes != nil {
            map["NeedDetailAttributes"] = self.needDetailAttributes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NeedDetailAttributes") {
            self.needDetailAttributes = dict["NeedDetailAttributes"] as! Bool
        }
    }
}

public class DescribeDomainInfoResponseBody : Tea.TeaModel {
    public class AvailableTtls : Tea.TeaModel {
        public var availableTtl: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableTtl != nil {
                map["AvailableTtl"] = self.availableTtl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableTtl") {
                self.availableTtl = dict["AvailableTtl"] as! [String]
            }
        }
    }
    public class DnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServer") {
                self.dnsServer = dict["DnsServer"] as! [String]
            }
        }
    }
    public class RecordLines : Tea.TeaModel {
        public class RecordLine : Tea.TeaModel {
            public var fatherCode: String?

            public var lineCode: String?

            public var lineDisplayName: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineDisplayName != nil {
                    map["LineDisplayName"] = self.lineDisplayName!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FatherCode") {
                    self.fatherCode = dict["FatherCode"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineDisplayName") {
                    self.lineDisplayName = dict["LineDisplayName"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
            }
        }
        public var recordLine: [DescribeDomainInfoResponseBody.RecordLines.RecordLine]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordLine != nil {
                var tmp : [Any] = []
                for k in self.recordLine! {
                    tmp.append(k.toMap())
                }
                map["RecordLine"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecordLine") {
                var tmp : [DescribeDomainInfoResponseBody.RecordLines.RecordLine] = []
                for v in dict["RecordLine"] as! [Any] {
                    var model = DescribeDomainInfoResponseBody.RecordLines.RecordLine()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recordLine = tmp
            }
        }
    }
    public var aliDomain: Bool?

    public var availableTtls: DescribeDomainInfoResponseBody.AvailableTtls?

    public var createTime: String?

    public var dnsServers: DescribeDomainInfoResponseBody.DnsServers?

    public var domainId: String?

    public var domainLoggingSwitchStatus: String?

    public var domainName: String?

    public var groupId: String?

    public var groupName: String?

    public var inBlackHole: Bool?

    public var inClean: Bool?

    public var instanceId: String?

    public var lineType: String?

    public var minTtl: Int64?

    public var punyCode: String?

    public var recordLineTreeJson: String?

    public var recordLines: DescribeDomainInfoResponseBody.RecordLines?

    public var regionLines: Bool?

    public var remark: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var slaveDns: Bool?

    public var subDomain: Bool?

    public var versionCode: String?

    public var versionName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.availableTtls?.validate()
        try self.dnsServers?.validate()
        try self.recordLines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliDomain != nil {
            map["AliDomain"] = self.aliDomain!
        }
        if self.availableTtls != nil {
            map["AvailableTtls"] = self.availableTtls?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.dnsServers != nil {
            map["DnsServers"] = self.dnsServers?.toMap()
        }
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainLoggingSwitchStatus != nil {
            map["DomainLoggingSwitchStatus"] = self.domainLoggingSwitchStatus!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.inBlackHole != nil {
            map["InBlackHole"] = self.inBlackHole!
        }
        if self.inClean != nil {
            map["InClean"] = self.inClean!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lineType != nil {
            map["LineType"] = self.lineType!
        }
        if self.minTtl != nil {
            map["MinTtl"] = self.minTtl!
        }
        if self.punyCode != nil {
            map["PunyCode"] = self.punyCode!
        }
        if self.recordLineTreeJson != nil {
            map["RecordLineTreeJson"] = self.recordLineTreeJson!
        }
        if self.recordLines != nil {
            map["RecordLines"] = self.recordLines?.toMap()
        }
        if self.regionLines != nil {
            map["RegionLines"] = self.regionLines!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.slaveDns != nil {
            map["SlaveDns"] = self.slaveDns!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        if self.versionName != nil {
            map["VersionName"] = self.versionName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliDomain") {
            self.aliDomain = dict["AliDomain"] as! Bool
        }
        if dict.keys.contains("AvailableTtls") {
            var model = DescribeDomainInfoResponseBody.AvailableTtls()
            model.fromMap(dict["AvailableTtls"] as! [String: Any])
            self.availableTtls = model
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("DnsServers") {
            var model = DescribeDomainInfoResponseBody.DnsServers()
            model.fromMap(dict["DnsServers"] as! [String: Any])
            self.dnsServers = model
        }
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! String
        }
        if dict.keys.contains("DomainLoggingSwitchStatus") {
            self.domainLoggingSwitchStatus = dict["DomainLoggingSwitchStatus"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InBlackHole") {
            self.inBlackHole = dict["InBlackHole"] as! Bool
        }
        if dict.keys.contains("InClean") {
            self.inClean = dict["InClean"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LineType") {
            self.lineType = dict["LineType"] as! String
        }
        if dict.keys.contains("MinTtl") {
            self.minTtl = dict["MinTtl"] as! Int64
        }
        if dict.keys.contains("PunyCode") {
            self.punyCode = dict["PunyCode"] as! String
        }
        if dict.keys.contains("RecordLineTreeJson") {
            self.recordLineTreeJson = dict["RecordLineTreeJson"] as! String
        }
        if dict.keys.contains("RecordLines") {
            var model = DescribeDomainInfoResponseBody.RecordLines()
            model.fromMap(dict["RecordLines"] as! [String: Any])
            self.recordLines = model
        }
        if dict.keys.contains("RegionLines") {
            self.regionLines = dict["RegionLines"] as! Bool
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SlaveDns") {
            self.slaveDns = dict["SlaveDns"] as! Bool
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! Bool
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
        if dict.keys.contains("VersionName") {
            self.versionName = dict["VersionName"] as! String
        }
    }
}

public class DescribeDomainInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainLogsRequest : Tea.TeaModel {
    public var groupId: String?

    public var keyWord: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var type: String?

    public var endDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.endDate != nil {
            map["endDate"] = self.endDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("endDate") {
            self.endDate = dict["endDate"] as! String
        }
    }
}

public class DescribeDomainLogsResponseBody : Tea.TeaModel {
    public class DomainLogs : Tea.TeaModel {
        public class DomainLog : Tea.TeaModel {
            public var action: String?

            public var actionTime: String?

            public var actionTimestamp: Int64?

            public var clientIp: String?

            public var domainName: String?

            public var message: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.actionTime != nil {
                    map["ActionTime"] = self.actionTime!
                }
                if self.actionTimestamp != nil {
                    map["ActionTimestamp"] = self.actionTimestamp!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ActionTime") {
                    self.actionTime = dict["ActionTime"] as! String
                }
                if dict.keys.contains("ActionTimestamp") {
                    self.actionTimestamp = dict["ActionTimestamp"] as! Int64
                }
                if dict.keys.contains("ClientIp") {
                    self.clientIp = dict["ClientIp"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var domainLog: [DescribeDomainLogsResponseBody.DomainLogs.DomainLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainLog != nil {
                var tmp : [Any] = []
                for k in self.domainLog! {
                    tmp.append(k.toMap())
                }
                map["DomainLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainLog") {
                var tmp : [DescribeDomainLogsResponseBody.DomainLogs.DomainLog] = []
                for v in dict["DomainLog"] as! [Any] {
                    var model = DescribeDomainLogsResponseBody.DomainLogs.DomainLog()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainLog = tmp
            }
        }
    }
    public var domainLogs: DescribeDomainLogsResponseBody.DomainLogs?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainLogs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLogs != nil {
            map["DomainLogs"] = self.domainLogs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainLogs") {
            var model = DescribeDomainLogsResponseBody.DomainLogs()
            model.fromMap(dict["DomainLogs"] as! [String: Any])
            self.domainLogs = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDomainLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainNsRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeDomainNsResponseBody : Tea.TeaModel {
    public class DnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServer") {
                self.dnsServer = dict["DnsServer"] as! [String]
            }
        }
    }
    public class ExpectDnsServers : Tea.TeaModel {
        public var expectDnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expectDnsServer != nil {
                map["ExpectDnsServer"] = self.expectDnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExpectDnsServer") {
                self.expectDnsServer = dict["ExpectDnsServer"] as! [String]
            }
        }
    }
    public var allAliDns: Bool?

    public var detectFailedReasonCode: String?

    public var dnsServers: DescribeDomainNsResponseBody.DnsServers?

    public var expectDnsServers: DescribeDomainNsResponseBody.ExpectDnsServers?

    public var includeAliDns: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dnsServers?.validate()
        try self.expectDnsServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allAliDns != nil {
            map["AllAliDns"] = self.allAliDns!
        }
        if self.detectFailedReasonCode != nil {
            map["DetectFailedReasonCode"] = self.detectFailedReasonCode!
        }
        if self.dnsServers != nil {
            map["DnsServers"] = self.dnsServers?.toMap()
        }
        if self.expectDnsServers != nil {
            map["ExpectDnsServers"] = self.expectDnsServers?.toMap()
        }
        if self.includeAliDns != nil {
            map["IncludeAliDns"] = self.includeAliDns!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllAliDns") {
            self.allAliDns = dict["AllAliDns"] as! Bool
        }
        if dict.keys.contains("DetectFailedReasonCode") {
            self.detectFailedReasonCode = dict["DetectFailedReasonCode"] as! String
        }
        if dict.keys.contains("DnsServers") {
            var model = DescribeDomainNsResponseBody.DnsServers()
            model.fromMap(dict["DnsServers"] as! [String: Any])
            self.dnsServers = model
        }
        if dict.keys.contains("ExpectDnsServers") {
            var model = DescribeDomainNsResponseBody.ExpectDnsServers()
            model.fromMap(dict["ExpectDnsServers"] as! [String: Any])
            self.expectDnsServers = model
        }
        if dict.keys.contains("IncludeAliDns") {
            self.includeAliDns = dict["IncludeAliDns"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDomainNsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainNsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainNsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainRecordInfoRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DescribeDomainRecordInfoResponseBody : Tea.TeaModel {
    public var domainId: String?

    public var domainName: String?

    public var groupId: String?

    public var groupName: String?

    public var line: String?

    public var locked: Bool?

    public var priority: Int64?

    public var punyCode: String?

    public var RR: String?

    public var recordId: String?

    public var remark: String?

    public var requestId: String?

    public var status: String?

    public var TTL: Int64?

    public var type: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.locked != nil {
            map["Locked"] = self.locked!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.punyCode != nil {
            map["PunyCode"] = self.punyCode!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.TTL != nil {
            map["TTL"] = self.TTL!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainId") {
            self.domainId = dict["DomainId"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Line") {
            self.line = dict["Line"] as! String
        }
        if dict.keys.contains("Locked") {
            self.locked = dict["Locked"] as! Bool
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int64
        }
        if dict.keys.contains("PunyCode") {
            self.punyCode = dict["PunyCode"] as! String
        }
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TTL") {
            self.TTL = dict["TTL"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class DescribeDomainRecordInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainRecordInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainRecordInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainRecordsRequest : Tea.TeaModel {
    public var direction: String?

    public var domainName: String?

    public var groupId: Int64?

    public var keyWord: String?

    public var lang: String?

    public var line: String?

    public var orderBy: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var RRKeyWord: String?

    public var searchMode: String?

    public var status: String?

    public var type: String?

    public var typeKeyWord: String?

    public var valueKeyWord: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.RRKeyWord != nil {
            map["RRKeyWord"] = self.RRKeyWord!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.typeKeyWord != nil {
            map["TypeKeyWord"] = self.typeKeyWord!
        }
        if self.valueKeyWord != nil {
            map["ValueKeyWord"] = self.valueKeyWord!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Line") {
            self.line = dict["Line"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RRKeyWord") {
            self.RRKeyWord = dict["RRKeyWord"] as! String
        }
        if dict.keys.contains("SearchMode") {
            self.searchMode = dict["SearchMode"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("TypeKeyWord") {
            self.typeKeyWord = dict["TypeKeyWord"] as! String
        }
        if dict.keys.contains("ValueKeyWord") {
            self.valueKeyWord = dict["ValueKeyWord"] as! String
        }
    }
}

public class DescribeDomainRecordsResponseBody : Tea.TeaModel {
    public class DomainRecords : Tea.TeaModel {
        public class Record : Tea.TeaModel {
            public var createTimestamp: Int64?

            public var domainName: String?

            public var line: String?

            public var locked: Bool?

            public var priority: Int64?

            public var RR: String?

            public var recordId: String?

            public var remark: String?

            public var status: String?

            public var TTL: Int64?

            public var type: String?

            public var updateTimestamp: Int64?

            public var value: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.line != nil {
                    map["Line"] = self.line!
                }
                if self.locked != nil {
                    map["Locked"] = self.locked!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.RR != nil {
                    map["RR"] = self.RR!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.TTL != nil {
                    map["TTL"] = self.TTL!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Line") {
                    self.line = dict["Line"] as! String
                }
                if dict.keys.contains("Locked") {
                    self.locked = dict["Locked"] as! Bool
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int64
                }
                if dict.keys.contains("RR") {
                    self.RR = dict["RR"] as! String
                }
                if dict.keys.contains("RecordId") {
                    self.recordId = dict["RecordId"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TTL") {
                    self.TTL = dict["TTL"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var record: [DescribeDomainRecordsResponseBody.DomainRecords.Record]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.record != nil {
                var tmp : [Any] = []
                for k in self.record! {
                    tmp.append(k.toMap())
                }
                map["Record"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Record") {
                var tmp : [DescribeDomainRecordsResponseBody.DomainRecords.Record] = []
                for v in dict["Record"] as! [Any] {
                    var model = DescribeDomainRecordsResponseBody.DomainRecords.Record()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.record = tmp
            }
        }
    }
    public var domainRecords: DescribeDomainRecordsResponseBody.DomainRecords?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainRecords?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainRecords != nil {
            map["DomainRecords"] = self.domainRecords?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainRecords") {
            var model = DescribeDomainRecordsResponseBody.DomainRecords()
            model.fromMap(dict["DomainRecords"] as! [String: Any])
            self.domainRecords = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDomainRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainResolveStatisticsSummaryRequest : Tea.TeaModel {
    public var direction: String?

    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchMode: String?

    public var startDate: String?

    public var threshold: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchMode") {
            self.searchMode = dict["SearchMode"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Int64
        }
    }
}

public class DescribeDomainResolveStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var count: String?

        public var domainName: String?

        public var domainType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainType != nil {
                map["DomainType"] = self.domainType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainType") {
                self.domainType = dict["DomainType"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: [DescribeDomainResolveStatisticsSummaryResponseBody.Statistics]?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var tmp : [DescribeDomainResolveStatisticsSummaryResponseBody.Statistics] = []
            for v in dict["Statistics"] as! [Any] {
                var model = DescribeDomainResolveStatisticsSummaryResponseBody.Statistics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.statistics = tmp
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDomainResolveStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainResolveStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainResolveStatisticsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainStatisticsRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainType: String?

    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainType") {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeDomainStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public class Statistic : Tea.TeaModel {
            public var count: Int64?

            public var domainName: String?

            public var timestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
            }
        }
        public var statistic: [DescribeDomainStatisticsResponseBody.Statistics.Statistic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.statistic != nil {
                var tmp : [Any] = []
                for k in self.statistic! {
                    tmp.append(k.toMap())
                }
                map["Statistic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Statistic") {
                var tmp : [DescribeDomainStatisticsResponseBody.Statistics.Statistic] = []
                for v in dict["Statistic"] as! [Any] {
                    var model = DescribeDomainStatisticsResponseBody.Statistics.Statistic()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.statistic = tmp
            }
        }
    }
    public var requestId: String?

    public var statistics: DescribeDomainStatisticsResponseBody.Statistics?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var model = DescribeDomainStatisticsResponseBody.Statistics()
            model.fromMap(dict["Statistics"] as! [String: Any])
            self.statistics = model
        }
    }
}

public class DescribeDomainStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainStatisticsSummaryRequest : Tea.TeaModel {
    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var searchMode: String?

    public var startDate: String?

    public var threshold: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SearchMode") {
            self.searchMode = dict["SearchMode"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Int64
        }
    }
}

public class DescribeDomainStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public class Statistic : Tea.TeaModel {
            public var count: Int64?

            public var domainName: String?

            public var domainType: String?

            public var resolveAnalysisStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.domainType != nil {
                    map["DomainType"] = self.domainType!
                }
                if self.resolveAnalysisStatus != nil {
                    map["resolveAnalysisStatus"] = self.resolveAnalysisStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("DomainType") {
                    self.domainType = dict["DomainType"] as! String
                }
                if dict.keys.contains("resolveAnalysisStatus") {
                    self.resolveAnalysisStatus = dict["resolveAnalysisStatus"] as! String
                }
            }
        }
        public var statistic: [DescribeDomainStatisticsSummaryResponseBody.Statistics.Statistic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.statistic != nil {
                var tmp : [Any] = []
                for k in self.statistic! {
                    tmp.append(k.toMap())
                }
                map["Statistic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Statistic") {
                var tmp : [DescribeDomainStatisticsSummaryResponseBody.Statistics.Statistic] = []
                for v in dict["Statistic"] as! [Any] {
                    var model = DescribeDomainStatisticsSummaryResponseBody.Statistics.Statistic()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.statistic = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: DescribeDomainStatisticsSummaryResponseBody.Statistics?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var model = DescribeDomainStatisticsSummaryResponseBody.Statistics()
            model.fromMap(dict["Statistics"] as! [String: Any])
            self.statistics = model
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeDomainStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainStatisticsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainsRequest : Tea.TeaModel {
    public var groupId: String?

    public var keyWord: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceGroupId: String?

    public var searchMode: String?

    public var starmark: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.starmark != nil {
            map["Starmark"] = self.starmark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SearchMode") {
            self.searchMode = dict["SearchMode"] as! String
        }
        if dict.keys.contains("Starmark") {
            self.starmark = dict["Starmark"] as! Bool
        }
    }
}

public class DescribeDomainsResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class Domain : Tea.TeaModel {
            public class DnsServers : Tea.TeaModel {
                public var dnsServer: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dnsServer != nil {
                        map["DnsServer"] = self.dnsServer!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DnsServer") {
                        self.dnsServer = dict["DnsServer"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeDomainsResponseBody.Domains.Domain.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeDomainsResponseBody.Domains.Domain.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeDomainsResponseBody.Domains.Domain.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var aliDomain: Bool?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var dnsServers: DescribeDomainsResponseBody.Domains.Domain.DnsServers?

            public var domainId: String?

            public var domainLoggingSwitchStatus: String?

            public var domainName: String?

            public var groupId: String?

            public var groupName: String?

            public var instanceEndTime: String?

            public var instanceExpired: Bool?

            public var instanceId: String?

            public var punyCode: String?

            public var recordCount: Int64?

            public var registrantEmail: String?

            public var remark: String?

            public var resourceGroupId: String?

            public var starmark: Bool?

            public var tags: DescribeDomainsResponseBody.Domains.Domain.Tags?

            public var versionCode: String?

            public var versionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dnsServers?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliDomain != nil {
                    map["AliDomain"] = self.aliDomain!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.dnsServers != nil {
                    map["DnsServers"] = self.dnsServers?.toMap()
                }
                if self.domainId != nil {
                    map["DomainId"] = self.domainId!
                }
                if self.domainLoggingSwitchStatus != nil {
                    map["DomainLoggingSwitchStatus"] = self.domainLoggingSwitchStatus!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.instanceEndTime != nil {
                    map["InstanceEndTime"] = self.instanceEndTime!
                }
                if self.instanceExpired != nil {
                    map["InstanceExpired"] = self.instanceExpired!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.punyCode != nil {
                    map["PunyCode"] = self.punyCode!
                }
                if self.recordCount != nil {
                    map["RecordCount"] = self.recordCount!
                }
                if self.registrantEmail != nil {
                    map["RegistrantEmail"] = self.registrantEmail!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.starmark != nil {
                    map["Starmark"] = self.starmark!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                if self.versionName != nil {
                    map["VersionName"] = self.versionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliDomain") {
                    self.aliDomain = dict["AliDomain"] as! Bool
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("DnsServers") {
                    var model = DescribeDomainsResponseBody.Domains.Domain.DnsServers()
                    model.fromMap(dict["DnsServers"] as! [String: Any])
                    self.dnsServers = model
                }
                if dict.keys.contains("DomainId") {
                    self.domainId = dict["DomainId"] as! String
                }
                if dict.keys.contains("DomainLoggingSwitchStatus") {
                    self.domainLoggingSwitchStatus = dict["DomainLoggingSwitchStatus"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("InstanceEndTime") {
                    self.instanceEndTime = dict["InstanceEndTime"] as! String
                }
                if dict.keys.contains("InstanceExpired") {
                    self.instanceExpired = dict["InstanceExpired"] as! Bool
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PunyCode") {
                    self.punyCode = dict["PunyCode"] as! String
                }
                if dict.keys.contains("RecordCount") {
                    self.recordCount = dict["RecordCount"] as! Int64
                }
                if dict.keys.contains("RegistrantEmail") {
                    self.registrantEmail = dict["RegistrantEmail"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Starmark") {
                    self.starmark = dict["Starmark"] as! Bool
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeDomainsResponseBody.Domains.Domain.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VersionCode") {
                    self.versionCode = dict["VersionCode"] as! String
                }
                if dict.keys.contains("VersionName") {
                    self.versionName = dict["VersionName"] as! String
                }
            }
        }
        public var domain: [DescribeDomainsResponseBody.Domains.Domain]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domain != nil {
                var tmp : [Any] = []
                for k in self.domain! {
                    tmp.append(k.toMap())
                }
                map["Domain"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domain") {
                var tmp : [DescribeDomainsResponseBody.Domains.Domain] = []
                for v in dict["Domain"] as! [Any] {
                    var model = DescribeDomainsResponseBody.Domains.Domain()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domain = tmp
            }
        }
    }
    public var domains: DescribeDomainsResponseBody.Domains?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domains != nil {
            map["Domains"] = self.domains?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Domains") {
            var model = DescribeDomainsResponseBody.Domains()
            model.fromMap(dict["Domains"] as! [String: Any])
            self.domains = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmAccessStrategiesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeGtmAccessStrategiesResponseBody : Tea.TeaModel {
    public class Strategies : Tea.TeaModel {
        public class Strategy : Tea.TeaModel {
            public class Lines : Tea.TeaModel {
                public class Line : Tea.TeaModel {
                    public var groupCode: String?

                    public var groupName: String?

                    public var lineCode: String?

                    public var lineName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.groupCode != nil {
                            map["GroupCode"] = self.groupCode!
                        }
                        if self.groupName != nil {
                            map["GroupName"] = self.groupName!
                        }
                        if self.lineCode != nil {
                            map["LineCode"] = self.lineCode!
                        }
                        if self.lineName != nil {
                            map["LineName"] = self.lineName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("GroupCode") {
                            self.groupCode = dict["GroupCode"] as! String
                        }
                        if dict.keys.contains("GroupName") {
                            self.groupName = dict["GroupName"] as! String
                        }
                        if dict.keys.contains("LineCode") {
                            self.lineCode = dict["LineCode"] as! String
                        }
                        if dict.keys.contains("LineName") {
                            self.lineName = dict["LineName"] as! String
                        }
                    }
                }
                public var line: [DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.line != nil {
                        var tmp : [Any] = []
                        for k in self.line! {
                            tmp.append(k.toMap())
                        }
                        map["Line"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Line") {
                        var tmp : [DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line] = []
                        for v in dict["Line"] as! [Any] {
                            var model = DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines.Line()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.line = tmp
                    }
                }
            }
            public var accessMode: String?

            public var accessStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var defaultAddrPoolId: String?

            public var defaultAddrPoolMonitorStatus: String?

            public var defaultAddrPoolName: String?

            public var defaultAddrPoolStatus: String?

            public var failoverAddrPoolId: String?

            public var failoverAddrPoolMonitorStatus: String?

            public var failoverAddrPoolName: String?

            public var failoverAddrPoolStatus: String?

            public var instanceId: String?

            public var lines: DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines?

            public var strategyId: String?

            public var strategyMode: String?

            public var strategyName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.lines?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessMode != nil {
                    map["AccessMode"] = self.accessMode!
                }
                if self.accessStatus != nil {
                    map["AccessStatus"] = self.accessStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.defaultAddrPoolId != nil {
                    map["DefaultAddrPoolId"] = self.defaultAddrPoolId!
                }
                if self.defaultAddrPoolMonitorStatus != nil {
                    map["DefaultAddrPoolMonitorStatus"] = self.defaultAddrPoolMonitorStatus!
                }
                if self.defaultAddrPoolName != nil {
                    map["DefaultAddrPoolName"] = self.defaultAddrPoolName!
                }
                if self.defaultAddrPoolStatus != nil {
                    map["DefaultAddrPoolStatus"] = self.defaultAddrPoolStatus!
                }
                if self.failoverAddrPoolId != nil {
                    map["FailoverAddrPoolId"] = self.failoverAddrPoolId!
                }
                if self.failoverAddrPoolMonitorStatus != nil {
                    map["FailoverAddrPoolMonitorStatus"] = self.failoverAddrPoolMonitorStatus!
                }
                if self.failoverAddrPoolName != nil {
                    map["FailoverAddrPoolName"] = self.failoverAddrPoolName!
                }
                if self.failoverAddrPoolStatus != nil {
                    map["FailoverAddrPoolStatus"] = self.failoverAddrPoolStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.lines != nil {
                    map["Lines"] = self.lines?.toMap()
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.strategyMode != nil {
                    map["StrategyMode"] = self.strategyMode!
                }
                if self.strategyName != nil {
                    map["StrategyName"] = self.strategyName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessMode") {
                    self.accessMode = dict["AccessMode"] as! String
                }
                if dict.keys.contains("AccessStatus") {
                    self.accessStatus = dict["AccessStatus"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("DefaultAddrPoolId") {
                    self.defaultAddrPoolId = dict["DefaultAddrPoolId"] as! String
                }
                if dict.keys.contains("DefaultAddrPoolMonitorStatus") {
                    self.defaultAddrPoolMonitorStatus = dict["DefaultAddrPoolMonitorStatus"] as! String
                }
                if dict.keys.contains("DefaultAddrPoolName") {
                    self.defaultAddrPoolName = dict["DefaultAddrPoolName"] as! String
                }
                if dict.keys.contains("DefaultAddrPoolStatus") {
                    self.defaultAddrPoolStatus = dict["DefaultAddrPoolStatus"] as! String
                }
                if dict.keys.contains("FailoverAddrPoolId") {
                    self.failoverAddrPoolId = dict["FailoverAddrPoolId"] as! String
                }
                if dict.keys.contains("FailoverAddrPoolMonitorStatus") {
                    self.failoverAddrPoolMonitorStatus = dict["FailoverAddrPoolMonitorStatus"] as! String
                }
                if dict.keys.contains("FailoverAddrPoolName") {
                    self.failoverAddrPoolName = dict["FailoverAddrPoolName"] as! String
                }
                if dict.keys.contains("FailoverAddrPoolStatus") {
                    self.failoverAddrPoolStatus = dict["FailoverAddrPoolStatus"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Lines") {
                    var model = DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy.Lines()
                    model.fromMap(dict["Lines"] as! [String: Any])
                    self.lines = model
                }
                if dict.keys.contains("StrategyId") {
                    self.strategyId = dict["StrategyId"] as! String
                }
                if dict.keys.contains("StrategyMode") {
                    self.strategyMode = dict["StrategyMode"] as! String
                }
                if dict.keys.contains("StrategyName") {
                    self.strategyName = dict["StrategyName"] as! String
                }
            }
        }
        public var strategy: [DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.strategy != nil {
                var tmp : [Any] = []
                for k in self.strategy! {
                    tmp.append(k.toMap())
                }
                map["Strategy"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Strategy") {
                var tmp : [DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy] = []
                for v in dict["Strategy"] as! [Any] {
                    var model = DescribeGtmAccessStrategiesResponseBody.Strategies.Strategy()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.strategy = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var strategies: DescribeGtmAccessStrategiesResponseBody.Strategies?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.strategies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategies != nil {
            map["Strategies"] = self.strategies?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Strategies") {
            var model = DescribeGtmAccessStrategiesResponseBody.Strategies()
            model.fromMap(dict["Strategies"] as! [String: Any])
            self.strategies = model
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeGtmAccessStrategiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmAccessStrategiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmAccessStrategiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmAccessStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class DescribeGtmAccessStrategyResponseBody : Tea.TeaModel {
    public class Lines : Tea.TeaModel {
        public class Line : Tea.TeaModel {
            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupCode") {
                    self.groupCode = dict["GroupCode"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
            }
        }
        public var line: [DescribeGtmAccessStrategyResponseBody.Lines.Line]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.line != nil {
                var tmp : [Any] = []
                for k in self.line! {
                    tmp.append(k.toMap())
                }
                map["Line"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Line") {
                var tmp : [DescribeGtmAccessStrategyResponseBody.Lines.Line] = []
                for v in dict["Line"] as! [Any] {
                    var model = DescribeGtmAccessStrategyResponseBody.Lines.Line()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.line = tmp
            }
        }
    }
    public var accessMode: String?

    public var accessStatus: String?

    public var defaultAddrPoolMonitorStatus: String?

    public var defaultAddrPoolName: String?

    public var defaultAddrPoolStatus: String?

    public var defultAddrPoolId: String?

    public var failoverAddrPoolId: String?

    public var failoverAddrPoolMonitorStatus: String?

    public var failoverAddrPoolName: String?

    public var failoverAddrPoolStatus: String?

    public var instanceId: String?

    public var lines: DescribeGtmAccessStrategyResponseBody.Lines?

    public var requestId: String?

    public var strategyId: String?

    public var strategyMode: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.accessStatus != nil {
            map["AccessStatus"] = self.accessStatus!
        }
        if self.defaultAddrPoolMonitorStatus != nil {
            map["DefaultAddrPoolMonitorStatus"] = self.defaultAddrPoolMonitorStatus!
        }
        if self.defaultAddrPoolName != nil {
            map["DefaultAddrPoolName"] = self.defaultAddrPoolName!
        }
        if self.defaultAddrPoolStatus != nil {
            map["DefaultAddrPoolStatus"] = self.defaultAddrPoolStatus!
        }
        if self.defultAddrPoolId != nil {
            map["DefultAddrPoolId"] = self.defultAddrPoolId!
        }
        if self.failoverAddrPoolId != nil {
            map["FailoverAddrPoolId"] = self.failoverAddrPoolId!
        }
        if self.failoverAddrPoolMonitorStatus != nil {
            map["FailoverAddrPoolMonitorStatus"] = self.failoverAddrPoolMonitorStatus!
        }
        if self.failoverAddrPoolName != nil {
            map["FailoverAddrPoolName"] = self.failoverAddrPoolName!
        }
        if self.failoverAddrPoolStatus != nil {
            map["FailoverAddrPoolStatus"] = self.failoverAddrPoolStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lines != nil {
            map["Lines"] = self.lines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessMode") {
            self.accessMode = dict["AccessMode"] as! String
        }
        if dict.keys.contains("AccessStatus") {
            self.accessStatus = dict["AccessStatus"] as! String
        }
        if dict.keys.contains("DefaultAddrPoolMonitorStatus") {
            self.defaultAddrPoolMonitorStatus = dict["DefaultAddrPoolMonitorStatus"] as! String
        }
        if dict.keys.contains("DefaultAddrPoolName") {
            self.defaultAddrPoolName = dict["DefaultAddrPoolName"] as! String
        }
        if dict.keys.contains("DefaultAddrPoolStatus") {
            self.defaultAddrPoolStatus = dict["DefaultAddrPoolStatus"] as! String
        }
        if dict.keys.contains("DefultAddrPoolId") {
            self.defultAddrPoolId = dict["DefultAddrPoolId"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolId") {
            self.failoverAddrPoolId = dict["FailoverAddrPoolId"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolMonitorStatus") {
            self.failoverAddrPoolMonitorStatus = dict["FailoverAddrPoolMonitorStatus"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolName") {
            self.failoverAddrPoolName = dict["FailoverAddrPoolName"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolStatus") {
            self.failoverAddrPoolStatus = dict["FailoverAddrPoolStatus"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lines") {
            var model = DescribeGtmAccessStrategyResponseBody.Lines()
            model.fromMap(dict["Lines"] as! [String: Any])
            self.lines = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
        if dict.keys.contains("StrategyMode") {
            self.strategyMode = dict["StrategyMode"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class DescribeGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmAccessStrategyAvailableConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmAccessStrategyAvailableConfigResponseBody : Tea.TeaModel {
    public class AddrPools : Tea.TeaModel {
        public class AddrPool : Tea.TeaModel {
            public var addrPoolId: String?

            public var addrPoolName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrPoolId != nil {
                    map["AddrPoolId"] = self.addrPoolId!
                }
                if self.addrPoolName != nil {
                    map["AddrPoolName"] = self.addrPoolName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrPoolId") {
                    self.addrPoolId = dict["AddrPoolId"] as! String
                }
                if dict.keys.contains("AddrPoolName") {
                    self.addrPoolName = dict["AddrPoolName"] as! String
                }
            }
        }
        public var addrPool: [DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools.AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addrPool != nil {
                var tmp : [Any] = []
                for k in self.addrPool! {
                    tmp.append(k.toMap())
                }
                map["AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddrPool") {
                var tmp : [DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools.AddrPool] = []
                for v in dict["AddrPool"] as! [Any] {
                    var model = DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools.AddrPool()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.addrPool = tmp
            }
        }
    }
    public class Lines : Tea.TeaModel {
        public class Line : Tea.TeaModel {
            public var fatherCode: String?

            public var groupCode: String?

            public var groupName: String?

            public var lineCode: String?

            public var lineName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.groupCode != nil {
                    map["GroupCode"] = self.groupCode!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FatherCode") {
                    self.fatherCode = dict["FatherCode"] as! String
                }
                if dict.keys.contains("GroupCode") {
                    self.groupCode = dict["GroupCode"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var line: [DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines.Line]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.line != nil {
                var tmp : [Any] = []
                for k in self.line! {
                    tmp.append(k.toMap())
                }
                map["Line"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Line") {
                var tmp : [DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines.Line] = []
                for v in dict["Line"] as! [Any] {
                    var model = DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines.Line()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.line = tmp
            }
        }
    }
    public var addrPools: DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools?

    public var lines: DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines?

    public var requestId: String?

    public var suggestSetDefaultLine: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrPools?.validate()
        try self.lines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPools != nil {
            map["AddrPools"] = self.addrPools?.toMap()
        }
        if self.lines != nil {
            map["Lines"] = self.lines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.suggestSetDefaultLine != nil {
            map["SuggestSetDefaultLine"] = self.suggestSetDefaultLine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPools") {
            var model = DescribeGtmAccessStrategyAvailableConfigResponseBody.AddrPools()
            model.fromMap(dict["AddrPools"] as! [String: Any])
            self.addrPools = model
        }
        if dict.keys.contains("Lines") {
            var model = DescribeGtmAccessStrategyAvailableConfigResponseBody.Lines()
            model.fromMap(dict["Lines"] as! [String: Any])
            self.lines = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuggestSetDefaultLine") {
            self.suggestSetDefaultLine = dict["SuggestSetDefaultLine"] as! Bool
        }
    }
}

public class DescribeGtmAccessStrategyAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmAccessStrategyAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmAccessStrategyAvailableConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmAvailableAlertGroupRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmAvailableAlertGroupResponseBody : Tea.TeaModel {
    public var availableAlertGroup: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableAlertGroup != nil {
            map["AvailableAlertGroup"] = self.availableAlertGroup!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableAlertGroup") {
            self.availableAlertGroup = dict["AvailableAlertGroup"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGtmAvailableAlertGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmAvailableAlertGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmAvailableAlertGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var needDetailAttributes: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.needDetailAttributes != nil {
            map["NeedDetailAttributes"] = self.needDetailAttributes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NeedDetailAttributes") {
            self.needDetailAttributes = dict["NeedDetailAttributes"] as! Bool
        }
    }
}

public class DescribeGtmInstanceResponseBody : Tea.TeaModel {
    public var accessStrategyNum: Int32?

    public var addressPoolNum: Int32?

    public var alertGroup: String?

    public var cname: String?

    public var cnameMode: String?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var expireTime: String?

    public var expireTimestamp: Int64?

    public var instanceId: String?

    public var instanceName: String?

    public var lbaStrategy: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var ttl: Int32?

    public var userDomainName: String?

    public var versionCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessStrategyNum != nil {
            map["AccessStrategyNum"] = self.accessStrategyNum!
        }
        if self.addressPoolNum != nil {
            map["AddressPoolNum"] = self.addressPoolNum!
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.cname != nil {
            map["Cname"] = self.cname!
        }
        if self.cnameMode != nil {
            map["CnameMode"] = self.cnameMode!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.expireTimestamp != nil {
            map["ExpireTimestamp"] = self.expireTimestamp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.userDomainName != nil {
            map["UserDomainName"] = self.userDomainName!
        }
        if self.versionCode != nil {
            map["VersionCode"] = self.versionCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessStrategyNum") {
            self.accessStrategyNum = dict["AccessStrategyNum"] as! Int32
        }
        if dict.keys.contains("AddressPoolNum") {
            self.addressPoolNum = dict["AddressPoolNum"] as! Int32
        }
        if dict.keys.contains("AlertGroup") {
            self.alertGroup = dict["AlertGroup"] as! String
        }
        if dict.keys.contains("Cname") {
            self.cname = dict["Cname"] as! String
        }
        if dict.keys.contains("CnameMode") {
            self.cnameMode = dict["CnameMode"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("ExpireTime") {
            self.expireTime = dict["ExpireTime"] as! String
        }
        if dict.keys.contains("ExpireTimestamp") {
            self.expireTimestamp = dict["ExpireTimestamp"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("LbaStrategy") {
            self.lbaStrategy = dict["LbaStrategy"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Ttl") {
            self.ttl = dict["Ttl"] as! Int32
        }
        if dict.keys.contains("UserDomainName") {
            self.userDomainName = dict["UserDomainName"] as! String
        }
        if dict.keys.contains("VersionCode") {
            self.versionCode = dict["VersionCode"] as! String
        }
    }
}

public class DescribeGtmInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmInstanceAddressPoolRequest : Tea.TeaModel {
    public var addrPoolId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmInstanceAddressPoolResponseBody : Tea.TeaModel {
    public class Addrs : Tea.TeaModel {
        public class Addr : Tea.TeaModel {
            public var addrId: Int64?

            public var alertStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var lbaWeight: Int32?

            public var mode: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrId != nil {
                    map["AddrId"] = self.addrId!
                }
                if self.alertStatus != nil {
                    map["AlertStatus"] = self.alertStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.lbaWeight != nil {
                    map["LbaWeight"] = self.lbaWeight!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrId") {
                    self.addrId = dict["AddrId"] as! Int64
                }
                if dict.keys.contains("AlertStatus") {
                    self.alertStatus = dict["AlertStatus"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("LbaWeight") {
                    self.lbaWeight = dict["LbaWeight"] as! Int32
                }
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var addr: [DescribeGtmInstanceAddressPoolResponseBody.Addrs.Addr]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                var tmp : [Any] = []
                for k in self.addr! {
                    tmp.append(k.toMap())
                }
                map["Addr"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Addr") {
                var tmp : [DescribeGtmInstanceAddressPoolResponseBody.Addrs.Addr] = []
                for v in dict["Addr"] as! [Any] {
                    var model = DescribeGtmInstanceAddressPoolResponseBody.Addrs.Addr()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.addr = tmp
            }
        }
    }
    public var addrCount: Int32?

    public var addrPoolId: String?

    public var addrs: DescribeGtmInstanceAddressPoolResponseBody.Addrs?

    public var createTime: String?

    public var createTimestamp: Int64?

    public var minAvailableAddrNum: Int32?

    public var monitorConfigId: String?

    public var monitorStatus: String?

    public var name: String?

    public var requestId: String?

    public var status: String?

    public var type: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrCount != nil {
            map["AddrCount"] = self.addrCount!
        }
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.addrs != nil {
            map["Addrs"] = self.addrs?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.minAvailableAddrNum != nil {
            map["MinAvailableAddrNum"] = self.minAvailableAddrNum!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorStatus != nil {
            map["MonitorStatus"] = self.monitorStatus!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrCount") {
            self.addrCount = dict["AddrCount"] as! Int32
        }
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Addrs") {
            var model = DescribeGtmInstanceAddressPoolResponseBody.Addrs()
            model.fromMap(dict["Addrs"] as! [String: Any])
            self.addrs = model
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("MinAvailableAddrNum") {
            self.minAvailableAddrNum = dict["MinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("MonitorStatus") {
            self.monitorStatus = dict["MonitorStatus"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
    }
}

public class DescribeGtmInstanceAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmInstanceAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmInstanceAddressPoolsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeGtmInstanceAddressPoolsResponseBody : Tea.TeaModel {
    public class AddrPools : Tea.TeaModel {
        public class AddrPool : Tea.TeaModel {
            public var addrCount: Int32?

            public var addrPoolId: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var minAvailableAddrNum: Int32?

            public var monitorConfigId: String?

            public var monitorStatus: String?

            public var name: String?

            public var status: String?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrCount != nil {
                    map["AddrCount"] = self.addrCount!
                }
                if self.addrPoolId != nil {
                    map["AddrPoolId"] = self.addrPoolId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.minAvailableAddrNum != nil {
                    map["MinAvailableAddrNum"] = self.minAvailableAddrNum!
                }
                if self.monitorConfigId != nil {
                    map["MonitorConfigId"] = self.monitorConfigId!
                }
                if self.monitorStatus != nil {
                    map["MonitorStatus"] = self.monitorStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrCount") {
                    self.addrCount = dict["AddrCount"] as! Int32
                }
                if dict.keys.contains("AddrPoolId") {
                    self.addrPoolId = dict["AddrPoolId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("MinAvailableAddrNum") {
                    self.minAvailableAddrNum = dict["MinAvailableAddrNum"] as! Int32
                }
                if dict.keys.contains("MonitorConfigId") {
                    self.monitorConfigId = dict["MonitorConfigId"] as! String
                }
                if dict.keys.contains("MonitorStatus") {
                    self.monitorStatus = dict["MonitorStatus"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var addrPool: [DescribeGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addrPool != nil {
                var tmp : [Any] = []
                for k in self.addrPool! {
                    tmp.append(k.toMap())
                }
                map["AddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddrPool") {
                var tmp : [DescribeGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool] = []
                for v in dict["AddrPool"] as! [Any] {
                    var model = DescribeGtmInstanceAddressPoolsResponseBody.AddrPools.AddrPool()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.addrPool = tmp
            }
        }
    }
    public var addrPools: DescribeGtmInstanceAddressPoolsResponseBody.AddrPools?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addrPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrPools != nil {
            map["AddrPools"] = self.addrPools?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrPools") {
            var model = DescribeGtmInstanceAddressPoolsResponseBody.AddrPools()
            model.fromMap(dict["AddrPools"] as! [String: Any])
            self.addrPools = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeGtmInstanceAddressPoolsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceAddressPoolsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmInstanceAddressPoolsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmInstanceStatusRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmInstanceStatusResponseBody : Tea.TeaModel {
    public var addrNotAvailableNum: Int32?

    public var addrPoolNotAvailableNum: Int32?

    public var requestId: String?

    public var status: String?

    public var statusReason: String?

    public var strategyNotAvailableNum: Int32?

    public var switchToFailoverStrategyNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addrNotAvailableNum != nil {
            map["AddrNotAvailableNum"] = self.addrNotAvailableNum!
        }
        if self.addrPoolNotAvailableNum != nil {
            map["AddrPoolNotAvailableNum"] = self.addrPoolNotAvailableNum!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.statusReason != nil {
            map["StatusReason"] = self.statusReason!
        }
        if self.strategyNotAvailableNum != nil {
            map["StrategyNotAvailableNum"] = self.strategyNotAvailableNum!
        }
        if self.switchToFailoverStrategyNum != nil {
            map["SwitchToFailoverStrategyNum"] = self.switchToFailoverStrategyNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddrNotAvailableNum") {
            self.addrNotAvailableNum = dict["AddrNotAvailableNum"] as! Int32
        }
        if dict.keys.contains("AddrPoolNotAvailableNum") {
            self.addrPoolNotAvailableNum = dict["AddrPoolNotAvailableNum"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StatusReason") {
            self.statusReason = dict["StatusReason"] as! String
        }
        if dict.keys.contains("StrategyNotAvailableNum") {
            self.strategyNotAvailableNum = dict["StrategyNotAvailableNum"] as! Int32
        }
        if dict.keys.contains("SwitchToFailoverStrategyNum") {
            self.switchToFailoverStrategyNum = dict["SwitchToFailoverStrategyNum"] as! Int32
        }
    }
}

public class DescribeGtmInstanceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmInstanceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmInstanceSystemCnameRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmInstanceSystemCnameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var systemCname: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemCname != nil {
            map["SystemCname"] = self.systemCname!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemCname") {
            self.systemCname = dict["SystemCname"] as! String
        }
    }
}

public class DescribeGtmInstanceSystemCnameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstanceSystemCnameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmInstanceSystemCnameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmInstancesRequest : Tea.TeaModel {
    public var keyword: String?

    public var lang: String?

    public var needDetailAttributes: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.needDetailAttributes != nil {
            map["NeedDetailAttributes"] = self.needDetailAttributes!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NeedDetailAttributes") {
            self.needDetailAttributes = dict["NeedDetailAttributes"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeGtmInstancesResponseBody : Tea.TeaModel {
    public class GtmInstances : Tea.TeaModel {
        public class GtmInstance : Tea.TeaModel {
            public var accessStrategyNum: Int32?

            public var addressPoolNum: Int32?

            public var alertGroup: String?

            public var cname: String?

            public var cnameMode: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var expireTime: String?

            public var expireTimestamp: Int64?

            public var instanceId: String?

            public var instanceName: String?

            public var lbaStrategy: String?

            public var resourceGroupId: String?

            public var ttl: Int32?

            public var userDomainName: String?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessStrategyNum != nil {
                    map["AccessStrategyNum"] = self.accessStrategyNum!
                }
                if self.addressPoolNum != nil {
                    map["AddressPoolNum"] = self.addressPoolNum!
                }
                if self.alertGroup != nil {
                    map["AlertGroup"] = self.alertGroup!
                }
                if self.cname != nil {
                    map["Cname"] = self.cname!
                }
                if self.cnameMode != nil {
                    map["CnameMode"] = self.cnameMode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.expireTimestamp != nil {
                    map["ExpireTimestamp"] = self.expireTimestamp!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.lbaStrategy != nil {
                    map["LbaStrategy"] = self.lbaStrategy!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.userDomainName != nil {
                    map["UserDomainName"] = self.userDomainName!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessStrategyNum") {
                    self.accessStrategyNum = dict["AccessStrategyNum"] as! Int32
                }
                if dict.keys.contains("AddressPoolNum") {
                    self.addressPoolNum = dict["AddressPoolNum"] as! Int32
                }
                if dict.keys.contains("AlertGroup") {
                    self.alertGroup = dict["AlertGroup"] as! String
                }
                if dict.keys.contains("Cname") {
                    self.cname = dict["Cname"] as! String
                }
                if dict.keys.contains("CnameMode") {
                    self.cnameMode = dict["CnameMode"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! String
                }
                if dict.keys.contains("ExpireTimestamp") {
                    self.expireTimestamp = dict["ExpireTimestamp"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("LbaStrategy") {
                    self.lbaStrategy = dict["LbaStrategy"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Ttl") {
                    self.ttl = dict["Ttl"] as! Int32
                }
                if dict.keys.contains("UserDomainName") {
                    self.userDomainName = dict["UserDomainName"] as! String
                }
                if dict.keys.contains("VersionCode") {
                    self.versionCode = dict["VersionCode"] as! String
                }
            }
        }
        public var gtmInstance: [DescribeGtmInstancesResponseBody.GtmInstances.GtmInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gtmInstance != nil {
                var tmp : [Any] = []
                for k in self.gtmInstance! {
                    tmp.append(k.toMap())
                }
                map["GtmInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GtmInstance") {
                var tmp : [DescribeGtmInstancesResponseBody.GtmInstances.GtmInstance] = []
                for v in dict["GtmInstance"] as! [Any] {
                    var model = DescribeGtmInstancesResponseBody.GtmInstances.GtmInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.gtmInstance = tmp
            }
        }
    }
    public var gtmInstances: DescribeGtmInstancesResponseBody.GtmInstances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.gtmInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gtmInstances != nil {
            map["GtmInstances"] = self.gtmInstances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GtmInstances") {
            var model = DescribeGtmInstancesResponseBody.GtmInstances()
            model.fromMap(dict["GtmInstances"] as! [String: Any])
            self.gtmInstances = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeGtmInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmLogsRequest : Tea.TeaModel {
    public var endTimestamp: Int64?

    public var instanceId: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimestamp != nil {
            map["StartTimestamp"] = self.startTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTimestamp") {
            self.endTimestamp = dict["EndTimestamp"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTimestamp") {
            self.startTimestamp = dict["StartTimestamp"] as! Int64
        }
    }
}

public class DescribeGtmLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public class Log : Tea.TeaModel {
            public var content: String?

            public var entityId: String?

            public var entityName: String?

            public var entityType: String?

            public var id: Int64?

            public var operAction: String?

            public var operIp: String?

            public var operTime: String?

            public var operTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.entityId != nil {
                    map["EntityId"] = self.entityId!
                }
                if self.entityName != nil {
                    map["EntityName"] = self.entityName!
                }
                if self.entityType != nil {
                    map["EntityType"] = self.entityType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.operAction != nil {
                    map["OperAction"] = self.operAction!
                }
                if self.operIp != nil {
                    map["OperIp"] = self.operIp!
                }
                if self.operTime != nil {
                    map["OperTime"] = self.operTime!
                }
                if self.operTimestamp != nil {
                    map["OperTimestamp"] = self.operTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("EntityId") {
                    self.entityId = dict["EntityId"] as! String
                }
                if dict.keys.contains("EntityName") {
                    self.entityName = dict["EntityName"] as! String
                }
                if dict.keys.contains("EntityType") {
                    self.entityType = dict["EntityType"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("OperAction") {
                    self.operAction = dict["OperAction"] as! String
                }
                if dict.keys.contains("OperIp") {
                    self.operIp = dict["OperIp"] as! String
                }
                if dict.keys.contains("OperTime") {
                    self.operTime = dict["OperTime"] as! String
                }
                if dict.keys.contains("OperTimestamp") {
                    self.operTimestamp = dict["OperTimestamp"] as! Int64
                }
            }
        }
        public var log: [DescribeGtmLogsResponseBody.Logs.Log]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.log != nil {
                var tmp : [Any] = []
                for k in self.log! {
                    tmp.append(k.toMap())
                }
                map["Log"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Log") {
                var tmp : [DescribeGtmLogsResponseBody.Logs.Log] = []
                for v in dict["Log"] as! [Any] {
                    var model = DescribeGtmLogsResponseBody.Logs.Log()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.log = tmp
            }
        }
    }
    public var logs: DescribeGtmLogsResponseBody.Logs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            map["Logs"] = self.logs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logs") {
            var model = DescribeGtmLogsResponseBody.Logs()
            model.fromMap(dict["Logs"] as! [String: Any])
            self.logs = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeGtmLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmMonitorAvailableConfigRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmMonitorAvailableConfigResponseBody : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public class IspCityNode : Tea.TeaModel {
            public var cityCode: String?

            public var cityName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ispCode: String?

            public var ispName: String?

            public var mainland: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                if self.mainland != nil {
                    map["Mainland"] = self.mainland!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("DefaultSelected") {
                    self.defaultSelected = dict["DefaultSelected"] as! Bool
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") {
                    self.groupType = dict["GroupType"] as! String
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
                if dict.keys.contains("Mainland") {
                    self.mainland = dict["Mainland"] as! Bool
                }
            }
        }
        public var ispCityNode: [DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes.IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ispCityNode != nil {
                var tmp : [Any] = []
                for k in self.ispCityNode! {
                    tmp.append(k.toMap())
                }
                map["IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IspCityNode") {
                var tmp : [DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes.IspCityNode] = []
                for v in dict["IspCityNode"] as! [Any] {
                    var model = DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes.IspCityNode()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ispCityNode = tmp
            }
        }
    }
    public var ispCityNodes: DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ispCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ispCityNodes != nil {
            map["IspCityNodes"] = self.ispCityNodes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IspCityNodes") {
            var model = DescribeGtmMonitorAvailableConfigResponseBody.IspCityNodes()
            model.fromMap(dict["IspCityNodes"] as! [String: Any])
            self.ispCityNodes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGtmMonitorAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmMonitorAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmMonitorAvailableConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmMonitorConfigRequest : Tea.TeaModel {
    public var lang: String?

    public var monitorConfigId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
    }
}

public class DescribeGtmMonitorConfigResponseBody : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public class IspCityNode : Tea.TeaModel {
            public var cityCode: String?

            public var cityName: String?

            public var countryCode: String?

            public var countryName: String?

            public var ispCode: String?

            public var ispName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.countryCode != nil {
                    map["CountryCode"] = self.countryCode!
                }
                if self.countryName != nil {
                    map["CountryName"] = self.countryName!
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("CountryCode") {
                    self.countryCode = dict["CountryCode"] as! String
                }
                if dict.keys.contains("CountryName") {
                    self.countryName = dict["CountryName"] as! String
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
            }
        }
        public var ispCityNode: [DescribeGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ispCityNode != nil {
                var tmp : [Any] = []
                for k in self.ispCityNode! {
                    tmp.append(k.toMap())
                }
                map["IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IspCityNode") {
                var tmp : [DescribeGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode] = []
                for v in dict["IspCityNode"] as! [Any] {
                    var model = DescribeGtmMonitorConfigResponseBody.IspCityNodes.IspCityNode()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ispCityNode = tmp
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNodes: DescribeGtmMonitorConfigResponseBody.IspCityNodes?

    public var monitorConfigId: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var requestId: String?

    public var timeout: Int32?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ispCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNodes != nil {
            map["IspCityNodes"] = self.ispCityNodes?.toMap()
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNodes") {
            var model = DescribeGtmMonitorConfigResponseBody.IspCityNodes()
            model.fromMap(dict["IspCityNodes"] as! [String: Any])
            self.ispCityNodes = model
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
    }
}

public class DescribeGtmMonitorConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmMonitorConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmMonitorConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
    }
}

public class DescribeGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public class FaultAddrPools : Tea.TeaModel {
        public class FaultAddrPool : Tea.TeaModel {
            public class Addrs : Tea.TeaModel {
                public class Addr : Tea.TeaModel {
                    public var id: Int64?

                    public var mode: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.mode != nil {
                            map["Mode"] = self.mode!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! Int64
                        }
                        if dict.keys.contains("Mode") {
                            self.mode = dict["Mode"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var addr: [DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs.Addr]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.addr != nil {
                        var tmp : [Any] = []
                        for k in self.addr! {
                            tmp.append(k.toMap())
                        }
                        map["Addr"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Addr") {
                        var tmp : [DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs.Addr] = []
                        for v in dict["Addr"] as! [Any] {
                            var model = DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs.Addr()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.addr = tmp
                    }
                }
            }
            public var addrPoolId: String?

            public var addrPoolName: String?

            public var addrs: DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addrs?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrPoolId != nil {
                    map["AddrPoolId"] = self.addrPoolId!
                }
                if self.addrPoolName != nil {
                    map["AddrPoolName"] = self.addrPoolName!
                }
                if self.addrs != nil {
                    map["Addrs"] = self.addrs?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrPoolId") {
                    self.addrPoolId = dict["AddrPoolId"] as! String
                }
                if dict.keys.contains("AddrPoolName") {
                    self.addrPoolName = dict["AddrPoolName"] as! String
                }
                if dict.keys.contains("Addrs") {
                    var model = DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool.Addrs()
                    model.fromMap(dict["Addrs"] as! [String: Any])
                    self.addrs = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var faultAddrPool: [DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.faultAddrPool != nil {
                var tmp : [Any] = []
                for k in self.faultAddrPool! {
                    tmp.append(k.toMap())
                }
                map["FaultAddrPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FaultAddrPool") {
                var tmp : [DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool] = []
                for v in dict["FaultAddrPool"] as! [Any] {
                    var model = DescribeGtmRecoveryPlanResponseBody.FaultAddrPools.FaultAddrPool()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.faultAddrPool = tmp
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var faultAddrPoolNum: Int32?

    public var faultAddrPools: DescribeGtmRecoveryPlanResponseBody.FaultAddrPools?

    public var lastExecuteTime: String?

    public var lastExecuteTimestamp: Int64?

    public var lastRollbackTime: String?

    public var lastRollbackTimestamp: Int64?

    public var name: String?

    public var recoveryPlanId: Int64?

    public var remark: String?

    public var requestId: String?

    public var status: String?

    public var updateTime: String?

    public var updateTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.faultAddrPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.faultAddrPoolNum != nil {
            map["FaultAddrPoolNum"] = self.faultAddrPoolNum!
        }
        if self.faultAddrPools != nil {
            map["FaultAddrPools"] = self.faultAddrPools?.toMap()
        }
        if self.lastExecuteTime != nil {
            map["LastExecuteTime"] = self.lastExecuteTime!
        }
        if self.lastExecuteTimestamp != nil {
            map["LastExecuteTimestamp"] = self.lastExecuteTimestamp!
        }
        if self.lastRollbackTime != nil {
            map["LastRollbackTime"] = self.lastRollbackTime!
        }
        if self.lastRollbackTimestamp != nil {
            map["LastRollbackTimestamp"] = self.lastRollbackTimestamp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.updateTimestamp != nil {
            map["UpdateTimestamp"] = self.updateTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("FaultAddrPoolNum") {
            self.faultAddrPoolNum = dict["FaultAddrPoolNum"] as! Int32
        }
        if dict.keys.contains("FaultAddrPools") {
            var model = DescribeGtmRecoveryPlanResponseBody.FaultAddrPools()
            model.fromMap(dict["FaultAddrPools"] as! [String: Any])
            self.faultAddrPools = model
        }
        if dict.keys.contains("LastExecuteTime") {
            self.lastExecuteTime = dict["LastExecuteTime"] as! String
        }
        if dict.keys.contains("LastExecuteTimestamp") {
            self.lastExecuteTimestamp = dict["LastExecuteTimestamp"] as! Int64
        }
        if dict.keys.contains("LastRollbackTime") {
            self.lastRollbackTime = dict["LastRollbackTime"] as! String
        }
        if dict.keys.contains("LastRollbackTimestamp") {
            self.lastRollbackTimestamp = dict["LastRollbackTimestamp"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! String
        }
        if dict.keys.contains("UpdateTimestamp") {
            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
        }
    }
}

public class DescribeGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmRecoveryPlanAvailableConfigRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGtmRecoveryPlanAvailableConfigResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public class AddrPools : Tea.TeaModel {
                public class AddrPool : Tea.TeaModel {
                    public var addrPoolId: String?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.addrPoolId != nil {
                            map["AddrPoolId"] = self.addrPoolId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AddrPoolId") {
                            self.addrPoolId = dict["AddrPoolId"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public var addrPool: [DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools.AddrPool]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.addrPool != nil {
                        var tmp : [Any] = []
                        for k in self.addrPool! {
                            tmp.append(k.toMap())
                        }
                        map["AddrPool"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AddrPool") {
                        var tmp : [DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools.AddrPool] = []
                        for v in dict["AddrPool"] as! [Any] {
                            var model = DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools.AddrPool()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.addrPool = tmp
                    }
                }
            }
            public var addrPools: DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools?

            public var instanceId: String?

            public var instanceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addrPools?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addrPools != nil {
                    map["AddrPools"] = self.addrPools?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddrPools") {
                    var model = DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance.AddrPools()
                    model.fromMap(dict["AddrPools"] as! [String: Any])
                    self.addrPools = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
            }
        }
        public var instance: [DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instance") {
                var tmp : [DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance] = []
                for v in dict["Instance"] as! [Any] {
                    var model = DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances.Instance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instance = tmp
            }
        }
    }
    public var instances: DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var model = DescribeGtmRecoveryPlanAvailableConfigResponseBody.Instances()
            model.fromMap(dict["Instances"] as! [String: Any])
            self.instances = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGtmRecoveryPlanAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmRecoveryPlanAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmRecoveryPlanAvailableConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGtmRecoveryPlansRequest : Tea.TeaModel {
    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeGtmRecoveryPlansResponseBody : Tea.TeaModel {
    public class RecoveryPlans : Tea.TeaModel {
        public class RecoveryPlan : Tea.TeaModel {
            public var createTime: String?

            public var createTimestamp: Int64?

            public var faultAddrPoolNum: Int32?

            public var lastExecuteTime: String?

            public var lastExecuteTimestamp: Int64?

            public var lastRollbackTime: String?

            public var lastRollbackTimestamp: Int64?

            public var name: String?

            public var recoveryPlanId: Int64?

            public var remark: String?

            public var status: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.faultAddrPoolNum != nil {
                    map["FaultAddrPoolNum"] = self.faultAddrPoolNum!
                }
                if self.lastExecuteTime != nil {
                    map["LastExecuteTime"] = self.lastExecuteTime!
                }
                if self.lastExecuteTimestamp != nil {
                    map["LastExecuteTimestamp"] = self.lastExecuteTimestamp!
                }
                if self.lastRollbackTime != nil {
                    map["LastRollbackTime"] = self.lastRollbackTime!
                }
                if self.lastRollbackTimestamp != nil {
                    map["LastRollbackTimestamp"] = self.lastRollbackTimestamp!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.recoveryPlanId != nil {
                    map["RecoveryPlanId"] = self.recoveryPlanId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("FaultAddrPoolNum") {
                    self.faultAddrPoolNum = dict["FaultAddrPoolNum"] as! Int32
                }
                if dict.keys.contains("LastExecuteTime") {
                    self.lastExecuteTime = dict["LastExecuteTime"] as! String
                }
                if dict.keys.contains("LastExecuteTimestamp") {
                    self.lastExecuteTimestamp = dict["LastExecuteTimestamp"] as! Int64
                }
                if dict.keys.contains("LastRollbackTime") {
                    self.lastRollbackTime = dict["LastRollbackTime"] as! String
                }
                if dict.keys.contains("LastRollbackTimestamp") {
                    self.lastRollbackTimestamp = dict["LastRollbackTimestamp"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RecoveryPlanId") {
                    self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var recoveryPlan: [DescribeGtmRecoveryPlansResponseBody.RecoveryPlans.RecoveryPlan]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recoveryPlan != nil {
                var tmp : [Any] = []
                for k in self.recoveryPlan! {
                    tmp.append(k.toMap())
                }
                map["RecoveryPlan"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecoveryPlan") {
                var tmp : [DescribeGtmRecoveryPlansResponseBody.RecoveryPlans.RecoveryPlan] = []
                for v in dict["RecoveryPlan"] as! [Any] {
                    var model = DescribeGtmRecoveryPlansResponseBody.RecoveryPlans.RecoveryPlan()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recoveryPlan = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var recoveryPlans: DescribeGtmRecoveryPlansResponseBody.RecoveryPlans?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recoveryPlans?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recoveryPlans != nil {
            map["RecoveryPlans"] = self.recoveryPlans?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecoveryPlans") {
            var model = DescribeGtmRecoveryPlansResponseBody.RecoveryPlans()
            model.fromMap(dict["RecoveryPlans"] as! [String: Any])
            self.recoveryPlans = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeGtmRecoveryPlansResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGtmRecoveryPlansResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGtmRecoveryPlansResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceDomainsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribeInstanceDomainsResponseBody : Tea.TeaModel {
    public class InstanceDomains : Tea.TeaModel {
        public var createTime: String?

        public var createTimestamp: Int64?

        public var domainName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
        }
    }
    public var instanceDomains: [DescribeInstanceDomainsResponseBody.InstanceDomains]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceDomains != nil {
            var tmp : [Any] = []
            for k in self.instanceDomains! {
                tmp.append(k.toMap())
            }
            map["InstanceDomains"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceDomains") {
            var tmp : [DescribeInstanceDomainsResponseBody.InstanceDomains] = []
            for v in dict["InstanceDomains"] as! [Any] {
                var model = DescribeInstanceDomainsResponseBody.InstanceDomains()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceDomains = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeInstanceDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInternetDnsLogsRequest : Tea.TeaModel {
    public var accountId: Int64?

    public var domainName: String?

    public var endTimestamp: Int64?

    public var lang: String?

    public var module: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var queryCondition: String?

    public var startTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.module != nil {
            map["Module"] = self.module!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryCondition != nil {
            map["QueryCondition"] = self.queryCondition!
        }
        if self.startTimestamp != nil {
            map["StartTimestamp"] = self.startTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! Int64
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTimestamp") {
            self.endTimestamp = dict["EndTimestamp"] as! Int64
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Module") {
            self.module = dict["Module"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QueryCondition") {
            self.queryCondition = dict["QueryCondition"] as! String
        }
        if dict.keys.contains("StartTimestamp") {
            self.startTimestamp = dict["StartTimestamp"] as! Int64
        }
    }
}

public class DescribeInternetDnsLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public class Log : Tea.TeaModel {
            public class Value : Tea.TeaModel {
                public var value: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! [String]
                    }
                }
            }
            public var dnsMsgId: String?

            public var logTime: Int64?

            public var protocol_: String?

            public var queryName: String?

            public var queryType: String?

            public var rt: Int32?

            public var serverIp: String?

            public var sourceIp: String?

            public var status: String?

            public var subnetIp: String?

            public var value: DescribeInternetDnsLogsResponseBody.Logs.Log.Value?

            public var zoneName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.value?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dnsMsgId != nil {
                    map["DnsMsgId"] = self.dnsMsgId!
                }
                if self.logTime != nil {
                    map["LogTime"] = self.logTime!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.queryName != nil {
                    map["QueryName"] = self.queryName!
                }
                if self.queryType != nil {
                    map["QueryType"] = self.queryType!
                }
                if self.rt != nil {
                    map["Rt"] = self.rt!
                }
                if self.serverIp != nil {
                    map["ServerIp"] = self.serverIp!
                }
                if self.sourceIp != nil {
                    map["SourceIp"] = self.sourceIp!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.subnetIp != nil {
                    map["SubnetIp"] = self.subnetIp!
                }
                if self.value != nil {
                    map["Value"] = self.value?.toMap()
                }
                if self.zoneName != nil {
                    map["ZoneName"] = self.zoneName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DnsMsgId") {
                    self.dnsMsgId = dict["DnsMsgId"] as! String
                }
                if dict.keys.contains("LogTime") {
                    self.logTime = dict["LogTime"] as! Int64
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("QueryName") {
                    self.queryName = dict["QueryName"] as! String
                }
                if dict.keys.contains("QueryType") {
                    self.queryType = dict["QueryType"] as! String
                }
                if dict.keys.contains("Rt") {
                    self.rt = dict["Rt"] as! Int32
                }
                if dict.keys.contains("ServerIp") {
                    self.serverIp = dict["ServerIp"] as! String
                }
                if dict.keys.contains("SourceIp") {
                    self.sourceIp = dict["SourceIp"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubnetIp") {
                    self.subnetIp = dict["SubnetIp"] as! String
                }
                if dict.keys.contains("Value") {
                    var model = DescribeInternetDnsLogsResponseBody.Logs.Log.Value()
                    model.fromMap(dict["Value"] as! [String: Any])
                    self.value = model
                }
                if dict.keys.contains("ZoneName") {
                    self.zoneName = dict["ZoneName"] as! String
                }
            }
        }
        public var log: [DescribeInternetDnsLogsResponseBody.Logs.Log]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.log != nil {
                var tmp : [Any] = []
                for k in self.log! {
                    tmp.append(k.toMap())
                }
                map["Log"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Log") {
                var tmp : [DescribeInternetDnsLogsResponseBody.Logs.Log] = []
                for v in dict["Log"] as! [Any] {
                    var model = DescribeInternetDnsLogsResponseBody.Logs.Log()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.log = tmp
            }
        }
    }
    public var complete: Bool?

    public var curPage: Int32?

    public var logs: DescribeInternetDnsLogsResponseBody.Logs?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalPage: Int32?

    public var totalSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complete != nil {
            map["Complete"] = self.complete!
        }
        if self.curPage != nil {
            map["CurPage"] = self.curPage!
        }
        if self.logs != nil {
            map["Logs"] = self.logs?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        if self.totalSize != nil {
            map["TotalSize"] = self.totalSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Complete") {
            self.complete = dict["Complete"] as! Bool
        }
        if dict.keys.contains("CurPage") {
            self.curPage = dict["CurPage"] as! Int32
        }
        if dict.keys.contains("Logs") {
            var model = DescribeInternetDnsLogsResponseBody.Logs()
            model.fromMap(dict["Logs"] as! [String: Any])
            self.logs = model
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalPage") {
            self.totalPage = dict["TotalPage"] as! Int32
        }
        if dict.keys.contains("TotalSize") {
            self.totalSize = dict["TotalSize"] as! Int32
        }
    }
}

public class DescribeInternetDnsLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInternetDnsLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInternetDnsLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIspFlushCacheInstancesRequest : Tea.TeaModel {
    public var direction: String?

    public var isp: String?

    public var keyword: String?

    public var lang: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeIspFlushCacheInstancesResponseBody : Tea.TeaModel {
    public class IspFlushCacheInstances : Tea.TeaModel {
        public class QuotaInfo : Tea.TeaModel {
            public var instanceQuota: Int32?

            public var instanceQuotaUsed: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceQuota != nil {
                    map["InstanceQuota"] = self.instanceQuota!
                }
                if self.instanceQuotaUsed != nil {
                    map["InstanceQuotaUsed"] = self.instanceQuotaUsed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceQuota") {
                    self.instanceQuota = dict["InstanceQuota"] as! Int32
                }
                if dict.keys.contains("InstanceQuotaUsed") {
                    self.instanceQuotaUsed = dict["InstanceQuotaUsed"] as! Int32
                }
            }
        }
        public var expireTime: String?

        public var expireTimestamp: Int64?

        public var instanceId: String?

        public var instanceName: String?

        public var isp: String?

        public var quotaInfo: DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances.QuotaInfo?

        public var status: String?

        public var versionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.quotaInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.expireTimestamp != nil {
                map["ExpireTimestamp"] = self.expireTimestamp!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.isp != nil {
                map["Isp"] = self.isp!
            }
            if self.quotaInfo != nil {
                map["QuotaInfo"] = self.quotaInfo?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.versionCode != nil {
                map["VersionCode"] = self.versionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("ExpireTimestamp") {
                self.expireTimestamp = dict["ExpireTimestamp"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("Isp") {
                self.isp = dict["Isp"] as! String
            }
            if dict.keys.contains("QuotaInfo") {
                var model = DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances.QuotaInfo()
                model.fromMap(dict["QuotaInfo"] as! [String: Any])
                self.quotaInfo = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("VersionCode") {
                self.versionCode = dict["VersionCode"] as! String
            }
        }
    }
    public var ispFlushCacheInstances: [DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ispFlushCacheInstances != nil {
            var tmp : [Any] = []
            for k in self.ispFlushCacheInstances! {
                tmp.append(k.toMap())
            }
            map["IspFlushCacheInstances"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IspFlushCacheInstances") {
            var tmp : [DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances] = []
            for v in dict["IspFlushCacheInstances"] as! [Any] {
                var model = DescribeIspFlushCacheInstancesResponseBody.IspFlushCacheInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ispFlushCacheInstances = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeIspFlushCacheInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIspFlushCacheInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIspFlushCacheInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIspFlushCacheRemainQuotaRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeIspFlushCacheRemainQuotaResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var telecomRemainQuota: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.telecomRemainQuota != nil {
            map["TelecomRemainQuota"] = self.telecomRemainQuota!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TelecomRemainQuota") {
            self.telecomRemainQuota = dict["TelecomRemainQuota"] as! Int32
        }
    }
}

public class DescribeIspFlushCacheRemainQuotaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIspFlushCacheRemainQuotaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIspFlushCacheRemainQuotaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIspFlushCacheTaskRequest : Tea.TeaModel {
    public var lang: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeIspFlushCacheTaskResponseBody : Tea.TeaModel {
    public class FlushCacheResults : Tea.TeaModel {
        public class DnsNodes : Tea.TeaModel {
            public class Answers : Tea.TeaModel {
                public var name: String?

                public var record: String?

                public var ttl: Int64?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.record != nil {
                        map["Record"] = self.record!
                    }
                    if self.ttl != nil {
                        map["Ttl"] = self.ttl!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Record") {
                        self.record = dict["Record"] as! String
                    }
                    if dict.keys.contains("Ttl") {
                        self.ttl = dict["Ttl"] as! Int64
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var answers: [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes.Answers]?

            public var nodeIp: String?

            public var spName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answers != nil {
                    var tmp : [Any] = []
                    for k in self.answers! {
                        tmp.append(k.toMap())
                    }
                    map["Answers"] = tmp
                }
                if self.nodeIp != nil {
                    map["NodeIp"] = self.nodeIp!
                }
                if self.spName != nil {
                    map["SpName"] = self.spName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Answers") {
                    var tmp : [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes.Answers] = []
                    for v in dict["Answers"] as! [Any] {
                        var model = DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes.Answers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.answers = tmp
                }
                if dict.keys.contains("NodeIp") {
                    self.nodeIp = dict["NodeIp"] as! String
                }
                if dict.keys.contains("SpName") {
                    self.spName = dict["SpName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var dnsNodes: [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes]?

        public var province: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsNodes != nil {
                var tmp : [Any] = []
                for k in self.dnsNodes! {
                    tmp.append(k.toMap())
                }
                map["DnsNodes"] = tmp
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsNodes") {
                var tmp : [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes] = []
                for v in dict["DnsNodes"] as! [Any] {
                    var model = DescribeIspFlushCacheTaskResponseBody.FlushCacheResults.DnsNodes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dnsNodes = tmp
            }
            if dict.keys.contains("Province") {
                self.province = dict["Province"] as! String
            }
        }
    }
    public var createTime: String?

    public var createTimestamp: Int64?

    public var domainName: String?

    public var flushCacheResults: [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults]?

    public var instanceId: String?

    public var instanceName: String?

    public var isp: String?

    public var requestId: String?

    public var taskId: String?

    public var taskStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.createTimestamp != nil {
            map["CreateTimestamp"] = self.createTimestamp!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.flushCacheResults != nil {
            var tmp : [Any] = []
            for k in self.flushCacheResults! {
                tmp.append(k.toMap())
            }
            map["FlushCacheResults"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("CreateTimestamp") {
            self.createTimestamp = dict["CreateTimestamp"] as! Int64
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("FlushCacheResults") {
            var tmp : [DescribeIspFlushCacheTaskResponseBody.FlushCacheResults] = []
            for v in dict["FlushCacheResults"] as! [Any] {
                var model = DescribeIspFlushCacheTaskResponseBody.FlushCacheResults()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.flushCacheResults = tmp
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskStatus") {
            self.taskStatus = dict["TaskStatus"] as! String
        }
    }
}

public class DescribeIspFlushCacheTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIspFlushCacheTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIspFlushCacheTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIspFlushCacheTasksRequest : Tea.TeaModel {
    public var direction: String?

    public var domainName: String?

    public var instanceId: String?

    public var isp: String?

    public var lang: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeIspFlushCacheTasksResponseBody : Tea.TeaModel {
    public class IspFlushCacheTasks : Tea.TeaModel {
        public var createTime: String?

        public var createTimestamp: Int64?

        public var domainName: String?

        public var instanceId: String?

        public var instanceName: String?

        public var isp: String?

        public var taskId: String?

        public var taskStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.isp != nil {
                map["Isp"] = self.isp!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("Isp") {
                self.isp = dict["Isp"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskStatus") {
                self.taskStatus = dict["TaskStatus"] as! String
            }
        }
    }
    public var ispFlushCacheTasks: [DescribeIspFlushCacheTasksResponseBody.IspFlushCacheTasks]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ispFlushCacheTasks != nil {
            var tmp : [Any] = []
            for k in self.ispFlushCacheTasks! {
                tmp.append(k.toMap())
            }
            map["IspFlushCacheTasks"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IspFlushCacheTasks") {
            var tmp : [DescribeIspFlushCacheTasksResponseBody.IspFlushCacheTasks] = []
            for v in dict["IspFlushCacheTasks"] as! [Any] {
                var model = DescribeIspFlushCacheTasksResponseBody.IspFlushCacheTasks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ispFlushCacheTasks = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeIspFlushCacheTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIspFlushCacheTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIspFlushCacheTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsAccountSummaryRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribePdnsAccountSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var domainCount: Int64?

        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var subDomainCount: Int64?

        public var threatCount: Int64?

        public var totalCount: Int64?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainCount != nil {
                map["DomainCount"] = self.domainCount!
            }
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.subDomainCount != nil {
                map["SubDomainCount"] = self.subDomainCount!
            }
            if self.threatCount != nil {
                map["ThreatCount"] = self.threatCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainCount") {
                self.domainCount = dict["DomainCount"] as! Int64
            }
            if dict.keys.contains("HttpCount") {
                self.httpCount = dict["HttpCount"] as! Int64
            }
            if dict.keys.contains("HttpsCount") {
                self.httpsCount = dict["HttpsCount"] as! Int64
            }
            if dict.keys.contains("SubDomainCount") {
                self.subDomainCount = dict["SubDomainCount"] as! Int64
            }
            if dict.keys.contains("ThreatCount") {
                self.threatCount = dict["ThreatCount"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var data: DescribePdnsAccountSummaryResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribePdnsAccountSummaryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePdnsAccountSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsAccountSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsAccountSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsAppKeyRequest : Tea.TeaModel {
    public var appKeyId: String?

    public var authCode: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKeyId != nil {
            map["AppKeyId"] = self.appKeyId!
        }
        if self.authCode != nil {
            map["AuthCode"] = self.authCode!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppKeyId") {
            self.appKeyId = dict["AppKeyId"] as! String
        }
        if dict.keys.contains("AuthCode") {
            self.authCode = dict["AuthCode"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribePdnsAppKeyResponseBody : Tea.TeaModel {
    public class AppKey : Tea.TeaModel {
        public var appKeyId: String?

        public var appKeySecret: String?

        public var createDate: String?

        public var createTimestamp: Int64?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appKeyId != nil {
                map["AppKeyId"] = self.appKeyId!
            }
            if self.appKeySecret != nil {
                map["AppKeySecret"] = self.appKeySecret!
            }
            if self.createDate != nil {
                map["CreateDate"] = self.createDate!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppKeyId") {
                self.appKeyId = dict["AppKeyId"] as! String
            }
            if dict.keys.contains("AppKeySecret") {
                self.appKeySecret = dict["AppKeySecret"] as! String
            }
            if dict.keys.contains("CreateDate") {
                self.createDate = dict["CreateDate"] as! String
            }
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var appKey: DescribePdnsAppKeyResponseBody.AppKey?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appKey?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKey != nil {
            map["AppKey"] = self.appKey?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppKey") {
            var model = DescribePdnsAppKeyResponseBody.AppKey()
            model.fromMap(dict["AppKey"] as! [String: Any])
            self.appKey = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePdnsAppKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsAppKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsAppKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsAppKeysRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribePdnsAppKeysResponseBody : Tea.TeaModel {
    public class AppKeys : Tea.TeaModel {
        public var appKeyId: String?

        public var createDate: String?

        public var createTimestamp: Int64?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appKeyId != nil {
                map["AppKeyId"] = self.appKeyId!
            }
            if self.createDate != nil {
                map["CreateDate"] = self.createDate!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppKeyId") {
                self.appKeyId = dict["AppKeyId"] as! String
            }
            if dict.keys.contains("CreateDate") {
                self.createDate = dict["CreateDate"] as! String
            }
            if dict.keys.contains("CreateTimestamp") {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var appKeys: [DescribePdnsAppKeysResponseBody.AppKeys]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKeys != nil {
            var tmp : [Any] = []
            for k in self.appKeys! {
                tmp.append(k.toMap())
            }
            map["AppKeys"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppKeys") {
            var tmp : [DescribePdnsAppKeysResponseBody.AppKeys] = []
            for v in dict["AppKeys"] as! [Any] {
                var model = DescribePdnsAppKeysResponseBody.AppKeys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.appKeys = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePdnsAppKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsAppKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsAppKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsOperateLogsRequest : Tea.TeaModel {
    public var actionType: String?

    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["ActionType"] = self.actionType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionType") {
            self.actionType = dict["ActionType"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribePdnsOperateLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public var action: String?

        public var operateTime: String?

        public var type: String?

        public var content: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.operateTime != nil {
                map["OperateTime"] = self.operateTime!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.content != nil {
                map["content"] = self.content!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("OperateTime") {
                self.operateTime = dict["OperateTime"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
        }
    }
    public var logs: [DescribePdnsOperateLogsResponseBody.Logs]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            var tmp : [Any] = []
            for k in self.logs! {
                tmp.append(k.toMap())
            }
            map["Logs"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logs") {
            var tmp : [DescribePdnsOperateLogsResponseBody.Logs] = []
            for v in dict["Logs"] as! [Any] {
                var model = DescribePdnsOperateLogsResponseBody.Logs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.logs = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePdnsOperateLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsOperateLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsOperateLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsRequestStatisticRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
    }
}

public class DescribePdnsRequestStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dohTotalCount: Int64?

        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var ipCount: Int64?

        public var timestamp: Int64?

        public var totalCount: Int64?

        public var udpTotalCount: Int64?

        public var v4Count: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6Count: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dohTotalCount != nil {
                map["DohTotalCount"] = self.dohTotalCount!
            }
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.udpTotalCount != nil {
                map["UdpTotalCount"] = self.udpTotalCount!
            }
            if self.v4Count != nil {
                map["V4Count"] = self.v4Count!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6Count != nil {
                map["V6Count"] = self.v6Count!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DohTotalCount") {
                self.dohTotalCount = dict["DohTotalCount"] as! Int64
            }
            if dict.keys.contains("HttpCount") {
                self.httpCount = dict["HttpCount"] as! Int64
            }
            if dict.keys.contains("HttpsCount") {
                self.httpsCount = dict["HttpsCount"] as! Int64
            }
            if dict.keys.contains("IpCount") {
                self.ipCount = dict["IpCount"] as! Int64
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("UdpTotalCount") {
                self.udpTotalCount = dict["UdpTotalCount"] as! Int64
            }
            if dict.keys.contains("V4Count") {
                self.v4Count = dict["V4Count"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6Count") {
                self.v6Count = dict["V6Count"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var data: [DescribePdnsRequestStatisticResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribePdnsRequestStatisticResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribePdnsRequestStatisticResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePdnsRequestStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsRequestStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsRequestStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsRequestStatisticsRequest : Tea.TeaModel {
    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var subDomain: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribePdnsRequestStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ThreatInfo : Tea.TeaModel {
            public var threatLevel: String?

            public var threatType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.threatLevel != nil {
                    map["ThreatLevel"] = self.threatLevel!
                }
                if self.threatType != nil {
                    map["ThreatType"] = self.threatType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ThreatLevel") {
                    self.threatLevel = dict["ThreatLevel"] as! String
                }
                if dict.keys.contains("ThreatType") {
                    self.threatType = dict["ThreatType"] as! String
                }
            }
        }
        public var dohTotalCount: Int64?

        public var domainName: String?

        public var httpCount: Int64?

        public var httpsCount: Int64?

        public var ipCount: Int64?

        public var maxThreatLevel: String?

        public var subDomain: String?

        public var threatCount: Int64?

        public var threatInfo: [DescribePdnsRequestStatisticsResponseBody.Data.ThreatInfo]?

        public var totalCount: Int64?

        public var udpTotalCount: Int64?

        public var v4Count: Int64?

        public var v4HttpCount: Int64?

        public var v4HttpsCount: Int64?

        public var v6Count: Int64?

        public var v6HttpCount: Int64?

        public var v6HttpsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dohTotalCount != nil {
                map["DohTotalCount"] = self.dohTotalCount!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.httpCount != nil {
                map["HttpCount"] = self.httpCount!
            }
            if self.httpsCount != nil {
                map["HttpsCount"] = self.httpsCount!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.maxThreatLevel != nil {
                map["MaxThreatLevel"] = self.maxThreatLevel!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            if self.threatCount != nil {
                map["ThreatCount"] = self.threatCount!
            }
            if self.threatInfo != nil {
                var tmp : [Any] = []
                for k in self.threatInfo! {
                    tmp.append(k.toMap())
                }
                map["ThreatInfo"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.udpTotalCount != nil {
                map["UdpTotalCount"] = self.udpTotalCount!
            }
            if self.v4Count != nil {
                map["V4Count"] = self.v4Count!
            }
            if self.v4HttpCount != nil {
                map["V4HttpCount"] = self.v4HttpCount!
            }
            if self.v4HttpsCount != nil {
                map["V4HttpsCount"] = self.v4HttpsCount!
            }
            if self.v6Count != nil {
                map["V6Count"] = self.v6Count!
            }
            if self.v6HttpCount != nil {
                map["V6HttpCount"] = self.v6HttpCount!
            }
            if self.v6HttpsCount != nil {
                map["V6HttpsCount"] = self.v6HttpsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DohTotalCount") {
                self.dohTotalCount = dict["DohTotalCount"] as! Int64
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("HttpCount") {
                self.httpCount = dict["HttpCount"] as! Int64
            }
            if dict.keys.contains("HttpsCount") {
                self.httpsCount = dict["HttpsCount"] as! Int64
            }
            if dict.keys.contains("IpCount") {
                self.ipCount = dict["IpCount"] as! Int64
            }
            if dict.keys.contains("MaxThreatLevel") {
                self.maxThreatLevel = dict["MaxThreatLevel"] as! String
            }
            if dict.keys.contains("SubDomain") {
                self.subDomain = dict["SubDomain"] as! String
            }
            if dict.keys.contains("ThreatCount") {
                self.threatCount = dict["ThreatCount"] as! Int64
            }
            if dict.keys.contains("ThreatInfo") {
                var tmp : [DescribePdnsRequestStatisticsResponseBody.Data.ThreatInfo] = []
                for v in dict["ThreatInfo"] as! [Any] {
                    var model = DescribePdnsRequestStatisticsResponseBody.Data.ThreatInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.threatInfo = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("UdpTotalCount") {
                self.udpTotalCount = dict["UdpTotalCount"] as! Int64
            }
            if dict.keys.contains("V4Count") {
                self.v4Count = dict["V4Count"] as! Int64
            }
            if dict.keys.contains("V4HttpCount") {
                self.v4HttpCount = dict["V4HttpCount"] as! Int64
            }
            if dict.keys.contains("V4HttpsCount") {
                self.v4HttpsCount = dict["V4HttpsCount"] as! Int64
            }
            if dict.keys.contains("V6Count") {
                self.v6Count = dict["V6Count"] as! Int64
            }
            if dict.keys.contains("V6HttpCount") {
                self.v6HttpCount = dict["V6HttpCount"] as! Int64
            }
            if dict.keys.contains("V6HttpsCount") {
                self.v6HttpsCount = dict["V6HttpsCount"] as! Int64
            }
        }
    }
    public var data: [DescribePdnsRequestStatisticsResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribePdnsRequestStatisticsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribePdnsRequestStatisticsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePdnsRequestStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsRequestStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsRequestStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsThreatLogsRequest : Tea.TeaModel {
    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var threatLevel: String?

    public var threatSourceIp: String?

    public var threatType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threatLevel != nil {
            map["ThreatLevel"] = self.threatLevel!
        }
        if self.threatSourceIp != nil {
            map["ThreatSourceIp"] = self.threatSourceIp!
        }
        if self.threatType != nil {
            map["ThreatType"] = self.threatType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("ThreatLevel") {
            self.threatLevel = dict["ThreatLevel"] as! String
        }
        if dict.keys.contains("ThreatSourceIp") {
            self.threatSourceIp = dict["ThreatSourceIp"] as! String
        }
        if dict.keys.contains("ThreatType") {
            self.threatType = dict["ThreatType"] as! String
        }
    }
}

public class DescribePdnsThreatLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public var sourceIp: String?

        public var subDomain: String?

        public var threatLevel: String?

        public var threatTime: String?

        public var threatType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceIp != nil {
                map["SourceIp"] = self.sourceIp!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            if self.threatLevel != nil {
                map["ThreatLevel"] = self.threatLevel!
            }
            if self.threatTime != nil {
                map["ThreatTime"] = self.threatTime!
            }
            if self.threatType != nil {
                map["ThreatType"] = self.threatType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SourceIp") {
                self.sourceIp = dict["SourceIp"] as! String
            }
            if dict.keys.contains("SubDomain") {
                self.subDomain = dict["SubDomain"] as! String
            }
            if dict.keys.contains("ThreatLevel") {
                self.threatLevel = dict["ThreatLevel"] as! String
            }
            if dict.keys.contains("ThreatTime") {
                self.threatTime = dict["ThreatTime"] as! String
            }
            if dict.keys.contains("ThreatType") {
                self.threatType = dict["ThreatType"] as! String
            }
        }
    }
    public var logs: [DescribePdnsThreatLogsResponseBody.Logs]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            var tmp : [Any] = []
            for k in self.logs! {
                tmp.append(k.toMap())
            }
            map["Logs"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logs") {
            var tmp : [DescribePdnsThreatLogsResponseBody.Logs] = []
            for v in dict["Logs"] as! [Any] {
                var model = DescribePdnsThreatLogsResponseBody.Logs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.logs = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePdnsThreatLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsThreatLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsThreatLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsThreatStatisticRequest : Tea.TeaModel {
    public var endDate: String?

    public var lang: String?

    public var startDate: String?

    public var threatSourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threatSourceIp != nil {
            map["ThreatSourceIp"] = self.threatSourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("ThreatSourceIp") {
            self.threatSourceIp = dict["ThreatSourceIp"] as! String
        }
    }
}

public class DescribePdnsThreatStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dohTotalCount: Int64?

        public var threatLevel: String?

        public var threatType: String?

        public var timestamp: Int64?

        public var totalCount: Int64?

        public var udpTotalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dohTotalCount != nil {
                map["DohTotalCount"] = self.dohTotalCount!
            }
            if self.threatLevel != nil {
                map["ThreatLevel"] = self.threatLevel!
            }
            if self.threatType != nil {
                map["ThreatType"] = self.threatType!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.udpTotalCount != nil {
                map["UdpTotalCount"] = self.udpTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DohTotalCount") {
                self.dohTotalCount = dict["DohTotalCount"] as! Int64
            }
            if dict.keys.contains("ThreatLevel") {
                self.threatLevel = dict["ThreatLevel"] as! String
            }
            if dict.keys.contains("ThreatType") {
                self.threatType = dict["ThreatType"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("UdpTotalCount") {
                self.udpTotalCount = dict["UdpTotalCount"] as! Int64
            }
        }
    }
    public var data: [DescribePdnsThreatStatisticResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribePdnsThreatStatisticResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribePdnsThreatStatisticResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePdnsThreatStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsThreatStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsThreatStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsThreatStatisticsRequest : Tea.TeaModel {
    public var direction: String?

    public var domainName: String?

    public var endDate: String?

    public var lang: String?

    public var orderBy: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var subDomain: String?

    public var threatLevel: String?

    public var threatSourceIp: String?

    public var threatType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.threatLevel != nil {
            map["ThreatLevel"] = self.threatLevel!
        }
        if self.threatSourceIp != nil {
            map["ThreatSourceIp"] = self.threatSourceIp!
        }
        if self.threatType != nil {
            map["ThreatType"] = self.threatType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
        if dict.keys.contains("ThreatLevel") {
            self.threatLevel = dict["ThreatLevel"] as! String
        }
        if dict.keys.contains("ThreatSourceIp") {
            self.threatSourceIp = dict["ThreatSourceIp"] as! String
        }
        if dict.keys.contains("ThreatType") {
            self.threatType = dict["ThreatType"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribePdnsThreatStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dohTotalCount: Int64?

        public var domainCount: Int64?

        public var domainName: String?

        public var latestThreatTime: Int64?

        public var maxThreatLevel: String?

        public var sourceIp: String?

        public var subDomain: String?

        public var threatLevel: String?

        public var threatType: String?

        public var totalCount: Int64?

        public var udpTotalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dohTotalCount != nil {
                map["DohTotalCount"] = self.dohTotalCount!
            }
            if self.domainCount != nil {
                map["DomainCount"] = self.domainCount!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.latestThreatTime != nil {
                map["LatestThreatTime"] = self.latestThreatTime!
            }
            if self.maxThreatLevel != nil {
                map["MaxThreatLevel"] = self.maxThreatLevel!
            }
            if self.sourceIp != nil {
                map["SourceIp"] = self.sourceIp!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            if self.threatLevel != nil {
                map["ThreatLevel"] = self.threatLevel!
            }
            if self.threatType != nil {
                map["ThreatType"] = self.threatType!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.udpTotalCount != nil {
                map["UdpTotalCount"] = self.udpTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DohTotalCount") {
                self.dohTotalCount = dict["DohTotalCount"] as! Int64
            }
            if dict.keys.contains("DomainCount") {
                self.domainCount = dict["DomainCount"] as! Int64
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("LatestThreatTime") {
                self.latestThreatTime = dict["LatestThreatTime"] as! Int64
            }
            if dict.keys.contains("MaxThreatLevel") {
                self.maxThreatLevel = dict["MaxThreatLevel"] as! String
            }
            if dict.keys.contains("SourceIp") {
                self.sourceIp = dict["SourceIp"] as! String
            }
            if dict.keys.contains("SubDomain") {
                self.subDomain = dict["SubDomain"] as! String
            }
            if dict.keys.contains("ThreatLevel") {
                self.threatLevel = dict["ThreatLevel"] as! String
            }
            if dict.keys.contains("ThreatType") {
                self.threatType = dict["ThreatType"] as! String
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("UdpTotalCount") {
                self.udpTotalCount = dict["UdpTotalCount"] as! Int64
            }
        }
    }
    public var data: [DescribePdnsThreatStatisticsResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribePdnsThreatStatisticsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribePdnsThreatStatisticsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribePdnsThreatStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsThreatStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsThreatStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsUdpIpSegmentsRequest : Tea.TeaModel {
    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribePdnsUdpIpSegmentsResponseBody : Tea.TeaModel {
    public class IpSegments : Tea.TeaModel {
        public var createDate: String?

        public var ip: String?

        public var mask: Int64?

        public var name: String?

        public var state: String?

        public var updateDate: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createDate != nil {
                map["CreateDate"] = self.createDate!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.mask != nil {
                map["Mask"] = self.mask!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.updateDate != nil {
                map["UpdateDate"] = self.updateDate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateDate") {
                self.createDate = dict["CreateDate"] as! String
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Mask") {
                self.mask = dict["Mask"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("UpdateDate") {
                self.updateDate = dict["UpdateDate"] as! String
            }
        }
    }
    public var ipSegments: [DescribePdnsUdpIpSegmentsResponseBody.IpSegments]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var totalPages: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipSegments != nil {
            var tmp : [Any] = []
            for k in self.ipSegments! {
                tmp.append(k.toMap())
            }
            map["IpSegments"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpSegments") {
            var tmp : [DescribePdnsUdpIpSegmentsResponseBody.IpSegments] = []
            for v in dict["IpSegments"] as! [Any] {
                var model = DescribePdnsUdpIpSegmentsResponseBody.IpSegments()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ipSegments = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! String
        }
    }
}

public class DescribePdnsUdpIpSegmentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsUdpIpSegmentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsUdpIpSegmentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePdnsUserInfoRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribePdnsUserInfoResponseBody : Tea.TeaModel {
    public class UserInfo : Tea.TeaModel {
        public var availableService: String?

        public var pdnsId: Int64?

        public var serviceType: String?

        public var state: String?

        public var statisticSwitchStatus: String?

        public var stoppedService: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableService != nil {
                map["AvailableService"] = self.availableService!
            }
            if self.pdnsId != nil {
                map["PdnsId"] = self.pdnsId!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.statisticSwitchStatus != nil {
                map["StatisticSwitchStatus"] = self.statisticSwitchStatus!
            }
            if self.stoppedService != nil {
                map["StoppedService"] = self.stoppedService!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableService") {
                self.availableService = dict["AvailableService"] as! String
            }
            if dict.keys.contains("PdnsId") {
                self.pdnsId = dict["PdnsId"] as! Int64
            }
            if dict.keys.contains("ServiceType") {
                self.serviceType = dict["ServiceType"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("StatisticSwitchStatus") {
                self.statisticSwitchStatus = dict["StatisticSwitchStatus"] as! String
            }
            if dict.keys.contains("StoppedService") {
                self.stoppedService = dict["StoppedService"] as! String
            }
        }
    }
    public var requestId: String?

    public var userInfo: DescribePdnsUserInfoResponseBody.UserInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userInfo != nil {
            map["UserInfo"] = self.userInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserInfo") {
            var model = DescribePdnsUserInfoResponseBody.UserInfo()
            model.fromMap(dict["UserInfo"] as! [String: Any])
            self.userInfo = model
        }
    }
}

public class DescribePdnsUserInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePdnsUserInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePdnsUserInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecordLogsRequest : Tea.TeaModel {
    public var domainName: String?

    public var keyWord: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startDate: String?

    public var userClientIp: String?

    public var endDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.endDate != nil {
            map["endDate"] = self.endDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("KeyWord") {
            self.keyWord = dict["KeyWord"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
        if dict.keys.contains("endDate") {
            self.endDate = dict["endDate"] as! String
        }
    }
}

public class DescribeRecordLogsResponseBody : Tea.TeaModel {
    public class RecordLogs : Tea.TeaModel {
        public class RecordLog : Tea.TeaModel {
            public var action: String?

            public var actionTime: String?

            public var actionTimestamp: Int64?

            public var clientIp: String?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.actionTime != nil {
                    map["ActionTime"] = self.actionTime!
                }
                if self.actionTimestamp != nil {
                    map["ActionTimestamp"] = self.actionTimestamp!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ActionTime") {
                    self.actionTime = dict["ActionTime"] as! String
                }
                if dict.keys.contains("ActionTimestamp") {
                    self.actionTimestamp = dict["ActionTimestamp"] as! Int64
                }
                if dict.keys.contains("ClientIp") {
                    self.clientIp = dict["ClientIp"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public var recordLog: [DescribeRecordLogsResponseBody.RecordLogs.RecordLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordLog != nil {
                var tmp : [Any] = []
                for k in self.recordLog! {
                    tmp.append(k.toMap())
                }
                map["RecordLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecordLog") {
                var tmp : [DescribeRecordLogsResponseBody.RecordLogs.RecordLog] = []
                for v in dict["RecordLog"] as! [Any] {
                    var model = DescribeRecordLogsResponseBody.RecordLogs.RecordLog()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recordLog = tmp
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var recordLogs: DescribeRecordLogsResponseBody.RecordLogs?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordLogs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordLogs != nil {
            map["RecordLogs"] = self.recordLogs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RecordLogs") {
            var model = DescribeRecordLogsResponseBody.RecordLogs()
            model.fromMap(dict["RecordLogs"] as! [String: Any])
            self.recordLogs = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeRecordLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecordLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecordLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecordResolveStatisticsSummaryRequest : Tea.TeaModel {
    public var direction: String?

    public var domainName: String?

    public var domainType: String?

    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchMode: String?

    public var startDate: String?

    public var threshold: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainType") {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchMode") {
            self.searchMode = dict["SearchMode"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Int64
        }
    }
}

public class DescribeRecordResolveStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var count: String?

        public var domainName: String?

        public var domainType: String?

        public var subDomain: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainType != nil {
                map["DomainType"] = self.domainType!
            }
            if self.subDomain != nil {
                map["SubDomain"] = self.subDomain!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainType") {
                self.domainType = dict["DomainType"] as! String
            }
            if dict.keys.contains("SubDomain") {
                self.subDomain = dict["SubDomain"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: [DescribeRecordResolveStatisticsSummaryResponseBody.Statistics]?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var tmp : [DescribeRecordResolveStatisticsSummaryResponseBody.Statistics] = []
            for v in dict["Statistics"] as! [Any] {
                var model = DescribeRecordResolveStatisticsSummaryResponseBody.Statistics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.statistics = tmp
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeRecordResolveStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecordResolveStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecordResolveStatisticsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecordStatisticsRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainType: String?

    public var endDate: String?

    public var lang: String?

    public var rr: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.rr != nil {
            map["Rr"] = self.rr!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainType") {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Rr") {
            self.rr = dict["Rr"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeRecordStatisticsResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public class Statistic : Tea.TeaModel {
            public var count: Int64?

            public var timestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
            }
        }
        public var statistic: [DescribeRecordStatisticsResponseBody.Statistics.Statistic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.statistic != nil {
                var tmp : [Any] = []
                for k in self.statistic! {
                    tmp.append(k.toMap())
                }
                map["Statistic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Statistic") {
                var tmp : [DescribeRecordStatisticsResponseBody.Statistics.Statistic] = []
                for v in dict["Statistic"] as! [Any] {
                    var model = DescribeRecordStatisticsResponseBody.Statistics.Statistic()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.statistic = tmp
            }
        }
    }
    public var requestId: String?

    public var statistics: DescribeRecordStatisticsResponseBody.Statistics?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var model = DescribeRecordStatisticsResponseBody.Statistics()
            model.fromMap(dict["Statistics"] as! [String: Any])
            self.statistics = model
        }
    }
}

public class DescribeRecordStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecordStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecordStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecordStatisticsSummaryRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainType: String?

    public var endDate: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var searchMode: String?

    public var startDate: String?

    public var threshold: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchMode != nil {
            map["SearchMode"] = self.searchMode!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainType") {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SearchMode") {
            self.searchMode = dict["SearchMode"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! Int64
        }
    }
}

public class DescribeRecordStatisticsSummaryResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public class Statistic : Tea.TeaModel {
            public var count: Int64?

            public var subDomain: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.subDomain != nil {
                    map["SubDomain"] = self.subDomain!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("SubDomain") {
                    self.subDomain = dict["SubDomain"] as! String
                }
            }
        }
        public var statistic: [DescribeRecordStatisticsSummaryResponseBody.Statistics.Statistic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.statistic != nil {
                var tmp : [Any] = []
                for k in self.statistic! {
                    tmp.append(k.toMap())
                }
                map["Statistic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Statistic") {
                var tmp : [DescribeRecordStatisticsSummaryResponseBody.Statistics.Statistic] = []
                for v in dict["Statistic"] as! [Any] {
                    var model = DescribeRecordStatisticsSummaryResponseBody.Statistics.Statistic()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.statistic = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var statistics: DescribeRecordStatisticsSummaryResponseBody.Statistics?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.statistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            map["Statistics"] = self.statistics?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") {
            var model = DescribeRecordStatisticsSummaryResponseBody.Statistics()
            model.fromMap(dict["Statistics"] as! [String: Any])
            self.statistics = model
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class DescribeRecordStatisticsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecordStatisticsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecordStatisticsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSubDomainRecordsRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var line: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var subDomain: String?

    public var type: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Line") {
            self.line = dict["Line"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DescribeSubDomainRecordsResponseBody : Tea.TeaModel {
    public class DomainRecords : Tea.TeaModel {
        public class Record : Tea.TeaModel {
            public var domainName: String?

            public var line: String?

            public var locked: Bool?

            public var priority: Int64?

            public var RR: String?

            public var recordId: String?

            public var remark: String?

            public var status: String?

            public var TTL: Int64?

            public var type: String?

            public var value: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.line != nil {
                    map["Line"] = self.line!
                }
                if self.locked != nil {
                    map["Locked"] = self.locked!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.RR != nil {
                    map["RR"] = self.RR!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.TTL != nil {
                    map["TTL"] = self.TTL!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Line") {
                    self.line = dict["Line"] as! String
                }
                if dict.keys.contains("Locked") {
                    self.locked = dict["Locked"] as! Bool
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int64
                }
                if dict.keys.contains("RR") {
                    self.RR = dict["RR"] as! String
                }
                if dict.keys.contains("RecordId") {
                    self.recordId = dict["RecordId"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TTL") {
                    self.TTL = dict["TTL"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var record: [DescribeSubDomainRecordsResponseBody.DomainRecords.Record]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.record != nil {
                var tmp : [Any] = []
                for k in self.record! {
                    tmp.append(k.toMap())
                }
                map["Record"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Record") {
                var tmp : [DescribeSubDomainRecordsResponseBody.DomainRecords.Record] = []
                for v in dict["Record"] as! [Any] {
                    var model = DescribeSubDomainRecordsResponseBody.DomainRecords.Record()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.record = tmp
            }
        }
    }
    public var domainRecords: DescribeSubDomainRecordsResponseBody.DomainRecords?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainRecords?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainRecords != nil {
            map["DomainRecords"] = self.domainRecords?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainRecords") {
            var model = DescribeSubDomainRecordsResponseBody.DomainRecords()
            model.fromMap(dict["DomainRecords"] as! [String: Any])
            self.domainRecords = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeSubDomainRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSubDomainRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSubDomainRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSupportLinesRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class DescribeSupportLinesResponseBody : Tea.TeaModel {
    public class RecordLines : Tea.TeaModel {
        public class RecordLine : Tea.TeaModel {
            public var fatherCode: String?

            public var lineCode: String?

            public var lineDisplayName: String?

            public var lineName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fatherCode != nil {
                    map["FatherCode"] = self.fatherCode!
                }
                if self.lineCode != nil {
                    map["LineCode"] = self.lineCode!
                }
                if self.lineDisplayName != nil {
                    map["LineDisplayName"] = self.lineDisplayName!
                }
                if self.lineName != nil {
                    map["LineName"] = self.lineName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FatherCode") {
                    self.fatherCode = dict["FatherCode"] as! String
                }
                if dict.keys.contains("LineCode") {
                    self.lineCode = dict["LineCode"] as! String
                }
                if dict.keys.contains("LineDisplayName") {
                    self.lineDisplayName = dict["LineDisplayName"] as! String
                }
                if dict.keys.contains("LineName") {
                    self.lineName = dict["LineName"] as! String
                }
            }
        }
        public var recordLine: [DescribeSupportLinesResponseBody.RecordLines.RecordLine]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordLine != nil {
                var tmp : [Any] = []
                for k in self.recordLine! {
                    tmp.append(k.toMap())
                }
                map["RecordLine"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecordLine") {
                var tmp : [DescribeSupportLinesResponseBody.RecordLines.RecordLine] = []
                for v in dict["RecordLine"] as! [Any] {
                    var model = DescribeSupportLinesResponseBody.RecordLines.RecordLine()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recordLine = tmp
            }
        }
    }
    public var recordLines: DescribeSupportLinesResponseBody.RecordLines?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordLines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordLines != nil {
            map["RecordLines"] = self.recordLines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordLines") {
            var model = DescribeSupportLinesResponseBody.RecordLines()
            model.fromMap(dict["RecordLines"] as! [String: Any])
            self.recordLines = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSupportLinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSupportLinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSupportLinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagsRequest : Tea.TeaModel {
    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeTagsResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var values: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.values != nil {
                map["Values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Values") {
                self.values = dict["Values"] as! [String]
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var tags: [DescribeTagsResponseBody.Tags]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [DescribeTagsResponseBody.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeTagsResponseBody.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTransferDomainsRequest : Tea.TeaModel {
    public var domainName: String?

    public var fromUserId: Int64?

    public var lang: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var targetUserId: Int64?

    public var transferType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.fromUserId != nil {
            map["FromUserId"] = self.fromUserId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        if self.transferType != nil {
            map["TransferType"] = self.transferType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("FromUserId") {
            self.fromUserId = dict["FromUserId"] as! Int64
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("TargetUserId") {
            self.targetUserId = dict["TargetUserId"] as! Int64
        }
        if dict.keys.contains("TransferType") {
            self.transferType = dict["TransferType"] as! String
        }
    }
}

public class DescribeTransferDomainsResponseBody : Tea.TeaModel {
    public class DomainTransfers : Tea.TeaModel {
        public class DomainTransfer : Tea.TeaModel {
            public var createTime: String?

            public var createTimestamp: Int64?

            public var domainName: String?

            public var fromUserId: Int64?

            public var id: Int64?

            public var targetUserId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.fromUserId != nil {
                    map["FromUserId"] = self.fromUserId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.targetUserId != nil {
                    map["TargetUserId"] = self.targetUserId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("FromUserId") {
                    self.fromUserId = dict["FromUserId"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("TargetUserId") {
                    self.targetUserId = dict["TargetUserId"] as! Int64
                }
            }
        }
        public var domainTransfer: [DescribeTransferDomainsResponseBody.DomainTransfers.DomainTransfer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainTransfer != nil {
                var tmp : [Any] = []
                for k in self.domainTransfer! {
                    tmp.append(k.toMap())
                }
                map["DomainTransfer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainTransfer") {
                var tmp : [DescribeTransferDomainsResponseBody.DomainTransfers.DomainTransfer] = []
                for v in dict["DomainTransfer"] as! [Any] {
                    var model = DescribeTransferDomainsResponseBody.DomainTransfers.DomainTransfer()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainTransfer = tmp
            }
        }
    }
    public var domainTransfers: DescribeTransferDomainsResponseBody.DomainTransfers?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainTransfers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainTransfers != nil {
            map["DomainTransfers"] = self.domainTransfers?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainTransfers") {
            var model = DescribeTransferDomainsResponseBody.DomainTransfers()
            model.fromMap(dict["DomainTransfers"] as! [String: Any])
            self.domainTransfers = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeTransferDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTransferDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTransferDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
    }
}

public class ExecuteGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExecuteGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExecuteGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMainDomainNameRequest : Tea.TeaModel {
    public var inputString: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputString != nil {
            map["InputString"] = self.inputString!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputString") {
            self.inputString = dict["InputString"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class GetMainDomainNameResponseBody : Tea.TeaModel {
    public var domainLevel: Int64?

    public var domainName: String?

    public var RR: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLevel != nil {
            map["DomainLevel"] = self.domainLevel!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainLevel") {
            self.domainLevel = dict["DomainLevel"] as! Int64
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMainDomainNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMainDomainNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMainDomainNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTxtRecordForVerifyRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetTxtRecordForVerifyResponseBody : Tea.TeaModel {
    public var domainName: String?

    public var parentDomainName: String?

    public var RR: String?

    public var requestId: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.parentDomainName != nil {
            map["ParentDomainName"] = self.parentDomainName!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("ParentDomainName") {
            self.parentDomainName = dict["ParentDomainName"] as! String
        }
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class GetTxtRecordForVerifyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTxtRecordForVerifyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTxtRecordForVerifyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCloudGtmAddressPoolsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolName: String?

    public var addressPoolType: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolName != nil {
            map["AddressPoolName"] = self.addressPoolName!
        }
        if self.addressPoolType != nil {
            map["AddressPoolType"] = self.addressPoolType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPoolName") {
            self.addressPoolName = dict["AddressPoolName"] as! String
        }
        if dict.keys.contains("AddressPoolType") {
            self.addressPoolType = dict["AddressPoolType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class ListCloudGtmAddressPoolsResponseBody : Tea.TeaModel {
    public class AddressPools : Tea.TeaModel {
        public class AddressPool : Tea.TeaModel {
            public class Addresses : Tea.TeaModel {
                public class Address : Tea.TeaModel {
                    public class HealthTasks : Tea.TeaModel {
                        public class HealthTask : Tea.TeaModel {
                            public var port: Int32?

                            public var templateId: String?

                            public var templateName: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.port != nil {
                                    map["Port"] = self.port!
                                }
                                if self.templateId != nil {
                                    map["TemplateId"] = self.templateId!
                                }
                                if self.templateName != nil {
                                    map["TemplateName"] = self.templateName!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Port") {
                                    self.port = dict["Port"] as! Int32
                                }
                                if dict.keys.contains("TemplateId") {
                                    self.templateId = dict["TemplateId"] as! String
                                }
                                if dict.keys.contains("TemplateName") {
                                    self.templateName = dict["TemplateName"] as! String
                                }
                            }
                        }
                        public var healthTask: [ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks.HealthTask]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.healthTask != nil {
                                var tmp : [Any] = []
                                for k in self.healthTask! {
                                    tmp.append(k.toMap())
                                }
                                map["HealthTask"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("HealthTask") {
                                var tmp : [ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks.HealthTask] = []
                                for v in dict["HealthTask"] as! [Any] {
                                    var model = ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks.HealthTask()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.healthTask = tmp
                            }
                        }
                    }
                    public class RequestSource : Tea.TeaModel {
                        public var requestSource: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.requestSource != nil {
                                map["RequestSource"] = self.requestSource!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("RequestSource") {
                                self.requestSource = dict["RequestSource"] as! [String]
                            }
                        }
                    }
                    public var address: String?

                    public var addressId: String?

                    public var attributeInfo: String?

                    public var availableMode: String?

                    public var availableStatus: String?

                    public var createTime: String?

                    public var createTimestamp: Int64?

                    public var enableStatus: String?

                    public var healthJudgement: String?

                    public var healthStatus: String?

                    public var healthTasks: ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks?

                    public var manualAvailableStatus: String?

                    public var name: String?

                    public var remark: String?

                    public var requestSource: ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.RequestSource?

                    public var seqNonPreemptiveSchedule: Bool?

                    public var serialNumber: Int32?

                    public var type: String?

                    public var updateTime: String?

                    public var updateTimestamp: Int64?

                    public var weightValue: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.healthTasks?.validate()
                        try self.requestSource?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.addressId != nil {
                            map["AddressId"] = self.addressId!
                        }
                        if self.attributeInfo != nil {
                            map["AttributeInfo"] = self.attributeInfo!
                        }
                        if self.availableMode != nil {
                            map["AvailableMode"] = self.availableMode!
                        }
                        if self.availableStatus != nil {
                            map["AvailableStatus"] = self.availableStatus!
                        }
                        if self.createTime != nil {
                            map["CreateTime"] = self.createTime!
                        }
                        if self.createTimestamp != nil {
                            map["CreateTimestamp"] = self.createTimestamp!
                        }
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.healthJudgement != nil {
                            map["HealthJudgement"] = self.healthJudgement!
                        }
                        if self.healthStatus != nil {
                            map["HealthStatus"] = self.healthStatus!
                        }
                        if self.healthTasks != nil {
                            map["HealthTasks"] = self.healthTasks?.toMap()
                        }
                        if self.manualAvailableStatus != nil {
                            map["ManualAvailableStatus"] = self.manualAvailableStatus!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.remark != nil {
                            map["Remark"] = self.remark!
                        }
                        if self.requestSource != nil {
                            map["RequestSource"] = self.requestSource?.toMap()
                        }
                        if self.seqNonPreemptiveSchedule != nil {
                            map["SeqNonPreemptiveSchedule"] = self.seqNonPreemptiveSchedule!
                        }
                        if self.serialNumber != nil {
                            map["SerialNumber"] = self.serialNumber!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        if self.updateTimestamp != nil {
                            map["UpdateTimestamp"] = self.updateTimestamp!
                        }
                        if self.weightValue != nil {
                            map["WeightValue"] = self.weightValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("AddressId") {
                            self.addressId = dict["AddressId"] as! String
                        }
                        if dict.keys.contains("AttributeInfo") {
                            self.attributeInfo = dict["AttributeInfo"] as! String
                        }
                        if dict.keys.contains("AvailableMode") {
                            self.availableMode = dict["AvailableMode"] as! String
                        }
                        if dict.keys.contains("AvailableStatus") {
                            self.availableStatus = dict["AvailableStatus"] as! String
                        }
                        if dict.keys.contains("CreateTime") {
                            self.createTime = dict["CreateTime"] as! String
                        }
                        if dict.keys.contains("CreateTimestamp") {
                            self.createTimestamp = dict["CreateTimestamp"] as! Int64
                        }
                        if dict.keys.contains("EnableStatus") {
                            self.enableStatus = dict["EnableStatus"] as! String
                        }
                        if dict.keys.contains("HealthJudgement") {
                            self.healthJudgement = dict["HealthJudgement"] as! String
                        }
                        if dict.keys.contains("HealthStatus") {
                            self.healthStatus = dict["HealthStatus"] as! String
                        }
                        if dict.keys.contains("HealthTasks") {
                            var model = ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks()
                            model.fromMap(dict["HealthTasks"] as! [String: Any])
                            self.healthTasks = model
                        }
                        if dict.keys.contains("ManualAvailableStatus") {
                            self.manualAvailableStatus = dict["ManualAvailableStatus"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Remark") {
                            self.remark = dict["Remark"] as! String
                        }
                        if dict.keys.contains("RequestSource") {
                            var model = ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.RequestSource()
                            model.fromMap(dict["RequestSource"] as! [String: Any])
                            self.requestSource = model
                        }
                        if dict.keys.contains("SeqNonPreemptiveSchedule") {
                            self.seqNonPreemptiveSchedule = dict["SeqNonPreemptiveSchedule"] as! Bool
                        }
                        if dict.keys.contains("SerialNumber") {
                            self.serialNumber = dict["SerialNumber"] as! Int32
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("UpdateTime") {
                            self.updateTime = dict["UpdateTime"] as! String
                        }
                        if dict.keys.contains("UpdateTimestamp") {
                            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                        }
                        if dict.keys.contains("WeightValue") {
                            self.weightValue = dict["WeightValue"] as! Int32
                        }
                    }
                }
                public var address: [ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.address != nil {
                        var tmp : [Any] = []
                        for k in self.address! {
                            tmp.append(k.toMap())
                        }
                        map["Address"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Address") {
                        var tmp : [ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address] = []
                        for v in dict["Address"] as! [Any] {
                            var model = ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.address = tmp
                    }
                }
            }
            public var addressLbStrategy: String?

            public var addressPoolId: String?

            public var addressPoolName: String?

            public var addressPoolType: String?

            public var addresses: ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses?

            public var availableStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var remark: String?

            public var sequenceLbStrategyMode: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addresses?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressLbStrategy != nil {
                    map["AddressLbStrategy"] = self.addressLbStrategy!
                }
                if self.addressPoolId != nil {
                    map["AddressPoolId"] = self.addressPoolId!
                }
                if self.addressPoolName != nil {
                    map["AddressPoolName"] = self.addressPoolName!
                }
                if self.addressPoolType != nil {
                    map["AddressPoolType"] = self.addressPoolType!
                }
                if self.addresses != nil {
                    map["Addresses"] = self.addresses?.toMap()
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddressLbStrategy") {
                    self.addressLbStrategy = dict["AddressLbStrategy"] as! String
                }
                if dict.keys.contains("AddressPoolId") {
                    self.addressPoolId = dict["AddressPoolId"] as! String
                }
                if dict.keys.contains("AddressPoolName") {
                    self.addressPoolName = dict["AddressPoolName"] as! String
                }
                if dict.keys.contains("AddressPoolType") {
                    self.addressPoolType = dict["AddressPoolType"] as! String
                }
                if dict.keys.contains("Addresses") {
                    var model = ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses()
                    model.fromMap(dict["Addresses"] as! [String: Any])
                    self.addresses = model
                }
                if dict.keys.contains("AvailableStatus") {
                    self.availableStatus = dict["AvailableStatus"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("EnableStatus") {
                    self.enableStatus = dict["EnableStatus"] as! String
                }
                if dict.keys.contains("HealthJudgement") {
                    self.healthJudgement = dict["HealthJudgement"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("SequenceLbStrategyMode") {
                    self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var addressPool: [ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressPool != nil {
                var tmp : [Any] = []
                for k in self.addressPool! {
                    tmp.append(k.toMap())
                }
                map["AddressPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddressPool") {
                var tmp : [ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool] = []
                for v in dict["AddressPool"] as! [Any] {
                    var model = ListCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.addressPool = tmp
            }
        }
    }
    public var addressPools: ListCloudGtmAddressPoolsResponseBody.AddressPools?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addressPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPools != nil {
            map["AddressPools"] = self.addressPools?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressPools") {
            var model = ListCloudGtmAddressPoolsResponseBody.AddressPools()
            model.fromMap(dict["AddressPools"] as! [String: Any])
            self.addressPools = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class ListCloudGtmAddressPoolsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmAddressPoolsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCloudGtmAddressPoolsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCloudGtmAddressesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var addressId: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var healthStatus: String?

    public var monitorTemplateId: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.monitorTemplateId != nil {
            map["MonitorTemplateId"] = self.monitorTemplateId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("AddressId") {
            self.addressId = dict["AddressId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("HealthStatus") {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("MonitorTemplateId") {
            self.monitorTemplateId = dict["MonitorTemplateId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListCloudGtmAddressesResponseBody : Tea.TeaModel {
    public class Addresses : Tea.TeaModel {
        public class Address : Tea.TeaModel {
            public class HealthTasks : Tea.TeaModel {
                public class HealthTask : Tea.TeaModel {
                    public var monitorStatus: String?

                    public var port: Int32?

                    public var templateId: String?

                    public var templateName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.monitorStatus != nil {
                            map["MonitorStatus"] = self.monitorStatus!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        if self.templateName != nil {
                            map["TemplateName"] = self.templateName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("MonitorStatus") {
                            self.monitorStatus = dict["MonitorStatus"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                        if dict.keys.contains("TemplateName") {
                            self.templateName = dict["TemplateName"] as! String
                        }
                    }
                }
                public var healthTask: [ListCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks.HealthTask]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.healthTask != nil {
                        var tmp : [Any] = []
                        for k in self.healthTask! {
                            tmp.append(k.toMap())
                        }
                        map["HealthTask"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HealthTask") {
                        var tmp : [ListCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks.HealthTask] = []
                        for v in dict["HealthTask"] as! [Any] {
                            var model = ListCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks.HealthTask()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.healthTask = tmp
                    }
                }
            }
            public var address: String?

            public var addressId: String?

            public var attributeInfo: String?

            public var availableMode: String?

            public var availableStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var healthTasks: ListCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks?

            public var manualAvailableStatus: String?

            public var name: String?

            public var remark: String?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.healthTasks?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.addressId != nil {
                    map["AddressId"] = self.addressId!
                }
                if self.attributeInfo != nil {
                    map["AttributeInfo"] = self.attributeInfo!
                }
                if self.availableMode != nil {
                    map["AvailableMode"] = self.availableMode!
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.healthTasks != nil {
                    map["HealthTasks"] = self.healthTasks?.toMap()
                }
                if self.manualAvailableStatus != nil {
                    map["ManualAvailableStatus"] = self.manualAvailableStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("AddressId") {
                    self.addressId = dict["AddressId"] as! String
                }
                if dict.keys.contains("AttributeInfo") {
                    self.attributeInfo = dict["AttributeInfo"] as! String
                }
                if dict.keys.contains("AvailableMode") {
                    self.availableMode = dict["AvailableMode"] as! String
                }
                if dict.keys.contains("AvailableStatus") {
                    self.availableStatus = dict["AvailableStatus"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("EnableStatus") {
                    self.enableStatus = dict["EnableStatus"] as! String
                }
                if dict.keys.contains("HealthJudgement") {
                    self.healthJudgement = dict["HealthJudgement"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("HealthTasks") {
                    var model = ListCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks()
                    model.fromMap(dict["HealthTasks"] as! [String: Any])
                    self.healthTasks = model
                }
                if dict.keys.contains("ManualAvailableStatus") {
                    self.manualAvailableStatus = dict["ManualAvailableStatus"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var address: [ListCloudGtmAddressesResponseBody.Addresses.Address]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                var tmp : [Any] = []
                for k in self.address! {
                    tmp.append(k.toMap())
                }
                map["Address"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") {
                var tmp : [ListCloudGtmAddressesResponseBody.Addresses.Address] = []
                for v in dict["Address"] as! [Any] {
                    var model = ListCloudGtmAddressesResponseBody.Addresses.Address()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.address = tmp
            }
        }
    }
    public var addresses: ListCloudGtmAddressesResponseBody.Addresses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addresses != nil {
            map["Addresses"] = self.addresses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addresses") {
            var model = ListCloudGtmAddressesResponseBody.Addresses()
            model.fromMap(dict["Addresses"] as! [String: Any])
            self.addresses = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class ListCloudGtmAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCloudGtmAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCloudGtmAlertLogsRequest : Tea.TeaModel {
    public var actionType: String?

    public var endTimestamp: Int64?

    public var entityType: String?

    public var keyword: String?

    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["ActionType"] = self.actionType!
        }
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.entityType != nil {
            map["EntityType"] = self.entityType!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimestamp != nil {
            map["StartTimestamp"] = self.startTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionType") {
            self.actionType = dict["ActionType"] as! String
        }
        if dict.keys.contains("EndTimestamp") {
            self.endTimestamp = dict["EndTimestamp"] as! Int64
        }
        if dict.keys.contains("EntityType") {
            self.entityType = dict["EntityType"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTimestamp") {
            self.startTimestamp = dict["StartTimestamp"] as! Int64
        }
    }
}

public class ListCloudGtmAlertLogsResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public class Log : Tea.TeaModel {
            public var actionType: String?

            public var content: String?

            public var entityType: String?

            public var timestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionType != nil {
                    map["ActionType"] = self.actionType!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.entityType != nil {
                    map["EntityType"] = self.entityType!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActionType") {
                    self.actionType = dict["ActionType"] as! String
                }
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("EntityType") {
                    self.entityType = dict["EntityType"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
            }
        }
        public var log: [ListCloudGtmAlertLogsResponseBody.Logs.Log]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.log != nil {
                var tmp : [Any] = []
                for k in self.log! {
                    tmp.append(k.toMap())
                }
                map["Log"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Log") {
                var tmp : [ListCloudGtmAlertLogsResponseBody.Logs.Log] = []
                for v in dict["Log"] as! [Any] {
                    var model = ListCloudGtmAlertLogsResponseBody.Logs.Log()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.log = tmp
            }
        }
    }
    public var logs: ListCloudGtmAlertLogsResponseBody.Logs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            map["Logs"] = self.logs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logs") {
            var model = ListCloudGtmAlertLogsResponseBody.Logs()
            model.fromMap(dict["Logs"] as! [String: Any])
            self.logs = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class ListCloudGtmAlertLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmAlertLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCloudGtmAlertLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCloudGtmAvailableAlertGroupsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class ListCloudGtmAvailableAlertGroupsResponseBody : Tea.TeaModel {
    public class AlertGroups : Tea.TeaModel {
        public class AlertGroup : Tea.TeaModel {
            public var groupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
            }
        }
        public var alertGroup: [ListCloudGtmAvailableAlertGroupsResponseBody.AlertGroups.AlertGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertGroup != nil {
                var tmp : [Any] = []
                for k in self.alertGroup! {
                    tmp.append(k.toMap())
                }
                map["AlertGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertGroup") {
                var tmp : [ListCloudGtmAvailableAlertGroupsResponseBody.AlertGroups.AlertGroup] = []
                for v in dict["AlertGroup"] as! [Any] {
                    var model = ListCloudGtmAvailableAlertGroupsResponseBody.AlertGroups.AlertGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertGroup = tmp
            }
        }
    }
    public var alertGroups: ListCloudGtmAvailableAlertGroupsResponseBody.AlertGroups?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertGroups != nil {
            map["AlertGroups"] = self.alertGroups?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertGroups") {
            var model = ListCloudGtmAvailableAlertGroupsResponseBody.AlertGroups()
            model.fromMap(dict["AlertGroups"] as! [String: Any])
            self.alertGroups = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCloudGtmAvailableAlertGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmAvailableAlertGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCloudGtmAvailableAlertGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCloudGtmInstanceConfigsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remark: String?

    public var scheduleDomainName: String?

    public var scheduleZoneName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.scheduleDomainName != nil {
            map["ScheduleDomainName"] = self.scheduleDomainName!
        }
        if self.scheduleZoneName != nil {
            map["ScheduleZoneName"] = self.scheduleZoneName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("ScheduleDomainName") {
            self.scheduleDomainName = dict["ScheduleDomainName"] as! String
        }
        if dict.keys.contains("ScheduleZoneName") {
            self.scheduleZoneName = dict["ScheduleZoneName"] as! String
        }
    }
}

public class ListCloudGtmInstanceConfigsResponseBody : Tea.TeaModel {
    public class InstanceConfigs : Tea.TeaModel {
        public class InstanceConfig : Tea.TeaModel {
            public class AddressPools : Tea.TeaModel {
                public class AddressPool : Tea.TeaModel {
                    public class RequestSource : Tea.TeaModel {
                        public var requestSource: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.requestSource != nil {
                                map["RequestSource"] = self.requestSource!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("RequestSource") {
                                self.requestSource = dict["RequestSource"] as! [String]
                            }
                        }
                    }
                    public var addressLbStrategy: String?

                    public var addressPoolId: String?

                    public var addressPoolName: String?

                    public var addressPoolType: String?

                    public var availableStatus: String?

                    public var createTime: String?

                    public var createTimestamp: Int64?

                    public var enableStatus: String?

                    public var healthJudgement: String?

                    public var healthStatus: String?

                    public var requestSource: ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool.RequestSource?

                    public var seqNonPreemptiveSchedule: Bool?

                    public var sequenceLbStrategyMode: String?

                    public var serialNumber: Int32?

                    public var updateTime: String?

                    public var updateTimestamp: Int64?

                    public var weightValue: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.requestSource?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.addressLbStrategy != nil {
                            map["AddressLbStrategy"] = self.addressLbStrategy!
                        }
                        if self.addressPoolId != nil {
                            map["AddressPoolId"] = self.addressPoolId!
                        }
                        if self.addressPoolName != nil {
                            map["AddressPoolName"] = self.addressPoolName!
                        }
                        if self.addressPoolType != nil {
                            map["AddressPoolType"] = self.addressPoolType!
                        }
                        if self.availableStatus != nil {
                            map["AvailableStatus"] = self.availableStatus!
                        }
                        if self.createTime != nil {
                            map["CreateTime"] = self.createTime!
                        }
                        if self.createTimestamp != nil {
                            map["CreateTimestamp"] = self.createTimestamp!
                        }
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.healthJudgement != nil {
                            map["HealthJudgement"] = self.healthJudgement!
                        }
                        if self.healthStatus != nil {
                            map["HealthStatus"] = self.healthStatus!
                        }
                        if self.requestSource != nil {
                            map["RequestSource"] = self.requestSource?.toMap()
                        }
                        if self.seqNonPreemptiveSchedule != nil {
                            map["SeqNonPreemptiveSchedule"] = self.seqNonPreemptiveSchedule!
                        }
                        if self.sequenceLbStrategyMode != nil {
                            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                        }
                        if self.serialNumber != nil {
                            map["SerialNumber"] = self.serialNumber!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        if self.updateTimestamp != nil {
                            map["UpdateTimestamp"] = self.updateTimestamp!
                        }
                        if self.weightValue != nil {
                            map["WeightValue"] = self.weightValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AddressLbStrategy") {
                            self.addressLbStrategy = dict["AddressLbStrategy"] as! String
                        }
                        if dict.keys.contains("AddressPoolId") {
                            self.addressPoolId = dict["AddressPoolId"] as! String
                        }
                        if dict.keys.contains("AddressPoolName") {
                            self.addressPoolName = dict["AddressPoolName"] as! String
                        }
                        if dict.keys.contains("AddressPoolType") {
                            self.addressPoolType = dict["AddressPoolType"] as! String
                        }
                        if dict.keys.contains("AvailableStatus") {
                            self.availableStatus = dict["AvailableStatus"] as! String
                        }
                        if dict.keys.contains("CreateTime") {
                            self.createTime = dict["CreateTime"] as! String
                        }
                        if dict.keys.contains("CreateTimestamp") {
                            self.createTimestamp = dict["CreateTimestamp"] as! Int64
                        }
                        if dict.keys.contains("EnableStatus") {
                            self.enableStatus = dict["EnableStatus"] as! String
                        }
                        if dict.keys.contains("HealthJudgement") {
                            self.healthJudgement = dict["HealthJudgement"] as! String
                        }
                        if dict.keys.contains("HealthStatus") {
                            self.healthStatus = dict["HealthStatus"] as! String
                        }
                        if dict.keys.contains("RequestSource") {
                            var model = ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool.RequestSource()
                            model.fromMap(dict["RequestSource"] as! [String: Any])
                            self.requestSource = model
                        }
                        if dict.keys.contains("SeqNonPreemptiveSchedule") {
                            self.seqNonPreemptiveSchedule = dict["SeqNonPreemptiveSchedule"] as! Bool
                        }
                        if dict.keys.contains("SequenceLbStrategyMode") {
                            self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
                        }
                        if dict.keys.contains("SerialNumber") {
                            self.serialNumber = dict["SerialNumber"] as! Int32
                        }
                        if dict.keys.contains("UpdateTime") {
                            self.updateTime = dict["UpdateTime"] as! String
                        }
                        if dict.keys.contains("UpdateTimestamp") {
                            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                        }
                        if dict.keys.contains("WeightValue") {
                            self.weightValue = dict["WeightValue"] as! Int32
                        }
                    }
                }
                public var addressPool: [ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.addressPool != nil {
                        var tmp : [Any] = []
                        for k in self.addressPool! {
                            tmp.append(k.toMap())
                        }
                        map["AddressPool"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AddressPool") {
                        var tmp : [ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool] = []
                        for v in dict["AddressPool"] as! [Any] {
                            var model = ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.addressPool = tmp
                    }
                }
            }
            public var addressPoolLbStrategy: String?

            public var addressPools: ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools?

            public var availableStatus: String?

            public var commodityCode: String?

            public var configId: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthStatus: String?

            public var instanceId: String?

            public var remark: String?

            public var scheduleDomainName: String?

            public var scheduleHostname: String?

            public var scheduleRrType: String?

            public var scheduleZoneMode: String?

            public var scheduleZoneName: String?

            public var sequenceLbStrategyMode: String?

            public var ttl: Int32?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addressPools?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressPoolLbStrategy != nil {
                    map["AddressPoolLbStrategy"] = self.addressPoolLbStrategy!
                }
                if self.addressPools != nil {
                    map["AddressPools"] = self.addressPools?.toMap()
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.configId != nil {
                    map["ConfigId"] = self.configId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.scheduleDomainName != nil {
                    map["ScheduleDomainName"] = self.scheduleDomainName!
                }
                if self.scheduleHostname != nil {
                    map["ScheduleHostname"] = self.scheduleHostname!
                }
                if self.scheduleRrType != nil {
                    map["ScheduleRrType"] = self.scheduleRrType!
                }
                if self.scheduleZoneMode != nil {
                    map["ScheduleZoneMode"] = self.scheduleZoneMode!
                }
                if self.scheduleZoneName != nil {
                    map["ScheduleZoneName"] = self.scheduleZoneName!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddressPoolLbStrategy") {
                    self.addressPoolLbStrategy = dict["AddressPoolLbStrategy"] as! String
                }
                if dict.keys.contains("AddressPools") {
                    var model = ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools()
                    model.fromMap(dict["AddressPools"] as! [String: Any])
                    self.addressPools = model
                }
                if dict.keys.contains("AvailableStatus") {
                    self.availableStatus = dict["AvailableStatus"] as! String
                }
                if dict.keys.contains("CommodityCode") {
                    self.commodityCode = dict["CommodityCode"] as! String
                }
                if dict.keys.contains("ConfigId") {
                    self.configId = dict["ConfigId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("EnableStatus") {
                    self.enableStatus = dict["EnableStatus"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("ScheduleDomainName") {
                    self.scheduleDomainName = dict["ScheduleDomainName"] as! String
                }
                if dict.keys.contains("ScheduleHostname") {
                    self.scheduleHostname = dict["ScheduleHostname"] as! String
                }
                if dict.keys.contains("ScheduleRrType") {
                    self.scheduleRrType = dict["ScheduleRrType"] as! String
                }
                if dict.keys.contains("ScheduleZoneMode") {
                    self.scheduleZoneMode = dict["ScheduleZoneMode"] as! String
                }
                if dict.keys.contains("ScheduleZoneName") {
                    self.scheduleZoneName = dict["ScheduleZoneName"] as! String
                }
                if dict.keys.contains("SequenceLbStrategyMode") {
                    self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
                }
                if dict.keys.contains("Ttl") {
                    self.ttl = dict["Ttl"] as! Int32
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
                if dict.keys.contains("VersionCode") {
                    self.versionCode = dict["VersionCode"] as! String
                }
            }
        }
        public var instanceConfig: [ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceConfig != nil {
                var tmp : [Any] = []
                for k in self.instanceConfig! {
                    tmp.append(k.toMap())
                }
                map["InstanceConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceConfig") {
                var tmp : [ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig] = []
                for v in dict["InstanceConfig"] as! [Any] {
                    var model = ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceConfig = tmp
            }
        }
    }
    public var instanceConfigs: ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceConfigs != nil {
            map["InstanceConfigs"] = self.instanceConfigs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceConfigs") {
            var model = ListCloudGtmInstanceConfigsResponseBody.InstanceConfigs()
            model.fromMap(dict["InstanceConfigs"] as! [String: Any])
            self.instanceConfigs = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class ListCloudGtmInstanceConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmInstanceConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCloudGtmInstanceConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCloudGtmInstancesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var instanceId: String?

    public var instanceName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListCloudGtmInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public var commodityCode: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var expireTime: String?

            public var expireTimestamp: Int64?

            public var instanceId: String?

            public var instanceName: String?

            public var monitorTaskQuota: Int32?

            public var monthlyEmailUsed: Int32?

            public var monthlySmsQuota: Int32?

            public var monthlySmsUsed: Int32?

            public var monthlyWebhookUsed: Int32?

            public var scheduleDomainName: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.expireTimestamp != nil {
                    map["ExpireTimestamp"] = self.expireTimestamp!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.monitorTaskQuota != nil {
                    map["MonitorTaskQuota"] = self.monitorTaskQuota!
                }
                if self.monthlyEmailUsed != nil {
                    map["MonthlyEmailUsed"] = self.monthlyEmailUsed!
                }
                if self.monthlySmsQuota != nil {
                    map["MonthlySmsQuota"] = self.monthlySmsQuota!
                }
                if self.monthlySmsUsed != nil {
                    map["MonthlySmsUsed"] = self.monthlySmsUsed!
                }
                if self.monthlyWebhookUsed != nil {
                    map["MonthlyWebhookUsed"] = self.monthlyWebhookUsed!
                }
                if self.scheduleDomainName != nil {
                    map["ScheduleDomainName"] = self.scheduleDomainName!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CommodityCode") {
                    self.commodityCode = dict["CommodityCode"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! String
                }
                if dict.keys.contains("ExpireTimestamp") {
                    self.expireTimestamp = dict["ExpireTimestamp"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("MonitorTaskQuota") {
                    self.monitorTaskQuota = dict["MonitorTaskQuota"] as! Int32
                }
                if dict.keys.contains("MonthlyEmailUsed") {
                    self.monthlyEmailUsed = dict["MonthlyEmailUsed"] as! Int32
                }
                if dict.keys.contains("MonthlySmsQuota") {
                    self.monthlySmsQuota = dict["MonthlySmsQuota"] as! Int32
                }
                if dict.keys.contains("MonthlySmsUsed") {
                    self.monthlySmsUsed = dict["MonthlySmsUsed"] as! Int32
                }
                if dict.keys.contains("MonthlyWebhookUsed") {
                    self.monthlyWebhookUsed = dict["MonthlyWebhookUsed"] as! Int32
                }
                if dict.keys.contains("ScheduleDomainName") {
                    self.scheduleDomainName = dict["ScheduleDomainName"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
                if dict.keys.contains("VersionCode") {
                    self.versionCode = dict["VersionCode"] as! String
                }
            }
        }
        public var instance: [ListCloudGtmInstancesResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instance") {
                var tmp : [ListCloudGtmInstancesResponseBody.Instances.Instance] = []
                for v in dict["Instance"] as! [Any] {
                    var model = ListCloudGtmInstancesResponseBody.Instances.Instance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instance = tmp
            }
        }
    }
    public var instances: ListCloudGtmInstancesResponseBody.Instances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var model = ListCloudGtmInstancesResponseBody.Instances()
            model.fromMap(dict["Instances"] as! [String: Any])
            self.instances = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class ListCloudGtmInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCloudGtmInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCloudGtmMonitorNodesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
    }
}

public class ListCloudGtmMonitorNodesResponseBody : Tea.TeaModel {
    public class Ipv4IspCityNodes : Tea.TeaModel {
        public class Ipv4IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! [String]
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var countryCode: String?

            public var countryName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public var nodeId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.countryCode != nil {
                    map["CountryCode"] = self.countryCode!
                }
                if self.countryName != nil {
                    map["CountryName"] = self.countryName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("CountryCode") {
                    self.countryCode = dict["CountryCode"] as! String
                }
                if dict.keys.contains("CountryName") {
                    self.countryName = dict["CountryName"] as! String
                }
                if dict.keys.contains("DefaultSelected") {
                    self.defaultSelected = dict["DefaultSelected"] as! Bool
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") {
                    self.groupType = dict["GroupType"] as! String
                }
                if dict.keys.contains("Ips") {
                    var model = ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode.Ips()
                    model.fromMap(dict["Ips"] as! [String: Any])
                    self.ips = model
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! String
                }
            }
        }
        public var ipv4IspCityNode: [ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.ipv4IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["Ipv4IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv4IspCityNode") {
                var tmp : [ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode] = []
                for v in dict["Ipv4IspCityNode"] as! [Any] {
                    var model = ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes.Ipv4IspCityNode()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv4IspCityNode = tmp
            }
        }
    }
    public class Ipv6IspCityNodes : Tea.TeaModel {
        public class Ipv6IspCityNode : Tea.TeaModel {
            public class Ips : Tea.TeaModel {
                public var ip: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! [String]
                    }
                }
            }
            public var cityCode: String?

            public var cityName: String?

            public var countryCode: String?

            public var countryName: String?

            public var defaultSelected: Bool?

            public var groupName: String?

            public var groupType: String?

            public var ips: ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode.Ips?

            public var ispCode: String?

            public var ispName: String?

            public var nodeId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ips?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cityCode != nil {
                    map["CityCode"] = self.cityCode!
                }
                if self.cityName != nil {
                    map["CityName"] = self.cityName!
                }
                if self.countryCode != nil {
                    map["CountryCode"] = self.countryCode!
                }
                if self.countryName != nil {
                    map["CountryName"] = self.countryName!
                }
                if self.defaultSelected != nil {
                    map["DefaultSelected"] = self.defaultSelected!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips?.toMap()
                }
                if self.ispCode != nil {
                    map["IspCode"] = self.ispCode!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CityCode") {
                    self.cityCode = dict["CityCode"] as! String
                }
                if dict.keys.contains("CityName") {
                    self.cityName = dict["CityName"] as! String
                }
                if dict.keys.contains("CountryCode") {
                    self.countryCode = dict["CountryCode"] as! String
                }
                if dict.keys.contains("CountryName") {
                    self.countryName = dict["CountryName"] as! String
                }
                if dict.keys.contains("DefaultSelected") {
                    self.defaultSelected = dict["DefaultSelected"] as! Bool
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("GroupType") {
                    self.groupType = dict["GroupType"] as! String
                }
                if dict.keys.contains("Ips") {
                    var model = ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode.Ips()
                    model.fromMap(dict["Ips"] as! [String: Any])
                    self.ips = model
                }
                if dict.keys.contains("IspCode") {
                    self.ispCode = dict["IspCode"] as! String
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! String
                }
            }
        }
        public var ipv6IspCityNode: [ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6IspCityNode != nil {
                var tmp : [Any] = []
                for k in self.ipv6IspCityNode! {
                    tmp.append(k.toMap())
                }
                map["Ipv6IspCityNode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6IspCityNode") {
                var tmp : [ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode] = []
                for v in dict["Ipv6IspCityNode"] as! [Any] {
                    var model = ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes.Ipv6IspCityNode()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6IspCityNode = tmp
            }
        }
    }
    public var ipv4IspCityNodes: ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes?

    public var ipv6IspCityNodes: ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv4IspCityNodes?.validate()
        try self.ipv6IspCityNodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv4IspCityNodes != nil {
            map["Ipv4IspCityNodes"] = self.ipv4IspCityNodes?.toMap()
        }
        if self.ipv6IspCityNodes != nil {
            map["Ipv6IspCityNodes"] = self.ipv6IspCityNodes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv4IspCityNodes") {
            var model = ListCloudGtmMonitorNodesResponseBody.Ipv4IspCityNodes()
            model.fromMap(dict["Ipv4IspCityNodes"] as! [String: Any])
            self.ipv4IspCityNodes = model
        }
        if dict.keys.contains("Ipv6IspCityNodes") {
            var model = ListCloudGtmMonitorNodesResponseBody.Ipv6IspCityNodes()
            model.fromMap(dict["Ipv6IspCityNodes"] as! [String: Any])
            self.ipv6IspCityNodes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCloudGtmMonitorNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmMonitorNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCloudGtmMonitorNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCloudGtmMonitorTemplatesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ipVersion: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
    }
}

public class ListCloudGtmMonitorTemplatesResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public class IspCityNodes : Tea.TeaModel {
                public class IspCityNode : Tea.TeaModel {
                    public var cityCode: String?

                    public var cityName: String?

                    public var countryCode: String?

                    public var countryName: String?

                    public var groupName: String?

                    public var groupType: String?

                    public var ispCode: String?

                    public var ispName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cityCode != nil {
                            map["CityCode"] = self.cityCode!
                        }
                        if self.cityName != nil {
                            map["CityName"] = self.cityName!
                        }
                        if self.countryCode != nil {
                            map["CountryCode"] = self.countryCode!
                        }
                        if self.countryName != nil {
                            map["CountryName"] = self.countryName!
                        }
                        if self.groupName != nil {
                            map["GroupName"] = self.groupName!
                        }
                        if self.groupType != nil {
                            map["GroupType"] = self.groupType!
                        }
                        if self.ispCode != nil {
                            map["IspCode"] = self.ispCode!
                        }
                        if self.ispName != nil {
                            map["IspName"] = self.ispName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CityCode") {
                            self.cityCode = dict["CityCode"] as! String
                        }
                        if dict.keys.contains("CityName") {
                            self.cityName = dict["CityName"] as! String
                        }
                        if dict.keys.contains("CountryCode") {
                            self.countryCode = dict["CountryCode"] as! String
                        }
                        if dict.keys.contains("CountryName") {
                            self.countryName = dict["CountryName"] as! String
                        }
                        if dict.keys.contains("GroupName") {
                            self.groupName = dict["GroupName"] as! String
                        }
                        if dict.keys.contains("GroupType") {
                            self.groupType = dict["GroupType"] as! String
                        }
                        if dict.keys.contains("IspCode") {
                            self.ispCode = dict["IspCode"] as! String
                        }
                        if dict.keys.contains("IspName") {
                            self.ispName = dict["IspName"] as! String
                        }
                    }
                }
                public var ispCityNode: [ListCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes.IspCityNode]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ispCityNode != nil {
                        var tmp : [Any] = []
                        for k in self.ispCityNode! {
                            tmp.append(k.toMap())
                        }
                        map["IspCityNode"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IspCityNode") {
                        var tmp : [ListCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes.IspCityNode] = []
                        for v in dict["IspCityNode"] as! [Any] {
                            var model = ListCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes.IspCityNode()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ispCityNode = tmp
                    }
                }
            }
            public var createTime: String?

            public var createTimestamp: Int64?

            public var evaluationCount: Int32?

            public var extendInfo: String?

            public var failureRate: Int32?

            public var interval: Int32?

            public var ipVersion: String?

            public var ispCityNodes: ListCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes?

            public var name: String?

            public var protocol_: String?

            public var remark: String?

            public var templateId: String?

            public var timeout: Int32?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ispCityNodes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.evaluationCount != nil {
                    map["EvaluationCount"] = self.evaluationCount!
                }
                if self.extendInfo != nil {
                    map["ExtendInfo"] = self.extendInfo!
                }
                if self.failureRate != nil {
                    map["FailureRate"] = self.failureRate!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.ispCityNodes != nil {
                    map["IspCityNodes"] = self.ispCityNodes?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("EvaluationCount") {
                    self.evaluationCount = dict["EvaluationCount"] as! Int32
                }
                if dict.keys.contains("ExtendInfo") {
                    self.extendInfo = dict["ExtendInfo"] as! String
                }
                if dict.keys.contains("FailureRate") {
                    self.failureRate = dict["FailureRate"] as! Int32
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("IpVersion") {
                    self.ipVersion = dict["IpVersion"] as! String
                }
                if dict.keys.contains("IspCityNodes") {
                    var model = ListCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes()
                    model.fromMap(dict["IspCityNodes"] as! [String: Any])
                    self.ispCityNodes = model
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! String
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int32
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var template: [ListCloudGtmMonitorTemplatesResponseBody.Templates.Template]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                var tmp : [Any] = []
                for k in self.template! {
                    tmp.append(k.toMap())
                }
                map["Template"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Template") {
                var tmp : [ListCloudGtmMonitorTemplatesResponseBody.Templates.Template] = []
                for v in dict["Template"] as! [Any] {
                    var model = ListCloudGtmMonitorTemplatesResponseBody.Templates.Template()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.template = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var templates: ListCloudGtmMonitorTemplatesResponseBody.Templates?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templates?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templates != nil {
            map["Templates"] = self.templates?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Templates") {
            var model = ListCloudGtmMonitorTemplatesResponseBody.Templates()
            model.fromMap(dict["Templates"] as! [String: Any])
            self.templates = model
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class ListCloudGtmMonitorTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudGtmMonitorTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCloudGtmMonitorTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var lang: String?

    public var nextToken: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListTagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("TagKey") {
                self.tagKey = dict["TagKey"] as! String
            }
            if dict.keys.contains("TagValue") {
                self.tagValue = dict["TagValue"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: [ListTagResourcesResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var tmp : [ListTagResourcesResponseBody.TagResources] = []
            for v in dict["TagResources"] as! [Any] {
                var model = ListTagResourcesResponseBody.TagResources()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tagResources = tmp
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyHichinaDomainDNSRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class ModifyHichinaDomainDNSResponseBody : Tea.TeaModel {
    public class NewDnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServer") {
                self.dnsServer = dict["DnsServer"] as! [String]
            }
        }
    }
    public class OriginalDnsServers : Tea.TeaModel {
        public var dnsServer: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsServer != nil {
                map["DnsServer"] = self.dnsServer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DnsServer") {
                self.dnsServer = dict["DnsServer"] as! [String]
            }
        }
    }
    public var newDnsServers: ModifyHichinaDomainDNSResponseBody.NewDnsServers?

    public var originalDnsServers: ModifyHichinaDomainDNSResponseBody.OriginalDnsServers?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.newDnsServers?.validate()
        try self.originalDnsServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newDnsServers != nil {
            map["NewDnsServers"] = self.newDnsServers?.toMap()
        }
        if self.originalDnsServers != nil {
            map["OriginalDnsServers"] = self.originalDnsServers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NewDnsServers") {
            var model = ModifyHichinaDomainDNSResponseBody.NewDnsServers()
            model.fromMap(dict["NewDnsServers"] as! [String: Any])
            self.newDnsServers = model
        }
        if dict.keys.contains("OriginalDnsServers") {
            var model = ModifyHichinaDomainDNSResponseBody.OriginalDnsServers()
            model.fromMap(dict["OriginalDnsServers"] as! [String: Any])
            self.originalDnsServers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyHichinaDomainDNSResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHichinaDomainDNSResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyHichinaDomainDNSResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveDomainResourceGroupRequest : Tea.TeaModel {
    public var lang: String?

    public var newResourceGroupId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NewResourceGroupId") {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class MoveDomainResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MoveDomainResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveDomainResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveDomainResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveGtmResourceGroupRequest : Tea.TeaModel {
    public var lang: String?

    public var newResourceGroupId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NewResourceGroupId") {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class MoveGtmResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MoveGtmResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveGtmResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveGtmResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateBatchDomainRequest : Tea.TeaModel {
    public class DomainRecordInfo : Tea.TeaModel {
        public var domain: String?

        public var line: String?

        public var newRr: String?

        public var newType: String?

        public var newValue: String?

        public var priority: Int32?

        public var rr: String?

        public var ttl: Int32?

        public var type: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.line != nil {
                map["Line"] = self.line!
            }
            if self.newRr != nil {
                map["NewRr"] = self.newRr!
            }
            if self.newType != nil {
                map["NewType"] = self.newType!
            }
            if self.newValue != nil {
                map["NewValue"] = self.newValue!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.rr != nil {
                map["Rr"] = self.rr!
            }
            if self.ttl != nil {
                map["Ttl"] = self.ttl!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Line") {
                self.line = dict["Line"] as! String
            }
            if dict.keys.contains("NewRr") {
                self.newRr = dict["NewRr"] as! String
            }
            if dict.keys.contains("NewType") {
                self.newType = dict["NewType"] as! String
            }
            if dict.keys.contains("NewValue") {
                self.newValue = dict["NewValue"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("Rr") {
                self.rr = dict["Rr"] as! String
            }
            if dict.keys.contains("Ttl") {
                self.ttl = dict["Ttl"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var domainRecordInfo: [OperateBatchDomainRequest.DomainRecordInfo]?

    public var lang: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainRecordInfo != nil {
            var tmp : [Any] = []
            for k in self.domainRecordInfo! {
                tmp.append(k.toMap())
            }
            map["DomainRecordInfo"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainRecordInfo") {
            var tmp : [OperateBatchDomainRequest.DomainRecordInfo] = []
            for v in dict["DomainRecordInfo"] as! [Any] {
                var model = OperateBatchDomainRequest.DomainRecordInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.domainRecordInfo = tmp
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class OperateBatchDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class OperateBatchDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateBatchDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OperateBatchDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PausePdnsServiceRequest : Tea.TeaModel {
    public var lang: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ServiceType") {
            self.serviceType = dict["ServiceType"] as! String
        }
    }
}

public class PausePdnsServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PausePdnsServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PausePdnsServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PausePdnsServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PreviewGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
    }
}

public class PreviewGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public class Previews : Tea.TeaModel {
        public class Preview : Tea.TeaModel {
            public class SwitchInfos : Tea.TeaModel {
                public class SwitchInfo : Tea.TeaModel {
                    public var content: String?

                    public var strategyName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.strategyName != nil {
                            map["StrategyName"] = self.strategyName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("StrategyName") {
                            self.strategyName = dict["StrategyName"] as! String
                        }
                    }
                }
                public var switchInfo: [PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos.SwitchInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.switchInfo != nil {
                        var tmp : [Any] = []
                        for k in self.switchInfo! {
                            tmp.append(k.toMap())
                        }
                        map["SwitchInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SwitchInfo") {
                        var tmp : [PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos.SwitchInfo] = []
                        for v in dict["SwitchInfo"] as! [Any] {
                            var model = PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos.SwitchInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.switchInfo = tmp
                    }
                }
            }
            public var instanceId: String?

            public var name: String?

            public var switchInfos: PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos?

            public var userDomainName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.switchInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.switchInfos != nil {
                    map["SwitchInfos"] = self.switchInfos?.toMap()
                }
                if self.userDomainName != nil {
                    map["UserDomainName"] = self.userDomainName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SwitchInfos") {
                    var model = PreviewGtmRecoveryPlanResponseBody.Previews.Preview.SwitchInfos()
                    model.fromMap(dict["SwitchInfos"] as! [String: Any])
                    self.switchInfos = model
                }
                if dict.keys.contains("UserDomainName") {
                    self.userDomainName = dict["UserDomainName"] as! String
                }
            }
        }
        public var preview: [PreviewGtmRecoveryPlanResponseBody.Previews.Preview]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preview != nil {
                var tmp : [Any] = []
                for k in self.preview! {
                    tmp.append(k.toMap())
                }
                map["Preview"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Preview") {
                var tmp : [PreviewGtmRecoveryPlanResponseBody.Previews.Preview] = []
                for v in dict["Preview"] as! [Any] {
                    var model = PreviewGtmRecoveryPlanResponseBody.Previews.Preview()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.preview = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var previews: PreviewGtmRecoveryPlanResponseBody.Previews?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.previews?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.previews != nil {
            map["Previews"] = self.previews?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Previews") {
            var model = PreviewGtmRecoveryPlanResponseBody.Previews()
            model.fromMap(dict["Previews"] as! [String: Any])
            self.previews = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class PreviewGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PreviewGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PreviewGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePdnsAppKeyRequest : Tea.TeaModel {
    public var appKeyId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKeyId != nil {
            map["AppKeyId"] = self.appKeyId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppKeyId") {
            self.appKeyId = dict["AppKeyId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class RemovePdnsAppKeyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePdnsAppKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePdnsAppKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemovePdnsAppKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePdnsUdpIpSegmentRequest : Tea.TeaModel {
    public var ip: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class RemovePdnsUdpIpSegmentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePdnsUdpIpSegmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePdnsUdpIpSegmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemovePdnsUdpIpSegmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReplaceCloudGtmAddressPoolAddressRequest : Tea.TeaModel {
    public class Addresses : Tea.TeaModel {
        public var addressId: String?

        public var requestSource: [String]?

        public var serialNumber: Int32?

        public var weightValue: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressId != nil {
                map["AddressId"] = self.addressId!
            }
            if self.requestSource != nil {
                map["RequestSource"] = self.requestSource!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.weightValue != nil {
                map["WeightValue"] = self.weightValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddressId") {
                self.addressId = dict["AddressId"] as! String
            }
            if dict.keys.contains("RequestSource") {
                self.requestSource = dict["RequestSource"] as! [String]
            }
            if dict.keys.contains("SerialNumber") {
                self.serialNumber = dict["SerialNumber"] as! Int32
            }
            if dict.keys.contains("WeightValue") {
                self.weightValue = dict["WeightValue"] as! Int32
            }
        }
    }
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var addresses: [ReplaceCloudGtmAddressPoolAddressRequest.Addresses]?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.addresses != nil {
            var tmp : [Any] = []
            for k in self.addresses! {
                tmp.append(k.toMap())
            }
            map["Addresses"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("Addresses") {
            var tmp : [ReplaceCloudGtmAddressPoolAddressRequest.Addresses] = []
            for v in dict["Addresses"] as! [Any] {
                var model = ReplaceCloudGtmAddressPoolAddressRequest.Addresses()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.addresses = tmp
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class ReplaceCloudGtmAddressPoolAddressShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var addressesShrink: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.addressesShrink != nil {
            map["Addresses"] = self.addressesShrink!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("Addresses") {
            self.addressesShrink = dict["Addresses"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class ReplaceCloudGtmAddressPoolAddressResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ReplaceCloudGtmAddressPoolAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReplaceCloudGtmAddressPoolAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReplaceCloudGtmAddressPoolAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReplaceCloudGtmInstanceConfigAddressPoolRequest : Tea.TeaModel {
    public class AddressPools : Tea.TeaModel {
        public var addressPoolId: String?

        public var requestSource: [String]?

        public var serialNumber: Int32?

        public var weightValue: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressPoolId != nil {
                map["AddressPoolId"] = self.addressPoolId!
            }
            if self.requestSource != nil {
                map["RequestSource"] = self.requestSource!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.weightValue != nil {
                map["WeightValue"] = self.weightValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddressPoolId") {
                self.addressPoolId = dict["AddressPoolId"] as! String
            }
            if dict.keys.contains("RequestSource") {
                self.requestSource = dict["RequestSource"] as! [String]
            }
            if dict.keys.contains("SerialNumber") {
                self.serialNumber = dict["SerialNumber"] as! Int32
            }
            if dict.keys.contains("WeightValue") {
                self.weightValue = dict["WeightValue"] as! Int32
            }
        }
    }
    public var acceptLanguage: String?

    public var addressPools: [ReplaceCloudGtmInstanceConfigAddressPoolRequest.AddressPools]?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPools != nil {
            var tmp : [Any] = []
            for k in self.addressPools! {
                tmp.append(k.toMap())
            }
            map["AddressPools"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPools") {
            var tmp : [ReplaceCloudGtmInstanceConfigAddressPoolRequest.AddressPools] = []
            for v in dict["AddressPools"] as! [Any] {
                var model = ReplaceCloudGtmInstanceConfigAddressPoolRequest.AddressPools()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.addressPools = tmp
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ReplaceCloudGtmInstanceConfigAddressPoolShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolsShrink: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolsShrink != nil {
            map["AddressPools"] = self.addressPoolsShrink!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPools") {
            self.addressPoolsShrink = dict["AddressPools"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ReplaceCloudGtmInstanceConfigAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ReplaceCloudGtmInstanceConfigAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReplaceCloudGtmInstanceConfigAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReplaceCloudGtmInstanceConfigAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumePdnsServiceRequest : Tea.TeaModel {
    public var lang: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ServiceType") {
            self.serviceType = dict["ServiceType"] as! String
        }
    }
}

public class ResumePdnsServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResumePdnsServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumePdnsServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumePdnsServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetrieveDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class RetrieveDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RetrieveDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetrieveDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RetrieveDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RollbackGtmRecoveryPlanRequest : Tea.TeaModel {
    public var lang: String?

    public var recoveryPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
    }
}

public class RollbackGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RollbackGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RollbackGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchCloudGtmAddressPoolsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolName: String?

    public var addressPoolType: String?

    public var availableStatus: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var healthStatus: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolName != nil {
            map["AddressPoolName"] = self.addressPoolName!
        }
        if self.addressPoolType != nil {
            map["AddressPoolType"] = self.addressPoolType!
        }
        if self.availableStatus != nil {
            map["AvailableStatus"] = self.availableStatus!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPoolName") {
            self.addressPoolName = dict["AddressPoolName"] as! String
        }
        if dict.keys.contains("AddressPoolType") {
            self.addressPoolType = dict["AddressPoolType"] as! String
        }
        if dict.keys.contains("AvailableStatus") {
            self.availableStatus = dict["AvailableStatus"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("HealthStatus") {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class SearchCloudGtmAddressPoolsResponseBody : Tea.TeaModel {
    public class AddressPools : Tea.TeaModel {
        public class AddressPool : Tea.TeaModel {
            public class Addresses : Tea.TeaModel {
                public class Address : Tea.TeaModel {
                    public class HealthTasks : Tea.TeaModel {
                        public class HealthTask : Tea.TeaModel {
                            public var port: Int32?

                            public var templateId: String?

                            public var templateName: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.port != nil {
                                    map["Port"] = self.port!
                                }
                                if self.templateId != nil {
                                    map["TemplateId"] = self.templateId!
                                }
                                if self.templateName != nil {
                                    map["TemplateName"] = self.templateName!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Port") {
                                    self.port = dict["Port"] as! Int32
                                }
                                if dict.keys.contains("TemplateId") {
                                    self.templateId = dict["TemplateId"] as! String
                                }
                                if dict.keys.contains("TemplateName") {
                                    self.templateName = dict["TemplateName"] as! String
                                }
                            }
                        }
                        public var healthTask: [SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks.HealthTask]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.healthTask != nil {
                                var tmp : [Any] = []
                                for k in self.healthTask! {
                                    tmp.append(k.toMap())
                                }
                                map["HealthTask"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("HealthTask") {
                                var tmp : [SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks.HealthTask] = []
                                for v in dict["HealthTask"] as! [Any] {
                                    var model = SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks.HealthTask()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.healthTask = tmp
                            }
                        }
                    }
                    public var address: String?

                    public var addressId: String?

                    public var attributeInfo: String?

                    public var availableMode: String?

                    public var availableStatus: String?

                    public var createTime: String?

                    public var createTimestamp: Int64?

                    public var enableStatus: String?

                    public var healthJudgement: String?

                    public var healthStatus: String?

                    public var healthTasks: SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks?

                    public var manualAvailableStatus: String?

                    public var name: String?

                    public var remark: String?

                    public var requestSource: String?

                    public var serialNumber: Int32?

                    public var type: String?

                    public var updateTime: String?

                    public var updateTimestamp: Int64?

                    public var weightValue: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.healthTasks?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.addressId != nil {
                            map["AddressId"] = self.addressId!
                        }
                        if self.attributeInfo != nil {
                            map["AttributeInfo"] = self.attributeInfo!
                        }
                        if self.availableMode != nil {
                            map["AvailableMode"] = self.availableMode!
                        }
                        if self.availableStatus != nil {
                            map["AvailableStatus"] = self.availableStatus!
                        }
                        if self.createTime != nil {
                            map["CreateTime"] = self.createTime!
                        }
                        if self.createTimestamp != nil {
                            map["CreateTimestamp"] = self.createTimestamp!
                        }
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.healthJudgement != nil {
                            map["HealthJudgement"] = self.healthJudgement!
                        }
                        if self.healthStatus != nil {
                            map["HealthStatus"] = self.healthStatus!
                        }
                        if self.healthTasks != nil {
                            map["HealthTasks"] = self.healthTasks?.toMap()
                        }
                        if self.manualAvailableStatus != nil {
                            map["ManualAvailableStatus"] = self.manualAvailableStatus!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.remark != nil {
                            map["Remark"] = self.remark!
                        }
                        if self.requestSource != nil {
                            map["RequestSource"] = self.requestSource!
                        }
                        if self.serialNumber != nil {
                            map["SerialNumber"] = self.serialNumber!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        if self.updateTimestamp != nil {
                            map["UpdateTimestamp"] = self.updateTimestamp!
                        }
                        if self.weightValue != nil {
                            map["WeightValue"] = self.weightValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("AddressId") {
                            self.addressId = dict["AddressId"] as! String
                        }
                        if dict.keys.contains("AttributeInfo") {
                            self.attributeInfo = dict["AttributeInfo"] as! String
                        }
                        if dict.keys.contains("AvailableMode") {
                            self.availableMode = dict["AvailableMode"] as! String
                        }
                        if dict.keys.contains("AvailableStatus") {
                            self.availableStatus = dict["AvailableStatus"] as! String
                        }
                        if dict.keys.contains("CreateTime") {
                            self.createTime = dict["CreateTime"] as! String
                        }
                        if dict.keys.contains("CreateTimestamp") {
                            self.createTimestamp = dict["CreateTimestamp"] as! Int64
                        }
                        if dict.keys.contains("EnableStatus") {
                            self.enableStatus = dict["EnableStatus"] as! String
                        }
                        if dict.keys.contains("HealthJudgement") {
                            self.healthJudgement = dict["HealthJudgement"] as! String
                        }
                        if dict.keys.contains("HealthStatus") {
                            self.healthStatus = dict["HealthStatus"] as! String
                        }
                        if dict.keys.contains("HealthTasks") {
                            var model = SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address.HealthTasks()
                            model.fromMap(dict["HealthTasks"] as! [String: Any])
                            self.healthTasks = model
                        }
                        if dict.keys.contains("ManualAvailableStatus") {
                            self.manualAvailableStatus = dict["ManualAvailableStatus"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Remark") {
                            self.remark = dict["Remark"] as! String
                        }
                        if dict.keys.contains("RequestSource") {
                            self.requestSource = dict["RequestSource"] as! String
                        }
                        if dict.keys.contains("SerialNumber") {
                            self.serialNumber = dict["SerialNumber"] as! Int32
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("UpdateTime") {
                            self.updateTime = dict["UpdateTime"] as! String
                        }
                        if dict.keys.contains("UpdateTimestamp") {
                            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                        }
                        if dict.keys.contains("WeightValue") {
                            self.weightValue = dict["WeightValue"] as! Int32
                        }
                    }
                }
                public var address: [SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.address != nil {
                        var tmp : [Any] = []
                        for k in self.address! {
                            tmp.append(k.toMap())
                        }
                        map["Address"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Address") {
                        var tmp : [SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address] = []
                        for v in dict["Address"] as! [Any] {
                            var model = SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses.Address()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.address = tmp
                    }
                }
            }
            public var addressLbStrategy: String?

            public var addressPoolId: String?

            public var addressPoolName: String?

            public var addressPoolType: String?

            public var addresses: SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses?

            public var availableStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var remark: String?

            public var sequenceLbStrategyMode: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addresses?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressLbStrategy != nil {
                    map["AddressLbStrategy"] = self.addressLbStrategy!
                }
                if self.addressPoolId != nil {
                    map["AddressPoolId"] = self.addressPoolId!
                }
                if self.addressPoolName != nil {
                    map["AddressPoolName"] = self.addressPoolName!
                }
                if self.addressPoolType != nil {
                    map["AddressPoolType"] = self.addressPoolType!
                }
                if self.addresses != nil {
                    map["Addresses"] = self.addresses?.toMap()
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddressLbStrategy") {
                    self.addressLbStrategy = dict["AddressLbStrategy"] as! String
                }
                if dict.keys.contains("AddressPoolId") {
                    self.addressPoolId = dict["AddressPoolId"] as! String
                }
                if dict.keys.contains("AddressPoolName") {
                    self.addressPoolName = dict["AddressPoolName"] as! String
                }
                if dict.keys.contains("AddressPoolType") {
                    self.addressPoolType = dict["AddressPoolType"] as! String
                }
                if dict.keys.contains("Addresses") {
                    var model = SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool.Addresses()
                    model.fromMap(dict["Addresses"] as! [String: Any])
                    self.addresses = model
                }
                if dict.keys.contains("AvailableStatus") {
                    self.availableStatus = dict["AvailableStatus"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("EnableStatus") {
                    self.enableStatus = dict["EnableStatus"] as! String
                }
                if dict.keys.contains("HealthJudgement") {
                    self.healthJudgement = dict["HealthJudgement"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("SequenceLbStrategyMode") {
                    self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var addressPool: [SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addressPool != nil {
                var tmp : [Any] = []
                for k in self.addressPool! {
                    tmp.append(k.toMap())
                }
                map["AddressPool"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddressPool") {
                var tmp : [SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool] = []
                for v in dict["AddressPool"] as! [Any] {
                    var model = SearchCloudGtmAddressPoolsResponseBody.AddressPools.AddressPool()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.addressPool = tmp
            }
        }
    }
    public var addressPools: SearchCloudGtmAddressPoolsResponseBody.AddressPools?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addressPools?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPools != nil {
            map["AddressPools"] = self.addressPools?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressPools") {
            var model = SearchCloudGtmAddressPoolsResponseBody.AddressPools()
            model.fromMap(dict["AddressPools"] as! [String: Any])
            self.addressPools = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class SearchCloudGtmAddressPoolsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchCloudGtmAddressPoolsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchCloudGtmAddressPoolsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchCloudGtmAddressesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var addressId: String?

    public var availableStatus: String?

    public var enableStatus: String?

    public var healthStatus: String?

    public var monitorTemplateName: String?

    public var nameSearchCondition: String?

    public var names: [String]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remarkSearchCondition: String?

    public var remarks: [String]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.availableStatus != nil {
            map["AvailableStatus"] = self.availableStatus!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.monitorTemplateName != nil {
            map["MonitorTemplateName"] = self.monitorTemplateName!
        }
        if self.nameSearchCondition != nil {
            map["NameSearchCondition"] = self.nameSearchCondition!
        }
        if self.names != nil {
            map["Names"] = self.names!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remarkSearchCondition != nil {
            map["RemarkSearchCondition"] = self.remarkSearchCondition!
        }
        if self.remarks != nil {
            map["Remarks"] = self.remarks!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("AddressId") {
            self.addressId = dict["AddressId"] as! String
        }
        if dict.keys.contains("AvailableStatus") {
            self.availableStatus = dict["AvailableStatus"] as! String
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("HealthStatus") {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("MonitorTemplateName") {
            self.monitorTemplateName = dict["MonitorTemplateName"] as! String
        }
        if dict.keys.contains("NameSearchCondition") {
            self.nameSearchCondition = dict["NameSearchCondition"] as! String
        }
        if dict.keys.contains("Names") {
            self.names = dict["Names"] as! [String]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RemarkSearchCondition") {
            self.remarkSearchCondition = dict["RemarkSearchCondition"] as! String
        }
        if dict.keys.contains("Remarks") {
            self.remarks = dict["Remarks"] as! [String]
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class SearchCloudGtmAddressesResponseBody : Tea.TeaModel {
    public class Addresses : Tea.TeaModel {
        public class Address : Tea.TeaModel {
            public class HealthTasks : Tea.TeaModel {
                public class HealthTask : Tea.TeaModel {
                    public var monitorStatus: String?

                    public var port: Int32?

                    public var templateId: String?

                    public var templateName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.monitorStatus != nil {
                            map["MonitorStatus"] = self.monitorStatus!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        if self.templateName != nil {
                            map["TemplateName"] = self.templateName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("MonitorStatus") {
                            self.monitorStatus = dict["MonitorStatus"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                        if dict.keys.contains("TemplateName") {
                            self.templateName = dict["TemplateName"] as! String
                        }
                    }
                }
                public var healthTask: [SearchCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks.HealthTask]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.healthTask != nil {
                        var tmp : [Any] = []
                        for k in self.healthTask! {
                            tmp.append(k.toMap())
                        }
                        map["HealthTask"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HealthTask") {
                        var tmp : [SearchCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks.HealthTask] = []
                        for v in dict["HealthTask"] as! [Any] {
                            var model = SearchCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks.HealthTask()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.healthTask = tmp
                    }
                }
            }
            public var address: String?

            public var addressId: String?

            public var attributeInfo: String?

            public var availableMode: String?

            public var availableStatus: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthJudgement: String?

            public var healthStatus: String?

            public var healthTasks: SearchCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks?

            public var manualAvailableStatus: String?

            public var name: String?

            public var remark: String?

            public var type: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.healthTasks?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.addressId != nil {
                    map["AddressId"] = self.addressId!
                }
                if self.attributeInfo != nil {
                    map["AttributeInfo"] = self.attributeInfo!
                }
                if self.availableMode != nil {
                    map["AvailableMode"] = self.availableMode!
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthJudgement != nil {
                    map["HealthJudgement"] = self.healthJudgement!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.healthTasks != nil {
                    map["HealthTasks"] = self.healthTasks?.toMap()
                }
                if self.manualAvailableStatus != nil {
                    map["ManualAvailableStatus"] = self.manualAvailableStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("AddressId") {
                    self.addressId = dict["AddressId"] as! String
                }
                if dict.keys.contains("AttributeInfo") {
                    self.attributeInfo = dict["AttributeInfo"] as! String
                }
                if dict.keys.contains("AvailableMode") {
                    self.availableMode = dict["AvailableMode"] as! String
                }
                if dict.keys.contains("AvailableStatus") {
                    self.availableStatus = dict["AvailableStatus"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("EnableStatus") {
                    self.enableStatus = dict["EnableStatus"] as! String
                }
                if dict.keys.contains("HealthJudgement") {
                    self.healthJudgement = dict["HealthJudgement"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("HealthTasks") {
                    var model = SearchCloudGtmAddressesResponseBody.Addresses.Address.HealthTasks()
                    model.fromMap(dict["HealthTasks"] as! [String: Any])
                    self.healthTasks = model
                }
                if dict.keys.contains("ManualAvailableStatus") {
                    self.manualAvailableStatus = dict["ManualAvailableStatus"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var address: [SearchCloudGtmAddressesResponseBody.Addresses.Address]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                var tmp : [Any] = []
                for k in self.address! {
                    tmp.append(k.toMap())
                }
                map["Address"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") {
                var tmp : [SearchCloudGtmAddressesResponseBody.Addresses.Address] = []
                for v in dict["Address"] as! [Any] {
                    var model = SearchCloudGtmAddressesResponseBody.Addresses.Address()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.address = tmp
            }
        }
    }
    public var addresses: SearchCloudGtmAddressesResponseBody.Addresses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addresses != nil {
            map["Addresses"] = self.addresses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addresses") {
            var model = SearchCloudGtmAddressesResponseBody.Addresses()
            model.fromMap(dict["Addresses"] as! [String: Any])
            self.addresses = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class SearchCloudGtmAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchCloudGtmAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchCloudGtmAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchCloudGtmInstanceConfigsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var availableStatus: String?

    public var clientToken: String?

    public var enableStatus: String?

    public var healthStatus: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remark: String?

    public var scheduleDomainName: String?

    public var scheduleZoneName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.availableStatus != nil {
            map["AvailableStatus"] = self.availableStatus!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.scheduleDomainName != nil {
            map["ScheduleDomainName"] = self.scheduleDomainName!
        }
        if self.scheduleZoneName != nil {
            map["ScheduleZoneName"] = self.scheduleZoneName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AvailableStatus") {
            self.availableStatus = dict["AvailableStatus"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("HealthStatus") {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("ScheduleDomainName") {
            self.scheduleDomainName = dict["ScheduleDomainName"] as! String
        }
        if dict.keys.contains("ScheduleZoneName") {
            self.scheduleZoneName = dict["ScheduleZoneName"] as! String
        }
    }
}

public class SearchCloudGtmInstanceConfigsResponseBody : Tea.TeaModel {
    public class InstanceConfigs : Tea.TeaModel {
        public class InstanceConfig : Tea.TeaModel {
            public class AddressPools : Tea.TeaModel {
                public class AddressPool : Tea.TeaModel {
                    public class RequestSource : Tea.TeaModel {
                        public var requestSource: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.requestSource != nil {
                                map["RequestSource"] = self.requestSource!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("RequestSource") {
                                self.requestSource = dict["RequestSource"] as! [String]
                            }
                        }
                    }
                    public var addressLbStrategy: String?

                    public var addressPoolId: String?

                    public var addressPoolName: String?

                    public var addressPoolType: String?

                    public var availableStatus: String?

                    public var createTime: String?

                    public var createTimestamp: Int64?

                    public var enableStatus: String?

                    public var healthJudgement: String?

                    public var healthStatus: String?

                    public var requestSource: SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool.RequestSource?

                    public var seqNonPreemptiveSchedule: Bool?

                    public var sequenceLbStrategyMode: String?

                    public var serialNumber: Int32?

                    public var updateTime: String?

                    public var updateTimestamp: Int64?

                    public var weightValue: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.requestSource?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.addressLbStrategy != nil {
                            map["AddressLbStrategy"] = self.addressLbStrategy!
                        }
                        if self.addressPoolId != nil {
                            map["AddressPoolId"] = self.addressPoolId!
                        }
                        if self.addressPoolName != nil {
                            map["AddressPoolName"] = self.addressPoolName!
                        }
                        if self.addressPoolType != nil {
                            map["AddressPoolType"] = self.addressPoolType!
                        }
                        if self.availableStatus != nil {
                            map["AvailableStatus"] = self.availableStatus!
                        }
                        if self.createTime != nil {
                            map["CreateTime"] = self.createTime!
                        }
                        if self.createTimestamp != nil {
                            map["CreateTimestamp"] = self.createTimestamp!
                        }
                        if self.enableStatus != nil {
                            map["EnableStatus"] = self.enableStatus!
                        }
                        if self.healthJudgement != nil {
                            map["HealthJudgement"] = self.healthJudgement!
                        }
                        if self.healthStatus != nil {
                            map["HealthStatus"] = self.healthStatus!
                        }
                        if self.requestSource != nil {
                            map["RequestSource"] = self.requestSource?.toMap()
                        }
                        if self.seqNonPreemptiveSchedule != nil {
                            map["SeqNonPreemptiveSchedule"] = self.seqNonPreemptiveSchedule!
                        }
                        if self.sequenceLbStrategyMode != nil {
                            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                        }
                        if self.serialNumber != nil {
                            map["SerialNumber"] = self.serialNumber!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        if self.updateTimestamp != nil {
                            map["UpdateTimestamp"] = self.updateTimestamp!
                        }
                        if self.weightValue != nil {
                            map["WeightValue"] = self.weightValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AddressLbStrategy") {
                            self.addressLbStrategy = dict["AddressLbStrategy"] as! String
                        }
                        if dict.keys.contains("AddressPoolId") {
                            self.addressPoolId = dict["AddressPoolId"] as! String
                        }
                        if dict.keys.contains("AddressPoolName") {
                            self.addressPoolName = dict["AddressPoolName"] as! String
                        }
                        if dict.keys.contains("AddressPoolType") {
                            self.addressPoolType = dict["AddressPoolType"] as! String
                        }
                        if dict.keys.contains("AvailableStatus") {
                            self.availableStatus = dict["AvailableStatus"] as! String
                        }
                        if dict.keys.contains("CreateTime") {
                            self.createTime = dict["CreateTime"] as! String
                        }
                        if dict.keys.contains("CreateTimestamp") {
                            self.createTimestamp = dict["CreateTimestamp"] as! Int64
                        }
                        if dict.keys.contains("EnableStatus") {
                            self.enableStatus = dict["EnableStatus"] as! String
                        }
                        if dict.keys.contains("HealthJudgement") {
                            self.healthJudgement = dict["HealthJudgement"] as! String
                        }
                        if dict.keys.contains("HealthStatus") {
                            self.healthStatus = dict["HealthStatus"] as! String
                        }
                        if dict.keys.contains("RequestSource") {
                            var model = SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool.RequestSource()
                            model.fromMap(dict["RequestSource"] as! [String: Any])
                            self.requestSource = model
                        }
                        if dict.keys.contains("SeqNonPreemptiveSchedule") {
                            self.seqNonPreemptiveSchedule = dict["SeqNonPreemptiveSchedule"] as! Bool
                        }
                        if dict.keys.contains("SequenceLbStrategyMode") {
                            self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
                        }
                        if dict.keys.contains("SerialNumber") {
                            self.serialNumber = dict["SerialNumber"] as! Int32
                        }
                        if dict.keys.contains("UpdateTime") {
                            self.updateTime = dict["UpdateTime"] as! String
                        }
                        if dict.keys.contains("UpdateTimestamp") {
                            self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                        }
                        if dict.keys.contains("WeightValue") {
                            self.weightValue = dict["WeightValue"] as! Int32
                        }
                    }
                }
                public var addressPool: [SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.addressPool != nil {
                        var tmp : [Any] = []
                        for k in self.addressPool! {
                            tmp.append(k.toMap())
                        }
                        map["AddressPool"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AddressPool") {
                        var tmp : [SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool] = []
                        for v in dict["AddressPool"] as! [Any] {
                            var model = SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools.AddressPool()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.addressPool = tmp
                    }
                }
            }
            public var addressPoolLbStrategy: String?

            public var addressPools: SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools?

            public var availableStatus: String?

            public var commodityCode: String?

            public var configId: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var enableStatus: String?

            public var healthStatus: String?

            public var instanceId: String?

            public var remark: String?

            public var scheduleDomainName: String?

            public var scheduleHostname: String?

            public var scheduleRrType: String?

            public var scheduleZoneMode: String?

            public var scheduleZoneName: String?

            public var sequenceLbStrategyMode: String?

            public var ttl: Int32?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addressPools?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressPoolLbStrategy != nil {
                    map["AddressPoolLbStrategy"] = self.addressPoolLbStrategy!
                }
                if self.addressPools != nil {
                    map["AddressPools"] = self.addressPools?.toMap()
                }
                if self.availableStatus != nil {
                    map["AvailableStatus"] = self.availableStatus!
                }
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.configId != nil {
                    map["ConfigId"] = self.configId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.enableStatus != nil {
                    map["EnableStatus"] = self.enableStatus!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.scheduleDomainName != nil {
                    map["ScheduleDomainName"] = self.scheduleDomainName!
                }
                if self.scheduleHostname != nil {
                    map["ScheduleHostname"] = self.scheduleHostname!
                }
                if self.scheduleRrType != nil {
                    map["ScheduleRrType"] = self.scheduleRrType!
                }
                if self.scheduleZoneMode != nil {
                    map["ScheduleZoneMode"] = self.scheduleZoneMode!
                }
                if self.scheduleZoneName != nil {
                    map["ScheduleZoneName"] = self.scheduleZoneName!
                }
                if self.sequenceLbStrategyMode != nil {
                    map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
                }
                if self.ttl != nil {
                    map["Ttl"] = self.ttl!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddressPoolLbStrategy") {
                    self.addressPoolLbStrategy = dict["AddressPoolLbStrategy"] as! String
                }
                if dict.keys.contains("AddressPools") {
                    var model = SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig.AddressPools()
                    model.fromMap(dict["AddressPools"] as! [String: Any])
                    self.addressPools = model
                }
                if dict.keys.contains("AvailableStatus") {
                    self.availableStatus = dict["AvailableStatus"] as! String
                }
                if dict.keys.contains("CommodityCode") {
                    self.commodityCode = dict["CommodityCode"] as! String
                }
                if dict.keys.contains("ConfigId") {
                    self.configId = dict["ConfigId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("EnableStatus") {
                    self.enableStatus = dict["EnableStatus"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("ScheduleDomainName") {
                    self.scheduleDomainName = dict["ScheduleDomainName"] as! String
                }
                if dict.keys.contains("ScheduleHostname") {
                    self.scheduleHostname = dict["ScheduleHostname"] as! String
                }
                if dict.keys.contains("ScheduleRrType") {
                    self.scheduleRrType = dict["ScheduleRrType"] as! String
                }
                if dict.keys.contains("ScheduleZoneMode") {
                    self.scheduleZoneMode = dict["ScheduleZoneMode"] as! String
                }
                if dict.keys.contains("ScheduleZoneName") {
                    self.scheduleZoneName = dict["ScheduleZoneName"] as! String
                }
                if dict.keys.contains("SequenceLbStrategyMode") {
                    self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
                }
                if dict.keys.contains("Ttl") {
                    self.ttl = dict["Ttl"] as! Int32
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
                if dict.keys.contains("VersionCode") {
                    self.versionCode = dict["VersionCode"] as! String
                }
            }
        }
        public var instanceConfig: [SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceConfig != nil {
                var tmp : [Any] = []
                for k in self.instanceConfig! {
                    tmp.append(k.toMap())
                }
                map["InstanceConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceConfig") {
                var tmp : [SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig] = []
                for v in dict["InstanceConfig"] as! [Any] {
                    var model = SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs.InstanceConfig()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceConfig = tmp
            }
        }
    }
    public var instanceConfigs: SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceConfigs != nil {
            map["InstanceConfigs"] = self.instanceConfigs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceConfigs") {
            var model = SearchCloudGtmInstanceConfigsResponseBody.InstanceConfigs()
            model.fromMap(dict["InstanceConfigs"] as! [String: Any])
            self.instanceConfigs = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class SearchCloudGtmInstanceConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchCloudGtmInstanceConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchCloudGtmInstanceConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchCloudGtmInstancesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var instanceId: String?

    public var instanceName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class SearchCloudGtmInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public var commodityCode: String?

            public var createTime: String?

            public var createTimestamp: Int64?

            public var expireTime: Int64?

            public var expireTimestamp: String?

            public var instanceId: String?

            public var instanceName: String?

            public var monitorTaskQuota: Int32?

            public var monthlyEmailUsed: Int32?

            public var monthlySmsQuota: Int32?

            public var monthlySmsUsed: Int32?

            public var monthlyWebhookUsed: Int32?

            public var scheduleDomainName: String?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.expireTimestamp != nil {
                    map["ExpireTimestamp"] = self.expireTimestamp!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.monitorTaskQuota != nil {
                    map["MonitorTaskQuota"] = self.monitorTaskQuota!
                }
                if self.monthlyEmailUsed != nil {
                    map["MonthlyEmailUsed"] = self.monthlyEmailUsed!
                }
                if self.monthlySmsQuota != nil {
                    map["MonthlySmsQuota"] = self.monthlySmsQuota!
                }
                if self.monthlySmsUsed != nil {
                    map["MonthlySmsUsed"] = self.monthlySmsUsed!
                }
                if self.monthlyWebhookUsed != nil {
                    map["MonthlyWebhookUsed"] = self.monthlyWebhookUsed!
                }
                if self.scheduleDomainName != nil {
                    map["ScheduleDomainName"] = self.scheduleDomainName!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CommodityCode") {
                    self.commodityCode = dict["CommodityCode"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! Int64
                }
                if dict.keys.contains("ExpireTimestamp") {
                    self.expireTimestamp = dict["ExpireTimestamp"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("MonitorTaskQuota") {
                    self.monitorTaskQuota = dict["MonitorTaskQuota"] as! Int32
                }
                if dict.keys.contains("MonthlyEmailUsed") {
                    self.monthlyEmailUsed = dict["MonthlyEmailUsed"] as! Int32
                }
                if dict.keys.contains("MonthlySmsQuota") {
                    self.monthlySmsQuota = dict["MonthlySmsQuota"] as! Int32
                }
                if dict.keys.contains("MonthlySmsUsed") {
                    self.monthlySmsUsed = dict["MonthlySmsUsed"] as! Int32
                }
                if dict.keys.contains("MonthlyWebhookUsed") {
                    self.monthlyWebhookUsed = dict["MonthlyWebhookUsed"] as! Int32
                }
                if dict.keys.contains("ScheduleDomainName") {
                    self.scheduleDomainName = dict["ScheduleDomainName"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
                if dict.keys.contains("VersionCode") {
                    self.versionCode = dict["VersionCode"] as! String
                }
            }
        }
        public var instance: [SearchCloudGtmInstancesResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instance") {
                var tmp : [SearchCloudGtmInstancesResponseBody.Instances.Instance] = []
                for v in dict["Instance"] as! [Any] {
                    var model = SearchCloudGtmInstancesResponseBody.Instances.Instance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instance = tmp
            }
        }
    }
    public var instances: SearchCloudGtmInstancesResponseBody.Instances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var model = SearchCloudGtmInstancesResponseBody.Instances()
            model.fromMap(dict["Instances"] as! [String: Any])
            self.instances = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class SearchCloudGtmInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchCloudGtmInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchCloudGtmInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchCloudGtmMonitorTemplatesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ipVersion: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("IpVersion") {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
    }
}

public class SearchCloudGtmMonitorTemplatesResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public class IspCityNodes : Tea.TeaModel {
                public class IspCityNode : Tea.TeaModel {
                    public var cityCode: String?

                    public var cityName: String?

                    public var countryCode: String?

                    public var countryName: String?

                    public var groupName: String?

                    public var groupType: String?

                    public var ispCode: String?

                    public var ispName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cityCode != nil {
                            map["CityCode"] = self.cityCode!
                        }
                        if self.cityName != nil {
                            map["CityName"] = self.cityName!
                        }
                        if self.countryCode != nil {
                            map["CountryCode"] = self.countryCode!
                        }
                        if self.countryName != nil {
                            map["CountryName"] = self.countryName!
                        }
                        if self.groupName != nil {
                            map["GroupName"] = self.groupName!
                        }
                        if self.groupType != nil {
                            map["GroupType"] = self.groupType!
                        }
                        if self.ispCode != nil {
                            map["IspCode"] = self.ispCode!
                        }
                        if self.ispName != nil {
                            map["IspName"] = self.ispName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CityCode") {
                            self.cityCode = dict["CityCode"] as! String
                        }
                        if dict.keys.contains("CityName") {
                            self.cityName = dict["CityName"] as! String
                        }
                        if dict.keys.contains("CountryCode") {
                            self.countryCode = dict["CountryCode"] as! String
                        }
                        if dict.keys.contains("CountryName") {
                            self.countryName = dict["CountryName"] as! String
                        }
                        if dict.keys.contains("GroupName") {
                            self.groupName = dict["GroupName"] as! String
                        }
                        if dict.keys.contains("GroupType") {
                            self.groupType = dict["GroupType"] as! String
                        }
                        if dict.keys.contains("IspCode") {
                            self.ispCode = dict["IspCode"] as! String
                        }
                        if dict.keys.contains("IspName") {
                            self.ispName = dict["IspName"] as! String
                        }
                    }
                }
                public var ispCityNode: [SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes.IspCityNode]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ispCityNode != nil {
                        var tmp : [Any] = []
                        for k in self.ispCityNode! {
                            tmp.append(k.toMap())
                        }
                        map["IspCityNode"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IspCityNode") {
                        var tmp : [SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes.IspCityNode] = []
                        for v in dict["IspCityNode"] as! [Any] {
                            var model = SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes.IspCityNode()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ispCityNode = tmp
                    }
                }
            }
            public var createTime: String?

            public var createTimestamp: Int64?

            public var evaluationCount: Int32?

            public var extendInfo: String?

            public var failureRate: Int32?

            public var interval: Int32?

            public var ipVersion: String?

            public var ispCityNodes: SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes?

            public var name: String?

            public var protocol_: String?

            public var remark: String?

            public var templateId: String?

            public var timeout: Int32?

            public var updateTime: String?

            public var updateTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ispCityNodes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.evaluationCount != nil {
                    map["EvaluationCount"] = self.evaluationCount!
                }
                if self.extendInfo != nil {
                    map["ExtendInfo"] = self.extendInfo!
                }
                if self.failureRate != nil {
                    map["FailureRate"] = self.failureRate!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.ispCityNodes != nil {
                    map["IspCityNodes"] = self.ispCityNodes?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.updateTimestamp != nil {
                    map["UpdateTimestamp"] = self.updateTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("EvaluationCount") {
                    self.evaluationCount = dict["EvaluationCount"] as! Int32
                }
                if dict.keys.contains("ExtendInfo") {
                    self.extendInfo = dict["ExtendInfo"] as! String
                }
                if dict.keys.contains("FailureRate") {
                    self.failureRate = dict["FailureRate"] as! Int32
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("IpVersion") {
                    self.ipVersion = dict["IpVersion"] as! String
                }
                if dict.keys.contains("IspCityNodes") {
                    var model = SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template.IspCityNodes()
                    model.fromMap(dict["IspCityNodes"] as! [String: Any])
                    self.ispCityNodes = model
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! String
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int32
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("UpdateTimestamp") {
                    self.updateTimestamp = dict["UpdateTimestamp"] as! Int64
                }
            }
        }
        public var template: [SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                var tmp : [Any] = []
                for k in self.template! {
                    tmp.append(k.toMap())
                }
                map["Template"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Template") {
                var tmp : [SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template] = []
                for v in dict["Template"] as! [Any] {
                    var model = SearchCloudGtmMonitorTemplatesResponseBody.Templates.Template()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.template = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var templates: SearchCloudGtmMonitorTemplatesResponseBody.Templates?

    public var totalItems: Int32?

    public var totalPages: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templates?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templates != nil {
            map["Templates"] = self.templates?.toMap()
        }
        if self.totalItems != nil {
            map["TotalItems"] = self.totalItems!
        }
        if self.totalPages != nil {
            map["TotalPages"] = self.totalPages!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Templates") {
            var model = SearchCloudGtmMonitorTemplatesResponseBody.Templates()
            model.fromMap(dict["Templates"] as! [String: Any])
            self.templates = model
        }
        if dict.keys.contains("TotalItems") {
            self.totalItems = dict["TotalItems"] as! Int32
        }
        if dict.keys.contains("TotalPages") {
            self.totalPages = dict["TotalPages"] as! Int32
        }
    }
}

public class SearchCloudGtmMonitorTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchCloudGtmMonitorTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchCloudGtmMonitorTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDNSSLBStatusRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var line: String?

    public var open_: Bool?

    public var subDomain: String?

    public var type: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.open_ != nil {
            map["Open"] = self.open_!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Line") {
            self.line = dict["Line"] as! String
        }
        if dict.keys.contains("Open") {
            self.open_ = dict["Open"] as! Bool
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class SetDNSSLBStatusResponseBody : Tea.TeaModel {
    public var open_: Bool?

    public var recordCount: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.open_ != nil {
            map["Open"] = self.open_!
        }
        if self.recordCount != nil {
            map["RecordCount"] = self.recordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Open") {
            self.open_ = dict["Open"] as! Bool
        }
        if dict.keys.contains("RecordCount") {
            self.recordCount = dict["RecordCount"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDNSSLBStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDNSSLBStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDNSSLBStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDnsGtmAccessModeRequest : Tea.TeaModel {
    public var accessMode: String?

    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessMode") {
            self.accessMode = dict["AccessMode"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class SetDnsGtmAccessModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDnsGtmAccessModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDnsGtmAccessModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDnsGtmAccessModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDnsGtmMonitorStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var monitorConfigId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class SetDnsGtmMonitorStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDnsGtmMonitorStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDnsGtmMonitorStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDnsGtmMonitorStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDomainDnssecStatusRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class SetDomainDnssecStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDomainDnssecStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDomainDnssecStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDomainDnssecStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDomainRecordStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var status: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class SetDomainRecordStatusResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class SetDomainRecordStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDomainRecordStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDomainRecordStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetGtmAccessModeRequest : Tea.TeaModel {
    public var accessMode: String?

    public var lang: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessMode") {
            self.accessMode = dict["AccessMode"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class SetGtmAccessModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetGtmAccessModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetGtmAccessModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetGtmAccessModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetGtmMonitorStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var monitorConfigId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class SetGtmMonitorStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetGtmMonitorStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetGtmMonitorStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetGtmMonitorStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitIspFlushCacheTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public var domainName: String?

    public var isp: [String]?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! [String]
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class SubmitIspFlushCacheTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitIspFlushCacheTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitIspFlushCacheTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitIspFlushCacheTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchDnsGtmInstanceStrategyModeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var lang: String?

    public var strategyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyMode != nil {
            map["StrategyMode"] = self.strategyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyMode") {
            self.strategyMode = dict["StrategyMode"] as! String
        }
    }
}

public class SwitchDnsGtmInstanceStrategyModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SwitchDnsGtmInstanceStrategyModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchDnsGtmInstanceStrategyModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SwitchDnsGtmInstanceStrategyModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var lang: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TransferDomainRequest : Tea.TeaModel {
    public var domainNames: String?

    public var lang: String?

    public var remark: String?

    public var targetUserId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.targetUserId != nil {
            map["TargetUserId"] = self.targetUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("TargetUserId") {
            self.targetUserId = dict["TargetUserId"] as! Int64
        }
    }
}

public class TransferDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class TransferDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransferDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TransferDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindInstanceDomainsRequest : Tea.TeaModel {
    public var domainNames: String?

    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class UnbindInstanceDomainsResponseBody : Tea.TeaModel {
    public var failedCount: Int32?

    public var requestId: String?

    public var successCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedCount") {
            self.failedCount = dict["FailedCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessCount") {
            self.successCount = dict["SuccessCount"] as! Int32
        }
    }
}

public class UnbindInstanceDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindInstanceDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnbindInstanceDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var lang: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAppKeyStateRequest : Tea.TeaModel {
    public var appKeyId: String?

    public var lang: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKeyId != nil {
            map["AppKeyId"] = self.appKeyId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppKeyId") {
            self.appKeyId = dict["AppKeyId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class UpdateAppKeyStateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAppKeyStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAppKeyStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAppKeyStateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressRequest : Tea.TeaModel {
    public class HealthTasks : Tea.TeaModel {
        public var port: Int32?

        public var templateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var address: String?

    public var addressId: String?

    public var attributeInfo: String?

    public var clientToken: String?

    public var healthJudgement: String?

    public var healthTasks: [UpdateCloudGtmAddressRequest.HealthTasks]?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.attributeInfo != nil {
            map["AttributeInfo"] = self.attributeInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.healthTasks != nil {
            var tmp : [Any] = []
            for k in self.healthTasks! {
                tmp.append(k.toMap())
            }
            map["HealthTasks"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("AddressId") {
            self.addressId = dict["AddressId"] as! String
        }
        if dict.keys.contains("AttributeInfo") {
            self.attributeInfo = dict["AttributeInfo"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("HealthJudgement") {
            self.healthJudgement = dict["HealthJudgement"] as! String
        }
        if dict.keys.contains("HealthTasks") {
            var tmp : [UpdateCloudGtmAddressRequest.HealthTasks] = []
            for v in dict["HealthTasks"] as! [Any] {
                var model = UpdateCloudGtmAddressRequest.HealthTasks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.healthTasks = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class UpdateCloudGtmAddressShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var address: String?

    public var addressId: String?

    public var attributeInfo: String?

    public var clientToken: String?

    public var healthJudgement: String?

    public var healthTasksShrink: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.attributeInfo != nil {
            map["AttributeInfo"] = self.attributeInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        if self.healthTasksShrink != nil {
            map["HealthTasks"] = self.healthTasksShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("AddressId") {
            self.addressId = dict["AddressId"] as! String
        }
        if dict.keys.contains("AttributeInfo") {
            self.attributeInfo = dict["AttributeInfo"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("HealthJudgement") {
            self.healthJudgement = dict["HealthJudgement"] as! String
        }
        if dict.keys.contains("HealthTasks") {
            self.healthTasksShrink = dict["HealthTasks"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class UpdateCloudGtmAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressEnableStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressId: String?

    public var clientToken: String?

    public var enableStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressId") {
            self.addressId = dict["AddressId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
    }
}

public class UpdateCloudGtmAddressEnableStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmAddressEnableStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressEnableStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmAddressEnableStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressManualAvailableStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressId: String?

    public var availableMode: String?

    public var clientToken: String?

    public var manualAvailableStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.availableMode != nil {
            map["AvailableMode"] = self.availableMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.manualAvailableStatus != nil {
            map["ManualAvailableStatus"] = self.manualAvailableStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressId") {
            self.addressId = dict["AddressId"] as! String
        }
        if dict.keys.contains("AvailableMode") {
            self.availableMode = dict["AvailableMode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ManualAvailableStatus") {
            self.manualAvailableStatus = dict["ManualAvailableStatus"] as! String
        }
    }
}

public class UpdateCloudGtmAddressManualAvailableStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmAddressManualAvailableStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressManualAvailableStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmAddressManualAvailableStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressPoolBasicConfigRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var addressPoolName: String?

    public var clientToken: String?

    public var healthJudgement: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.addressPoolName != nil {
            map["AddressPoolName"] = self.addressPoolName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.healthJudgement != nil {
            map["HealthJudgement"] = self.healthJudgement!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("AddressPoolName") {
            self.addressPoolName = dict["AddressPoolName"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("HealthJudgement") {
            self.healthJudgement = dict["HealthJudgement"] as! String
        }
    }
}

public class UpdateCloudGtmAddressPoolBasicConfigResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmAddressPoolBasicConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressPoolBasicConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmAddressPoolBasicConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressPoolEnableStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var clientToken: String?

    public var enableStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
    }
}

public class UpdateCloudGtmAddressPoolEnableStatusResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmAddressPoolEnableStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressPoolEnableStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmAddressPoolEnableStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressPoolLbStrategyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressLbStrategy: String?

    public var addressPoolId: String?

    public var clientToken: String?

    public var sequenceLbStrategyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressLbStrategy != nil {
            map["AddressLbStrategy"] = self.addressLbStrategy!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.sequenceLbStrategyMode != nil {
            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressLbStrategy") {
            self.addressLbStrategy = dict["AddressLbStrategy"] as! String
        }
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("SequenceLbStrategyMode") {
            self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
        }
    }
}

public class UpdateCloudGtmAddressPoolLbStrategyResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmAddressPoolLbStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressPoolLbStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmAddressPoolLbStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressPoolRemarkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolId: String?

    public var clientToken: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class UpdateCloudGtmAddressPoolRemarkResponseBody : Tea.TeaModel {
    public var addressPoolId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressPoolId != nil {
            map["AddressPoolId"] = self.addressPoolId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressPoolId") {
            self.addressPoolId = dict["AddressPoolId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmAddressPoolRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressPoolRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmAddressPoolRemarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmAddressRemarkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressId: String?

    public var clientToken: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressId != nil {
            map["AddressId"] = self.addressId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressId") {
            self.addressId = dict["AddressId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class UpdateCloudGtmAddressRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmAddressRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmAddressRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmAddressRemarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmGlobalAlertRequest : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public var dingtalkNotice: Bool?

        public var emailNotice: Bool?

        public var noticeType: String?

        public var smsNotice: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingtalkNotice != nil {
                map["DingtalkNotice"] = self.dingtalkNotice!
            }
            if self.emailNotice != nil {
                map["EmailNotice"] = self.emailNotice!
            }
            if self.noticeType != nil {
                map["NoticeType"] = self.noticeType!
            }
            if self.smsNotice != nil {
                map["SmsNotice"] = self.smsNotice!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DingtalkNotice") {
                self.dingtalkNotice = dict["DingtalkNotice"] as! Bool
            }
            if dict.keys.contains("EmailNotice") {
                self.emailNotice = dict["EmailNotice"] as! Bool
            }
            if dict.keys.contains("NoticeType") {
                self.noticeType = dict["NoticeType"] as! String
            }
            if dict.keys.contains("SmsNotice") {
                self.smsNotice = dict["SmsNotice"] as! Bool
            }
        }
    }
    public var acceptLanguage: String?

    public var alertConfig: [UpdateCloudGtmGlobalAlertRequest.AlertConfig]?

    public var alertGroup: [String]?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.alertConfig != nil {
            var tmp : [Any] = []
            for k in self.alertConfig! {
                tmp.append(k.toMap())
            }
            map["AlertConfig"] = tmp
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AlertConfig") {
            var tmp : [UpdateCloudGtmGlobalAlertRequest.AlertConfig] = []
            for v in dict["AlertConfig"] as! [Any] {
                var model = UpdateCloudGtmGlobalAlertRequest.AlertConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertConfig = tmp
        }
        if dict.keys.contains("AlertGroup") {
            self.alertGroup = dict["AlertGroup"] as! [String]
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class UpdateCloudGtmGlobalAlertShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var alertConfigShrink: String?

    public var alertGroupShrink: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.alertConfigShrink != nil {
            map["AlertConfig"] = self.alertConfigShrink!
        }
        if self.alertGroupShrink != nil {
            map["AlertGroup"] = self.alertGroupShrink!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AlertConfig") {
            self.alertConfigShrink = dict["AlertConfig"] as! String
        }
        if dict.keys.contains("AlertGroup") {
            self.alertGroupShrink = dict["AlertGroup"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class UpdateCloudGtmGlobalAlertResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmGlobalAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmGlobalAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmGlobalAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmInstanceConfigAlertRequest : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public var dingtalkNotice: Bool?

        public var emailNotice: Bool?

        public var noticeType: String?

        public var smsNotice: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingtalkNotice != nil {
                map["DingtalkNotice"] = self.dingtalkNotice!
            }
            if self.emailNotice != nil {
                map["EmailNotice"] = self.emailNotice!
            }
            if self.noticeType != nil {
                map["NoticeType"] = self.noticeType!
            }
            if self.smsNotice != nil {
                map["SmsNotice"] = self.smsNotice!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DingtalkNotice") {
                self.dingtalkNotice = dict["DingtalkNotice"] as! Bool
            }
            if dict.keys.contains("EmailNotice") {
                self.emailNotice = dict["EmailNotice"] as! Bool
            }
            if dict.keys.contains("NoticeType") {
                self.noticeType = dict["NoticeType"] as! String
            }
            if dict.keys.contains("SmsNotice") {
                self.smsNotice = dict["SmsNotice"] as! Bool
            }
        }
    }
    public var acceptLanguage: String?

    public var alertConfig: [UpdateCloudGtmInstanceConfigAlertRequest.AlertConfig]?

    public var alertGroup: [String]?

    public var alertMode: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.alertConfig != nil {
            var tmp : [Any] = []
            for k in self.alertConfig! {
                tmp.append(k.toMap())
            }
            map["AlertConfig"] = tmp
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.alertMode != nil {
            map["AlertMode"] = self.alertMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AlertConfig") {
            var tmp : [UpdateCloudGtmInstanceConfigAlertRequest.AlertConfig] = []
            for v in dict["AlertConfig"] as! [Any] {
                var model = UpdateCloudGtmInstanceConfigAlertRequest.AlertConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertConfig = tmp
        }
        if dict.keys.contains("AlertGroup") {
            self.alertGroup = dict["AlertGroup"] as! [String]
        }
        if dict.keys.contains("AlertMode") {
            self.alertMode = dict["AlertMode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class UpdateCloudGtmInstanceConfigAlertShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var alertConfigShrink: String?

    public var alertGroupShrink: String?

    public var alertMode: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.alertConfigShrink != nil {
            map["AlertConfig"] = self.alertConfigShrink!
        }
        if self.alertGroupShrink != nil {
            map["AlertGroup"] = self.alertGroupShrink!
        }
        if self.alertMode != nil {
            map["AlertMode"] = self.alertMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AlertConfig") {
            self.alertConfigShrink = dict["AlertConfig"] as! String
        }
        if dict.keys.contains("AlertGroup") {
            self.alertGroupShrink = dict["AlertGroup"] as! String
        }
        if dict.keys.contains("AlertMode") {
            self.alertMode = dict["AlertMode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class UpdateCloudGtmInstanceConfigAlertResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmInstanceConfigAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmInstanceConfigAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmInstanceConfigAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmInstanceConfigBasicRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public var scheduleHostname: String?

    public var scheduleZoneName: String?

    public var ttl: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scheduleHostname != nil {
            map["ScheduleHostname"] = self.scheduleHostname!
        }
        if self.scheduleZoneName != nil {
            map["ScheduleZoneName"] = self.scheduleZoneName!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScheduleHostname") {
            self.scheduleHostname = dict["ScheduleHostname"] as! String
        }
        if dict.keys.contains("ScheduleZoneName") {
            self.scheduleZoneName = dict["ScheduleZoneName"] as! String
        }
        if dict.keys.contains("Ttl") {
            self.ttl = dict["Ttl"] as! Int32
        }
    }
}

public class UpdateCloudGtmInstanceConfigBasicResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmInstanceConfigBasicResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmInstanceConfigBasicResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmInstanceConfigBasicResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmInstanceConfigEnableStatusRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var configId: String?

    public var enableStatus: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("EnableStatus") {
            self.enableStatus = dict["EnableStatus"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class UpdateCloudGtmInstanceConfigEnableStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmInstanceConfigEnableStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmInstanceConfigEnableStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmInstanceConfigEnableStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmInstanceConfigLbStrategyRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var addressPoolLbStrategy: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public var sequenceLbStrategyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.addressPoolLbStrategy != nil {
            map["AddressPoolLbStrategy"] = self.addressPoolLbStrategy!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sequenceLbStrategyMode != nil {
            map["SequenceLbStrategyMode"] = self.sequenceLbStrategyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("AddressPoolLbStrategy") {
            self.addressPoolLbStrategy = dict["AddressPoolLbStrategy"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SequenceLbStrategyMode") {
            self.sequenceLbStrategyMode = dict["SequenceLbStrategyMode"] as! String
        }
    }
}

public class UpdateCloudGtmInstanceConfigLbStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmInstanceConfigLbStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmInstanceConfigLbStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmInstanceConfigLbStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmInstanceConfigRemarkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var configId: String?

    public var instanceId: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class UpdateCloudGtmInstanceConfigRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmInstanceConfigRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmInstanceConfigRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmInstanceConfigRemarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmInstanceNameRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var instanceId: String?

    public var instanceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
    }
}

public class UpdateCloudGtmInstanceNameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmInstanceNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmInstanceNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmInstanceNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmMonitorTemplateRequest : Tea.TeaModel {
    public class IspCityNodes : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var acceptLanguage: String?

    public var clientToken: String?

    public var evaluationCount: Int32?

    public var extendInfo: String?

    public var failureRate: Int32?

    public var interval: Int32?

    public var ispCityNodes: [UpdateCloudGtmMonitorTemplateRequest.IspCityNodes]?

    public var name: String?

    public var templateId: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.failureRate != nil {
            map["FailureRate"] = self.failureRate!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNodes != nil {
            var tmp : [Any] = []
            for k in self.ispCityNodes! {
                tmp.append(k.toMap())
            }
            map["IspCityNodes"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("ExtendInfo") {
            self.extendInfo = dict["ExtendInfo"] as! String
        }
        if dict.keys.contains("FailureRate") {
            self.failureRate = dict["FailureRate"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNodes") {
            var tmp : [UpdateCloudGtmMonitorTemplateRequest.IspCityNodes] = []
            for v in dict["IspCityNodes"] as! [Any] {
                var model = UpdateCloudGtmMonitorTemplateRequest.IspCityNodes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ispCityNodes = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpdateCloudGtmMonitorTemplateShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var evaluationCount: Int32?

    public var extendInfo: String?

    public var failureRate: Int32?

    public var interval: Int32?

    public var ispCityNodesShrink: String?

    public var name: String?

    public var templateId: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.failureRate != nil {
            map["FailureRate"] = self.failureRate!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNodesShrink != nil {
            map["IspCityNodes"] = self.ispCityNodesShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("ExtendInfo") {
            self.extendInfo = dict["ExtendInfo"] as! String
        }
        if dict.keys.contains("FailureRate") {
            self.failureRate = dict["FailureRate"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNodes") {
            self.ispCityNodesShrink = dict["IspCityNodes"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpdateCloudGtmMonitorTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmMonitorTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmMonitorTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmMonitorTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCloudGtmMonitorTemplateRemarkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var remark: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateCloudGtmMonitorTemplateRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateCloudGtmMonitorTemplateRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCloudGtmMonitorTemplateRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCloudGtmMonitorTemplateRemarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCustomLineRequest : Tea.TeaModel {
    public class IpSegment : Tea.TeaModel {
        public var endIp: String?

        public var startIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endIp != nil {
                map["EndIp"] = self.endIp!
            }
            if self.startIp != nil {
                map["StartIp"] = self.startIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndIp") {
                self.endIp = dict["EndIp"] as! String
            }
            if dict.keys.contains("StartIp") {
                self.startIp = dict["StartIp"] as! String
            }
        }
    }
    public var ipSegment: [UpdateCustomLineRequest.IpSegment]?

    public var lang: String?

    public var lineId: Int64?

    public var lineName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipSegment != nil {
            var tmp : [Any] = []
            for k in self.ipSegment! {
                tmp.append(k.toMap())
            }
            map["IpSegment"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lineId != nil {
            map["LineId"] = self.lineId!
        }
        if self.lineName != nil {
            map["LineName"] = self.lineName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpSegment") {
            var tmp : [UpdateCustomLineRequest.IpSegment] = []
            for v in dict["IpSegment"] as! [Any] {
                var model = UpdateCustomLineRequest.IpSegment()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ipSegment = tmp
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LineId") {
            self.lineId = dict["LineId"] as! Int64
        }
        if dict.keys.contains("LineName") {
            self.lineName = dict["LineName"] as! String
        }
    }
}

public class UpdateCustomLineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCustomLineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomLineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCustomLineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDNSSLBWeightRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var userClientIp: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class UpdateDNSSLBWeightResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public var weight: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Weight") {
            self.weight = dict["Weight"] as! Int32
        }
    }
}

public class UpdateDNSSLBWeightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDNSSLBWeightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDNSSLBWeightResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDnsCacheDomainRequest : Tea.TeaModel {
    public class SourceDnsServer : Tea.TeaModel {
        public var host: String?

        public var port: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
        }
    }
    public var cacheTtlMax: Int32?

    public var cacheTtlMin: Int32?

    public var domainName: String?

    public var instanceId: String?

    public var lang: String?

    public var sourceDnsServer: [UpdateDnsCacheDomainRequest.SourceDnsServer]?

    public var sourceEdns: String?

    public var sourceProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cacheTtlMax != nil {
            map["CacheTtlMax"] = self.cacheTtlMax!
        }
        if self.cacheTtlMin != nil {
            map["CacheTtlMin"] = self.cacheTtlMin!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceDnsServer != nil {
            var tmp : [Any] = []
            for k in self.sourceDnsServer! {
                tmp.append(k.toMap())
            }
            map["SourceDnsServer"] = tmp
        }
        if self.sourceEdns != nil {
            map["SourceEdns"] = self.sourceEdns!
        }
        if self.sourceProtocol != nil {
            map["SourceProtocol"] = self.sourceProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CacheTtlMax") {
            self.cacheTtlMax = dict["CacheTtlMax"] as! Int32
        }
        if dict.keys.contains("CacheTtlMin") {
            self.cacheTtlMin = dict["CacheTtlMin"] as! Int32
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceDnsServer") {
            var tmp : [UpdateDnsCacheDomainRequest.SourceDnsServer] = []
            for v in dict["SourceDnsServer"] as! [Any] {
                var model = UpdateDnsCacheDomainRequest.SourceDnsServer()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sourceDnsServer = tmp
        }
        if dict.keys.contains("SourceEdns") {
            self.sourceEdns = dict["SourceEdns"] as! String
        }
        if dict.keys.contains("SourceProtocol") {
            self.sourceProtocol = dict["SourceProtocol"] as! String
        }
    }
}

public class UpdateDnsCacheDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDnsCacheDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsCacheDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDnsCacheDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDnsCacheDomainRemarkRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class UpdateDnsCacheDomainRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDnsCacheDomainRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsCacheDomainRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDnsCacheDomainRemarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDnsGtmAccessStrategyRequest : Tea.TeaModel {
    public class DefaultAddrPool : Tea.TeaModel {
        public var id: String?

        public var lbaWeight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
        }
    }
    public class FailoverAddrPool : Tea.TeaModel {
        public var id: String?

        public var lbaWeight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
        }
    }
    public var accessMode: String?

    public var defaultAddrPool: [UpdateDnsGtmAccessStrategyRequest.DefaultAddrPool]?

    public var defaultAddrPoolType: String?

    public var defaultLatencyOptimization: String?

    public var defaultLbaStrategy: String?

    public var defaultMaxReturnAddrNum: Int32?

    public var defaultMinAvailableAddrNum: Int32?

    public var failoverAddrPool: [UpdateDnsGtmAccessStrategyRequest.FailoverAddrPool]?

    public var failoverAddrPoolType: String?

    public var failoverLatencyOptimization: String?

    public var failoverLbaStrategy: String?

    public var failoverMaxReturnAddrNum: Int32?

    public var failoverMinAvailableAddrNum: Int32?

    public var lang: String?

    public var lines: String?

    public var strategyId: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessMode != nil {
            map["AccessMode"] = self.accessMode!
        }
        if self.defaultAddrPool != nil {
            var tmp : [Any] = []
            for k in self.defaultAddrPool! {
                tmp.append(k.toMap())
            }
            map["DefaultAddrPool"] = tmp
        }
        if self.defaultAddrPoolType != nil {
            map["DefaultAddrPoolType"] = self.defaultAddrPoolType!
        }
        if self.defaultLatencyOptimization != nil {
            map["DefaultLatencyOptimization"] = self.defaultLatencyOptimization!
        }
        if self.defaultLbaStrategy != nil {
            map["DefaultLbaStrategy"] = self.defaultLbaStrategy!
        }
        if self.defaultMaxReturnAddrNum != nil {
            map["DefaultMaxReturnAddrNum"] = self.defaultMaxReturnAddrNum!
        }
        if self.defaultMinAvailableAddrNum != nil {
            map["DefaultMinAvailableAddrNum"] = self.defaultMinAvailableAddrNum!
        }
        if self.failoverAddrPool != nil {
            var tmp : [Any] = []
            for k in self.failoverAddrPool! {
                tmp.append(k.toMap())
            }
            map["FailoverAddrPool"] = tmp
        }
        if self.failoverAddrPoolType != nil {
            map["FailoverAddrPoolType"] = self.failoverAddrPoolType!
        }
        if self.failoverLatencyOptimization != nil {
            map["FailoverLatencyOptimization"] = self.failoverLatencyOptimization!
        }
        if self.failoverLbaStrategy != nil {
            map["FailoverLbaStrategy"] = self.failoverLbaStrategy!
        }
        if self.failoverMaxReturnAddrNum != nil {
            map["FailoverMaxReturnAddrNum"] = self.failoverMaxReturnAddrNum!
        }
        if self.failoverMinAvailableAddrNum != nil {
            map["FailoverMinAvailableAddrNum"] = self.failoverMinAvailableAddrNum!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lines != nil {
            map["Lines"] = self.lines!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessMode") {
            self.accessMode = dict["AccessMode"] as! String
        }
        if dict.keys.contains("DefaultAddrPool") {
            var tmp : [UpdateDnsGtmAccessStrategyRequest.DefaultAddrPool] = []
            for v in dict["DefaultAddrPool"] as! [Any] {
                var model = UpdateDnsGtmAccessStrategyRequest.DefaultAddrPool()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.defaultAddrPool = tmp
        }
        if dict.keys.contains("DefaultAddrPoolType") {
            self.defaultAddrPoolType = dict["DefaultAddrPoolType"] as! String
        }
        if dict.keys.contains("DefaultLatencyOptimization") {
            self.defaultLatencyOptimization = dict["DefaultLatencyOptimization"] as! String
        }
        if dict.keys.contains("DefaultLbaStrategy") {
            self.defaultLbaStrategy = dict["DefaultLbaStrategy"] as! String
        }
        if dict.keys.contains("DefaultMaxReturnAddrNum") {
            self.defaultMaxReturnAddrNum = dict["DefaultMaxReturnAddrNum"] as! Int32
        }
        if dict.keys.contains("DefaultMinAvailableAddrNum") {
            self.defaultMinAvailableAddrNum = dict["DefaultMinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("FailoverAddrPool") {
            var tmp : [UpdateDnsGtmAccessStrategyRequest.FailoverAddrPool] = []
            for v in dict["FailoverAddrPool"] as! [Any] {
                var model = UpdateDnsGtmAccessStrategyRequest.FailoverAddrPool()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.failoverAddrPool = tmp
        }
        if dict.keys.contains("FailoverAddrPoolType") {
            self.failoverAddrPoolType = dict["FailoverAddrPoolType"] as! String
        }
        if dict.keys.contains("FailoverLatencyOptimization") {
            self.failoverLatencyOptimization = dict["FailoverLatencyOptimization"] as! String
        }
        if dict.keys.contains("FailoverLbaStrategy") {
            self.failoverLbaStrategy = dict["FailoverLbaStrategy"] as! String
        }
        if dict.keys.contains("FailoverMaxReturnAddrNum") {
            self.failoverMaxReturnAddrNum = dict["FailoverMaxReturnAddrNum"] as! Int32
        }
        if dict.keys.contains("FailoverMinAvailableAddrNum") {
            self.failoverMinAvailableAddrNum = dict["FailoverMinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Lines") {
            self.lines = dict["Lines"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class UpdateDnsGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var strategyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
    }
}

public class UpdateDnsGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDnsGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDnsGtmAddressPoolRequest : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public var addr: String?

        public var attributeInfo: String?

        public var lbaWeight: Int32?

        public var mode: String?

        public var remark: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addr != nil {
                map["Addr"] = self.addr!
            }
            if self.attributeInfo != nil {
                map["AttributeInfo"] = self.attributeInfo!
            }
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Addr") {
                self.addr = dict["Addr"] as! String
            }
            if dict.keys.contains("AttributeInfo") {
                self.attributeInfo = dict["AttributeInfo"] as! String
            }
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! String
            }
            if dict.keys.contains("Remark") {
                self.remark = dict["Remark"] as! String
            }
        }
    }
    public var addr: [UpdateDnsGtmAddressPoolRequest.Addr]?

    public var addrPoolId: String?

    public var lang: String?

    public var lbaStrategy: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            var tmp : [Any] = []
            for k in self.addr! {
                tmp.append(k.toMap())
            }
            map["Addr"] = tmp
        }
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addr") {
            var tmp : [UpdateDnsGtmAddressPoolRequest.Addr] = []
            for v in dict["Addr"] as! [Any] {
                var model = UpdateDnsGtmAddressPoolRequest.Addr()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.addr = tmp
        }
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LbaStrategy") {
            self.lbaStrategy = dict["LbaStrategy"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class UpdateDnsGtmAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDnsGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDnsGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDnsGtmInstanceGlobalConfigRequest : Tea.TeaModel {
    public class AlertConfig : Tea.TeaModel {
        public var dingtalkNotice: Bool?

        public var emailNotice: Bool?

        public var noticeType: String?

        public var smsNotice: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingtalkNotice != nil {
                map["DingtalkNotice"] = self.dingtalkNotice!
            }
            if self.emailNotice != nil {
                map["EmailNotice"] = self.emailNotice!
            }
            if self.noticeType != nil {
                map["NoticeType"] = self.noticeType!
            }
            if self.smsNotice != nil {
                map["SmsNotice"] = self.smsNotice!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DingtalkNotice") {
                self.dingtalkNotice = dict["DingtalkNotice"] as! Bool
            }
            if dict.keys.contains("EmailNotice") {
                self.emailNotice = dict["EmailNotice"] as! Bool
            }
            if dict.keys.contains("NoticeType") {
                self.noticeType = dict["NoticeType"] as! String
            }
            if dict.keys.contains("SmsNotice") {
                self.smsNotice = dict["SmsNotice"] as! Bool
            }
        }
    }
    public var alertConfig: [UpdateDnsGtmInstanceGlobalConfigRequest.AlertConfig]?

    public var alertGroup: String?

    public var cnameType: String?

    public var forceUpdate: Bool?

    public var instanceId: String?

    public var instanceName: String?

    public var lang: String?

    public var publicCnameMode: String?

    public var publicRr: String?

    public var publicUserDomainName: String?

    public var publicZoneName: String?

    public var ttl: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConfig != nil {
            var tmp : [Any] = []
            for k in self.alertConfig! {
                tmp.append(k.toMap())
            }
            map["AlertConfig"] = tmp
        }
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.cnameType != nil {
            map["CnameType"] = self.cnameType!
        }
        if self.forceUpdate != nil {
            map["ForceUpdate"] = self.forceUpdate!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.publicCnameMode != nil {
            map["PublicCnameMode"] = self.publicCnameMode!
        }
        if self.publicRr != nil {
            map["PublicRr"] = self.publicRr!
        }
        if self.publicUserDomainName != nil {
            map["PublicUserDomainName"] = self.publicUserDomainName!
        }
        if self.publicZoneName != nil {
            map["PublicZoneName"] = self.publicZoneName!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertConfig") {
            var tmp : [UpdateDnsGtmInstanceGlobalConfigRequest.AlertConfig] = []
            for v in dict["AlertConfig"] as! [Any] {
                var model = UpdateDnsGtmInstanceGlobalConfigRequest.AlertConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.alertConfig = tmp
        }
        if dict.keys.contains("AlertGroup") {
            self.alertGroup = dict["AlertGroup"] as! String
        }
        if dict.keys.contains("CnameType") {
            self.cnameType = dict["CnameType"] as! String
        }
        if dict.keys.contains("ForceUpdate") {
            self.forceUpdate = dict["ForceUpdate"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PublicCnameMode") {
            self.publicCnameMode = dict["PublicCnameMode"] as! String
        }
        if dict.keys.contains("PublicRr") {
            self.publicRr = dict["PublicRr"] as! String
        }
        if dict.keys.contains("PublicUserDomainName") {
            self.publicUserDomainName = dict["PublicUserDomainName"] as! String
        }
        if dict.keys.contains("PublicZoneName") {
            self.publicZoneName = dict["PublicZoneName"] as! String
        }
        if dict.keys.contains("Ttl") {
            self.ttl = dict["Ttl"] as! Int32
        }
    }
}

public class UpdateDnsGtmInstanceGlobalConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDnsGtmInstanceGlobalConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsGtmInstanceGlobalConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDnsGtmInstanceGlobalConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDnsGtmMonitorRequest : Tea.TeaModel {
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNode: [UpdateDnsGtmMonitorRequest.IspCityNode]?

    public var lang: String?

    public var monitorConfigId: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNode") {
            var tmp : [UpdateDnsGtmMonitorRequest.IspCityNode] = []
            for v in dict["IspCityNode"] as! [Any] {
                var model = UpdateDnsGtmMonitorRequest.IspCityNode()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ispCityNode = tmp
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpdateDnsGtmMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDnsGtmMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDnsGtmMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDnsGtmMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDomainGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class UpdateDomainGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDomainGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDomainGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDomainRecordRequest : Tea.TeaModel {
    public var lang: String?

    public var line: String?

    public var priority: Int64?

    public var RR: String?

    public var recordId: String?

    public var TTL: Int64?

    public var type: String?

    public var userClientIp: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.RR != nil {
            map["RR"] = self.RR!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.TTL != nil {
            map["TTL"] = self.TTL!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Line") {
            self.line = dict["Line"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int64
        }
        if dict.keys.contains("RR") {
            self.RR = dict["RR"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("TTL") {
            self.TTL = dict["TTL"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class UpdateDomainRecordResponseBody : Tea.TeaModel {
    public var recordId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDomainRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDomainRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDomainRecordRemarkRequest : Tea.TeaModel {
    public var lang: String?

    public var recordId: String?

    public var remark: String?

    public var userClientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.userClientIp != nil {
            map["UserClientIp"] = self.userClientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("UserClientIp") {
            self.userClientIp = dict["UserClientIp"] as! String
        }
    }
}

public class UpdateDomainRecordRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDomainRecordRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainRecordRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDomainRecordRemarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDomainRemarkRequest : Tea.TeaModel {
    public var domainName: String?

    public var lang: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class UpdateDomainRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDomainRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDomainRemarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGtmAccessStrategyRequest : Tea.TeaModel {
    public var accessLines: String?

    public var defaultAddrPoolId: String?

    public var failoverAddrPoolId: String?

    public var lang: String?

    public var strategyId: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessLines != nil {
            map["AccessLines"] = self.accessLines!
        }
        if self.defaultAddrPoolId != nil {
            map["DefaultAddrPoolId"] = self.defaultAddrPoolId!
        }
        if self.failoverAddrPoolId != nil {
            map["FailoverAddrPoolId"] = self.failoverAddrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessLines") {
            self.accessLines = dict["AccessLines"] as! String
        }
        if dict.keys.contains("DefaultAddrPoolId") {
            self.defaultAddrPoolId = dict["DefaultAddrPoolId"] as! String
        }
        if dict.keys.contains("FailoverAddrPoolId") {
            self.failoverAddrPoolId = dict["FailoverAddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") {
            self.strategyId = dict["StrategyId"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class UpdateGtmAccessStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGtmAccessStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmAccessStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGtmAccessStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGtmAddressPoolRequest : Tea.TeaModel {
    public class Addr : Tea.TeaModel {
        public var lbaWeight: Int32?

        public var mode: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lbaWeight != nil {
                map["LbaWeight"] = self.lbaWeight!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LbaWeight") {
                self.lbaWeight = dict["LbaWeight"] as! Int32
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var addr: [UpdateGtmAddressPoolRequest.Addr]?

    public var addrPoolId: String?

    public var lang: String?

    public var minAvailableAddrNum: Int32?

    public var name: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addr != nil {
            var tmp : [Any] = []
            for k in self.addr! {
                tmp.append(k.toMap())
            }
            map["Addr"] = tmp
        }
        if self.addrPoolId != nil {
            map["AddrPoolId"] = self.addrPoolId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.minAvailableAddrNum != nil {
            map["MinAvailableAddrNum"] = self.minAvailableAddrNum!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Addr") {
            var tmp : [UpdateGtmAddressPoolRequest.Addr] = []
            for v in dict["Addr"] as! [Any] {
                var model = UpdateGtmAddressPoolRequest.Addr()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.addr = tmp
        }
        if dict.keys.contains("AddrPoolId") {
            self.addrPoolId = dict["AddrPoolId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MinAvailableAddrNum") {
            self.minAvailableAddrNum = dict["MinAvailableAddrNum"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class UpdateGtmAddressPoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGtmAddressPoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmAddressPoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGtmAddressPoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGtmInstanceGlobalConfigRequest : Tea.TeaModel {
    public var alertGroup: String?

    public var cnameCustomDomainName: String?

    public var cnameMode: String?

    public var instanceId: String?

    public var instanceName: String?

    public var lang: String?

    public var lbaStrategy: String?

    public var ttl: Int32?

    public var userDomainName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertGroup != nil {
            map["AlertGroup"] = self.alertGroup!
        }
        if self.cnameCustomDomainName != nil {
            map["CnameCustomDomainName"] = self.cnameCustomDomainName!
        }
        if self.cnameMode != nil {
            map["CnameMode"] = self.cnameMode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.lbaStrategy != nil {
            map["LbaStrategy"] = self.lbaStrategy!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.userDomainName != nil {
            map["UserDomainName"] = self.userDomainName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertGroup") {
            self.alertGroup = dict["AlertGroup"] as! String
        }
        if dict.keys.contains("CnameCustomDomainName") {
            self.cnameCustomDomainName = dict["CnameCustomDomainName"] as! String
        }
        if dict.keys.contains("CnameMode") {
            self.cnameMode = dict["CnameMode"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LbaStrategy") {
            self.lbaStrategy = dict["LbaStrategy"] as! String
        }
        if dict.keys.contains("Ttl") {
            self.ttl = dict["Ttl"] as! Int32
        }
        if dict.keys.contains("UserDomainName") {
            self.userDomainName = dict["UserDomainName"] as! String
        }
    }
}

public class UpdateGtmInstanceGlobalConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGtmInstanceGlobalConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmInstanceGlobalConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGtmInstanceGlobalConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGtmMonitorRequest : Tea.TeaModel {
    public class IspCityNode : Tea.TeaModel {
        public var cityCode: String?

        public var ispCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            if self.ispCode != nil {
                map["IspCode"] = self.ispCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
            if dict.keys.contains("IspCode") {
                self.ispCode = dict["IspCode"] as! String
            }
        }
    }
    public var evaluationCount: Int32?

    public var interval: Int32?

    public var ispCityNode: [UpdateGtmMonitorRequest.IspCityNode]?

    public var lang: String?

    public var monitorConfigId: String?

    public var monitorExtendInfo: String?

    public var protocolType: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.evaluationCount != nil {
            map["EvaluationCount"] = self.evaluationCount!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispCityNode != nil {
            var tmp : [Any] = []
            for k in self.ispCityNode! {
                tmp.append(k.toMap())
            }
            map["IspCityNode"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.monitorConfigId != nil {
            map["MonitorConfigId"] = self.monitorConfigId!
        }
        if self.monitorExtendInfo != nil {
            map["MonitorExtendInfo"] = self.monitorExtendInfo!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EvaluationCount") {
            self.evaluationCount = dict["EvaluationCount"] as! Int32
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("IspCityNode") {
            var tmp : [UpdateGtmMonitorRequest.IspCityNode] = []
            for v in dict["IspCityNode"] as! [Any] {
                var model = UpdateGtmMonitorRequest.IspCityNode()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ispCityNode = tmp
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MonitorConfigId") {
            self.monitorConfigId = dict["MonitorConfigId"] as! String
        }
        if dict.keys.contains("MonitorExtendInfo") {
            self.monitorExtendInfo = dict["MonitorExtendInfo"] as! String
        }
        if dict.keys.contains("ProtocolType") {
            self.protocolType = dict["ProtocolType"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpdateGtmMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGtmMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGtmMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGtmRecoveryPlanRequest : Tea.TeaModel {
    public var faultAddrPool: String?

    public var lang: String?

    public var name: String?

    public var recoveryPlanId: Int64?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.faultAddrPool != nil {
            map["FaultAddrPool"] = self.faultAddrPool!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recoveryPlanId != nil {
            map["RecoveryPlanId"] = self.recoveryPlanId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FaultAddrPool") {
            self.faultAddrPool = dict["FaultAddrPool"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RecoveryPlanId") {
            self.recoveryPlanId = dict["RecoveryPlanId"] as! Int64
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class UpdateGtmRecoveryPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateGtmRecoveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGtmRecoveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGtmRecoveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIspFlushCacheInstanceConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceName: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class UpdateIspFlushCacheInstanceConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateIspFlushCacheInstanceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIspFlushCacheInstanceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateIspFlushCacheInstanceConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ValidateDnsGtmCnameRrCanUseRequest : Tea.TeaModel {
    public var cnameMode: String?

    public var cnameRr: String?

    public var cnameType: String?

    public var cnameZone: String?

    public var instanceId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cnameMode != nil {
            map["CnameMode"] = self.cnameMode!
        }
        if self.cnameRr != nil {
            map["CnameRr"] = self.cnameRr!
        }
        if self.cnameType != nil {
            map["CnameType"] = self.cnameType!
        }
        if self.cnameZone != nil {
            map["CnameZone"] = self.cnameZone!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CnameMode") {
            self.cnameMode = dict["CnameMode"] as! String
        }
        if dict.keys.contains("CnameRr") {
            self.cnameRr = dict["CnameRr"] as! String
        }
        if dict.keys.contains("CnameType") {
            self.cnameType = dict["CnameType"] as! String
        }
        if dict.keys.contains("CnameZone") {
            self.cnameZone = dict["CnameZone"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class ValidateDnsGtmCnameRrCanUseResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ValidateDnsGtmCnameRrCanUseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateDnsGtmCnameRrCanUseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ValidateDnsGtmCnameRrCanUseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ValidatePdnsUdpIpSegmentRequest : Tea.TeaModel {
    public var ip: String?

    public var ipToken: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.ipToken != nil {
            map["IpToken"] = self.ipToken!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("IpToken") {
            self.ipToken = dict["IpToken"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class ValidatePdnsUdpIpSegmentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ValidatePdnsUdpIpSegmentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidatePdnsUdpIpSegmentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ValidatePdnsUdpIpSegmentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
